{"version":3,"file":"933-a6ccbdd60703b75794db.js","mappings":"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","sources":["webpack://@my-react/ssr-example/../../packages/myreact-three-fiber/dist/esm/ lazy strict namespace object","webpack://@my-react/ssr-example/../../packages/myreact-three-fiber/dist/esm/index.mjs"],"sourcesContent":["function webpackEmptyAsyncContext(req) {\n\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\n\t// uncaught exception popping up in devtools\n\treturn Promise.resolve().then(() => {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t});\n}\nwebpackEmptyAsyncContext.keys = () => ([]);\nwebpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;\nwebpackEmptyAsyncContext.id = 15327;\nmodule.exports = webpackEmptyAsyncContext;","import * as THREE from 'three';\nimport { jsx, Fragment } from '@my-react/react/jsx-runtime';\nimport * as React from '@my-react/react';\nimport React__default, { __my_react_internal__, __my_react_shared__, createElement } from '@my-react/react';\nimport { suspend, preload, clear } from 'suspend-react';\nimport { createWithEqualityFn } from 'zustand/traditional';\nimport useMeasure from 'react-use-measure';\n\nvar threeTypes = /*#__PURE__*/Object.freeze({\n    __proto__: null\n});\n\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\nvar HOOK_TYPE$1;\n(function (HOOK_TYPE) {\n    HOOK_TYPE[HOOK_TYPE[\"useId\"] = 0] = \"useId\";\n    HOOK_TYPE[HOOK_TYPE[\"useRef\"] = 1] = \"useRef\";\n    HOOK_TYPE[HOOK_TYPE[\"useMemo\"] = 2] = \"useMemo\";\n    HOOK_TYPE[HOOK_TYPE[\"useState\"] = 3] = \"useState\";\n    HOOK_TYPE[HOOK_TYPE[\"useSignal\"] = 4] = \"useSignal\";\n    HOOK_TYPE[HOOK_TYPE[\"useEffect\"] = 5] = \"useEffect\";\n    HOOK_TYPE[HOOK_TYPE[\"useContext\"] = 6] = \"useContext\";\n    HOOK_TYPE[HOOK_TYPE[\"useReducer\"] = 7] = \"useReducer\";\n    HOOK_TYPE[HOOK_TYPE[\"useCallback\"] = 8] = \"useCallback\";\n    HOOK_TYPE[HOOK_TYPE[\"useTransition\"] = 9] = \"useTransition\";\n    HOOK_TYPE[HOOK_TYPE[\"useDebugValue\"] = 10] = \"useDebugValue\";\n    HOOK_TYPE[HOOK_TYPE[\"useLayoutEffect\"] = 11] = \"useLayoutEffect\";\n    HOOK_TYPE[HOOK_TYPE[\"useDeferredValue\"] = 12] = \"useDeferredValue\";\n    HOOK_TYPE[HOOK_TYPE[\"useInsertionEffect\"] = 13] = \"useInsertionEffect\";\n    HOOK_TYPE[HOOK_TYPE[\"useImperativeHandle\"] = 14] = \"useImperativeHandle\";\n    HOOK_TYPE[HOOK_TYPE[\"useSyncExternalStore\"] = 15] = \"useSyncExternalStore\";\n    HOOK_TYPE[HOOK_TYPE[\"useOptimistic\"] = 16] = \"useOptimistic\";\n    HOOK_TYPE[HOOK_TYPE[\"useEffectEvent\"] = 17] = \"useEffectEvent\";\n})(HOOK_TYPE$1 || (HOOK_TYPE$1 = {}));\n\nvar UpdateQueueType$1;\n(function (UpdateQueueType) {\n    UpdateQueueType[UpdateQueueType[\"component\"] = 1] = \"component\";\n    UpdateQueueType[UpdateQueueType[\"hook\"] = 2] = \"hook\";\n    UpdateQueueType[UpdateQueueType[\"context\"] = 3] = \"context\";\n    UpdateQueueType[UpdateQueueType[\"hmr\"] = 4] = \"hmr\";\n    UpdateQueueType[UpdateQueueType[\"trigger\"] = 5] = \"trigger\";\n    UpdateQueueType[UpdateQueueType[\"suspense\"] = 6] = \"suspense\";\n    UpdateQueueType[UpdateQueueType[\"lazy\"] = 7] = \"lazy\";\n    UpdateQueueType[UpdateQueueType[\"promise\"] = 8] = \"promise\";\n})(UpdateQueueType$1 || (UpdateQueueType$1 = {}));\n\nvar STATE_TYPE$1;\n(function (STATE_TYPE) {\n    STATE_TYPE[STATE_TYPE[\"__initial__\"] = 0] = \"__initial__\";\n    STATE_TYPE[STATE_TYPE[\"__create__\"] = 1] = \"__create__\";\n    STATE_TYPE[STATE_TYPE[\"__stable__\"] = 2] = \"__stable__\";\n    STATE_TYPE[STATE_TYPE[\"__inherit__\"] = 4] = \"__inherit__\";\n    STATE_TYPE[STATE_TYPE[\"__triggerConcurrent__\"] = 8] = \"__triggerConcurrent__\";\n    STATE_TYPE[STATE_TYPE[\"__triggerConcurrentForce__\"] = 16] = \"__triggerConcurrentForce__\";\n    STATE_TYPE[STATE_TYPE[\"__triggerSync__\"] = 32] = \"__triggerSync__\";\n    STATE_TYPE[STATE_TYPE[\"__triggerSyncForce__\"] = 64] = \"__triggerSyncForce__\";\n    STATE_TYPE[STATE_TYPE[\"__unmount__\"] = 128] = \"__unmount__\";\n    STATE_TYPE[STATE_TYPE[\"__hmr__\"] = 256] = \"__hmr__\";\n    STATE_TYPE[STATE_TYPE[\"__retrigger__\"] = 512] = \"__retrigger__\";\n    STATE_TYPE[STATE_TYPE[\"__reschedule__\"] = 1024] = \"__reschedule__\";\n    STATE_TYPE[STATE_TYPE[\"__recreate__\"] = 2048] = \"__recreate__\";\n    STATE_TYPE[STATE_TYPE[\"__suspense__\"] = 4096] = \"__suspense__\";\n})(STATE_TYPE$1 || (STATE_TYPE$1 = {}));\n\nvar PATCH_TYPE$1;\n(function (PATCH_TYPE) {\n    PATCH_TYPE[PATCH_TYPE[\"__initial__\"] = 0] = \"__initial__\";\n    PATCH_TYPE[PATCH_TYPE[\"__create__\"] = 1] = \"__create__\";\n    PATCH_TYPE[PATCH_TYPE[\"__update__\"] = 2] = \"__update__\";\n    PATCH_TYPE[PATCH_TYPE[\"__append__\"] = 4] = \"__append__\";\n    PATCH_TYPE[PATCH_TYPE[\"__position__\"] = 8] = \"__position__\";\n    PATCH_TYPE[PATCH_TYPE[\"__effect__\"] = 16] = \"__effect__\";\n    PATCH_TYPE[PATCH_TYPE[\"__layoutEffect__\"] = 32] = \"__layoutEffect__\";\n    PATCH_TYPE[PATCH_TYPE[\"__insertionEffect__\"] = 64] = \"__insertionEffect__\";\n    PATCH_TYPE[PATCH_TYPE[\"__unmount__\"] = 128] = \"__unmount__\";\n    PATCH_TYPE[PATCH_TYPE[\"__ref__\"] = 256] = \"__ref__\";\n})(PATCH_TYPE$1 || (PATCH_TYPE$1 = {}));\n\nvar Effect_TYPE$1;\n(function (Effect_TYPE) {\n    Effect_TYPE[Effect_TYPE[\"__initial__\"] = 0] = \"__initial__\";\n    Effect_TYPE[Effect_TYPE[\"__effect__\"] = 1] = \"__effect__\";\n    Effect_TYPE[Effect_TYPE[\"__unmount__\"] = 2] = \"__unmount__\";\n})(Effect_TYPE$1 || (Effect_TYPE$1 = {}));\n\nvar ListTreeNode$1 = /** @class */ (function () {\n    function ListTreeNode(value) {\n        this.prev = null;\n        this.next = null;\n        this.value = value;\n    }\n    return ListTreeNode;\n}());\nvar ListTree$1 = /** @class */ (function () {\n    function ListTree() {\n        this.length = 0;\n        var _stickyHead = null;\n        Object.defineProperty(this, \"stickyHead\", {\n            get: function () {\n                return _stickyHead;\n            },\n            set: function (v) {\n                _stickyHead = v;\n            },\n        });\n        var _stickyFoot = null;\n        Object.defineProperty(this, \"stickyFoot\", {\n            get: function () {\n                return _stickyFoot;\n            },\n            set: function (v) {\n                _stickyFoot = v;\n            },\n        });\n        var _head = null;\n        Object.defineProperty(this, \"head\", {\n            get: function () {\n                return _head;\n            },\n            set: function (v) {\n                _head = v;\n            },\n        });\n        var _foot = null;\n        Object.defineProperty(this, \"foot\", {\n            get: function () {\n                return _foot;\n            },\n            set: function (v) {\n                _foot = v;\n            },\n        });\n    }\n    ListTree.prototype.push = function (node) {\n        var listNode = new ListTreeNode$1(node);\n        this.length++;\n        if (!this.foot) {\n            this.head = listNode;\n            this.foot = listNode;\n        }\n        else {\n            this.foot.next = listNode;\n            listNode.prev = this.foot;\n            this.foot = listNode;\n        }\n    };\n    ListTree.prototype.pushToLast = function (node) {\n        if (this.stickyFoot) {\n            var node_1 = this.stickyFoot;\n            this.push(node_1.value);\n            this.stickyFoot = null;\n        }\n        else {\n            this.length++;\n        }\n        var listNode = new ListTreeNode$1(node);\n        this.stickyFoot = listNode;\n    };\n    ListTree.prototype.pushToHead = function (node) {\n        if (this.stickyHead) {\n            var node_2 = this.stickyHead;\n            this.unshift(node_2.value);\n            this.stickyHead = null;\n        }\n        else {\n            this.length++;\n        }\n        var listNode = new ListTreeNode$1(node);\n        this.stickyHead = listNode;\n    };\n    ListTree.prototype.pop = function () {\n        var foot = this.stickyFoot || this.foot || this.stickyHead;\n        if (foot) {\n            this.delete(foot);\n            return foot.value;\n        }\n        else {\n            return null;\n        }\n    };\n    ListTree.prototype.unshift = function (node) {\n        var listNode = new ListTreeNode$1(node);\n        this.length++;\n        if (!this.head) {\n            this.head = listNode;\n            this.foot = listNode;\n        }\n        else {\n            this.head.prev = listNode;\n            listNode.next = this.head;\n            this.head = listNode;\n        }\n    };\n    ListTree.prototype.unshiftToHead = function (node) {\n        if (this.stickyHead) {\n            var node_3 = this.stickyHead;\n            this.unshift(node_3.value);\n            this.stickyHead = null;\n        }\n        else {\n            this.length++;\n        }\n        var listNode = new ListTreeNode$1(node);\n        this.stickyHead = listNode;\n    };\n    ListTree.prototype.unshiftToFoot = function (node) {\n        if (this.stickyFoot) {\n            var node_4 = this.stickyFoot;\n            this.push(node_4.value);\n            this.stickyFoot = null;\n        }\n        else {\n            this.length++;\n        }\n        var listNode = new ListTreeNode$1(node);\n        this.stickyFoot = listNode;\n    };\n    ListTree.prototype.shift = function () {\n        var head = this.stickyHead || this.head || this.stickyFoot;\n        if (head) {\n            this.delete(head);\n            return head.value;\n        }\n        else {\n            return null;\n        }\n    };\n    ListTree.prototype.pickHead = function () {\n        var _a, _b;\n        return ((_a = this.stickyHead) === null || _a === void 0 ? void 0 : _a.value) || ((_b = this.head) === null || _b === void 0 ? void 0 : _b.value);\n    };\n    ListTree.prototype.pickFoot = function () {\n        var _a, _b;\n        return ((_a = this.stickyFoot) === null || _a === void 0 ? void 0 : _a.value) || ((_b = this.foot) === null || _b === void 0 ? void 0 : _b.value);\n    };\n    ListTree.prototype.listToFoot = function (action) {\n        if (this.stickyHead) {\n            action(this.stickyHead.value);\n        }\n        var node = this.head;\n        while (node) {\n            action(node.value);\n            node = node.next;\n        }\n        if (this.stickyFoot) {\n            action(this.stickyFoot.value);\n        }\n    };\n    ListTree.prototype.listToHead = function (action) {\n        if (this.stickyFoot) {\n            action(this.stickyFoot.value);\n        }\n        var node = this.foot;\n        while (node) {\n            action(node.value);\n            node = node.prev;\n        }\n        if (this.stickyHead) {\n            action(this.stickyHead.value);\n        }\n    };\n    ListTree.prototype.toArray = function () {\n        var re = [];\n        this.listToFoot(function (v) { return re.push(v); });\n        return re;\n    };\n    ListTree.prototype.delete = function (node) {\n        if (this.stickyHead === node) {\n            this.stickyHead = null;\n            this.length--;\n        }\n        else if (this.stickyFoot === node) {\n            this.stickyFoot = null;\n            this.length--;\n        }\n        else if (this.head === node) {\n            var next = node.next;\n            node.next = null;\n            if (next) {\n                this.head = next;\n                next.prev = null;\n            }\n            else {\n                this.head = null;\n                this.foot = null;\n            }\n            this.length--;\n        }\n        else if (this.foot === node) {\n            var prev = node.prev;\n            node.prev = null;\n            if (prev) {\n                this.foot = prev;\n                prev.next = null;\n            }\n            else {\n                this.head = null;\n                this.foot = null;\n            }\n            this.length--;\n        }\n        else if (this.hasNode(node)) {\n            var prev = node.prev;\n            var next = node.next;\n            node.prev = null;\n            node.next = null;\n            prev.next = next;\n            next.prev = prev;\n            this.length--;\n        }\n    };\n    ListTree.prototype.size = function () {\n        return this.length;\n    };\n    ListTree.prototype.hasNode = function (node) {\n        if (this.stickyHead && Object.is(this.stickyHead, node))\n            return true;\n        if (this.stickyFoot && Object.is(this.stickyFoot, node))\n            return true;\n        var listNode = this.head;\n        while (listNode) {\n            if (Object.is(listNode, node))\n                return true;\n            listNode = listNode.next;\n        }\n        return false;\n    };\n    ListTree.prototype.hasValue = function (node) {\n        if (this.stickyHead && Object.is(this.stickyHead.value, node))\n            return true;\n        if (this.stickyFoot && Object.is(this.stickyFoot.value, node))\n            return true;\n        var listNode = this.head;\n        while (listNode) {\n            if (Object.is(listNode.value, node))\n                return true;\n            listNode = listNode.next;\n        }\n        return false;\n    };\n    ListTree.prototype.some = function (iterator) {\n        var re = false;\n        this.listToFoot(function (node) {\n            re = re || iterator(node);\n        });\n        return re;\n    };\n    ListTree.prototype.every = function (iterator) {\n        var re = true;\n        this.listToFoot(function (node) {\n            re = re && iterator(node);\n        });\n        return re;\n    };\n    ListTree.prototype.concat = function (list) {\n        var newList = new ListTree();\n        this.listToFoot(function (node) { return newList.push(node); });\n        list.listToFoot(function (node) { return newList.push(node); });\n        return newList;\n    };\n    ListTree.prototype.clone = function () {\n        var newList = new ListTree();\n        this.listToFoot(function (v) { return newList.push(v); });\n        return newList;\n    };\n    ListTree.prototype.clear = function () {\n        this.length = 0;\n        this.head = null;\n        this.foot = null;\n        this.stickyHead = null;\n        this.stickyFoot = null;\n    };\n    return ListTree;\n}());\nif (process.env.NODE_ENV === \"development\") {\n    Object.defineProperty(ListTree$1.prototype, \"_debugToArray\", {\n        get: function () {\n            return this.toArray();\n        },\n    });\n}\n\n/**\n * An SSR-friendly useLayoutEffect.\n *\n * React currently throws a warning when using useLayoutEffect on the server.\n * To get around it, we can conditionally useEffect on the server (no-op) and\n * useLayoutEffect elsewhere.\n *\n * @see https://github.com/facebook/react/issues/14927\n */\nconst useIsomorphicLayoutEffect$1 = /* @__PURE__ */ (() => typeof window !== \"undefined\" && (window.document?.createElement || window.navigator?.product === \"ReactNative\"))()\n    ? React.useLayoutEffect\n    : React.useEffect;\n/**\n * Traverses up or down a {@link Fiber}, return `true` to stop and select a node.\n */\nfunction traverseFiber(\n/** Input {@link Fiber} to traverse. */\nfiber, \n/** Whether to ascend and walk up the tree. Will walk down if `false`. */\nascending, \n/** A {@link Fiber} node selector, returns the first match when `true` is passed. */\nselector) {\n    if (!fiber)\n        return;\n    if (selector(fiber) === true)\n        return fiber;\n    let child = ascending ? fiber.return : fiber.child;\n    while (child) {\n        const match = traverseFiber(child, ascending, selector);\n        if (match)\n            return match;\n        child = ascending ? null : child.sibling;\n    }\n}\nconst FiberContext = /* @__PURE__ */ React.createContext(null);\n/**\n * A react-internal {@link Fiber} provider. This component binds React children to the React Fiber tree. Call its-fine hooks within this.\n */\nclass FiberProvider extends React.Component {\n    _reactInternals;\n    render() {\n        return jsx(FiberContext.Provider, { value: this._reactInternals, children: this.props.children });\n    }\n}\n/**\n * Returns the current react-internal {@link Fiber}. This is an implementation detail of [react-reconciler](https://github.com/facebook/react/tree/main/packages/react-reconciler).\n */\nfunction useFiber() {\n    const root = React.useContext(FiberContext);\n    if (root === null)\n        throw new Error(\"its-fine: useFiber must be called within a <FiberProvider />!\");\n    const id = React.useId();\n    const fiber = React.useMemo(() => {\n        for (const maybeFiber of [root, root?.alternate]) {\n            if (!maybeFiber)\n                continue;\n            const fiber = traverseFiber(maybeFiber, false, (node) => {\n                const hookList = node.hookList;\n                let hook = hookList?.head;\n                while (hook) {\n                    const typedHook = hook.value;\n                    if (typedHook.type === HOOK_TYPE$1.useId && typedHook.result === id) {\n                        return true;\n                    }\n                    hook = hook.next;\n                }\n            });\n            if (fiber)\n                return fiber;\n        }\n    }, [root, id]);\n    return fiber;\n}\n/**\n * Returns the current react-reconciler container info passed to {@link ReactReconciler.Reconciler.createContainer}.\n *\n * In react-dom, a container will point to the root DOM element; in react-three-fiber, it will point to the root Zustand store.\n */\nfunction useContainer() {\n    const fiber = useFiber();\n    const root = React.useMemo(() => traverseFiber(fiber, true, (node) => node.stateNode?.containerInfo != null), [fiber]);\n    return root?.stateNode.containerInfo;\n}\n/**\n * Returns the nearest react-reconciler child instance or the node created from {@link ReactReconciler.HostConfig.createInstance}.\n *\n * In react-dom, this would be a DOM element; in react-three-fiber this would be an instance descriptor.\n */\nfunction useNearestChild(\n/** An optional element type to filter to. */\ntype) {\n    const fiber = useFiber();\n    const childRef = React.useRef(undefined);\n    useIsomorphicLayoutEffect$1(() => {\n        childRef.current = traverseFiber(fiber, false, (node) => typeof node.elementType === \"string\" && (type === undefined || node.elementType === type))?.stateNode;\n    }, [fiber]);\n    return childRef;\n}\n/**\n * Returns the nearest react-reconciler parent instance or the node created from {@link ReactReconciler.HostConfig.createInstance}.\n *\n * In react-dom, this would be a DOM element; in react-three-fiber this would be an instance descriptor.\n */\nfunction useNearestParent(\n/** An optional element type to filter to. */\ntype) {\n    const fiber = useFiber();\n    const parentRef = React.useRef(undefined);\n    useIsomorphicLayoutEffect$1(() => {\n        parentRef.current = traverseFiber(fiber, true, (node) => typeof node.elementType === \"string\" && (type === undefined || node.elementType === type))?.stateNode;\n    }, [fiber]);\n    return parentRef;\n}\nconst REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\nconst REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\nconst isContext = (type) => type !== null && typeof type === \"object\" && \"$$typeof\" in type && (type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_PROVIDER_TYPE);\n/**\n * Returns a map of all contexts and their values.\n */\nfunction useContextMap() {\n    const fiber = useFiber();\n    const [contextMap] = React.useState(() => new Map());\n    // Collect live context\n    contextMap.clear();\n    let node = fiber;\n    while (node) {\n        const context = node.elementType;\n        if (isContext(context)) {\n            // @ts-ignore\n            const contextProvider = context.Provider ? context : context.Context;\n            if (!contextMap.has(context) && contextProvider !== FiberContext) {\n                // @ts-ignore\n                contextMap.set(context, React.use(contextProvider));\n            }\n        }\n        node = node.return;\n    }\n    return contextMap;\n}\n/**\n * React Context currently cannot be shared across [React renderers](https://reactjs.org/docs/codebase-overview.html#renderers) but explicitly forwarded between providers (see [react#17275](https://github.com/facebook/react/issues/17275)). This hook returns a {@link ContextBridge} of live context providers to pierce Context across renderers.\n *\n * Pass {@link ContextBridge} as a component to a secondary renderer to enable context-sharing within its children.\n */\nfunction useContextBridge() {\n    const contextMap = useContextMap();\n    // Flatten context and their memoized values into a `ContextBridge` provider\n    return React.useMemo(() => Array.from(contextMap.keys()).reduce((Prev, context) => (props) => {\n        const Tar = (context.Provider || context);\n        return (jsx(Prev, { children: jsx(Tar, { ...props, value: contextMap.get(context) }) }));\n    }, (props) => jsx(FiberProvider, { ...props })), [contextMap]);\n}\n\n/**\n * Returns the instance's initial (outmost) root.\n */\nfunction findInitialRoot(instance) {\n    let root = instance.root;\n    while (root.getState().previousRoot)\n        root = root.getState().previousRoot;\n    return root;\n}\nconst isOrthographicCamera = (def) => def && def.isOrthographicCamera;\nconst isRef = (obj) => obj && obj.hasOwnProperty(\"current\");\nconst isColorRepresentation = (value) => value != null && (typeof value === \"string\" || typeof value === \"number\" || value.isColor);\n/**\n * An SSR-friendly useLayoutEffect.\n *\n * React currently throws a warning when using useLayoutEffect on the server.\n * To get around it, we can conditionally useEffect on the server (no-op) and\n * useLayoutEffect elsewhere.\n *\n * @see https://github.com/facebook/react/issues/14927\n */\nconst useIsomorphicLayoutEffect = /* @__PURE__ */ (() => typeof window !== \"undefined\" && (window.document?.createElement || window.navigator?.product === \"ReactNative\"))()\n    ? React.useLayoutEffect\n    : React.useEffect;\nfunction useMutableCallback(fn) {\n    const ref = React.useRef(fn);\n    useIsomorphicLayoutEffect(() => void (ref.current = fn), [fn]);\n    return ref;\n}\n/**\n * Bridges renderer Context and StrictMode from a primary renderer.\n */\nfunction useBridge() {\n    const fiber = useFiber();\n    const ContextBridge = useContextBridge();\n    return React.useMemo(() => ({ children }) => {\n        const strict = !!traverseFiber(fiber, true, (node) => node.elementType === React.StrictMode);\n        const Root = strict ? React.StrictMode : React.Fragment;\n        return (jsx(Root, { children: jsx(ContextBridge, { children: children }) }));\n    }, [fiber, ContextBridge]);\n}\nfunction Block({ set }) {\n    useIsomorphicLayoutEffect(() => {\n        set(new Promise(() => null));\n        return () => set(false);\n    }, [set]);\n    return null;\n}\n// NOTE: static members get down-level transpiled to mutations which break tree-shaking\nconst ErrorBoundary = /* @__PURE__ */ (() => class ErrorBoundary extends React.Component {\n    state = { error: false };\n    static getDerivedStateFromError = () => ({ error: true });\n    componentDidCatch(err) {\n        this.props.set(err);\n    }\n    render() {\n        return this.state.error ? null : this.props.children;\n    }\n})();\nfunction calculateDpr(dpr) {\n    // Err on the side of progress by assuming 2x dpr if we can't detect it\n    // This will happen in workers where window is defined but dpr isn't.\n    const target = typeof window !== \"undefined\" ? (window.devicePixelRatio ?? 2) : 1;\n    return Array.isArray(dpr) ? Math.min(Math.max(dpr[0], target), dpr[1]) : dpr;\n}\n/**\n * Returns instance root state\n */\nfunction getRootState(obj) {\n    return obj.__r3f?.root.getState();\n}\n// A collection of compare functions\nconst is = {\n    obj: (a) => a === Object(a) && !is.arr(a) && typeof a !== \"function\",\n    fun: (a) => typeof a === \"function\",\n    str: (a) => typeof a === \"string\",\n    num: (a) => typeof a === \"number\",\n    boo: (a) => typeof a === \"boolean\",\n    und: (a) => a === void 0,\n    nul: (a) => a === null,\n    arr: (a) => Array.isArray(a),\n    equ(a, b, { arrays = \"shallow\", objects = \"reference\", strict = true } = {}) {\n        // Wrong type or one of the two undefined, doesn't match\n        if (typeof a !== typeof b || !!a !== !!b)\n            return false;\n        // Atomic, just compare a against b\n        if (is.str(a) || is.num(a) || is.boo(a))\n            return a === b;\n        const isObj = is.obj(a);\n        if (isObj && objects === \"reference\")\n            return a === b;\n        const isArr = is.arr(a);\n        if (isArr && arrays === \"reference\")\n            return a === b;\n        // Array or Object, shallow compare first to see if it's a match\n        if ((isArr || isObj) && a === b)\n            return true;\n        // Last resort, go through keys\n        let i;\n        // Check if a has all the keys of b\n        for (i in a)\n            if (!(i in b))\n                return false;\n        // Check if values between keys match\n        if (isObj && arrays === \"shallow\" && objects === \"shallow\") {\n            for (i in strict ? b : a)\n                if (!is.equ(a[i], b[i], { strict, objects: \"reference\" }))\n                    return false;\n        }\n        else {\n            for (i in strict ? b : a)\n                if (a[i] !== b[i])\n                    return false;\n        }\n        // If i is undefined\n        if (is.und(i)) {\n            // If both arrays are empty we consider them equal\n            if (isArr && a.length === 0 && b.length === 0)\n                return true;\n            // If both objects are empty we consider them equal\n            if (isObj && Object.keys(a).length === 0 && Object.keys(b).length === 0)\n                return true;\n            // Otherwise match them by value\n            if (a !== b)\n                return false;\n        }\n        return true;\n    },\n};\n// Collects nodes and materials from a THREE.Object3D\nfunction buildGraph(object) {\n    const data = { nodes: {}, materials: {}, meshes: {} };\n    if (object) {\n        object.traverse((obj) => {\n            if (obj.name)\n                data.nodes[obj.name] = obj;\n            if (obj.material && !data.materials[obj.material.name])\n                data.materials[obj.material.name] = obj.material;\n            if (obj.isMesh && !data.meshes[obj.name])\n                data.meshes[obj.name] = obj;\n        });\n    }\n    return data;\n}\n// Disposes an object and all its properties\nfunction dispose(obj) {\n    if (obj.type !== \"Scene\")\n        obj.dispose?.();\n    for (const p in obj) {\n        const prop = obj[p];\n        if (prop?.type !== \"Scene\")\n            prop?.dispose?.();\n    }\n}\nconst REACT_INTERNAL_PROPS = [\"children\", \"key\", \"ref\"];\n// Gets only instance props from reconciler fibers\nfunction getInstanceProps(queue) {\n    const props = {};\n    for (const key in queue) {\n        if (!REACT_INTERNAL_PROPS.includes(key))\n            props[key] = queue[key];\n    }\n    return props;\n}\n// Each object in the scene carries a small LocalState descriptor\nfunction prepare(target, root, type, props) {\n    const object = target;\n    // Create instance descriptor\n    let instance = object?.__r3f;\n    if (!instance) {\n        instance = {\n            root,\n            type,\n            parent: null,\n            children: [],\n            props: getInstanceProps(props),\n            object,\n            eventCount: 0,\n            handlers: {},\n            isHidden: false,\n        };\n        if (object)\n            object.__r3f = instance;\n    }\n    return instance;\n}\nfunction resolve(root, key) {\n    if (!key.includes(\"-\"))\n        return { root, key, target: root[key] };\n    // First try the entire key as a single property (e.g., 'foo-bar')\n    if (key in root) {\n        return { root, key, target: root[key] };\n    }\n    // Try piercing (e.g., 'material-color' -> material.color)\n    let target = root;\n    const parts = key.split(\"-\");\n    for (const part of parts) {\n        if (typeof target !== \"object\" || target === null) {\n            if (target !== undefined) {\n                // Property exists but has unexpected shape\n                const remaining = parts.slice(parts.indexOf(part)).join(\"-\");\n                return { root: target, key: remaining, target: undefined };\n            }\n            // Property doesn't exist - fallback to original key\n            return { root, key, target: undefined };\n        }\n        key = part;\n        root = target;\n        target = target[key];\n    }\n    return { root, key, target };\n}\n// Checks if a dash-cased string ends with an integer\nconst INDEX_REGEX = /-\\d+$/;\nfunction attach(parent, child) {\n    if (is.str(child.props.attach)) {\n        // If attaching into an array (foo-0), create one\n        if (INDEX_REGEX.test(child.props.attach)) {\n            const index = child.props.attach.replace(INDEX_REGEX, \"\");\n            const { root, key } = resolve(parent.object, index);\n            if (!Array.isArray(root[key]))\n                root[key] = [];\n        }\n        const { root, key } = resolve(parent.object, child.props.attach);\n        child.previousAttach = root[key];\n        root[key] = child.object;\n    }\n    else if (is.fun(child.props.attach)) {\n        child.previousAttach = child.props.attach(parent.object, child.object);\n    }\n}\nfunction detach(parent, child) {\n    if (is.str(child.props.attach)) {\n        const { root, key } = resolve(parent.object, child.props.attach);\n        const previous = child.previousAttach;\n        // When the previous value was undefined, it means the value was never set to begin with\n        if (previous === undefined)\n            delete root[key];\n        // Otherwise set the previous value\n        else\n            root[key] = previous;\n    }\n    else {\n        child.previousAttach?.(parent.object, child.object);\n    }\n    delete child.previousAttach;\n}\nconst RESERVED_PROPS = [\n    ...REACT_INTERNAL_PROPS,\n    // Instance props\n    \"args\",\n    \"dispose\",\n    \"attach\",\n    \"object\",\n    \"onUpdate\",\n    // Behavior flags\n    \"dispose\",\n];\nconst MEMOIZED_PROTOTYPES = new Map();\nfunction getMemoizedPrototype(root) {\n    let ctor = MEMOIZED_PROTOTYPES.get(root.constructor);\n    try {\n        if (!ctor) {\n            ctor = new root.constructor();\n            MEMOIZED_PROTOTYPES.set(root.constructor, ctor);\n        }\n    }\n    catch (e) {\n        console.log(e);\n        // ...\n    }\n    return ctor;\n}\n// This function prepares a set of changes to be applied to the instance\nfunction diffProps(instance, newProps) {\n    const changedProps = {};\n    // Sort through props\n    for (const prop in newProps) {\n        // Skip reserved keys\n        if (RESERVED_PROPS.includes(prop))\n            continue;\n        // Skip if props match\n        if (is.equ(newProps[prop], instance.props[prop]))\n            continue;\n        // Props changed, add them\n        changedProps[prop] = newProps[prop];\n        // Reset pierced props\n        for (const other in newProps) {\n            if (other.startsWith(`${prop}-`))\n                changedProps[other] = newProps[other];\n        }\n    }\n    // Reset removed props for HMR\n    for (const prop in instance.props) {\n        if (RESERVED_PROPS.includes(prop) || newProps.hasOwnProperty(prop))\n            continue;\n        const { root, key } = resolve(instance.object, prop);\n        // https://github.com/mrdoob/three.js/issues/21209\n        // HMR/fast-refresh relies on the ability to cancel out props, but threejs\n        // has no means to do this. Hence we curate a small collection of value-classes\n        // with their respective constructor/set arguments\n        // For removed props, try to set default values, if possible\n        if (root.constructor && root.constructor.length === 0) {\n            // create a blank slate of the instance and copy the particular parameter.\n            const ctor = getMemoizedPrototype(root);\n            if (!is.und(ctor))\n                changedProps[key] = ctor[key];\n        }\n        else {\n            // instance does not have constructor, just set it to 0\n            changedProps[key] = 0;\n        }\n    }\n    return changedProps;\n}\n// https://github.com/mrdoob/three.js/pull/27042\n// https://github.com/mrdoob/three.js/pull/22748\nconst colorMaps = [\"map\", \"emissiveMap\", \"sheenColorMap\", \"specularColorMap\", \"envMap\"];\nconst EVENT_REGEX = /^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/;\n// This function applies a set of changes to the instance\nfunction applyProps(object, props) {\n    const instance = object.__r3f;\n    const rootState = instance && findInitialRoot(instance).getState();\n    const prevHandlers = instance?.eventCount;\n    for (const prop in props) {\n        const value = props[prop];\n        // Don't mutate reserved keys\n        if (RESERVED_PROPS.includes(prop))\n            continue;\n        // Deal with pointer events, including removing them if undefined\n        if (instance && EVENT_REGEX.test(prop)) {\n            if (typeof value === \"function\")\n                instance.handlers[prop] = value;\n            else\n                delete instance.handlers[prop];\n            instance.eventCount = Object.keys(instance.handlers).length;\n            continue;\n        }\n        // Ignore setting undefined props\n        // https://github.com/pmndrs/react-three-fiber/issues/274\n        if (value === undefined)\n            continue;\n        const { root, key, target } = resolve(object, prop);\n        // Throw an error if we attempted to set a pierced prop to a non-object\n        if (target === undefined && (typeof root !== \"object\" || root === null)) {\n            throw Error(`R3F: Cannot set \"${prop}\". Ensure it is an object before setting \"${key}\".`);\n        }\n        // Layers must be written to the mask property\n        if (target instanceof THREE.Layers && value instanceof THREE.Layers) {\n            target.mask = value.mask;\n        }\n        // Set colors if valid color representation for automatic conversion (copy)\n        else if (target instanceof THREE.Color && isColorRepresentation(value)) {\n            target.set(value);\n        }\n        // Copy if properties match signatures and implement math interface (likely read-only)\n        else if (target !== null &&\n            typeof target === \"object\" &&\n            typeof target.set === \"function\" &&\n            typeof target.copy === \"function\" &&\n            value?.constructor &&\n            target.constructor === value.constructor) {\n            target.copy(value);\n        }\n        // Set array types\n        else if (target !== null && typeof target === \"object\" && typeof target.set === \"function\" && Array.isArray(value)) {\n            if (typeof target.fromArray === \"function\")\n                target.fromArray(value);\n            else\n                target.set(...value);\n        }\n        // Set literal types\n        else if (target !== null && typeof target === \"object\" && typeof target.set === \"function\" && typeof value === \"number\") {\n            // Allow setting array scalars\n            if (typeof target.setScalar === \"function\")\n                target.setScalar(value);\n            // Otherwise just set single value\n            else\n                target.set(value);\n        }\n        // Else, just overwrite the value\n        else {\n            root[key] = value;\n            // Auto-convert sRGB texture parameters for built-in materials\n            // https://github.com/pmndrs/react-three-fiber/issues/344\n            // https://github.com/mrdoob/three.js/pull/25857\n            if (rootState &&\n                !rootState.linear &&\n                colorMaps.includes(key) &&\n                root[key]?.isTexture &&\n                // sRGB textures must be RGBA8 since r137 https://github.com/mrdoob/three.js/pull/23129\n                root[key].format === THREE.RGBAFormat &&\n                root[key].type === THREE.UnsignedByteType) {\n                // NOTE: this cannot be set from the renderer (e.g. sRGB source textures rendered to P3)\n                root[key].colorSpace = THREE.SRGBColorSpace;\n            }\n        }\n    }\n    // Register event handlers\n    if (instance?.parent &&\n        rootState?.internal &&\n        instance.object?.isObject3D &&\n        prevHandlers !== instance.eventCount) {\n        const object = instance.object;\n        // Pre-emptively remove the instance from the interaction manager\n        const index = rootState.internal.interaction.indexOf(object);\n        if (index > -1)\n            rootState.internal.interaction.splice(index, 1);\n        // Add the instance to the interaction manager only when it has handlers\n        if (instance.eventCount && object.raycast !== null) {\n            rootState.internal.interaction.push(object);\n        }\n    }\n    // Auto-attach geometries and materials\n    if (instance && instance.props.attach === undefined) {\n        if (instance.object.isBufferGeometry)\n            instance.props.attach = \"geometry\";\n        else if (instance.object.isMaterial)\n            instance.props.attach = \"material\";\n    }\n    // Instance was updated, request a frame\n    if (instance)\n        invalidateInstance(instance);\n    return object;\n}\nfunction invalidateInstance(instance) {\n    if (!instance.parent)\n        return;\n    instance.props.onUpdate?.(instance.object);\n    const state = instance.root?.getState?.();\n    if (state && state.internal.frames === 0)\n        state.invalidate();\n}\nfunction updateCamera(camera, size) {\n    // Do not mess with the camera if it belongs to the user\n    // https://github.com/pmndrs/react-three-fiber/issues/92\n    if (camera.manual)\n        return;\n    if (isOrthographicCamera(camera)) {\n        camera.left = size.width / -2;\n        camera.right = size.width / 2;\n        camera.top = size.height / 2;\n        camera.bottom = size.height / -2;\n    }\n    else {\n        camera.aspect = size.width / size.height;\n    }\n    camera.updateProjectionMatrix();\n}\nconst isObject3D = (object) => object?.isObject3D;\n\n/* eslint-disable @typescript-eslint/ban-ts-comment */\n/* eslint-disable import/namespace */\n/* eslint-disable max-lines */\nfunction makeId(event) {\n    return (event.eventObject || event.object).uuid + \"/\" + event.index + event.instanceId;\n}\n/**\n * Release pointer captures.\n * This is called by releasePointerCapture in the API, and when an object is removed.\n */\nfunction releaseInternalPointerCapture(capturedMap, obj, captures, pointerId) {\n    const captureData = captures.get(obj);\n    if (captureData) {\n        captures.delete(obj);\n        // If this was the last capturing object for this pointer\n        if (captures.size === 0) {\n            capturedMap.delete(pointerId);\n            captureData.target.releasePointerCapture(pointerId);\n        }\n    }\n}\nfunction removeInteractivity(store, object) {\n    const { internal } = store.getState();\n    // Removes every trace of an object from the data store\n    internal.interaction = internal.interaction.filter((o) => o !== object);\n    internal.initialHits = internal.initialHits.filter((o) => o !== object);\n    internal.hovered.forEach((value, key) => {\n        if (value.eventObject === object || value.object === object) {\n            // Clear out intersects, they are outdated by now\n            internal.hovered.delete(key);\n        }\n    });\n    internal.capturedMap.forEach((captures, pointerId) => {\n        releaseInternalPointerCapture(internal.capturedMap, object, captures, pointerId);\n    });\n}\nfunction createEvents(store) {\n    /** Calculates delta */\n    function calculateDistance(event) {\n        const { internal } = store.getState();\n        const dx = event.offsetX - internal.initialClick[0];\n        const dy = event.offsetY - internal.initialClick[1];\n        return Math.round(Math.sqrt(dx * dx + dy * dy));\n    }\n    /** Returns true if an instance has a valid pointer-event registered, this excludes scroll, clicks etc */\n    function filterPointerEvents(objects) {\n        return objects.filter((obj) => [\"Move\", \"Over\", \"Enter\", \"Out\", \"Leave\"].some((name) => obj.__r3f?.handlers[(\"onPointer\" + name)]));\n    }\n    function intersect(event, filter) {\n        const state = store.getState();\n        const duplicates = new Set();\n        const intersections = [];\n        // Allow callers to eliminate event objects\n        const eventsObjects = filter ? filter(state.internal.interaction) : state.internal.interaction;\n        // Reset all raycaster cameras to undefined\n        for (let i = 0; i < eventsObjects.length; i++) {\n            const state = getRootState(eventsObjects[i]);\n            if (state) {\n                state.raycaster.camera = undefined;\n            }\n        }\n        if (!state.previousRoot) {\n            // Make sure root-level pointer and ray are set up\n            state.events.compute?.(event, state);\n        }\n        function handleRaycast(obj) {\n            const state = getRootState(obj);\n            // Skip event handling when noEvents is set, or when the raycasters camera is null\n            if (!state || !state.events.enabled || state.raycaster.camera === null)\n                return [];\n            // When the camera is undefined we have to call the event layers update function\n            if (state.raycaster.camera === undefined) {\n                state.events.compute?.(event, state, state.previousRoot?.getState());\n                // If the camera is still undefined we have to skip this layer entirely\n                if (state.raycaster.camera === undefined)\n                    state.raycaster.camera = null;\n            }\n            // Intersect object by object\n            return state.raycaster.camera ? state.raycaster.intersectObject(obj, true) : [];\n        }\n        // Collect events\n        let hits = eventsObjects\n            // Intersect objects\n            .flatMap(handleRaycast)\n            // Sort by event priority and distance\n            .sort((a, b) => {\n            const aState = getRootState(a.object);\n            const bState = getRootState(b.object);\n            if (!aState || !bState)\n                return a.distance - b.distance;\n            return bState.events.priority - aState.events.priority || a.distance - b.distance;\n        })\n            // Filter out duplicates\n            .filter((item) => {\n            const id = makeId(item);\n            if (duplicates.has(id))\n                return false;\n            duplicates.add(id);\n            return true;\n        });\n        // https://github.com/mrdoob/three.js/issues/16031\n        // Allow custom userland intersect sort order, this likely only makes sense on the root filter\n        if (state.events.filter)\n            hits = state.events.filter(hits, state);\n        // Bubble up the events, find the event source (eventObject)\n        for (const hit of hits) {\n            let eventObject = hit.object;\n            // Bubble event up\n            while (eventObject) {\n                if (eventObject.__r3f?.eventCount)\n                    intersections.push({ ...hit, eventObject });\n                eventObject = eventObject.parent;\n            }\n        }\n        // If the interaction is captured, make all capturing targets part of the intersect.\n        if (\"pointerId\" in event && state.internal.capturedMap.has(event.pointerId)) {\n            for (const captureData of state.internal.capturedMap.get(event.pointerId).values()) {\n                if (!duplicates.has(makeId(captureData.intersection)))\n                    intersections.push(captureData.intersection);\n            }\n        }\n        return intersections;\n    }\n    /**  Handles intersections by forwarding them to handlers */\n    function handleIntersects(intersections, event, delta, callback) {\n        // If anything has been found, forward it to the event listeners\n        if (intersections.length) {\n            const localState = { stopped: false };\n            for (const hit of intersections) {\n                let state = getRootState(hit.object);\n                // If the object is not managed by R3F, it might be parented to an element which is.\n                // Traverse upwards until we find a managed parent and use its state instead.\n                if (!state) {\n                    hit.object.traverseAncestors((obj) => {\n                        const parentState = getRootState(obj);\n                        if (parentState) {\n                            state = parentState;\n                            return false;\n                        }\n                    });\n                }\n                if (state) {\n                    const { raycaster, pointer, camera, internal } = state;\n                    const unprojectedPoint = new THREE.Vector3(pointer.x, pointer.y, 0).unproject(camera);\n                    const hasPointerCapture = (id) => internal.capturedMap.get(id)?.has(hit.eventObject) ?? false;\n                    const setPointerCapture = (id) => {\n                        const captureData = { intersection: hit, target: event.target };\n                        if (internal.capturedMap.has(id)) {\n                            // if the pointerId was previously captured, we add the hit to the\n                            // event capturedMap.\n                            internal.capturedMap.get(id).set(hit.eventObject, captureData);\n                        }\n                        else {\n                            // if the pointerId was not previously captured, we create a map\n                            // containing the hitObject, and the hit. hitObject is used for\n                            // faster access.\n                            internal.capturedMap.set(id, new Map([[hit.eventObject, captureData]]));\n                        }\n                        // Call the original event now\n                        event.target.setPointerCapture(id);\n                    };\n                    const releasePointerCapture = (id) => {\n                        const captures = internal.capturedMap.get(id);\n                        if (captures) {\n                            releaseInternalPointerCapture(internal.capturedMap, hit.eventObject, captures, id);\n                        }\n                    };\n                    // Add native event props\n                    const extractEventProps = {};\n                    // This iterates over the event's properties including the inherited ones. Native PointerEvents have most of their props as getters which are inherited, but polyfilled PointerEvents have them all as their own properties (i.e. not inherited). We can't use Object.keys() or Object.entries() as they only return \"own\" properties; nor Object.getPrototypeOf(event) as that *doesn't* return \"own\" properties, only inherited ones.\n                    for (const prop in event) {\n                        const property = event[prop];\n                        // Only copy over atomics, leave functions alone as these should be\n                        // called as event.nativeEvent.fn()\n                        if (typeof property !== \"function\")\n                            extractEventProps[prop] = property;\n                    }\n                    const raycastEvent = {\n                        ...hit,\n                        ...extractEventProps,\n                        pointer,\n                        intersections,\n                        stopped: localState.stopped,\n                        delta,\n                        unprojectedPoint,\n                        ray: raycaster.ray,\n                        camera: camera,\n                        // Hijack stopPropagation, which just sets a flag\n                        stopPropagation() {\n                            // https://github.com/pmndrs/react-three-fiber/issues/596\n                            // Events are not allowed to stop propagation if the pointer has been captured\n                            const capturesForPointer = \"pointerId\" in event && internal.capturedMap.get(event.pointerId);\n                            // We only authorize stopPropagation...\n                            if (\n                            // ...if this pointer hasn't been captured\n                            !capturesForPointer ||\n                                // ... or if the hit object is capturing the pointer\n                                capturesForPointer.has(hit.eventObject)) {\n                                raycastEvent.stopped = localState.stopped = true;\n                                // Propagation is stopped, remove all other hover records\n                                // An event handler is only allowed to flush other handlers if it is hovered itself\n                                if (internal.hovered.size && Array.from(internal.hovered.values()).find((i) => i.eventObject === hit.eventObject)) {\n                                    // Objects cannot flush out higher up objects that have already caught the event\n                                    const higher = intersections.slice(0, intersections.indexOf(hit));\n                                    cancelPointer([...higher, hit]);\n                                }\n                            }\n                        },\n                        // there should be a distinction between target and currentTarget\n                        target: { hasPointerCapture, setPointerCapture, releasePointerCapture },\n                        currentTarget: { hasPointerCapture, setPointerCapture, releasePointerCapture },\n                        nativeEvent: event,\n                    };\n                    // Call subscribers\n                    callback(raycastEvent);\n                    // Event bubbling may be interrupted by stopPropagation\n                    if (localState.stopped === true)\n                        break;\n                }\n            }\n        }\n        return intersections;\n    }\n    function cancelPointer(intersections) {\n        const { internal } = store.getState();\n        for (const hoveredObj of internal.hovered.values()) {\n            // When no objects were hit or the the hovered object wasn't found underneath the cursor\n            // we call onPointerOut and delete the object from the hovered-elements map\n            if (!intersections.length ||\n                !intersections.find((hit) => hit.object === hoveredObj.object && hit.index === hoveredObj.index && hit.instanceId === hoveredObj.instanceId)) {\n                const eventObject = hoveredObj.eventObject;\n                const instance = eventObject.__r3f;\n                internal.hovered.delete(makeId(hoveredObj));\n                if (instance?.eventCount) {\n                    const handlers = instance.handlers;\n                    // Clear out intersects, they are outdated by now\n                    const data = { ...hoveredObj, intersections };\n                    handlers.onPointerOut?.(data);\n                    handlers.onPointerLeave?.(data);\n                }\n            }\n        }\n    }\n    function pointerMissed(event, objects) {\n        for (let i = 0; i < objects.length; i++) {\n            const instance = objects[i].__r3f;\n            instance?.handlers.onPointerMissed?.(event);\n        }\n    }\n    function handlePointer(name) {\n        // Deal with cancelation\n        switch (name) {\n            case \"onPointerLeave\":\n            case \"onPointerCancel\":\n                return () => cancelPointer([]);\n            case \"onLostPointerCapture\":\n                return (event) => {\n                    const { internal } = store.getState();\n                    if (\"pointerId\" in event && internal.capturedMap.has(event.pointerId)) {\n                        // If the object event interface had onLostPointerCapture, we'd call it here on every\n                        // object that's getting removed. We call it on the next frame because onLostPointerCapture\n                        // fires before onPointerUp. Otherwise pointerUp would never be called if the event didn't\n                        // happen in the object it originated from, leaving components in a in-between state.\n                        requestAnimationFrame(() => {\n                            // Only release if pointer-up didn't do it already\n                            if (internal.capturedMap.has(event.pointerId)) {\n                                internal.capturedMap.delete(event.pointerId);\n                                cancelPointer([]);\n                            }\n                        });\n                    }\n                };\n        }\n        // Any other pointer goes here ...\n        return function handleEvent(event) {\n            const { onPointerMissed, internal } = store.getState();\n            // prepareRay(event)\n            // @ts-ignore\n            internal.lastEvent.current = event;\n            // Get fresh intersects\n            const isPointerMove = name === \"onPointerMove\";\n            const isClickEvent = name === \"onClick\" || name === \"onContextMenu\" || name === \"onDoubleClick\";\n            const filter = isPointerMove ? filterPointerEvents : undefined;\n            const hits = intersect(event, filter);\n            const delta = isClickEvent ? calculateDistance(event) : 0;\n            // Save initial coordinates on pointer-down\n            if (name === \"onPointerDown\") {\n                internal.initialClick = [event.offsetX, event.offsetY];\n                internal.initialHits = hits.map((hit) => hit.eventObject);\n            }\n            // If a click yields no results, pass it back to the user as a miss\n            // Missed events have to come first in order to establish user-land side-effect clean up\n            if (isClickEvent && !hits.length) {\n                if (delta <= 2) {\n                    pointerMissed(event, internal.interaction);\n                    if (onPointerMissed)\n                        onPointerMissed(event);\n                }\n            }\n            // Take care of unhover\n            if (isPointerMove)\n                cancelPointer(hits);\n            function onIntersect(data) {\n                const eventObject = data.eventObject;\n                const instance = eventObject.__r3f;\n                // Check presence of handlers\n                if (!instance?.eventCount)\n                    return;\n                const handlers = instance.handlers;\n                /*\n                MAYBE TODO, DELETE IF NOT:\n                  Check if the object is captured, captured events should not have intersects running in parallel\n                  But wouldn't it be better to just replace capturedMap with a single entry?\n                  Also, are we OK with straight up making picking up multiple objects impossible?\n                  \n                const pointerId = (data as ThreeEvent<PointerEvent>).pointerId\n                if (pointerId !== undefined) {\n                  const capturedMeshSet = internal.capturedMap.get(pointerId)\n                  if (capturedMeshSet) {\n                    const captured = capturedMeshSet.get(eventObject)\n                    if (captured && captured.localState.stopped) return\n                  }\n                }*/\n                if (isPointerMove) {\n                    // Move event ...\n                    if (handlers.onPointerOver || handlers.onPointerEnter || handlers.onPointerOut || handlers.onPointerLeave) {\n                        // When enter or out is present take care of hover-state\n                        const id = makeId(data);\n                        const hoveredItem = internal.hovered.get(id);\n                        if (!hoveredItem) {\n                            // If the object wasn't previously hovered, book it and call its handler\n                            internal.hovered.set(id, data);\n                            handlers.onPointerOver?.(data);\n                            handlers.onPointerEnter?.(data);\n                        }\n                        else if (hoveredItem.stopped) {\n                            // If the object was previously hovered and stopped, we shouldn't allow other items to proceed\n                            data.stopPropagation();\n                        }\n                    }\n                    // Call mouse move\n                    handlers.onPointerMove?.(data);\n                }\n                else {\n                    // All other events ...\n                    const handler = handlers[name];\n                    if (handler) {\n                        // Forward all events back to their respective handlers with the exception of click events,\n                        // which must use the initial target\n                        if (!isClickEvent || internal.initialHits.includes(eventObject)) {\n                            // Missed events have to come first\n                            pointerMissed(event, internal.interaction.filter((object) => !internal.initialHits.includes(object)));\n                            // Now call the handler\n                            handler(data);\n                        }\n                    }\n                    else {\n                        // Trigger onPointerMissed on all elements that have pointer over/out handlers, but not click and weren't hit\n                        if (isClickEvent && internal.initialHits.includes(eventObject)) {\n                            pointerMissed(event, internal.interaction.filter((object) => !internal.initialHits.includes(object)));\n                        }\n                    }\n                }\n            }\n            handleIntersects(hits, event, delta, onIntersect);\n        };\n    }\n    return { handlePointer };\n}\n\n/* eslint-disable import/namespace */\nconst isRenderer = (def) => !!def?.render;\nconst context = /* @__PURE__ */ React.createContext(null);\nconst createStore = (invalidate, advance) => {\n    const rootStore = createWithEqualityFn((set, get) => {\n        const position = new THREE.Vector3();\n        const defaultTarget = new THREE.Vector3();\n        const tempTarget = new THREE.Vector3();\n        function getCurrentViewport(camera = get().camera, target = defaultTarget, size = get().size) {\n            const { width, height, top, left } = size;\n            const aspect = width / height;\n            if (target.isVector3)\n                tempTarget.copy(target);\n            else\n                tempTarget.set(...target);\n            const distance = camera.getWorldPosition(position).distanceTo(tempTarget);\n            if (isOrthographicCamera(camera)) {\n                return { width: width / camera.zoom, height: height / camera.zoom, top, left, factor: 1, distance, aspect };\n            }\n            else {\n                const fov = (camera.fov * Math.PI) / 180; // convert vertical fov to radians\n                const h = 2 * Math.tan(fov / 2) * distance; // visible height\n                const w = h * (width / height);\n                return { width: w, height: h, top, left, factor: width / w, distance, aspect };\n            }\n        }\n        let performanceTimeout = undefined;\n        const setPerformanceCurrent = (current) => set((state) => ({ performance: { ...state.performance, current } }));\n        const pointer = new THREE.Vector2();\n        const rootState = {\n            set,\n            get,\n            // Mock objects that have to be configured\n            gl: null,\n            camera: null,\n            raycaster: null,\n            events: { priority: 1, enabled: true, connected: false },\n            scene: null,\n            xr: null,\n            invalidate: (frames = 1) => invalidate(get(), frames),\n            advance: (timestamp, runGlobalEffects) => advance(timestamp, runGlobalEffects, get()),\n            legacy: false,\n            linear: false,\n            flat: false,\n            controls: null,\n            clock: new THREE.Clock(),\n            pointer,\n            mouse: pointer,\n            frameloop: \"always\",\n            onPointerMissed: undefined,\n            performance: {\n                current: 1,\n                min: 0.5,\n                max: 1,\n                debounce: 200,\n                regress: () => {\n                    const state = get();\n                    // Clear timeout\n                    if (performanceTimeout)\n                        clearTimeout(performanceTimeout);\n                    // Set lower bound performance\n                    if (state.performance.current !== state.performance.min)\n                        setPerformanceCurrent(state.performance.min);\n                    // Go back to upper bound performance after a while unless something regresses meanwhile\n                    performanceTimeout = setTimeout(() => setPerformanceCurrent(get().performance.max), state.performance.debounce);\n                },\n            },\n            size: { width: 0, height: 0, top: 0, left: 0 },\n            viewport: {\n                initialDpr: 0,\n                dpr: 0,\n                width: 0,\n                height: 0,\n                top: 0,\n                left: 0,\n                aspect: 0,\n                distance: 0,\n                factor: 0,\n                getCurrentViewport,\n            },\n            setEvents: (events) => set((state) => ({ ...state, events: { ...state.events, ...events } })),\n            setSize: (width, height, top = 0, left = 0) => {\n                const camera = get().camera;\n                const size = { width, height, top, left };\n                set((state) => ({ size, viewport: { ...state.viewport, ...getCurrentViewport(camera, defaultTarget, size) } }));\n            },\n            setDpr: (dpr) => set((state) => {\n                const resolved = calculateDpr(dpr);\n                return { viewport: { ...state.viewport, dpr: resolved, initialDpr: state.viewport.initialDpr || resolved } };\n            }),\n            setFrameloop: (frameloop = \"always\") => {\n                const clock = get().clock;\n                // if frameloop === \"never\" clock.elapsedTime is updated using advance(timestamp)\n                clock.stop();\n                clock.elapsedTime = 0;\n                if (frameloop !== \"never\") {\n                    clock.start();\n                    clock.elapsedTime = 0;\n                }\n                set(() => ({ frameloop }));\n            },\n            previousRoot: undefined,\n            internal: {\n                // Events\n                interaction: [],\n                hovered: new Map(),\n                subscribers: [],\n                initialClick: [0, 0],\n                initialHits: [],\n                capturedMap: new Map(),\n                lastEvent: React.createRef(),\n                // Updates\n                active: false,\n                frames: 0,\n                priority: 0,\n                subscribe: (ref, priority, store) => {\n                    const internal = get().internal;\n                    // If this subscription was given a priority, it takes rendering into its own hands\n                    // For that reason we switch off automatic rendering and increase the manual flag\n                    // As long as this flag is positive there can be no internal rendering at all\n                    // because there could be multiple render subscriptions\n                    internal.priority = internal.priority + (priority > 0 ? 1 : 0);\n                    internal.subscribers.push({ ref, priority, store });\n                    // Register subscriber and sort layers from lowest to highest, meaning,\n                    // highest priority renders last (on top of the other frames)\n                    internal.subscribers = internal.subscribers.sort((a, b) => a.priority - b.priority);\n                    return () => {\n                        const internal = get().internal;\n                        if (internal?.subscribers) {\n                            // Decrease manual flag if this subscription had a priority\n                            internal.priority = internal.priority - (priority > 0 ? 1 : 0);\n                            // Remove subscriber from list\n                            internal.subscribers = internal.subscribers.filter((s) => s.ref !== ref);\n                        }\n                    };\n                },\n            },\n        };\n        return rootState;\n    });\n    const state = rootStore.getState();\n    let oldSize = state.size;\n    let oldDpr = state.viewport.dpr;\n    let oldCamera = state.camera;\n    rootStore.subscribe(() => {\n        const { camera, size, viewport, gl, set } = rootStore.getState();\n        // Resize camera and renderer on changes to size and pixelratio\n        if (size.width !== oldSize.width || size.height !== oldSize.height || viewport.dpr !== oldDpr) {\n            oldSize = size;\n            oldDpr = viewport.dpr;\n            // Update camera & renderer\n            updateCamera(camera, size);\n            if (viewport.dpr > 0)\n                gl.setPixelRatio(viewport.dpr);\n            const updateStyle = typeof HTMLCanvasElement !== \"undefined\" && gl.domElement instanceof HTMLCanvasElement;\n            gl.setSize(size.width, size.height, updateStyle);\n        }\n        // Update viewport once the camera changes\n        if (camera !== oldCamera) {\n            oldCamera = camera;\n            // Update viewport\n            set((state) => ({ viewport: { ...state.viewport, ...state.viewport.getCurrentViewport(camera) } }));\n        }\n    });\n    // Invalidate on any change\n    rootStore.subscribe((state) => invalidate(state));\n    // Return root state\n    return rootStore;\n};\n\n/**\n * Exposes an object's {@link Instance}.\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#useInstanceHandle\n *\n * **Note**: this is an escape hatch to react-internal fields. Expect this to change significantly between versions.\n */\nfunction useInstanceHandle(ref) {\n    const instance = React.useRef(null);\n    React.useImperativeHandle(instance, () => ref.current.__r3f, [ref]);\n    return instance;\n}\n/**\n * Returns the R3F Canvas' Zustand store. Useful for [transient updates](https://github.com/pmndrs/zustand#transient-updates-for-often-occurring-state-changes).\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#usestore\n */\nfunction useStore() {\n    const store = React.useContext(context);\n    if (!store)\n        throw new Error(\"R3F: Hooks can only be used within the Canvas component!\");\n    return store;\n}\n/**\n * Accesses R3F's internal state, containing renderer, canvas, scene, etc.\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#usethree\n */\nfunction useThree(selector = (state) => state, equalityFn) {\n    return useStore()(selector, equalityFn);\n}\n/**\n * Executes a callback before render in a shared frame loop.\n * Can order effects with render priority or manually render with a positive priority.\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#useframe\n */\nfunction useFrame(callback, renderPriority = 0) {\n    const store = useStore();\n    const subscribe = store.getState().internal.subscribe;\n    // Memoize ref\n    const ref = useMutableCallback(callback);\n    // Subscribe on mount, unsubscribe on unmount\n    useIsomorphicLayoutEffect(() => subscribe(ref, renderPriority, store), [renderPriority, subscribe, store]);\n    return null;\n}\n/**\n * Returns a node graph of an object with named nodes & materials.\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#usegraph\n */\nfunction useGraph(object) {\n    return React.useMemo(() => buildGraph(object), [object]);\n}\nconst memoizedLoaders = new WeakMap();\nconst isConstructor$1 = (value) => typeof value === \"function\" && value?.prototype?.constructor === value;\nfunction loadingFn(extensions, onProgress) {\n    return function (Proto, ...input) {\n        let loader;\n        // Construct and cache loader if constructor was passed\n        if (isConstructor$1(Proto)) {\n            loader = memoizedLoaders.get(Proto);\n            if (!loader) {\n                loader = new Proto();\n                memoizedLoaders.set(Proto, loader);\n            }\n        }\n        else {\n            loader = Proto;\n        }\n        // Apply loader extensions\n        if (extensions)\n            extensions(loader);\n        // Go through the urls and load them\n        return Promise.all(input.map((input) => new Promise((res, reject) => loader.load(input, (data) => {\n            if (isObject3D(data?.scene))\n                Object.assign(data, buildGraph(data.scene));\n            res(data);\n        }, onProgress, (error) => reject(new Error(`Could not load ${input}: ${error?.message}`))))));\n    };\n}\n/**\n * Synchronously loads and caches assets with a three loader.\n *\n * Note: this hook's caller must be wrapped with `React.Suspense`\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#useloader\n */\nfunction useLoader(loader, input, extensions, onProgress) {\n    // Use suspense to load async assets\n    const keys = (Array.isArray(input) ? input : [input]);\n    const results = suspend(loadingFn(extensions, onProgress), [loader, ...keys], { equal: is.equ });\n    // Return the object(s)\n    return (Array.isArray(input) ? results : results[0]);\n}\n/**\n * Preloads an asset into cache as a side-effect.\n */\nuseLoader.preload = function (loader, input, extensions) {\n    const keys = (Array.isArray(input) ? input : [input]);\n    return preload(loadingFn(extensions), [loader, ...keys]);\n};\n/**\n * Removes a loaded asset from cache.\n */\nuseLoader.clear = function (loader, input) {\n    const keys = (Array.isArray(input) ? input : [input]);\n    return clear([loader, ...keys]);\n};\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\r\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\nvar myreactReconciler = {exports: {}};\n\nvar index_production = {};\n\nvar hasRequiredIndex_production;\n\nfunction requireIndex_production () {\n\tif (hasRequiredIndex_production) return index_production;\n\thasRequiredIndex_production = 1;\n\t(function (exports) {\n\n\t\tvar react = React__default;\n\n\t\tvar merge = function (src, rest) {\n\t\t    return src | rest;\n\t\t};\n\t\tvar remove = function (src, rest) {\n\t\t    if (src & rest) {\n\t\t        return src ^ rest;\n\t\t    }\n\t\t    else {\n\t\t        return src;\n\t\t    }\n\t\t};\n\t\tvar include = function (src, rest) {\n\t\t    return !!(src & rest);\n\t\t};\n\t\tvar exclude = function (src, rest) {\n\t\t    return !(src & rest);\n\t\t};\n\r\n\t\ttypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n\t\t    var e = new Error(message);\r\n\t\t    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n\t\t};\n\n\t\tvar TYPEKEY = \"$$typeof\";\n\t\tvar Memo = Symbol.for(\"react.memo\");\n\t\tvar ForwardRef = Symbol.for(\"react.forward_ref\");\n\t\tvar Portal = Symbol.for(\"react.portal\");\n\t\tvar Fragment = Symbol.for(\"react.fragment\");\n\t\tvar Context = Symbol.for(\"react.context\");\n\t\tvar Provider = Symbol.for(\"react.provider\");\n\t\tvar Consumer = Symbol.for(\"react.consumer\");\n\t\tvar Lazy = Symbol.for(\"react.lazy\");\n\t\tvar Suspense = Symbol.for(\"react.suspense\");\n\t\tvar Strict = Symbol.for(\"react.strict_mode\");\n\t\tvar Root = Symbol.for(\"react.root\");\n\t\tvar Scope = Symbol.for(\"react.scope\");\n\t\tvar ScopeLazy = Symbol.for(\"react.scope_lazy\");\n\t\tvar ScopeSuspense = Symbol.for(\"react.scope_suspense\");\n\t\tvar Comment = Symbol.for(\"react.comment\");\n\t\tvar Activity = Symbol.for(\"react.activity\");\n\t\tvar Profiler = Symbol.for(\"react.profiler\");\n\n\t\tfunction isObject(target) {\n\t\t    return typeof target === \"object\" && target !== null;\n\t\t}\n\t\tfunction isFunction(target) {\n\t\t    return typeof target === \"function\";\n\t\t}\n\t\tvar isPromise = function (val) {\n\t\t    return (isObject(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);\n\t\t};\n\n\t\tvar UniqueArray = /** @class */ (function () {\n\t\t    function UniqueArray() {\n\t\t        this.set = new Set();\n\t\t        this.arr = new Array();\n\t\t        this.length = 0;\n\t\t    }\n\t\t    UniqueArray.prototype.uniPop = function () {\n\t\t        var v = this.arr.pop();\n\t\t        this.set.delete(v);\n\t\t        this.length--;\n\t\t        return v;\n\t\t    };\n\t\t    UniqueArray.prototype.uniPush = function (v) {\n\t\t        if (this.set.has(v))\n\t\t            return 0;\n\t\t        this.set.add(v);\n\t\t        this.arr.push(v);\n\t\t        this.length++;\n\t\t    };\n\t\t    UniqueArray.prototype.uniShift = function () {\n\t\t        var v = this.arr.shift();\n\t\t        this.set.delete(v);\n\t\t        this.length--;\n\t\t        return v;\n\t\t    };\n\t\t    UniqueArray.prototype.uniUnshift = function (v) {\n\t\t        if (this.set.has(v))\n\t\t            return 0;\n\t\t        this.set.add(v);\n\t\t        this.arr.unshift(v);\n\t\t        this.length++;\n\t\t    };\n\t\t    UniqueArray.prototype.uniDelete = function (v) {\n\t\t        if (this.set.has(v)) {\n\t\t            this.set.delete(v);\n\t\t            this.arr = this.arr.filter(function (i) { return i !== v; });\n\t\t            this.length--;\n\t\t        }\n\t\t    };\n\t\t    UniqueArray.prototype.clear = function () {\n\t\t        this.length = 0;\n\t\t        this.set.clear();\n\t\t        this.arr.length = 0;\n\t\t    };\n\t\t    UniqueArray.prototype.getAll = function () {\n\t\t        return Array.from(this.arr);\n\t\t    };\n\t\t    return UniqueArray;\n\t\t}());\n\n\t\tvar HOOK_TYPE;\n\t\t(function (HOOK_TYPE) {\n\t\t    HOOK_TYPE[HOOK_TYPE[\"useId\"] = 0] = \"useId\";\n\t\t    HOOK_TYPE[HOOK_TYPE[\"useRef\"] = 1] = \"useRef\";\n\t\t    HOOK_TYPE[HOOK_TYPE[\"useMemo\"] = 2] = \"useMemo\";\n\t\t    HOOK_TYPE[HOOK_TYPE[\"useState\"] = 3] = \"useState\";\n\t\t    HOOK_TYPE[HOOK_TYPE[\"useSignal\"] = 4] = \"useSignal\";\n\t\t    HOOK_TYPE[HOOK_TYPE[\"useEffect\"] = 5] = \"useEffect\";\n\t\t    HOOK_TYPE[HOOK_TYPE[\"useContext\"] = 6] = \"useContext\";\n\t\t    HOOK_TYPE[HOOK_TYPE[\"useReducer\"] = 7] = \"useReducer\";\n\t\t    HOOK_TYPE[HOOK_TYPE[\"useCallback\"] = 8] = \"useCallback\";\n\t\t    HOOK_TYPE[HOOK_TYPE[\"useTransition\"] = 9] = \"useTransition\";\n\t\t    HOOK_TYPE[HOOK_TYPE[\"useDebugValue\"] = 10] = \"useDebugValue\";\n\t\t    HOOK_TYPE[HOOK_TYPE[\"useLayoutEffect\"] = 11] = \"useLayoutEffect\";\n\t\t    HOOK_TYPE[HOOK_TYPE[\"useDeferredValue\"] = 12] = \"useDeferredValue\";\n\t\t    HOOK_TYPE[HOOK_TYPE[\"useInsertionEffect\"] = 13] = \"useInsertionEffect\";\n\t\t    HOOK_TYPE[HOOK_TYPE[\"useImperativeHandle\"] = 14] = \"useImperativeHandle\";\n\t\t    HOOK_TYPE[HOOK_TYPE[\"useSyncExternalStore\"] = 15] = \"useSyncExternalStore\";\n\t\t    HOOK_TYPE[HOOK_TYPE[\"useOptimistic\"] = 16] = \"useOptimistic\";\n\t\t    HOOK_TYPE[HOOK_TYPE[\"useEffectEvent\"] = 17] = \"useEffectEvent\";\n\t\t})(HOOK_TYPE || (HOOK_TYPE = {}));\n\n\t\tvar UpdateQueueType;\n\t\t(function (UpdateQueueType) {\n\t\t    UpdateQueueType[UpdateQueueType[\"component\"] = 1] = \"component\";\n\t\t    UpdateQueueType[UpdateQueueType[\"hook\"] = 2] = \"hook\";\n\t\t    UpdateQueueType[UpdateQueueType[\"context\"] = 3] = \"context\";\n\t\t    UpdateQueueType[UpdateQueueType[\"hmr\"] = 4] = \"hmr\";\n\t\t    UpdateQueueType[UpdateQueueType[\"trigger\"] = 5] = \"trigger\";\n\t\t    UpdateQueueType[UpdateQueueType[\"suspense\"] = 6] = \"suspense\";\n\t\t    UpdateQueueType[UpdateQueueType[\"lazy\"] = 7] = \"lazy\";\n\t\t    UpdateQueueType[UpdateQueueType[\"promise\"] = 8] = \"promise\";\n\t\t})(UpdateQueueType || (UpdateQueueType = {}));\n\n\t\tvar STATE_TYPE;\n\t\t(function (STATE_TYPE) {\n\t\t    STATE_TYPE[STATE_TYPE[\"__initial__\"] = 0] = \"__initial__\";\n\t\t    STATE_TYPE[STATE_TYPE[\"__create__\"] = 1] = \"__create__\";\n\t\t    STATE_TYPE[STATE_TYPE[\"__stable__\"] = 2] = \"__stable__\";\n\t\t    STATE_TYPE[STATE_TYPE[\"__inherit__\"] = 4] = \"__inherit__\";\n\t\t    STATE_TYPE[STATE_TYPE[\"__triggerConcurrent__\"] = 8] = \"__triggerConcurrent__\";\n\t\t    STATE_TYPE[STATE_TYPE[\"__triggerConcurrentForce__\"] = 16] = \"__triggerConcurrentForce__\";\n\t\t    STATE_TYPE[STATE_TYPE[\"__triggerSync__\"] = 32] = \"__triggerSync__\";\n\t\t    STATE_TYPE[STATE_TYPE[\"__triggerSyncForce__\"] = 64] = \"__triggerSyncForce__\";\n\t\t    STATE_TYPE[STATE_TYPE[\"__unmount__\"] = 128] = \"__unmount__\";\n\t\t    STATE_TYPE[STATE_TYPE[\"__hmr__\"] = 256] = \"__hmr__\";\n\t\t    STATE_TYPE[STATE_TYPE[\"__retrigger__\"] = 512] = \"__retrigger__\";\n\t\t    STATE_TYPE[STATE_TYPE[\"__reschedule__\"] = 1024] = \"__reschedule__\";\n\t\t    STATE_TYPE[STATE_TYPE[\"__recreate__\"] = 2048] = \"__recreate__\";\n\t\t    STATE_TYPE[STATE_TYPE[\"__suspense__\"] = 4096] = \"__suspense__\";\n\t\t})(STATE_TYPE || (STATE_TYPE = {}));\n\n\t\tvar PATCH_TYPE;\n\t\t(function (PATCH_TYPE) {\n\t\t    PATCH_TYPE[PATCH_TYPE[\"__initial__\"] = 0] = \"__initial__\";\n\t\t    PATCH_TYPE[PATCH_TYPE[\"__create__\"] = 1] = \"__create__\";\n\t\t    PATCH_TYPE[PATCH_TYPE[\"__update__\"] = 2] = \"__update__\";\n\t\t    PATCH_TYPE[PATCH_TYPE[\"__append__\"] = 4] = \"__append__\";\n\t\t    PATCH_TYPE[PATCH_TYPE[\"__position__\"] = 8] = \"__position__\";\n\t\t    PATCH_TYPE[PATCH_TYPE[\"__effect__\"] = 16] = \"__effect__\";\n\t\t    PATCH_TYPE[PATCH_TYPE[\"__layoutEffect__\"] = 32] = \"__layoutEffect__\";\n\t\t    PATCH_TYPE[PATCH_TYPE[\"__insertionEffect__\"] = 64] = \"__insertionEffect__\";\n\t\t    PATCH_TYPE[PATCH_TYPE[\"__unmount__\"] = 128] = \"__unmount__\";\n\t\t    PATCH_TYPE[PATCH_TYPE[\"__ref__\"] = 256] = \"__ref__\";\n\t\t})(PATCH_TYPE || (PATCH_TYPE = {}));\n\n\t\tvar Effect_TYPE;\n\t\t(function (Effect_TYPE) {\n\t\t    Effect_TYPE[Effect_TYPE[\"__initial__\"] = 0] = \"__initial__\";\n\t\t    Effect_TYPE[Effect_TYPE[\"__effect__\"] = 1] = \"__effect__\";\n\t\t    Effect_TYPE[Effect_TYPE[\"__unmount__\"] = 2] = \"__unmount__\";\n\t\t})(Effect_TYPE || (Effect_TYPE = {}));\n\n\t\tvar isNormalEquals = function (src, target, isSkipKey) {\n\t\t    var isEquals = Object.is(src, target);\n\t\t    if (isEquals)\n\t\t        return true;\n\t\t    var hasSkipKeyFunction = typeof isSkipKey === \"function\";\n\t\t    if (typeof src === \"object\" && typeof target === \"object\" && src !== null && target !== null) {\n\t\t        var srcKeys = Object.keys(src);\n\t\t        var targetKeys = Object.keys(target);\n\t\t        if (srcKeys.length !== targetKeys.length)\n\t\t            return false;\n\t\t        var res = true;\n\t\t        if (hasSkipKeyFunction) {\n\t\t            for (var _i = 0, srcKeys_1 = srcKeys; _i < srcKeys_1.length; _i++) {\n\t\t                var key = srcKeys_1[_i];\n\t\t                if (isSkipKey(key) && key in target) {\n\t\t                    continue;\n\t\t                }\n\t\t                else {\n\t\t                    res = res && Object.is(src[key], target[key]);\n\t\t                }\n\t\t                if (!res)\n\t\t                    return res;\n\t\t            }\n\t\t        }\n\t\t        else {\n\t\t            for (var _a = 0, srcKeys_2 = srcKeys; _a < srcKeys_2.length; _a++) {\n\t\t                var key = srcKeys_2[_a];\n\t\t                res = res && Object.is(src[key], target[key]);\n\t\t                if (!res)\n\t\t                    return res;\n\t\t            }\n\t\t        }\n\t\t        return res;\n\t\t    }\n\t\t    return false;\n\t\t};\n\t\tvar isArrayEquals = function (src, target) {\n\t\t    var isEquals = Object.is(src, target);\n\t\t    if (isEquals)\n\t\t        return true;\n\t\t    if (Array.isArray(src) && Array.isArray(target) && src.length === target.length) {\n\t\t        var re = true;\n\t\t        for (var key in src) {\n\t\t            re = re && Object.is(src[key], target[key]);\n\t\t            if (!re)\n\t\t                return re;\n\t\t        }\n\t\t        return re;\n\t\t    }\n\t\t    return false;\n\t\t};\n\n\t\tvar ListTreeNode = /** @class */ (function () {\n\t\t    function ListTreeNode(value) {\n\t\t        this.prev = null;\n\t\t        this.next = null;\n\t\t        this.value = value;\n\t\t    }\n\t\t    return ListTreeNode;\n\t\t}());\n\t\tvar ListTree = /** @class */ (function () {\n\t\t    function ListTree() {\n\t\t        this.length = 0;\n\t\t        var _stickyHead = null;\n\t\t        Object.defineProperty(this, \"stickyHead\", {\n\t\t            get: function () {\n\t\t                return _stickyHead;\n\t\t            },\n\t\t            set: function (v) {\n\t\t                _stickyHead = v;\n\t\t            },\n\t\t        });\n\t\t        var _stickyFoot = null;\n\t\t        Object.defineProperty(this, \"stickyFoot\", {\n\t\t            get: function () {\n\t\t                return _stickyFoot;\n\t\t            },\n\t\t            set: function (v) {\n\t\t                _stickyFoot = v;\n\t\t            },\n\t\t        });\n\t\t        var _head = null;\n\t\t        Object.defineProperty(this, \"head\", {\n\t\t            get: function () {\n\t\t                return _head;\n\t\t            },\n\t\t            set: function (v) {\n\t\t                _head = v;\n\t\t            },\n\t\t        });\n\t\t        var _foot = null;\n\t\t        Object.defineProperty(this, \"foot\", {\n\t\t            get: function () {\n\t\t                return _foot;\n\t\t            },\n\t\t            set: function (v) {\n\t\t                _foot = v;\n\t\t            },\n\t\t        });\n\t\t    }\n\t\t    ListTree.prototype.push = function (node) {\n\t\t        var listNode = new ListTreeNode(node);\n\t\t        this.length++;\n\t\t        if (!this.foot) {\n\t\t            this.head = listNode;\n\t\t            this.foot = listNode;\n\t\t        }\n\t\t        else {\n\t\t            this.foot.next = listNode;\n\t\t            listNode.prev = this.foot;\n\t\t            this.foot = listNode;\n\t\t        }\n\t\t    };\n\t\t    ListTree.prototype.pushToLast = function (node) {\n\t\t        if (this.stickyFoot) {\n\t\t            var node_1 = this.stickyFoot;\n\t\t            this.push(node_1.value);\n\t\t            this.stickyFoot = null;\n\t\t        }\n\t\t        else {\n\t\t            this.length++;\n\t\t        }\n\t\t        var listNode = new ListTreeNode(node);\n\t\t        this.stickyFoot = listNode;\n\t\t    };\n\t\t    ListTree.prototype.pushToHead = function (node) {\n\t\t        if (this.stickyHead) {\n\t\t            var node_2 = this.stickyHead;\n\t\t            this.unshift(node_2.value);\n\t\t            this.stickyHead = null;\n\t\t        }\n\t\t        else {\n\t\t            this.length++;\n\t\t        }\n\t\t        var listNode = new ListTreeNode(node);\n\t\t        this.stickyHead = listNode;\n\t\t    };\n\t\t    ListTree.prototype.pop = function () {\n\t\t        var foot = this.stickyFoot || this.foot || this.stickyHead;\n\t\t        if (foot) {\n\t\t            this.delete(foot);\n\t\t            return foot.value;\n\t\t        }\n\t\t        else {\n\t\t            return null;\n\t\t        }\n\t\t    };\n\t\t    ListTree.prototype.unshift = function (node) {\n\t\t        var listNode = new ListTreeNode(node);\n\t\t        this.length++;\n\t\t        if (!this.head) {\n\t\t            this.head = listNode;\n\t\t            this.foot = listNode;\n\t\t        }\n\t\t        else {\n\t\t            this.head.prev = listNode;\n\t\t            listNode.next = this.head;\n\t\t            this.head = listNode;\n\t\t        }\n\t\t    };\n\t\t    ListTree.prototype.unshiftToHead = function (node) {\n\t\t        if (this.stickyHead) {\n\t\t            var node_3 = this.stickyHead;\n\t\t            this.unshift(node_3.value);\n\t\t            this.stickyHead = null;\n\t\t        }\n\t\t        else {\n\t\t            this.length++;\n\t\t        }\n\t\t        var listNode = new ListTreeNode(node);\n\t\t        this.stickyHead = listNode;\n\t\t    };\n\t\t    ListTree.prototype.unshiftToFoot = function (node) {\n\t\t        if (this.stickyFoot) {\n\t\t            var node_4 = this.stickyFoot;\n\t\t            this.push(node_4.value);\n\t\t            this.stickyFoot = null;\n\t\t        }\n\t\t        else {\n\t\t            this.length++;\n\t\t        }\n\t\t        var listNode = new ListTreeNode(node);\n\t\t        this.stickyFoot = listNode;\n\t\t    };\n\t\t    ListTree.prototype.shift = function () {\n\t\t        var head = this.stickyHead || this.head || this.stickyFoot;\n\t\t        if (head) {\n\t\t            this.delete(head);\n\t\t            return head.value;\n\t\t        }\n\t\t        else {\n\t\t            return null;\n\t\t        }\n\t\t    };\n\t\t    ListTree.prototype.pickHead = function () {\n\t\t        var _a, _b;\n\t\t        return ((_a = this.stickyHead) === null || _a === void 0 ? void 0 : _a.value) || ((_b = this.head) === null || _b === void 0 ? void 0 : _b.value);\n\t\t    };\n\t\t    ListTree.prototype.pickFoot = function () {\n\t\t        var _a, _b;\n\t\t        return ((_a = this.stickyFoot) === null || _a === void 0 ? void 0 : _a.value) || ((_b = this.foot) === null || _b === void 0 ? void 0 : _b.value);\n\t\t    };\n\t\t    ListTree.prototype.listToFoot = function (action) {\n\t\t        if (this.stickyHead) {\n\t\t            action(this.stickyHead.value);\n\t\t        }\n\t\t        var node = this.head;\n\t\t        while (node) {\n\t\t            action(node.value);\n\t\t            node = node.next;\n\t\t        }\n\t\t        if (this.stickyFoot) {\n\t\t            action(this.stickyFoot.value);\n\t\t        }\n\t\t    };\n\t\t    ListTree.prototype.listToHead = function (action) {\n\t\t        if (this.stickyFoot) {\n\t\t            action(this.stickyFoot.value);\n\t\t        }\n\t\t        var node = this.foot;\n\t\t        while (node) {\n\t\t            action(node.value);\n\t\t            node = node.prev;\n\t\t        }\n\t\t        if (this.stickyHead) {\n\t\t            action(this.stickyHead.value);\n\t\t        }\n\t\t    };\n\t\t    ListTree.prototype.toArray = function () {\n\t\t        var re = [];\n\t\t        this.listToFoot(function (v) { return re.push(v); });\n\t\t        return re;\n\t\t    };\n\t\t    ListTree.prototype.delete = function (node) {\n\t\t        if (this.stickyHead === node) {\n\t\t            this.stickyHead = null;\n\t\t            this.length--;\n\t\t        }\n\t\t        else if (this.stickyFoot === node) {\n\t\t            this.stickyFoot = null;\n\t\t            this.length--;\n\t\t        }\n\t\t        else if (this.head === node) {\n\t\t            var next = node.next;\n\t\t            node.next = null;\n\t\t            if (next) {\n\t\t                this.head = next;\n\t\t                next.prev = null;\n\t\t            }\n\t\t            else {\n\t\t                this.head = null;\n\t\t                this.foot = null;\n\t\t            }\n\t\t            this.length--;\n\t\t        }\n\t\t        else if (this.foot === node) {\n\t\t            var prev = node.prev;\n\t\t            node.prev = null;\n\t\t            if (prev) {\n\t\t                this.foot = prev;\n\t\t                prev.next = null;\n\t\t            }\n\t\t            else {\n\t\t                this.head = null;\n\t\t                this.foot = null;\n\t\t            }\n\t\t            this.length--;\n\t\t        }\n\t\t        else if (this.hasNode(node)) {\n\t\t            var prev = node.prev;\n\t\t            var next = node.next;\n\t\t            node.prev = null;\n\t\t            node.next = null;\n\t\t            prev.next = next;\n\t\t            next.prev = prev;\n\t\t            this.length--;\n\t\t        }\n\t\t    };\n\t\t    ListTree.prototype.size = function () {\n\t\t        return this.length;\n\t\t    };\n\t\t    ListTree.prototype.hasNode = function (node) {\n\t\t        if (this.stickyHead && Object.is(this.stickyHead, node))\n\t\t            return true;\n\t\t        if (this.stickyFoot && Object.is(this.stickyFoot, node))\n\t\t            return true;\n\t\t        var listNode = this.head;\n\t\t        while (listNode) {\n\t\t            if (Object.is(listNode, node))\n\t\t                return true;\n\t\t            listNode = listNode.next;\n\t\t        }\n\t\t        return false;\n\t\t    };\n\t\t    ListTree.prototype.hasValue = function (node) {\n\t\t        if (this.stickyHead && Object.is(this.stickyHead.value, node))\n\t\t            return true;\n\t\t        if (this.stickyFoot && Object.is(this.stickyFoot.value, node))\n\t\t            return true;\n\t\t        var listNode = this.head;\n\t\t        while (listNode) {\n\t\t            if (Object.is(listNode.value, node))\n\t\t                return true;\n\t\t            listNode = listNode.next;\n\t\t        }\n\t\t        return false;\n\t\t    };\n\t\t    ListTree.prototype.some = function (iterator) {\n\t\t        var re = false;\n\t\t        this.listToFoot(function (node) {\n\t\t            re = re || iterator(node);\n\t\t        });\n\t\t        return re;\n\t\t    };\n\t\t    ListTree.prototype.every = function (iterator) {\n\t\t        var re = true;\n\t\t        this.listToFoot(function (node) {\n\t\t            re = re && iterator(node);\n\t\t        });\n\t\t        return re;\n\t\t    };\n\t\t    ListTree.prototype.concat = function (list) {\n\t\t        var newList = new ListTree();\n\t\t        this.listToFoot(function (node) { return newList.push(node); });\n\t\t        list.listToFoot(function (node) { return newList.push(node); });\n\t\t        return newList;\n\t\t    };\n\t\t    ListTree.prototype.clone = function () {\n\t\t        var newList = new ListTree();\n\t\t        this.listToFoot(function (v) { return newList.push(v); });\n\t\t        return newList;\n\t\t    };\n\t\t    ListTree.prototype.clear = function () {\n\t\t        this.length = 0;\n\t\t        this.head = null;\n\t\t        this.foot = null;\n\t\t        this.stickyHead = null;\n\t\t        this.stickyFoot = null;\n\t\t    };\n\t\t    return ListTree;\n\t\t}());\n\n\t\t/******************************************************************************\r\n\t\tCopyright (c) Microsoft Corporation.\r\n\r\n\t\tPermission to use, copy, modify, and/or distribute this software for any\r\n\t\tpurpose with or without fee is hereby granted.\r\n\r\n\t\tTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n\t\tREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n\t\tAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n\t\tINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n\t\tLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n\t\tOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n\t\tPERFORMANCE OF THIS SOFTWARE.\r\n\t\t***************************************************************************** */\r\n\t\t/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\n\t\tvar extendStatics = function(d, b) {\r\n\t\t    extendStatics = Object.setPrototypeOf ||\r\n\t\t        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n\t\t        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n\t\t    return extendStatics(d, b);\r\n\t\t};\r\n\r\n\t\tfunction __extends(d, b) {\r\n\t\t    if (typeof b !== \"function\" && b !== null)\r\n\t\t        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n\t\t    extendStatics(d, b);\r\n\t\t    function __() { this.constructor = d; }\r\n\t\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t\t}\r\n\r\n\t\tvar __assign = function() {\r\n\t\t    __assign = Object.assign || function __assign(t) {\r\n\t\t        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n\t\t            s = arguments[i];\r\n\t\t            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n\t\t        }\r\n\t\t        return t;\r\n\t\t    };\r\n\t\t    return __assign.apply(this, arguments);\r\n\t\t};\r\n\r\n\t\tfunction __awaiter(thisArg, _arguments, P, generator) {\r\n\t\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n\t\t    return new (P || (P = Promise))(function (resolve, reject) {\r\n\t\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n\t\t        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n\t\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n\t\t        step((generator = generator.apply(thisArg, [])).next());\r\n\t\t    });\r\n\t\t}\r\n\r\n\t\tfunction __generator(thisArg, body) {\r\n\t\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\r\n\t\t    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n\t\t    function verb(n) { return function (v) { return step([n, v]); }; }\r\n\t\t    function step(op) {\r\n\t\t        if (f) throw new TypeError(\"Generator is already executing.\");\r\n\t\t        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n\t\t            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n\t\t            if (y = 0, t) op = [op[0] & 2, t.value];\r\n\t\t            switch (op[0]) {\r\n\t\t                case 0: case 1: t = op; break;\r\n\t\t                case 4: _.label++; return { value: op[1], done: false };\r\n\t\t                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n\t\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n\t\t                default:\r\n\t\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n\t\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n\t\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n\t\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n\t\t                    if (t[2]) _.ops.pop();\r\n\t\t                    _.trys.pop(); continue;\r\n\t\t            }\r\n\t\t            op = body.call(thisArg, _);\r\n\t\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n\t\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n\t\t    }\r\n\t\t}\r\n\r\n\t\tfunction __spreadArray(to, from, pack) {\r\n\t\t    if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n\t\t        if (ar || !(i in from)) {\r\n\t\t            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n\t\t            ar[i] = from[i];\r\n\t\t        }\r\n\t\t    }\r\n\t\t    return to.concat(ar || Array.prototype.slice.call(from));\r\n\t\t}\r\n\r\n\t\ttypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n\t\t    var e = new Error(message);\r\n\t\t    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n\t\t};\n\n\t\tvar MyWeakMap = typeof WeakMap !== \"undefined\" ? WeakMap : Map;\n\n\t\tvar currentRefreshHandler = react.createRef(null);\n\t\t// TODO\n\t\t// need improve\n\t\tvar currentTriggerFiber = react.createRef(null);\n\t\tvar fiberToDispatchMap = react.__my_react_internal__.fiberToDispatchMap;\n\t\tvar enableFiberForLog = react.createRef(false);\n\t\tvar enableDebugUpdateQueue = react.createRef(false);\n\t\tvar enableValidMyReactElement = react.createRef(false);\n\t\tvar enableLogForCurrentFlowIsRunning = react.createRef(false);\n\n\t\texports.NODE_TYPE = void 0;\n\t\t(function (NODE_TYPE) {\n\t\t    NODE_TYPE[NODE_TYPE[\"__initial__\"] = 0] = \"__initial__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__class__\"] = 1] = \"__class__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__function__\"] = 2] = \"__function__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__lazy__\"] = 4] = \"__lazy__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__memo__\"] = 8] = \"__memo__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__forwardRef__\"] = 16] = \"__forwardRef__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__provider__\"] = 32] = \"__provider__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__consumer__\"] = 64] = \"__consumer__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__portal__\"] = 128] = \"__portal__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__null__\"] = 256] = \"__null__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__text__\"] = 512] = \"__text__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__empty__\"] = 1024] = \"__empty__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__plain__\"] = 2048] = \"__plain__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__strict__\"] = 4096] = \"__strict__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__suspense__\"] = 8192] = \"__suspense__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__fragment__\"] = 16384] = \"__fragment__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__root__\"] = 32768] = \"__root__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__scope__\"] = 65536] = \"__scope__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__comment__\"] = 131072] = \"__comment__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__profiler__\"] = 262144] = \"__profiler__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__context__\"] = 524288] = \"__context__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__scopeLazy__\"] = 1048576] = \"__scopeLazy__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__scopeSuspense__\"] = 2097152] = \"__scopeSuspense__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__activity__\"] = 4194304] = \"__activity__\";\n\t\t})(exports.NODE_TYPE || (exports.NODE_TYPE = {}));\n\n\t\tvar enableSyncFlush$1 = react.__my_react_shared__.enableSyncFlush;\n\t\t/**\n\t\t * @deprecated\n\t\t */\n\t\texports.syncFlush = false;\n\t\t/**\n\t\t * @deprecated\n\t\t */\n\t\tvar beforeSyncFlush = function () {\n\t\t    exports.syncFlush = true;\n\t\t};\n\t\t/**\n\t\t * @deprecated\n\t\t */\n\t\tvar afterSyncFlush = function () {\n\t\t    exports.syncFlush = false;\n\t\t};\n\t\tvar stack = [enableSyncFlush$1.current];\n\t\tvar beforeSyncUpdate = function () {\n\t\t    stack.push(enableSyncFlush$1.current);\n\t\t    enableSyncFlush$1.current = true;\n\t\t};\n\t\tvar afterSyncUpdate = function () {\n\t\t    enableSyncFlush$1.current = stack.pop();\n\t\t};\n\n\t\tvar currentRunningFiber$5 = react.__my_react_internal__.currentRunningFiber, currentScheduler$h = react.__my_react_internal__.currentScheduler, currentScopeFiber$1 = react.__my_react_internal__.currentScopeFiber, currentError$1 = react.__my_react_internal__.currentError, currentCallingFiber$1 = react.__my_react_internal__.currentCallingFiber;\n\t\tvar safeCall = function (action) {\n\t\t    var args = [];\n\t\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t\t        args[_i - 1] = arguments[_i];\n\t\t    }\n\t\t    try {\n\t\t        return action.call.apply(action, __spreadArray([null], args, false));\n\t\t    }\n\t\t    catch (e) {\n\t\t        var fiber = (currentCallingFiber$1 === null || currentCallingFiber$1 === void 0 ? void 0 : currentCallingFiber$1[(currentCallingFiber$1 === null || currentCallingFiber$1 === void 0 ? void 0 : currentCallingFiber$1.length) - 1]) || currentScopeFiber$1.current || currentRunningFiber$5.current;\n\t\t        var renderScheduler = currentScheduler$h.current;\n\t\t        currentError$1.current = currentError$1.current || e;\n\t\t        renderScheduler.dispatchError({ fiber: fiber, error: currentError$1.current });\n\t\t    }\n\t\t};\n\t\tvar safeCallWithCurrentFiber = function (_a) {\n\t\t    var action = _a.action, fiber = _a.fiber, fallback = _a.fallback;\n\t\t    var args = [];\n\t\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t\t        args[_i - 1] = arguments[_i];\n\t\t    }\n\t\t    currentCallingFiber$1.push(fiber);\n\t\t    try {\n\t\t        return action.call.apply(action, __spreadArray([null], args, false));\n\t\t    }\n\t\t    catch (e) {\n\t\t        if (fallback) {\n\t\t            return fallback();\n\t\t        }\n\t\t        else {\n\t\t            var renderScheduler = currentScheduler$h.current;\n\t\t            currentError$1.current = currentError$1.current || e;\n\t\t            renderScheduler.dispatchError({ fiber: fiber, error: currentError$1.current });\n\t\t        }\n\t\t    }\n\t\t    finally {\n\t\t        currentCallingFiber$1.pop();\n\t\t    }\n\t\t};\n\t\tvar callWithFiber = function (_a) {\n\t\t    var action = _a.action, fiber = _a.fiber;\n\t\t    var args = [];\n\t\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t\t        args[_i - 1] = arguments[_i];\n\t\t    }\n\t\t    currentScopeFiber$1.current = fiber;\n\t\t    try {\n\t\t        return action.call.apply(action, __spreadArray([null], args, false));\n\t\t    }\n\t\t    finally {\n\t\t        currentScopeFiber$1.current = null;\n\t\t    }\n\t\t};\n\t\tvar safeCallWithSync = function (action) {\n\t\t    var args = [];\n\t\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t\t        args[_i - 1] = arguments[_i];\n\t\t    }\n\t\t    try {\n\t\t        beforeSyncUpdate();\n\t\t        return action.call.apply(action, __spreadArray([null], args, false));\n\t\t    }\n\t\t    catch (e) {\n\t\t        var fiber = (currentCallingFiber$1 === null || currentCallingFiber$1 === void 0 ? void 0 : currentCallingFiber$1[(currentCallingFiber$1 === null || currentCallingFiber$1 === void 0 ? void 0 : currentCallingFiber$1.length) - 1]) || currentScopeFiber$1.current || currentRunningFiber$5.current;\n\t\t        var renderScheduler = currentScheduler$h.current;\n\t\t        currentError$1.current = currentError$1.current || e;\n\t\t        renderScheduler.dispatchError({ fiber: fiber, error: currentError$1.current });\n\t\t    }\n\t\t    finally {\n\t\t        afterSyncUpdate();\n\t\t    }\n\t\t};\n\n\t\tvar currentScheduler$g = react.__my_react_internal__.currentScheduler, currentRunningFiber$4 = react.__my_react_internal__.currentRunningFiber, currentScopeFiber = react.__my_react_internal__.currentScopeFiber, currentCallingFiber = react.__my_react_internal__.currentCallingFiber;\n\t\tvar enableOptimizeTreeLog = react.__my_react_shared__.enableOptimizeTreeLog;\n\t\tvar typeColor = {\n\t\t    normal: \"rgba(10, 190, 235, 0.8)\",\n\t\t    plain: \"rgba(100, 230, 40, 0.8)\",\n\t\t    unmount: \"rgba(230, 40, 40, 0.8)\",\n\t\t};\n\t\tvar warnMap = {};\n\t\tvar errorMap = {};\n\t\tvar fiberWarn = function (fiber) {\n\t\t    var args = [];\n\t\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t\t        args[_i - 1] = arguments[_i];\n\t\t    }\n\t\t    var renderDispatch = getCurrentDispatchFromFiber(fiber);\n\t\t    safeCallWithCurrentFiber({\n\t\t        fiber: fiber,\n\t\t        action: function () {\n\t\t            renderDispatch.callOnFiberWarn.apply(renderDispatch, __spreadArray([fiber], args, false));\n\t\t        },\n\t\t    });\n\t\t};\n\t\tvar fiberError = function (fiber) {\n\t\t    var args = [];\n\t\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t\t        args[_i - 1] = arguments[_i];\n\t\t    }\n\t\t    var renderDispatch = getCurrentDispatchFromFiber(fiber);\n\t\t    safeCallWithCurrentFiber({\n\t\t        fiber: fiber,\n\t\t        action: function () {\n\t\t            renderDispatch.callOnFiberError.apply(renderDispatch, __spreadArray([fiber], args, false));\n\t\t        },\n\t\t    });\n\t\t};\n\t\t// TODO! improve log\n\t\tvar originalWarn = console.warn;\n\t\tvar originalError = console.error;\n\t\tvar warnFiber = null;\n\t\tvar errorFiber = null;\n\t\tvar devWarn = function () {\n\t\t    var args = [];\n\t\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t\t        args[_i] = arguments[_i];\n\t\t    }\n\t\t    var renderScheduler = currentScheduler$g.current;\n\t\t    var startWithPlain = typeof args[0] === \"string\";\n\t\t    var renderFiber = warnFiber || (currentCallingFiber === null || currentCallingFiber === void 0 ? void 0 : currentCallingFiber[(currentCallingFiber === null || currentCallingFiber === void 0 ? void 0 : currentCallingFiber.length) - 1]) || currentScopeFiber.current || currentRunningFiber$4.current;\n\t\t    renderFiber && fiberWarn.apply(void 0, __spreadArray([renderFiber], args, false));\n\t\t    var treeLog = renderFiber ? renderScheduler.getFiberTree(renderFiber) : \"\";\n\t\t    if (enableFiberForLog.current && renderFiber) {\n\t\t        if (startWithPlain) {\n\t\t            originalWarn.call.apply(originalWarn, __spreadArray(__spreadArray([console], args, false), [treeLog, \"\\n\", renderFiber], false));\n\t\t        }\n\t\t        else {\n\t\t            originalWarn.call.apply(originalWarn, __spreadArray(__spreadArray([console, \"\"], args, false), [treeLog, \"\\n\", renderFiber], false));\n\t\t        }\n\t\t    }\n\t\t    else {\n\t\t        if (startWithPlain) {\n\t\t            originalWarn.call.apply(originalWarn, __spreadArray(__spreadArray([console], args, false), [treeLog], false));\n\t\t        }\n\t\t        else {\n\t\t            originalWarn.call.apply(originalWarn, __spreadArray(__spreadArray([console, \"\"], args, false), [treeLog], false));\n\t\t        }\n\t\t    }\n\t\t};\n\t\tvar devWarnWithFiber = function (fiber) {\n\t\t    var args = [];\n\t\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t\t        args[_i - 1] = arguments[_i];\n\t\t    }\n\t\t    warnFiber = fiber;\n\t\t    devWarn.apply(void 0, args);\n\t\t    // TODO\n\t\t    warnFiber = null;\n\t\t};\n\t\tvar devError = function () {\n\t\t    var args = [];\n\t\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t\t        args[_i] = arguments[_i];\n\t\t    }\n\t\t    var renderScheduler = currentScheduler$g.current;\n\t\t    var startWithPlain = typeof args[0] === \"string\";\n\t\t    var renderFiber = errorFiber || (currentCallingFiber === null || currentCallingFiber === void 0 ? void 0 : currentCallingFiber[(currentCallingFiber === null || currentCallingFiber === void 0 ? void 0 : currentCallingFiber.length) - 1]) || currentScopeFiber.current || currentRunningFiber$4.current;\n\t\t    renderFiber && fiberError.apply(void 0, __spreadArray([renderFiber], args, false));\n\t\t    var treeLog = renderFiber ? renderScheduler.getFiberTree(renderFiber) : \"\";\n\t\t    if (enableFiberForLog.current && renderFiber) {\n\t\t        if (startWithPlain) {\n\t\t            originalError.call.apply(originalError, __spreadArray(__spreadArray([console], args, false), [treeLog, \"\\n\", renderFiber], false));\n\t\t        }\n\t\t        else {\n\t\t            originalError.call.apply(originalError, __spreadArray(__spreadArray([console, \"\"], args, false), [treeLog, \"\\n\", renderFiber], false));\n\t\t        }\n\t\t    }\n\t\t    else {\n\t\t        if (startWithPlain) {\n\t\t            originalError.call.apply(originalError, __spreadArray(__spreadArray([console], args, false), [treeLog], false));\n\t\t        }\n\t\t        else {\n\t\t            originalError.call.apply(originalError, __spreadArray(__spreadArray([console, \"\"], args, false), [treeLog], false));\n\t\t        }\n\t\t    }\n\t\t};\n\t\tvar devErrorWithFiber = function (fiber) {\n\t\t    var args = [];\n\t\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t\t        args[_i - 1] = arguments[_i];\n\t\t    }\n\t\t    errorFiber = fiber;\n\t\t    devError.apply(void 0, args);\n\t\t    errorFiber = null;\n\t\t};\n\t\tvar setLogScope = function () {\n\t\t};\n\t\tvar resetLogScope = function () {\n\t\t};\n\t\tvar debugWithNode = function (fiber) {\n\t\t    var mayFiberContainer = fiber;\n\t\t    if (fiber.nativeNode || mayFiberContainer.containerNode) {\n\t\t        var node = (fiber.nativeNode || mayFiberContainer.containerNode);\n\t\t        node.__fiber__ = fiber;\n\t\t        node.__props__ = fiber.pendingProps;\n\t\t    }\n\t\t};\n\t\tvar getTrackDevLog = function (fiber) {\n\t\t    {\n\t\t        return \"\";\n\t\t    }\n\t\t};\n\t\tvar shouldIncludeLog = function (fiber) {\n\t\t    if (include(fiber.type, exports.NODE_TYPE.__class__ | exports.NODE_TYPE.__function__)) {\n\t\t        return true;\n\t\t    }\n\t\t    return false;\n\t\t};\n\t\tvar getFiberTagName = function (fiber) {\n\t\t    var tag = [];\n\t\t    if (fiber.type & exports.NODE_TYPE.__memo__) {\n\t\t        tag.push(\"memo\");\n\t\t    }\n\t\t    if (fiber.type & exports.NODE_TYPE.__forwardRef__) {\n\t\t        tag.push(\"forwardRef\");\n\t\t    }\n\t\t    if (fiber.type & exports.NODE_TYPE.__lazy__) {\n\t\t        tag.push(\"lazy\");\n\t\t    }\n\t\t    if (fiber.type & exports.NODE_TYPE.__fragment__ && fiber.pendingProps[\"wrap\"]) {\n\t\t        tag.push(\"auto-wrap\");\n\t\t    }\n\t\t    return tag.join(\"-\");\n\t\t};\n\t\tvar getPlainFiberName = function (fiber) {\n\t\t    if (fiber.type & exports.NODE_TYPE.__provider__) {\n\t\t        var typedElementType = fiber.elementType;\n\t\t        var name_2 = typedElementType.Context.displayName;\n\t\t        return \"\".concat(name_2 || \"Context\", \".Provider\");\n\t\t    }\n\t\t    if (fiber.type & exports.NODE_TYPE.__context__) {\n\t\t        var typedElementType = fiber.elementType;\n\t\t        var name_3 = typedElementType.displayName;\n\t\t        return \"\".concat(name_3 || \"Context\");\n\t\t    }\n\t\t    if (fiber.type & exports.NODE_TYPE.__consumer__) {\n\t\t        var typedElementType = fiber.elementType;\n\t\t        var name_4 = typedElementType.Context.displayName;\n\t\t        return \"\".concat(name_4 || \"Context\", \".Consumer\");\n\t\t    }\n\t\t    if (fiber.type & exports.NODE_TYPE.__lazy__) {\n\t\t        var typedElementType = fiber.elementType;\n\t\t        var typedRender = typedElementType === null || typedElementType === void 0 ? void 0 : typedElementType.render;\n\t\t        var name_5 = (typedRender === null || typedRender === void 0 ? void 0 : typedRender.displayName) || (typedRender === null || typedRender === void 0 ? void 0 : typedRender.name) || \"\";\n\t\t        return \"\".concat(name_5 || \"Anonymous\");\n\t\t    }\n\t\t    if (fiber.type & exports.NODE_TYPE.__portal__)\n\t\t        return \"Portal\";\n\t\t    if (fiber.type & exports.NODE_TYPE.__null__)\n\t\t        return \"Null\";\n\t\t    if (fiber.type & exports.NODE_TYPE.__empty__)\n\t\t        return \"Empty\";\n\t\t    if (fiber.type & exports.NODE_TYPE.__scope__)\n\t\t        return \"Scope\";\n\t\t    if (fiber.type & exports.NODE_TYPE.__scopeLazy__)\n\t\t        return \"ScopeLazy\";\n\t\t    if (fiber.type & exports.NODE_TYPE.__scopeSuspense__)\n\t\t        return \"ScopeSuspense\";\n\t\t    if (fiber.type & exports.NODE_TYPE.__strict__)\n\t\t        return \"Strict\";\n\t\t    if (fiber.type & exports.NODE_TYPE.__profiler__)\n\t\t        return \"Profiler\";\n\t\t    if (fiber.type & exports.NODE_TYPE.__suspense__)\n\t\t        return \"Suspense\";\n\t\t    if (fiber.type & exports.NODE_TYPE.__comment__)\n\t\t        return \"Comment\";\n\t\t    if (fiber.type & exports.NODE_TYPE.__root__)\n\t\t        return \"Root\";\n\t\t    if (fiber.type & exports.NODE_TYPE.__fragment__)\n\t\t        return \"Fragment\";\n\t\t    if (fiber.type & exports.NODE_TYPE.__text__)\n\t\t        return \"text\";\n\t\t    if (typeof fiber.elementType === \"string\")\n\t\t        return \"\".concat(fiber.elementType);\n\t\t    if (typeof fiber.elementType === \"function\") {\n\t\t        var typedElementType = fiber.elementType;\n\t\t        var name_6 = typedElementType.displayName || typedElementType.name || \"Anonymous\";\n\t\t        return \"\".concat(name_6);\n\t\t    }\n\t\t    return \"unknown\";\n\t\t};\n\t\t// TODO\n\t\tvar getElementName = function (fiber) {\n\t\t    var name = getPlainFiberName(fiber);\n\t\t    var tag = getFiberTagName(fiber);\n\t\t    return \"<\".concat(name).concat(tag ? \" - (\".concat(tag, \")\") : \"\", \" />\");\n\t\t};\n\t\tvar getFiberNodeName = function (fiber) { return \"\".concat(getElementName(fiber), \" \").concat(getTrackDevLog()); };\n\t\tvar getFiberNodeNameWithFiber = function (fiber) { return \"%c\".concat(getElementName(fiber), \"%c (%o)\"); };\n\t\tvar getFiberTree$1 = function (fiber) {\n\t\t    if (fiber) {\n\t\t        var preString = \"\".padEnd(4) + \"at\".padEnd(3);\n\t\t        var res = \"\";\n\t\t        var temp = fiber;\n\t\t        if (enableOptimizeTreeLog.current) {\n\t\t            while (temp) {\n\t\t                if (shouldIncludeLog(temp)) {\n\t\t                    res ? (res += \"\\n\".concat(preString).concat(getFiberNodeName(temp))) : (res = \"\".concat(preString).concat(getFiberNodeName(temp)));\n\t\t                }\n\t\t                temp = temp.parent;\n\t\t            }\n\t\t        }\n\t\t        else {\n\t\t            while (temp) {\n\t\t                res ? (res += \"\\n\".concat(preString).concat(getFiberNodeName(temp))) : (res = \"\".concat(preString).concat(getFiberNodeName(temp)));\n\t\t                temp = temp.parent;\n\t\t            }\n\t\t        }\n\t\t        return \"\\n\".concat(res);\n\t\t    }\n\t\t    return \"\";\n\t\t};\n\t\tvar getStackTree = function (fiber) {\n\t\t    var preString = \"\".padEnd(4) + \"at\".padEnd(3);\n\t\t    var res = \"\";\n\t\t    var temp = fiber;\n\t\t    while (temp) {\n\t\t        res ? (res += \"\\n\".concat(preString).concat(getElementName(temp))) : (res = \"\".concat(preString).concat(getElementName(temp)));\n\t\t        temp = temp.parent;\n\t\t    }\n\t\t    return \"\\n\".concat(res);\n\t\t};\n\t\tvar getFiberTreeWithFiber = function (fiber) {\n\t\t    var preString = \"at\".padEnd(3);\n\t\t    var res = \"\";\n\t\t    var arr = [];\n\t\t    var temp = fiber;\n\t\t    while (temp) {\n\t\t        res ? (res += \"\\n\".concat(preString).concat(getFiberNodeNameWithFiber(temp))) : (res = \"\".concat(preString).concat(getFiberNodeNameWithFiber(temp)));\n\t\t        var isMount = temp._debugIsMount;\n\t\t        var isPlain = temp.type & exports.NODE_TYPE.__plain__;\n\t\t        arr.push(\"color: white;background-color: \".concat(isMount ? (isPlain ? typeColor.plain : typeColor.normal) : typeColor.unmount, \"; border-radius: 2px; padding: 1px 5px; margin: 1px 0px\"));\n\t\t        arr.push(\"\");\n\t\t        arr.push(temp);\n\t\t        temp = temp.parent;\n\t\t    }\n\t\t    return { str: \"\".concat(res), arr: arr };\n\t\t};\n\t\tvar getHookTree = function (treeHookNode, errorType) {\n\t\t    var pre = \"\".toString().padEnd(3);\n\t\t    var message = \"[@my-react/react] hook for current component has a different state on current render and previous render, this is not a valid usage.\";\n\t\t    var re = \"\\n\" + pre + \"Last render:\".padEnd(28) + \"Next render:\".padEnd(10) + \"\\n\" + pre + \"-\".repeat(44) + \"\\n\";\n\t\t    var stack = pre + HOOK_TYPE[errorType.lastRender].padEnd(28) + HOOK_TYPE[errorType.nextRender].padEnd(10) + \"\\n\";\n\t\t    while (treeHookNode && treeHookNode.value) {\n\t\t        var t = treeHookNode.value.type;\n\t\t        stack = pre + HOOK_TYPE[t].padEnd(28) + HOOK_TYPE[t].padEnd(10) + \"\\n\" + stack;\n\t\t        treeHookNode = treeHookNode.prev;\n\t\t    }\n\t\t    stack += pre + \"^\".repeat(44);\n\t\t    return message + re + stack;\n\t\t};\n\t\tvar onceWarnWithKeyAndFiber = function (fiber, key) {\n\t\t    var _a;\n\t\t    var _b;\n\t\t    var args = [];\n\t\t    for (var _i = 2; _i < arguments.length; _i++) {\n\t\t        args[_i - 2] = arguments[_i];\n\t\t    }\n\t\t    var renderScheduler = currentScheduler$g.current;\n\t\t    var tree = renderScheduler.getFiberTree(fiber);\n\t\t    if ((_b = warnMap === null || warnMap === void 0 ? void 0 : warnMap[tree]) === null || _b === void 0 ? void 0 : _b[key])\n\t\t        return;\n\t\t    warnMap[tree] = __assign(__assign({}, warnMap === null || warnMap === void 0 ? void 0 : warnMap[tree]), (_a = {}, _a[key] = true, _a));\n\t\t    warnFiber = fiber;\n\t\t    devWarn.apply(void 0, args);\n\t\t    warnFiber = null;\n\t\t};\n\t\tvar onceErrorWithKeyAndFiber = function (fiber, key) {\n\t\t    var _a;\n\t\t    var _b;\n\t\t    var args = [];\n\t\t    for (var _i = 2; _i < arguments.length; _i++) {\n\t\t        args[_i - 2] = arguments[_i];\n\t\t    }\n\t\t    var renderScheduler = currentScheduler$g.current;\n\t\t    var tree = renderScheduler.getFiberTree(fiber);\n\t\t    if ((_b = errorMap === null || errorMap === void 0 ? void 0 : errorMap[tree]) === null || _b === void 0 ? void 0 : _b[key])\n\t\t        return;\n\t\t    errorMap[tree] = __assign(__assign({}, errorMap === null || errorMap === void 0 ? void 0 : errorMap[tree]), (_a = {}, _a[key] = true, _a));\n\t\t    errorFiber = fiber;\n\t\t    devError.apply(void 0, args);\n\t\t    errorFiber = null;\n\t\t};\n\n\t\treact.__my_react_shared__.enableHMRForDev;\n\t\tvar emptyProps$1 = {};\n\t\tvar getElementTypeFromType = function (type) {\n\t\t    if (typeof type === \"object\") {\n\t\t        switch (type[TYPEKEY]) {\n\t\t            case ForwardRef:\n\t\t            case Memo:\n\t\t                return getElementTypeFromType(type.render);\n\t\t        }\n\t\t    }\n\t\t    return type;\n\t\t};\n\t\tvar getTypeFromElementNode = function (element) {\n\t\t    var nodeType = exports.NODE_TYPE.__initial__;\n\t\t    if (react.isValidElement(element)) {\n\t\t        return getTypeFromElement(element);\n\t\t    }\n\t\t    else {\n\t\t        if (typeof element === \"object\" && element !== null) {\n\t\t            nodeType = merge(nodeType, exports.NODE_TYPE.__empty__);\n\t\t        }\n\t\t        else if (element === null || element === undefined || typeof element === \"boolean\" || typeof element === \"function\" || element === \"\") {\n\t\t            nodeType = merge(nodeType, exports.NODE_TYPE.__null__);\n\t\t        }\n\t\t        else {\n\t\t            // text element\n\t\t            return {\n\t\t                key: null,\n\t\t                ref: null,\n\t\t                nodeType: exports.NODE_TYPE.__text__,\n\t\t                elementType: String(element),\n\t\t                pendingProps: emptyProps$1,\n\t\t                finalElement: element,\n\t\t                pendingText: String(element),\n\t\t            };\n\t\t        }\n\t\t    }\n\t\t    return { key: null, ref: null, nodeType: nodeType, elementType: null, pendingProps: emptyProps$1, finalElement: element };\n\t\t};\n\t\tvar getTypeFromElement = function (element) {\n\t\t    var _a, _b, _e, _f, _g;\n\t\t    var nodeType = exports.NODE_TYPE.__initial__;\n\t\t    var elementType = element.type;\n\t\t    var finalElement = element;\n\t\t    var pendingProps = element.props;\n\t\t    var ref = (_a = element.ref) !== null && _a !== void 0 ? _a : undefined;\n\t\t    var key = (_b = element.key) !== null && _b !== void 0 ? _b : undefined;\n\t\t    if (typeof elementType === \"object\" && elementType !== null) {\n\t\t        var typedElementType = elementType;\n\t\t        switch (typedElementType[TYPEKEY]) {\n\t\t            case Provider:\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__provider__);\n\t\t                break;\n\t\t            // support react 19 context api\n\t\t            case Context:\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__context__);\n\t\t                break;\n\t\t            case Consumer:\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__consumer__);\n\t\t                break;\n\t\t            case Memo:\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__memo__);\n\t\t                elementType = typedElementType.render;\n\t\t                break;\n\t\t            case ForwardRef:\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__forwardRef__);\n\t\t                elementType = typedElementType.render;\n\t\t                break;\n\t\t            case Lazy:\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__lazy__);\n\t\t                break;\n\t\t            default:\n\t\t                throw new Error(\"[@my-react/react] invalid object element type \\\"\".concat((_e = typedElementType[TYPEKEY]) === null || _e === void 0 ? void 0 : _e.toString(), \"\\\"\"));\n\t\t        }\n\t\t        if (typeof elementType === \"object\") {\n\t\t            if (elementType[TYPEKEY] === ForwardRef) {\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__forwardRef__);\n\t\t                elementType = elementType.render;\n\t\t            }\n\t\t            if (elementType[TYPEKEY] === Provider) {\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__provider__);\n\t\t            }\n\t\t            if (elementType[TYPEKEY] === Context) {\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__context__);\n\t\t            }\n\t\t            if (elementType[TYPEKEY] === Consumer) {\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__consumer__);\n\t\t            }\n\t\t        }\n\t\t        if (typeof elementType === \"function\") {\n\t\t            if ((_f = elementType.prototype) === null || _f === void 0 ? void 0 : _f.isMyReactComponent) {\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__class__);\n\t\t            }\n\t\t            else {\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__function__);\n\t\t            }\n\t\t        }\n\t\t    }\n\t\t    else if (typeof elementType === \"function\") {\n\t\t        if ((_g = elementType.prototype) === null || _g === void 0 ? void 0 : _g.isMyReactComponent) {\n\t\t            nodeType = merge(nodeType, exports.NODE_TYPE.__class__);\n\t\t        }\n\t\t        else {\n\t\t            nodeType = merge(nodeType, exports.NODE_TYPE.__function__);\n\t\t        }\n\t\t    }\n\t\t    else if (typeof elementType === \"symbol\") {\n\t\t        switch (elementType) {\n\t\t            case Root:\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__root__);\n\t\t                break;\n\t\t            case Fragment:\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__fragment__);\n\t\t                break;\n\t\t            case Strict:\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__strict__);\n\t\t                break;\n\t\t            case Suspense:\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__suspense__);\n\t\t                break;\n\t\t            case Scope:\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__scope__);\n\t\t                break;\n\t\t            case ScopeLazy:\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__scopeLazy__);\n\t\t                break;\n\t\t            case ScopeSuspense:\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__scopeSuspense__);\n\t\t                break;\n\t\t            case Comment:\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__comment__);\n\t\t                break;\n\t\t            case Portal:\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__portal__);\n\t\t                break;\n\t\t            case Profiler:\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__profiler__);\n\t\t                break;\n\t\t            case Activity:\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__activity__);\n\t\t                break;\n\t\t            default:\n\t\t                throw new Error(\"[@my-react/react] invalid symbol element type \\\"\".concat(elementType === null || elementType === void 0 ? void 0 : elementType.toString(), \"\\\"\"));\n\t\t        }\n\t\t    }\n\t\t    else if (typeof elementType === \"string\" && elementType !== \"\") {\n\t\t        nodeType = merge(nodeType, exports.NODE_TYPE.__plain__);\n\t\t    }\n\t\t    else {\n\t\t        nodeType = merge(nodeType, exports.NODE_TYPE.__empty__);\n\t\t    }\n\t\t    return { key: key, ref: ref, nodeType: nodeType, elementType: elementType, pendingProps: pendingProps, finalElement: finalElement };\n\t\t};\n\n\t\t// used for hmr\n\t\tvar typeToFibersMap = new MyWeakMap();\n\t\tvar setRefreshHandler = function (handler) {\n\t\t};\n\t\tvar setRefreshTypeMap = function (fiber) {\n\t\t    if (include(fiber.type, exports.NODE_TYPE.__class__ | exports.NODE_TYPE.__function__)) {\n\t\t        var elementType = fiber.elementType;\n\t\t        var exist = typeToFibersMap.get(elementType) || new Set();\n\t\t        exist.add(fiber);\n\t\t        typeToFibersMap.set(elementType, exist);\n\t\t    }\n\t\t};\n\t\tvar getCurrentTypeFromRefresh = function (type) {\n\t\t    var _a;\n\t\t    return ((_a = void 0 ) === null || _a === void 0 ? void 0 : _a.current) || type;\n\t\t};\n\t\tvar getCurrentTypeFromRefreshOnly = function (type) {\n\t\t    var _a;\n\t\t    return (_a = void 0 ) === null || _a === void 0 ? void 0 : _a.current;\n\t\t};\n\t\tvar getCurrentFibersFromType = function (type) {\n\t\t    return typeToFibersMap.get(type);\n\t\t};\n\t\tvar getCurrentDispatchFromType = function (type) {\n\t\t    var fibers = getCurrentFibersFromType(type);\n\t\t    return new Set(Array.from(fibers || []).map(function (fiber) { return fiberToDispatchMap.get(fiber); }));\n\t\t};\n\t\tvar getCurrentDispatchFromFiber = function (fiber) {\n\t\t    var dispatch = fiberToDispatchMap.get(fiber);\n\t\t    if (dispatch)\n\t\t        return dispatch;\n\t\t    var parent = fiber.parent;\n\t\t    while (parent) {\n\t\t        var typedFiberRoot = parent;\n\t\t        if (typedFiberRoot.renderDispatch) {\n\t\t            return typedFiberRoot.renderDispatch;\n\t\t        }\n\t\t        parent = parent.parent;\n\t\t    }\n\t\t};\n\t\tvar getElementFromRefreshIfExist = function (element) {\n\t\t    var _a, _b;\n\t\t    var elementType = getElementTypeFromType(element.type);\n\t\t    // current element is React component\n\t\t    if (typeof elementType === \"function\") {\n\t\t        var typeFromRefresh = getCurrentTypeFromRefreshOnly();\n\t\t        // have a new version elementType from hmr runtime\n\t\t        if (typeFromRefresh) {\n\t\t            return react.createElement(typeFromRefresh, __assign(__assign({}, element.props), { key: (_a = element.key) !== null && _a !== void 0 ? _a : undefined, ref: (_b = element.ref) !== null && _b !== void 0 ? _b : undefined }));\n\t\t        }\n\t\t    }\n\t\t    return element;\n\t\t};\n\n\t\treact.__my_react_internal__.currentComponentFiber;\n\t\tvar initHMR = function (env) {\n\t\t};\n\n\t\tvar currentRunningFiber$3 = react.__my_react_internal__.currentRunningFiber, currentScheduler$f = react.__my_react_internal__.currentScheduler;\n\t\tvar dispatchHook = function (params) {\n\t\t    var fiber = currentRunningFiber$3.current;\n\t\t    if (!fiber) {\n\t\t        throw new Error(\"No current running fiber found for dispatching hook.\");\n\t\t    }\n\t\t    if (include(fiber.state, STATE_TYPE.__unmount__))\n\t\t        return;\n\t\t    var dispatch = getCurrentDispatchFromFiber(fiber);\n\t\t    if (!dispatch) {\n\t\t        throw new Error(\"No dispatch found for the current running fiber.\");\n\t\t    }\n\t\t    return dispatch.dispatchHook(params);\n\t\t};\n\t\tvar dispatchState = function (_params) {\n\t\t    var trigger = _params.trigger;\n\t\t    var fiber = trigger._reactInternals || trigger;\n\t\t    if (!fiber) {\n\t\t        throw new Error(\"No fiber found for dispatching state.\");\n\t\t    }\n\t\t    if (include(fiber.state, STATE_TYPE.__unmount__))\n\t\t        return;\n\t\t    var dispatch = getCurrentDispatchFromFiber(fiber);\n\t\t    if (!dispatch) {\n\t\t        throw new Error(\"No dispatch found for the current running fiber.\");\n\t\t    }\n\t\t    return dispatch.dispatchState(_params);\n\t\t};\n\t\tvar dispatchError = function (_params) {\n\t\t    var fiber = _params.fiber || currentRunningFiber$3.current;\n\t\t    if (!fiber) {\n\t\t        // a normal error\n\t\t        throw _params.error;\n\t\t    }\n\t\t    // if (include(fiber.state, STATE_TYPE.__unmount__)) return;\n\t\t    var dispatch = getCurrentDispatchFromFiber(fiber);\n\t\t    if (!dispatch) {\n\t\t        throw new Error(\"No dispatch found for the current running fiber.\");\n\t\t    }\n\t\t    return dispatch.dispatchError(_params);\n\t\t};\n\t\tvar dispatchPromise = function (_params) {\n\t\t    var fiber = _params.fiber || currentRunningFiber$3.current;\n\t\t    if (!fiber) {\n\t\t        throw new Error(\"No fiber found for dispatching promise.\");\n\t\t    }\n\t\t    // if (include(fiber.state, STATE_TYPE.__unmount__)) return;\n\t\t    var dispatch = getCurrentDispatchFromFiber(fiber);\n\t\t    if (!dispatch) {\n\t\t        throw new Error(\"No dispatch found for the current running fiber.\");\n\t\t    }\n\t\t    return dispatch.dispatchPromise(_params);\n\t\t};\n\t\tvar dispatchSuspensePromise = function (_params) {\n\t\t    var fiber = _params.fiber || currentRunningFiber$3.current;\n\t\t    if (!fiber) {\n\t\t        throw new Error(\"No fiber found for dispatching suspense promise.\");\n\t\t    }\n\t\t    // if (include(fiber.state, STATE_TYPE.__unmount__)) return;\n\t\t    var dispatch = getCurrentDispatchFromFiber(fiber);\n\t\t    if (!dispatch) {\n\t\t        throw new Error(\"No dispatch found for the current running fiber.\");\n\t\t    }\n\t\t    return dispatch.dispatchSuspensePromise(_params);\n\t\t};\n\t\tvar readContext = function (_params) {\n\t\t    var fiber = currentRunningFiber$3.current;\n\t\t    if (!fiber) {\n\t\t        throw new Error(\"No current running fiber found for reading context.\");\n\t\t    }\n\t\t    if (include(fiber.state, STATE_TYPE.__unmount__))\n\t\t        return;\n\t\t    var dispatch = getCurrentDispatchFromFiber(fiber);\n\t\t    if (!dispatch) {\n\t\t        throw new Error(\"No dispatch found for the current running fiber.\");\n\t\t    }\n\t\t    return dispatch.readContext(_params);\n\t\t};\n\t\tvar readPromise = function (_params) {\n\t\t    var fiber = currentRunningFiber$3.current;\n\t\t    if (!fiber) {\n\t\t        throw new Error(\"No current running fiber found for reading promise.\");\n\t\t    }\n\t\t    if (include(fiber.state, STATE_TYPE.__unmount__))\n\t\t        return;\n\t\t    var dispatch = getCurrentDispatchFromFiber(fiber);\n\t\t    if (!dispatch) {\n\t\t        throw new Error(\"No dispatch found for the current running fiber.\");\n\t\t    }\n\t\t    return dispatch.readPromise(_params);\n\t\t};\n\t\tvar getFiberTree = function (fiber) {\n\t\t    var dispatch = getCurrentDispatchFromFiber(fiber);\n\t\t    if (dispatch) {\n\t\t        return dispatch.getFiberTree(fiber);\n\t\t    }\n\t\t    else {\n\t\t        return getFiberTree$1(fiber);\n\t\t    }\n\t\t};\n\t\tvar initScheduler = function () {\n\t\t    var scheduler = currentScheduler$f.current;\n\t\t    scheduler.getFiberTree = getFiberTree;\n\t\t    scheduler.readPromise = readPromise;\n\t\t    scheduler.readContext = readContext;\n\t\t    scheduler.dispatchState = dispatchState;\n\t\t    scheduler.dispatchHook = dispatchHook;\n\t\t    scheduler.dispatchError = dispatchError;\n\t\t    scheduler.dispatchPromise = dispatchPromise;\n\t\t    scheduler.dispatchSuspensePromise = dispatchSuspensePromise;\n\t\t};\n\n\t\treact.__my_react_shared__.enableHMRForDev;\n\t\tfunction checkIsSameType(p, element) {\n\t\t    if (p instanceof MyReactFiberNode) {\n\t\t        var _a = getTypeFromElementNode(element), nodeType = _a.nodeType, elementType = _a.elementType;\n\t\t        if (p.type === nodeType) {\n\t\t            if (react.isValidElement(element)) {\n\t\t                {\n\t\t                    return Object.is(p.elementType, elementType);\n\t\t                }\n\t\t            }\n\t\t            else {\n\t\t                return true;\n\t\t            }\n\t\t        }\n\t\t        else {\n\t\t            return false;\n\t\t        }\n\t\t    }\n\t\t    else {\n\t\t        var existElementType = getTypeFromElementNode(p);\n\t\t        var incomingElementType = getTypeFromElementNode(element);\n\t\t        if (existElementType.nodeType === incomingElementType.nodeType) {\n\t\t            if (react.isValidElement(element)) {\n\t\t                var typedExistElement = p;\n\t\t                var typedIncomingElement = element;\n\t\t                {\n\t\t                    return Object.is(typedIncomingElement.type, typedExistElement.type);\n\t\t                }\n\t\t            }\n\t\t            else {\n\t\t                return true;\n\t\t            }\n\t\t        }\n\t\t        else {\n\t\t            return false;\n\t\t        }\n\t\t    }\n\t\t}\n\n\t\tvar generateFiberToMountList = function (fiber) {\n\t\t    var listTree = new ListTree();\n\t\t    var getNext = function (fiber, root) {\n\t\t        if (include(fiber.state, STATE_TYPE.__unmount__)) {\n\t\t            if (fiber.sibling)\n\t\t                return fiber.sibling;\n\t\t            return fiber.parent;\n\t\t        }\n\t\t        if (fiber.child)\n\t\t            return fiber.child;\n\t\t        while (fiber && fiber !== root) {\n\t\t            listTree.push(fiber);\n\t\t            if (fiber.sibling)\n\t\t                return fiber.sibling;\n\t\t            fiber = fiber.parent;\n\t\t        }\n\t\t        if (fiber === root) {\n\t\t            listTree.push(fiber);\n\t\t        }\n\t\t        return null;\n\t\t    };\n\t\t    var f = fiber;\n\t\t    while (f) {\n\t\t        f = getNext(f, fiber);\n\t\t    }\n\t\t    return listTree;\n\t\t};\n\t\tvar generateFiberToUnmountList = generateFiberToMountList;\n\t\t/**\n\t\t *\n\t\t * @param action listToFoot action for performance\n\t\t */\n\t\tvar generateFiberToListWithAction = function (fiber, action) {\n\t\t    var listTree = new ListTree();\n\t\t    var getNext = function (fiber, root) {\n\t\t        if (include(fiber.state, STATE_TYPE.__unmount__)) {\n\t\t            if (fiber.sibling)\n\t\t                return fiber.sibling;\n\t\t            return fiber.parent;\n\t\t        }\n\t\t        if (fiber.child)\n\t\t            return fiber.child;\n\t\t        while (fiber && fiber !== root) {\n\t\t            listTree.push(fiber);\n\t\t            action(fiber);\n\t\t            if (fiber.sibling)\n\t\t                return fiber.sibling;\n\t\t            fiber = fiber.parent;\n\t\t        }\n\t\t        if (fiber === root) {\n\t\t            listTree.push(fiber);\n\t\t            action(fiber);\n\t\t        }\n\t\t        return null;\n\t\t    };\n\t\t    var f = fiber;\n\t\t    while (f) {\n\t\t        f = getNext(f, fiber);\n\t\t    }\n\t\t    return listTree;\n\t\t};\n\n\t\tvar defaultGenerateEffectMap = function (fiber, effect, map, option) {\n\t\t    var list = map.get(fiber);\n\t\t    if (!list) {\n\t\t        list = new ListTree();\n\t\t        map.set(fiber, list);\n\t\t    }\n\t\t    if (option) {\n\t\t        if (option.stickyToHead) {\n\t\t            list.pushToHead(effect);\n\t\t        }\n\t\t        else if (option.stickyToFoot) {\n\t\t            list.pushToLast(effect);\n\t\t        }\n\t\t        else {\n\t\t            list.push(effect);\n\t\t        }\n\t\t    }\n\t\t    else {\n\t\t        list.push(effect);\n\t\t    }\n\t\t};\n\t\tvar defaultInvokeEffect = function (renderDispatch, fiber) {\n\t\t    if (include(fiber.patch, PATCH_TYPE.__effect__)) {\n\t\t        var effectMap = renderDispatch.runtimeMap.effectMap;\n\t\t        var allEffect = effectMap.get(fiber);\n\t\t        effectMap.delete(fiber);\n\t\t        if (allEffect && allEffect.length) {\n\t\t            allEffect.listToFoot(function invokeEffect(effect) {\n\t\t                safeCallWithCurrentFiber({\n\t\t                    fiber: fiber,\n\t\t                    action: function safeCallEffect() {\n\t\t                        effect.call(null);\n\t\t                    },\n\t\t                });\n\t\t            });\n\t\t        }\n\t\t        fiber.patch = remove(fiber.patch, PATCH_TYPE.__effect__);\n\t\t    }\n\t\t};\n\t\tvar defaultInvokeLayoutEffect = function (renderDispatch, fiber) {\n\t\t    if (include(fiber.patch, PATCH_TYPE.__layoutEffect__)) {\n\t\t        var layoutEffectMap = renderDispatch.runtimeMap.layoutEffectMap;\n\t\t        var allLayoutEffect = layoutEffectMap.get(fiber);\n\t\t        layoutEffectMap.delete(fiber);\n\t\t        if (allLayoutEffect && allLayoutEffect.length) {\n\t\t            allLayoutEffect.listToFoot(function invokeLayoutEffect(effect) {\n\t\t                safeCallWithCurrentFiber({\n\t\t                    fiber: fiber,\n\t\t                    action: function safeCallLayoutEffect() {\n\t\t                        effect.call(null);\n\t\t                    },\n\t\t                });\n\t\t            });\n\t\t        }\n\t\t        fiber.patch = remove(fiber.patch, PATCH_TYPE.__layoutEffect__);\n\t\t    }\n\t\t};\n\t\tvar defaultInvokeInsertionEffect = function (renderDispatch, fiber) {\n\t\t    if (include(fiber.patch, PATCH_TYPE.__insertionEffect__)) {\n\t\t        var insertionEffectMap = renderDispatch.runtimeMap.insertionEffectMap;\n\t\t        var allInsertionEffect = insertionEffectMap.get(fiber);\n\t\t        insertionEffectMap.delete(fiber);\n\t\t        if (allInsertionEffect && allInsertionEffect.length) {\n\t\t            allInsertionEffect.listToFoot(function invokeInsertionEffect(effect) {\n\t\t                safeCallWithCurrentFiber({\n\t\t                    fiber: fiber,\n\t\t                    action: function safeCallInsertionEffect() {\n\t\t                        effect.call(null);\n\t\t                    },\n\t\t                });\n\t\t            });\n\t\t        }\n\t\t        fiber.patch = remove(fiber.patch, PATCH_TYPE.__insertionEffect__);\n\t\t    }\n\t\t};\n\t\tvar defaultDeleteCurrentEffect = function (renderDispatch, fiber) {\n\t\t    if (include(fiber.patch, PATCH_TYPE.__insertionEffect__)) {\n\t\t        var insertionEffectMap = renderDispatch.runtimeMap.insertionEffectMap;\n\t\t        insertionEffectMap.delete(fiber);\n\t\t        fiber.patch = remove(fiber.patch, PATCH_TYPE.__insertionEffect__);\n\t\t    }\n\t\t    if (include(fiber.patch, PATCH_TYPE.__layoutEffect__)) {\n\t\t        var layoutEffectMap = renderDispatch.runtimeMap.layoutEffectMap;\n\t\t        layoutEffectMap.delete(fiber);\n\t\t        fiber.patch = remove(fiber.patch, PATCH_TYPE.__layoutEffect__);\n\t\t    }\n\t\t    if (include(fiber.patch, PATCH_TYPE.__effect__)) {\n\t\t        var effectMap = renderDispatch.runtimeMap.effectMap;\n\t\t        effectMap.delete(fiber);\n\t\t        fiber.patch = remove(fiber.patch, PATCH_TYPE.__effect__);\n\t\t    }\n\t\t};\n\t\tvar defaultDeleteChildEffect = function (renderDispatch, fiber) {\n\t\t    var child = fiber.child;\n\t\t    while (child) {\n\t\t        defaultDeleteCurrentEffect(renderDispatch, child);\n\t\t        defaultDeleteChildEffect(renderDispatch, child);\n\t\t        child = child.sibling;\n\t\t    }\n\t\t};\n\t\tvar effectCallbackList = new ListTree();\n\t\tvar addEffectCallback = function (cb) {\n\t\t    effectCallbackList.push(cb);\n\t\t};\n\t\tvar flushEffectCallback = function () {\n\t\t    effectCallbackList.listToFoot(function (cb) {\n\t\t        cb();\n\t\t    });\n\t\t    effectCallbackList.clear();\n\t\t};\n\t\tvar effect = defaultInvokeEffect;\n\t\tvar layoutEffect = defaultInvokeLayoutEffect;\n\t\tvar insertionEffect = defaultInvokeInsertionEffect;\n\n\t\t// TODO use Symbol to avoid conflict\n\t\tvar defaultReadPromise = function (_promise) {\n\t\t    if (_promise.status === \"fulfilled\") {\n\t\t        return _promise._value;\n\t\t    }\n\t\t    else if (_promise.status === \"rejected\") {\n\t\t        throw _promise._reason;\n\t\t    }\n\t\t    else {\n\t\t        throw _promise;\n\t\t    }\n\t\t};\n\t\tvar defaultResolveSuspenseValue = function (fiber) {\n\t\t    var _a;\n\t\t    var parent = fiber.parent;\n\t\t    while (parent) {\n\t\t        if (include(parent.type, exports.NODE_TYPE.__suspense__)) {\n\t\t            return (_a = parent.pendingProps) === null || _a === void 0 ? void 0 : _a[\"fallback\"];\n\t\t        }\n\t\t        parent = parent.parent;\n\t\t    }\n\t\t    return null;\n\t\t};\n\t\tvar defaultResolveSuspenseFiber = function (fiber) {\n\t\t    var parent = fiber.parent;\n\t\t    while (parent) {\n\t\t        if (include(parent.type, exports.NODE_TYPE.__suspense__)) {\n\t\t            return parent;\n\t\t        }\n\t\t        parent = parent.parent;\n\t\t    }\n\t\t    return null;\n\t\t};\n\t\tvar defaultResolveAliveSuspenseFiber = function (fiber) {\n\t\t    while (fiber) {\n\t\t        if (include(fiber.type, exports.NODE_TYPE.__suspense__) && exclude(fiber.state, STATE_TYPE.__unmount__)) {\n\t\t            return fiber;\n\t\t        }\n\t\t        fiber = fiber.parent;\n\t\t    }\n\t\t};\n\n\t\tvar currentRunningFiber$2 = react.__my_react_internal__.currentRunningFiber;\n\t\tvar mountToNextFiberFromRoot = function (renderDispatch, fiber) {\n\t\t    if (include(fiber.state, STATE_TYPE.__unmount__) || renderDispatch.isAppCrashed)\n\t\t        return null;\n\t\t    if (include(fiber.state, STATE_TYPE.__create__ |\n\t\t        STATE_TYPE.__inherit__ |\n\t\t        STATE_TYPE.__triggerSync__ |\n\t\t        STATE_TYPE.__triggerSyncForce__ |\n\t\t        STATE_TYPE.__triggerConcurrent__ |\n\t\t        STATE_TYPE.__triggerConcurrentForce__ |\n\t\t        STATE_TYPE.__retrigger__ |\n\t\t        STATE_TYPE.__reschedule__ |\n\t\t        STATE_TYPE.__recreate__)) {\n\t\t        fiber.state = remove(fiber.state, STATE_TYPE.__retrigger__);\n\t\t        currentRunningFiber$2.current = fiber;\n\t\t        {\n\t\t            runtimeNextWork(renderDispatch, fiber);\n\t\t        }\n\t\t        currentRunningFiber$2.current = null;\n\t\t    }\n\t\t    if (include(fiber.state, STATE_TYPE.__suspense__)) {\n\t\t        fiber.state = STATE_TYPE.__recreate__;\n\t\t    }\n\t\t    else if (!include(fiber.state, STATE_TYPE.__retrigger__)) {\n\t\t        fiber.state = STATE_TYPE.__stable__;\n\t\t    }\n\t\t    else {\n\t\t        fiber.state = STATE_TYPE.__triggerSync__;\n\t\t    }\n\t\t    if (fiber.child)\n\t\t        return fiber.child;\n\t\t    var nextFiber = fiber;\n\t\t    while (nextFiber && nextFiber !== renderDispatch.runtimeFiber.scheduledFiber) {\n\t\t        renderDispatch.generateCommitList(nextFiber);\n\t\t        if (nextFiber.sibling)\n\t\t            return nextFiber.sibling;\n\t\t        nextFiber = nextFiber.parent;\n\t\t    }\n\t\t    if (nextFiber === renderDispatch.runtimeFiber.scheduledFiber) {\n\t\t        renderDispatch.generateCommitList(nextFiber);\n\t\t    }\n\t\t    return null;\n\t\t};\n\t\tvar performToNextFiberFromRoot = function (renderDispatch, fiber) {\n\t\t    if (include(fiber.state, STATE_TYPE.__unmount__) || renderDispatch.isAppCrashed)\n\t\t        return null;\n\t\t    if (include(fiber.state, STATE_TYPE.__create__ |\n\t\t        STATE_TYPE.__inherit__ |\n\t\t        STATE_TYPE.__triggerSync__ |\n\t\t        STATE_TYPE.__triggerSyncForce__ |\n\t\t        STATE_TYPE.__triggerConcurrent__ |\n\t\t        STATE_TYPE.__triggerConcurrentForce__ |\n\t\t        STATE_TYPE.__retrigger__ |\n\t\t        STATE_TYPE.__reschedule__ |\n\t\t        STATE_TYPE.__recreate__)) {\n\t\t        fiber.state = remove(fiber.state, STATE_TYPE.__retrigger__);\n\t\t        currentRunningFiber$2.current = fiber;\n\t\t        {\n\t\t            runtimeNextWork(renderDispatch, fiber);\n\t\t        }\n\t\t        currentRunningFiber$2.current = null;\n\t\t        triggerFiberUpdateListener(renderDispatch, fiber);\n\t\t    }\n\t\t    if (include(fiber.state, STATE_TYPE.__suspense__)) {\n\t\t        fiber.state = STATE_TYPE.__recreate__;\n\t\t    }\n\t\t    else if (!include(fiber.state, STATE_TYPE.__retrigger__)) {\n\t\t        fiber.state = STATE_TYPE.__stable__;\n\t\t    }\n\t\t    else {\n\t\t        fiber.state = STATE_TYPE.__triggerSync__;\n\t\t    }\n\t\t    if (fiber.child)\n\t\t        return fiber.child;\n\t\t    var nextFiber = fiber;\n\t\t    while (nextFiber && nextFiber !== renderDispatch.runtimeFiber.scheduledFiber) {\n\t\t        renderDispatch.generateCommitList(nextFiber);\n\t\t        if (nextFiber.sibling)\n\t\t            return nextFiber.sibling;\n\t\t        nextFiber = nextFiber.parent;\n\t\t    }\n\t\t    if (nextFiber === renderDispatch.runtimeFiber.scheduledFiber) {\n\t\t        renderDispatch.generateCommitList(nextFiber);\n\t\t    }\n\t\t    return null;\n\t\t};\n\n\t\tvar enableSuspenseRoot$3 = react.__my_react_shared__.enableSuspenseRoot;\n\t\tvar currentScheduler$e = react.__my_react_internal__.currentScheduler;\n\t\tvar mountLoopAllFromScheduler = function (renderDispatch) {\n\t\t    while (renderDispatch.runtimeFiber.nextWorkingFiber) {\n\t\t        renderDispatch.runtimeFiber.retriggerFiber = null;\n\t\t        var currentFiber = renderDispatch.runtimeFiber.nextWorkingFiber;\n\t\t        var nextFiber = mountToNextFiberFromRoot(renderDispatch, currentFiber);\n\t\t        var retriggerFiber = renderDispatch.runtimeFiber.retriggerFiber;\n\t\t        renderDispatch.runtimeFiber.nextWorkingFiber = retriggerFiber || nextFiber;\n\t\t        renderDispatch.runtimeFiber.retriggerFiber = null;\n\t\t    }\n\t\t};\n\t\tvar mountLoopAll = function (renderDispatch, fiber) {\n\t\t    renderDispatch.runtimeFiber.scheduledFiber = fiber;\n\t\t    renderDispatch.runtimeFiber.nextWorkingFiber = fiber;\n\t\t    mountLoopAllFromScheduler(renderDispatch);\n\t\t};\n\t\tvar processAsyncLoadListOnAsyncMount = function (renderDispatch) { return __awaiter(void 0, void 0, void 0, function () {\n\t\t    var _loop_1, suspenseField_1, list;\n\t\t    return __generator(this, function (_a) {\n\t\t        switch (_a.label) {\n\t\t            case 0:\n\t\t                _loop_1 = function () {\n\t\t                    var node, suspenseField, list;\n\t\t                    return __generator(this, function (_b) {\n\t\t                        switch (_b.label) {\n\t\t                            case 0:\n\t\t                                node = renderDispatch.pendingSuspenseFiberArray.uniShift();\n\t\t                                suspenseField = getInstanceFieldByInstance(node.instance);\n\t\t                                renderDispatch.pendingSuspenseFiberArray.clear();\n\t\t                                list = suspenseField.asyncLoadList.getAll();\n\t\t                                return [4 /*yield*/, Promise.all(list.map(function (item) { return __awaiter(void 0, void 0, void 0, function () {\n\t\t                                        var set;\n\t\t                                        return __generator(this, function (_a) {\n\t\t                                            switch (_a.label) {\n\t\t                                                case 0:\n\t\t                                                    if (!isPromise(item)) return [3 /*break*/, 2];\n\t\t                                                    return [4 /*yield*/, renderDispatch.processPromise(item)];\n\t\t                                                case 1:\n\t\t                                                    _a.sent();\n\t\t                                                    return [3 /*break*/, 4];\n\t\t                                                case 2: return [4 /*yield*/, renderDispatch.processLazy(item)];\n\t\t                                                case 3:\n\t\t                                                    _a.sent();\n\t\t                                                    _a.label = 4;\n\t\t                                                case 4:\n\t\t                                                    set = new Set(item._list);\n\t\t                                                    item._list.clear();\n\t\t                                                    set.forEach(function (node) {\n\t\t                                                        node.state = remove(node.state, STATE_TYPE.__stable__);\n\t\t                                                        node.state = merge(node.state, STATE_TYPE.__create__);\n\t\t                                                        mountLoopAll(renderDispatch, node);\n\t\t                                                    });\n\t\t                                                    suspenseField.asyncLoadList.uniDelete(item);\n\t\t                                                    return [2 /*return*/];\n\t\t                                            }\n\t\t                                        });\n\t\t                                    }); }))];\n\t\t                            case 1:\n\t\t                                _b.sent();\n\t\t                                return [2 /*return*/];\n\t\t                        }\n\t\t                    });\n\t\t                };\n\t\t                _a.label = 1;\n\t\t            case 1:\n\t\t                if (!renderDispatch.pendingSuspenseFiberArray.length) return [3 /*break*/, 3];\n\t\t                return [5 /*yield**/, _loop_1()];\n\t\t            case 2:\n\t\t                _a.sent();\n\t\t                return [3 /*break*/, 1];\n\t\t            case 3:\n\t\t                if (!enableSuspenseRoot$3.current) return [3 /*break*/, 5];\n\t\t                suspenseField_1 = getInstanceFieldByInstance(renderDispatch);\n\t\t                list = suspenseField_1.asyncLoadList.getAll();\n\t\t                if (list.length === 0)\n\t\t                    return [2 /*return*/];\n\t\t                return [4 /*yield*/, Promise.all(list.map(function (item) { return __awaiter(void 0, void 0, void 0, function () {\n\t\t                        var set;\n\t\t                        return __generator(this, function (_a) {\n\t\t                            switch (_a.label) {\n\t\t                                case 0:\n\t\t                                    if (!isPromise(item)) return [3 /*break*/, 2];\n\t\t                                    return [4 /*yield*/, renderDispatch.processPromise(item)];\n\t\t                                case 1:\n\t\t                                    _a.sent();\n\t\t                                    return [3 /*break*/, 4];\n\t\t                                case 2: return [4 /*yield*/, renderDispatch.processLazy(item)];\n\t\t                                case 3:\n\t\t                                    _a.sent();\n\t\t                                    _a.label = 4;\n\t\t                                case 4:\n\t\t                                    set = new Set(item._list);\n\t\t                                    item._list.clear();\n\t\t                                    set.forEach(function (node) {\n\t\t                                        node.state = remove(node.state, STATE_TYPE.__stable__);\n\t\t                                        node.state = merge(node.state, STATE_TYPE.__create__);\n\t\t                                        mountLoopAll(renderDispatch, node);\n\t\t                                    });\n\t\t                                    suspenseField_1.asyncLoadList.uniDelete(item);\n\t\t                                    return [2 /*return*/];\n\t\t                            }\n\t\t                        });\n\t\t                    }); }))];\n\t\t            case 4:\n\t\t                _a.sent();\n\t\t                processAsyncLoadListOnAsyncMount(renderDispatch);\n\t\t                _a.label = 5;\n\t\t            case 5: return [2 /*return*/];\n\t\t        }\n\t\t    });\n\t\t}); };\n\t\tvar processAsyncLoadListOnSyncMount = function (renderDispatch) {\n\t\t    var _a;\n\t\t    if ((_a = renderDispatch.pendingSuspenseFiberArray) === null || _a === void 0 ? void 0 : _a.length) {\n\t\t        var allPendingSuspenseFiberArray = renderDispatch.pendingSuspenseFiberArray.getAll();\n\t\t        if (renderDispatch.enableAsyncLoad) {\n\t\t            var allField_1 = [];\n\t\t            allPendingSuspenseFiberArray.forEach(function (node) {\n\t\t                defaultDeleteChildEffect(renderDispatch, node);\n\t\t                var field = getInstanceFieldByInstance(node.instance);\n\t\t                var allPendingLoadArray = field.asyncLoadList.getAll().filter(function (item) {\n\t\t                    if (isPromise(item)) {\n\t\t                        return typeof item.status !== \"string\";\n\t\t                    }\n\t\t                    else {\n\t\t                        return !item._loading && !item._loaded && !item._error;\n\t\t                    }\n\t\t                });\n\t\t                if (allPendingLoadArray.length) {\n\t\t                    Promise.all(allPendingLoadArray.map(function (item) { return __awaiter(void 0, void 0, void 0, function () {\n\t\t                        var _a;\n\t\t                        return __generator(this, function (_b) {\n\t\t                            switch (_b.label) {\n\t\t                                case 0:\n\t\t                                    if (!isPromise(item)) return [3 /*break*/, 2];\n\t\t                                    return [4 /*yield*/, renderDispatch.processPromise(item)];\n\t\t                                case 1:\n\t\t                                    _b.sent();\n\t\t                                    return [3 /*break*/, 4];\n\t\t                                case 2: return [4 /*yield*/, renderDispatch.processLazy(item)];\n\t\t                                case 3:\n\t\t                                    _b.sent();\n\t\t                                    _b.label = 4;\n\t\t                                case 4:\n\t\t                                    (_a = item._list) === null || _a === void 0 ? void 0 : _a.clear();\n\t\t                                    field.asyncLoadList.uniDelete(item);\n\t\t                                    return [2 /*return*/];\n\t\t                            }\n\t\t                        });\n\t\t                    }); })).then(function () {\n\t\t                        var aliveNode = defaultResolveAliveSuspenseFiber(node) || renderDispatch.rootFiber;\n\t\t                        aliveNode.state = STATE_TYPE.__triggerSyncForce__;\n\t\t                        var renderScheduler = currentScheduler$e.current;\n\t\t                        var updater = {\n\t\t                            type: UpdateQueueType.suspense,\n\t\t                            trigger: aliveNode,\n\t\t                            isSync: true,\n\t\t                            isForce: true,\n\t\t                            payLoad: allPendingLoadArray,\n\t\t                        };\n\t\t                        renderScheduler.dispatchState(updater);\n\t\t                    });\n\t\t                }\n\t\t                node.state = STATE_TYPE.__create__;\n\t\t                field.isHidden = true;\n\t\t                allField_1.push(field);\n\t\t            });\n\t\t            var root = renderDispatch.rootFiber;\n\t\t            root.state = remove(root.state, STATE_TYPE.__stable__);\n\t\t            root.state = merge(root.state, STATE_TYPE.__retrigger__);\n\t\t            // TODO use hide tree to improve\n\t\t            mountLoopAll(renderDispatch, root);\n\t\t            allField_1.forEach(function (field) { return (field.isHidden = false); });\n\t\t            renderDispatch.pendingSuspenseFiberArray.clear();\n\t\t        }\n\t\t        else {\n\t\t            throw new Error(\"[@my-react/reconciler] should not process async load list on sync mount without enableAsyncLoad, you may use a wrong renderDispatch instance\");\n\t\t        }\n\t\t    }\n\t\t    if (enableSuspenseRoot$3.current) {\n\t\t        var suspenseField_2 = getInstanceFieldByInstance(renderDispatch);\n\t\t        var list = suspenseField_2.asyncLoadList.getAll();\n\t\t        if (list.length === 0)\n\t\t            return;\n\t\t        if (renderDispatch.enableAsyncLoad) {\n\t\t            var allPendingLoadArray = list.filter(function (item) {\n\t\t                if (isPromise(item)) {\n\t\t                    return typeof item.status !== \"string\";\n\t\t                }\n\t\t                else {\n\t\t                    return !item._loading && !item._loaded && !item._error;\n\t\t                }\n\t\t            });\n\t\t            if (allPendingLoadArray.length) {\n\t\t                allPendingLoadArray.forEach(function (item) { var _a; return (_a = item._list) === null || _a === void 0 ? void 0 : _a.forEach(function (node) { return defaultDeleteCurrentEffect(renderDispatch, node); }); });\n\t\t                Promise.all(allPendingLoadArray.map(function (item) { return __awaiter(void 0, void 0, void 0, function () {\n\t\t                    var allFiber;\n\t\t                    var _a;\n\t\t                    return __generator(this, function (_b) {\n\t\t                        switch (_b.label) {\n\t\t                            case 0:\n\t\t                                if (!isPromise(item)) return [3 /*break*/, 2];\n\t\t                                return [4 /*yield*/, renderDispatch.processPromise(item)];\n\t\t                            case 1:\n\t\t                                _b.sent();\n\t\t                                return [3 /*break*/, 4];\n\t\t                            case 2: return [4 /*yield*/, renderDispatch.processLazy(item)];\n\t\t                            case 3:\n\t\t                                _b.sent();\n\t\t                                _b.label = 4;\n\t\t                            case 4:\n\t\t                                allFiber = new Set(item._list);\n\t\t                                (_a = item._list) === null || _a === void 0 ? void 0 : _a.clear();\n\t\t                                allFiber.forEach(function (node) {\n\t\t                                    node.state = STATE_TYPE.__recreate__;\n\t\t                                    var renderScheduler = currentScheduler$e.current;\n\t\t                                    var updater = {\n\t\t                                        type: UpdateQueueType.suspense,\n\t\t                                        trigger: node,\n\t\t                                        isSync: true,\n\t\t                                        isForce: true,\n\t\t                                        payLoad: [item],\n\t\t                                    };\n\t\t                                    renderScheduler.dispatchState(updater);\n\t\t                                });\n\t\t                                suspenseField_2.asyncLoadList.uniDelete(item);\n\t\t                                return [2 /*return*/];\n\t\t                        }\n\t\t                    });\n\t\t                }); }));\n\t\t            }\n\t\t        }\n\t\t        else {\n\t\t            throw new Error(\"[@my-react/reconciler] should not process async load list on sync mount without enableAsyncLoad, you may use a wrong renderDispatch instance\");\n\t\t        }\n\t\t    }\n\t\t};\n\n\t\tvar enableSuspenseRoot$2 = react.__my_react_shared__.enableSuspenseRoot;\n\t\tvar currentScheduler$d = react.__my_react_internal__.currentScheduler;\n\t\texports.updateTypeEnum = void 0;\n\t\t(function (updateTypeEnum) {\n\t\t    updateTypeEnum[updateTypeEnum[\"syncFromRoot\"] = 0] = \"syncFromRoot\";\n\t\t    updateTypeEnum[updateTypeEnum[\"syncFromTrigger\"] = 1] = \"syncFromTrigger\";\n\t\t    updateTypeEnum[updateTypeEnum[\"concurrentFromRoot\"] = 2] = \"concurrentFromRoot\";\n\t\t    updateTypeEnum[updateTypeEnum[\"concurrentFromTrigger\"] = 3] = \"concurrentFromTrigger\";\n\t\t})(exports.updateTypeEnum || (exports.updateTypeEnum = {}));\n\t\tvar triggerFiberUpdateListener = function (renderDispatch, fiber) {\n\t\t    safeCallWithCurrentFiber({\n\t\t        fiber: fiber,\n\t\t        action: function safeCallPatchToFiberUpdate() {\n\t\t            var _a;\n\t\t            (_a = renderDispatch.patchToFiberUpdate) === null || _a === void 0 ? void 0 : _a.call(renderDispatch, fiber);\n\t\t        },\n\t\t    });\n\t\t    safeCallWithCurrentFiber({\n\t\t        fiber: fiber,\n\t\t        action: function safeCallFiberUpdateListener() {\n\t\t            renderDispatch.callOnFiberUpdate(fiber);\n\t\t        },\n\t\t    });\n\t\t};\n\t\tvar updateLoopSyncFromRoot = function (renderDispatch) {\n\t\t    while (renderDispatch.runtimeFiber.nextWorkingFiber) {\n\t\t        renderDispatch.runtimeFiber.retriggerFiber = null;\n\t\t        var currentFiber = renderDispatch.runtimeFiber.nextWorkingFiber;\n\t\t        var nextFiber = performToNextFiberFromRoot(renderDispatch, currentFiber);\n\t\t        var retriggerFiber = renderDispatch.runtimeFiber.retriggerFiber;\n\t\t        renderDispatch.runtimeFiber.nextWorkingFiber = retriggerFiber || nextFiber;\n\t\t        renderDispatch.runtimeFiber.retriggerFiber = null;\n\t\t    }\n\t\t};\n\t\tvar updateLoopConcurrentFromRoot = function (renderDispatch) {\n\t\t    var hasSync = false;\n\t\t    while (renderDispatch.runtimeFiber.nextWorkingFiber && !renderDispatch.shouldYield()) {\n\t\t        renderDispatch.runtimeFiber.retriggerFiber = null;\n\t\t        var currentFiber = renderDispatch.runtimeFiber.nextWorkingFiber;\n\t\t        hasSync = hasSync || include(currentFiber.state, STATE_TYPE.__triggerSync__ | STATE_TYPE.__triggerSyncForce__);\n\t\t        var nextFiber = performToNextFiberFromRoot(renderDispatch, currentFiber);\n\t\t        var retriggerFiber = renderDispatch.runtimeFiber.retriggerFiber;\n\t\t        renderDispatch.runtimeFiber.nextWorkingFiber = retriggerFiber || nextFiber;\n\t\t        renderDispatch.runtimeFiber.retriggerFiber = null;\n\t\t    }\n\t\t    return hasSync;\n\t\t};\n\t\tvar processAsyncLoadListOnUpdate = function (renderDispatch) {\n\t\t    var _a;\n\t\t    if ((_a = renderDispatch.pendingSuspenseFiberArray) === null || _a === void 0 ? void 0 : _a.length) {\n\t\t        var allPendingSuspenseFiberArray = renderDispatch.pendingSuspenseFiberArray.getAll();\n\t\t        if (renderDispatch.enableAsyncLoad) {\n\t\t            var allField_1 = [];\n\t\t            allPendingSuspenseFiberArray.forEach(function (node) {\n\t\t                defaultDeleteChildEffect(renderDispatch, node);\n\t\t                var field = getInstanceFieldByInstance(node.instance);\n\t\t                var allPendingLoadArray = field.asyncLoadList.getAll().filter(function (item) {\n\t\t                    if (isPromise(item)) {\n\t\t                        return typeof item.status !== \"string\";\n\t\t                    }\n\t\t                    else {\n\t\t                        return !item._loading && !item._loaded && !item._error;\n\t\t                    }\n\t\t                });\n\t\t                if (allPendingLoadArray.length) {\n\t\t                    Promise.all(allPendingLoadArray.map(function (item) { return __awaiter(void 0, void 0, void 0, function () {\n\t\t                        var _a;\n\t\t                        return __generator(this, function (_b) {\n\t\t                            switch (_b.label) {\n\t\t                                case 0:\n\t\t                                    if (!isPromise(item)) return [3 /*break*/, 2];\n\t\t                                    return [4 /*yield*/, renderDispatch.processPromise(item)];\n\t\t                                case 1:\n\t\t                                    _b.sent();\n\t\t                                    return [3 /*break*/, 4];\n\t\t                                case 2: return [4 /*yield*/, renderDispatch.processLazy(item)];\n\t\t                                case 3:\n\t\t                                    _b.sent();\n\t\t                                    _b.label = 4;\n\t\t                                case 4:\n\t\t                                    (_a = item._list) === null || _a === void 0 ? void 0 : _a.clear();\n\t\t                                    field.asyncLoadList.uniDelete(item);\n\t\t                                    return [2 /*return*/];\n\t\t                            }\n\t\t                        });\n\t\t                    }); })).then(function () {\n\t\t                        var aliveNode = defaultResolveAliveSuspenseFiber(node) || renderDispatch.rootFiber;\n\t\t                        aliveNode.state = STATE_TYPE.__triggerSyncForce__;\n\t\t                        var renderScheduler = currentScheduler$d.current;\n\t\t                        var updater = {\n\t\t                            type: UpdateQueueType.suspense,\n\t\t                            trigger: aliveNode,\n\t\t                            isSync: true,\n\t\t                            isForce: true,\n\t\t                            payLoad: allPendingLoadArray,\n\t\t                        };\n\t\t                        renderScheduler.dispatchState(updater);\n\t\t                    });\n\t\t                }\n\t\t                // fix hmr\n\t\t                node.state = STATE_TYPE.__reschedule__;\n\t\t                field.isHidden = true;\n\t\t                allField_1.push(field);\n\t\t            });\n\t\t            var root = renderDispatch.rootFiber;\n\t\t            root.state = remove(root.state, STATE_TYPE.__stable__);\n\t\t            root.state = merge(root.state, STATE_TYPE.__retrigger__);\n\t\t            // TODO use hide tree to improve\n\t\t            mountLoopAll(renderDispatch, root);\n\t\t            allField_1.forEach(function (field) { return (field.isHidden = false); });\n\t\t            renderDispatch.pendingSuspenseFiberArray.clear();\n\t\t        }\n\t\t        else {\n\t\t            throw new Error(\"[@my-react/reconciler] should not process async load list on sync mount without enableAsyncLoad, you may use a wrong renderDispatch instance\");\n\t\t        }\n\t\t    }\n\t\t    // TODO update flow\n\t\t    if (enableSuspenseRoot$2.current) {\n\t\t        var suspenseField = getInstanceFieldByInstance(renderDispatch);\n\t\t        var list = suspenseField.asyncLoadList.getAll();\n\t\t        if (list.length === 0)\n\t\t            return;\n\t\t        if (renderDispatch.enableAsyncLoad) {\n\t\t            throw new Error(\"[@my-react/reconciler] not implemented yet\");\n\t\t        }\n\t\t        else {\n\t\t            throw new Error(\"[@my-react/reconciler] should not process async load list on sync mount without enableAsyncLoad, you may use a wrong renderDispatch instance\");\n\t\t        }\n\t\t    }\n\t\t};\n\n\t\tvar isErrorBoundariesInstance = function (instance, Component) {\n\t\t    return typeof instance.componentDidCatch === \"function\" || typeof Component.getDerivedStateFromError === \"function\";\n\t\t};\n\t\tvar isErrorBoundariesComponent = function (fiber) {\n\t\t    if (include(fiber.type, exports.NODE_TYPE.__class__) && include(fiber.state, STATE_TYPE.__stable__)) {\n\t\t        var Component = fiber.elementType;\n\t\t        var typedComponent = Component;\n\t\t        var typedInstance = fiber.instance;\n\t\t        return isErrorBoundariesInstance(typedInstance, typedComponent);\n\t\t    }\n\t\t    return false;\n\t\t};\n\t\tvar defaultResolveErrorBoundaries = function (fiber) {\n\t\t    var parent = fiber.parent;\n\t\t    while (parent) {\n\t\t        if (isErrorBoundariesComponent(parent)) {\n\t\t            return parent;\n\t\t        }\n\t\t        parent = parent.parent;\n\t\t    }\n\t\t    return null;\n\t\t};\n\n\t\tvar initClassInstance = function (instance) {\n\t\t    var field = getInstanceFieldByInstance(instance);\n\t\t    if (!field)\n\t\t        throw new Error(\"[@my-react/react] can not find instance field for component, look like a bug for @my-react\");\n\t\t    var typedField = field;\n\t\t    typedField.isMounted = false;\n\t\t};\n\t\tvar mountClassInstance = function (instance) {\n\t\t    var field = getInstanceFieldByInstance(instance);\n\t\t    if (!field)\n\t\t        throw new Error(\"[@my-react/react] can not find instance field for component, look like a bug for @my-react\");\n\t\t    var typedField = field;\n\t\t    typedField.isMounted = true;\n\t\t};\n\t\tvar getClassInstanceFieldByInstance = function (instance) {\n\t\t    var field = getInstanceFieldByInstance(instance);\n\t\t    if (!field)\n\t\t        throw new Error(\"[@my-react/react] can not find instance field for component, look like a bug for @my-react\");\n\t\t    return field;\n\t\t};\n\n\t\t/* eslint-disable max-lines */\n\t\tvar enableLegacyLifeCycle = react.__my_react_shared__.enableLegacyLifeCycle;\n\t\t// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n\t\t// @ts-ignore\n\t\tif (!Object.prototype.hasOwnProperty.call(react.Component.prototype, \"_reactInternals\")) {\n\t\t    Object.defineProperty(react.Component.prototype, \"_reactInternals\", {\n\t\t        get: function () {\n\t\t            return getInstanceOwnerFiber(this);\n\t\t        },\n\t\t        set: function () {\n\t\t            // do nothing\n\t\t        },\n\t\t        configurable: false,\n\t\t    });\n\t\t}\n\t\tvar processComponentStateFromProps = function (fiber) {\n\t\t    var Component = fiber.elementType;\n\t\t    var typedComponent = Component;\n\t\t    var typedInstance = fiber.instance;\n\t\t    var pendingProps = fiber.pendingProps;\n\t\t    var pendingState = fiber.pendingState;\n\t\t    if (typedComponent.getDerivedStateFromProps) {\n\t\t        var payloadState = safeCallWithCurrentFiber({\n\t\t            fiber: fiber,\n\t\t            action: function safeCallGetDerivedStateFromProps() {\n\t\t                var _a;\n\t\t                return (_a = typedComponent.getDerivedStateFromProps) === null || _a === void 0 ? void 0 : _a.call(typedComponent, pendingProps, pendingState);\n\t\t            },\n\t\t        });\n\t\t        if (payloadState) {\n\t\t            var newState = Object.assign({}, pendingState, payloadState);\n\t\t            typedInstance.state = newState;\n\t\t            fiber.pendingState = newState;\n\t\t        }\n\t\t    }\n\t\t};\n\t\tvar processComponentInstanceOnMount = function (renderDispatch, fiber) {\n\t\t    var Component = fiber.elementType;\n\t\t    var typedComponent = Component;\n\t\t    var providerFiber = renderDispatch.resolveContextFiber(fiber, typedComponent.contextType);\n\t\t    var context = renderDispatch.resolveContextValue(providerFiber, typedComponent.contextType);\n\t\t    var props = Object.assign({}, fiber.pendingProps);\n\t\t    var instance = safeCallWithCurrentFiber({\n\t\t        fiber: fiber,\n\t\t        action: function safeCallCreateComponentInstance() {\n\t\t            return new typedComponent(props, context);\n\t\t        },\n\t\t    });\n\t\t    safeCallWithCurrentFiber({\n\t\t        fiber: fiber,\n\t\t        action: function safeCallInstanceInitialListener() {\n\t\t            renderDispatch.callOnInstanceInitial(instance, fiber);\n\t\t        },\n\t\t    });\n\t\t    instance.props = props;\n\t\t    instance.context = context;\n\t\t    fiber.instance = instance;\n\t\t    initInstance(instance);\n\t\t    initClassInstance(instance);\n\t\t    setOwnerForInstance(instance, fiber);\n\t\t    setContextForInstance(instance, providerFiber);\n\t\t    fiber.pendingState = instance.state;\n\t\t};\n\t\tvar processComponentFiberOnUpdate = function (renderDispatch, fiber) {\n\t\t    var typedInstance = fiber.instance;\n\t\t    safeCallWithCurrentFiber({\n\t\t        fiber: fiber,\n\t\t        action: function safeCallInstanceUpdateListener() {\n\t\t            renderDispatch.callOnInstanceUpdate(typedInstance, fiber);\n\t\t        },\n\t\t    });\n\t\t    setOwnerForInstance(typedInstance, fiber);\n\t\t};\n\t\tvar processComponentRenderOnMountAndUpdate = function (fiber) {\n\t\t    var typedInstance = fiber.instance;\n\t\t    var children = safeCallWithCurrentFiber({\n\t\t        fiber: fiber,\n\t\t        action: function safeCallRender() {\n\t\t            return typedInstance.render();\n\t\t        },\n\t\t    });\n\t\t    return children;\n\t\t};\n\t\tvar processComponentDidMountOnMount = function (renderDispatch, fiber) {\n\t\t    var typedInstance = fiber.instance;\n\t\t    var effect = getInstanceEffectState(typedInstance);\n\t\t    if (exclude(effect, Effect_TYPE.__effect__)) {\n\t\t        setEffectForInstance(typedInstance, Effect_TYPE.__effect__);\n\t\t        renderDispatch.pendingLayoutEffect(fiber, function invokeComponentDidMountOnInstance() {\n\t\t            var _a;\n\t\t            setEffectForInstance(typedInstance, Effect_TYPE.__initial__);\n\t\t            (_a = typedInstance.componentDidMount) === null || _a === void 0 ? void 0 : _a.call(typedInstance);\n\t\t            mountClassInstance(typedInstance);\n\t\t        });\n\t\t    }\n\t\t};\n\t\tvar processComponentContextOnUpdate = function (renderDispatch, fiber) {\n\t\t    var Component = fiber.elementType;\n\t\t    var typedComponent = Component;\n\t\t    var typedInstance = fiber.instance;\n\t\t    if (typedComponent.contextType) {\n\t\t        var contextFiber = getInstanceContextFiber(typedInstance);\n\t\t        if (!contextFiber || include(contextFiber.state, STATE_TYPE.__unmount__)) {\n\t\t            var providerFiber = renderDispatch.resolveContextFiber(fiber, typedComponent.contextType);\n\t\t            var context = renderDispatch.resolveContextValue(providerFiber, typedComponent.contextType);\n\t\t            setContextForInstance(typedInstance, providerFiber);\n\t\t            return context;\n\t\t        }\n\t\t        else {\n\t\t            var context = renderDispatch.resolveContextValue(contextFiber, typedComponent.contextType);\n\t\t            setContextForInstance(typedInstance, contextFiber);\n\t\t            return context;\n\t\t        }\n\t\t    }\n\t\t};\n\t\tvar processComponentPropsAndContextOnActive = function (renderDispatch, fiber) {\n\t\t    var props = Object.assign({}, fiber.pendingProps);\n\t\t    var context = processComponentContextOnUpdate(renderDispatch, fiber);\n\t\t    var typedInstance = fiber.instance;\n\t\t    typedInstance.props = props;\n\t\t    typedInstance.context = context;\n\t\t};\n\t\tvar processComponentShouldUpdateOnUpdate = function (fiber, _a) {\n\t\t    var nextState = _a.nextState, nextProps = _a.nextProps, nextContext = _a.nextContext;\n\t\t    var typedInstance = fiber.instance;\n\t\t    // if (include(fiber.state, STATE_TYPE.__triggerSync__ | STATE_TYPE.__triggerConcurrent__)) return true;\n\t\t    if (typedInstance.shouldComponentUpdate) {\n\t\t        return safeCallWithCurrentFiber({\n\t\t            fiber: fiber,\n\t\t            action: function safeCallShouldComponentUpdateOnInstance() {\n\t\t                var _a;\n\t\t                return (_a = typedInstance.shouldComponentUpdate) === null || _a === void 0 ? void 0 : _a.call(typedInstance, nextProps, nextState, nextContext);\n\t\t            },\n\t\t        });\n\t\t    }\n\t\t    return true;\n\t\t};\n\t\tvar processComponentGetSnapshotOnUpdate = function (fiber, _a) {\n\t\t    var baseState = _a.baseState, baseProps = _a.baseProps;\n\t\t    var typedInstance = fiber.instance;\n\t\t    if (typedInstance.getSnapshotBeforeUpdate) {\n\t\t        return safeCallWithCurrentFiber({\n\t\t            fiber: fiber,\n\t\t            action: function safeCallGetSnapshotBeforeUpdateOnInstance() {\n\t\t                var _a;\n\t\t                return (_a = typedInstance.getSnapshotBeforeUpdate) === null || _a === void 0 ? void 0 : _a.call(typedInstance, baseProps, baseState);\n\t\t            },\n\t\t        });\n\t\t    }\n\t\t    return null;\n\t\t};\n\t\tvar processComponentDidUpdateOnUpdate = function (renderDispatch, fiber, _a) {\n\t\t    var baseState = _a.baseState, baseProps = _a.baseProps, snapshot = _a.snapshot;\n\t\t    var typedInstance = fiber.instance;\n\t\t    var effect = getInstanceEffectState(typedInstance);\n\t\t    if (typedInstance.componentDidUpdate && exclude(effect, Effect_TYPE.__effect__)) {\n\t\t        setEffectForInstance(typedInstance, Effect_TYPE.__effect__);\n\t\t        renderDispatch.pendingLayoutEffect(fiber, function invokeComponentDidUpdateOnInstance() {\n\t\t            var _a;\n\t\t            setEffectForInstance(typedInstance, Effect_TYPE.__initial__);\n\t\t            (_a = typedInstance.componentDidUpdate) === null || _a === void 0 ? void 0 : _a.call(typedInstance, baseProps, baseState, snapshot);\n\t\t        });\n\t\t    }\n\t\t};\n\t\t/**\n\t\t * @deprecated\n\t\t */\n\t\tvar processComponentWillMountOnMount = function (fiber) {\n\t\t    var typedInstance = fiber.instance;\n\t\t    var hasLegacyLifeFunction = false;\n\t\t    if (typedInstance.UNSAFE_componentWillMount) {\n\t\t        hasLegacyLifeFunction = true;\n\t\t        safeCallWithCurrentFiber({\n\t\t            fiber: fiber,\n\t\t            action: function safeCallUNSAFE_componentWillMountOnInstance() {\n\t\t                var _a;\n\t\t                (_a = typedInstance.UNSAFE_componentWillMount) === null || _a === void 0 ? void 0 : _a.call(typedInstance);\n\t\t            },\n\t\t        });\n\t\t    }\n\t\t    if (typedInstance.componentWillMount) {\n\t\t        hasLegacyLifeFunction = true;\n\t\t        safeCallWithCurrentFiber({\n\t\t            fiber: fiber,\n\t\t            action: function safeCallComponentWillMountOnInstance() {\n\t\t                var _a;\n\t\t                (_a = typedInstance.componentWillMount) === null || _a === void 0 ? void 0 : _a.call(typedInstance);\n\t\t            },\n\t\t        });\n\t\t    }\n\t\t    return hasLegacyLifeFunction;\n\t\t};\n\t\t/**\n\t\t * @deprecated\n\t\t */\n\t\tvar processComponentWillReceiveProps = function (fiber) {\n\t\t    var typedInstance = fiber.instance;\n\t\t    var hasLegacyLifeFunction = false;\n\t\t    // only trigger on parent component update\n\t\t    if (include(fiber.state, STATE_TYPE.__inherit__)) {\n\t\t        if (typedInstance.UNSAFE_componentWillReceiveProps) {\n\t\t            hasLegacyLifeFunction = true;\n\t\t            var nextProps_1 = Object.assign({}, fiber.pendingProps);\n\t\t            safeCallWithCurrentFiber({\n\t\t                fiber: fiber,\n\t\t                action: function safeCallUNSAFE_componentWillReceivePropsOnInstance() {\n\t\t                    var _a;\n\t\t                    (_a = typedInstance.UNSAFE_componentWillReceiveProps) === null || _a === void 0 ? void 0 : _a.call(typedInstance, nextProps_1);\n\t\t                },\n\t\t            });\n\t\t        }\n\t\t        if (typedInstance.componentWillReceiveProps) {\n\t\t            hasLegacyLifeFunction = true;\n\t\t            var nextProps_2 = Object.assign({}, fiber.pendingProps);\n\t\t            safeCallWithCurrentFiber({\n\t\t                fiber: fiber,\n\t\t                action: function safeCallComponentWillReceivePropsOnInstance() {\n\t\t                    var _a;\n\t\t                    (_a = typedInstance.componentWillReceiveProps) === null || _a === void 0 ? void 0 : _a.call(typedInstance, nextProps_2);\n\t\t                },\n\t\t            });\n\t\t        }\n\t\t    }\n\t\t    return hasLegacyLifeFunction;\n\t\t};\n\t\t/**\n\t\t * @deprecated\n\t\t */\n\t\tvar processComponentWillUpdate = function (fiber, _a) {\n\t\t    var nextProps = _a.nextProps, nextState = _a.nextState;\n\t\t    var typedInstance = fiber.instance;\n\t\t    if (typedInstance.UNSAFE_componentWillUpdate) {\n\t\t        safeCallWithCurrentFiber({\n\t\t            fiber: fiber,\n\t\t            action: function safeCallUNSAFE_componentWillUpdateOnInstance() {\n\t\t                var _a;\n\t\t                (_a = typedInstance.UNSAFE_componentWillUpdate) === null || _a === void 0 ? void 0 : _a.call(typedInstance, nextProps, nextState);\n\t\t            },\n\t\t        });\n\t\t    }\n\t\t    if (typedInstance.componentWillUpdate) {\n\t\t        safeCallWithCurrentFiber({\n\t\t            fiber: fiber,\n\t\t            action: function safeCallComponentWillUpdateOnInstance() {\n\t\t                var _a;\n\t\t                (_a = typedInstance.componentWillUpdate) === null || _a === void 0 ? void 0 : _a.call(typedInstance, nextProps, nextState);\n\t\t            },\n\t\t        });\n\t\t    }\n\t\t};\n\t\tvar processClassComponentMount = function (renderDispatch, fiber) {\n\t\t    processComponentInstanceOnMount(renderDispatch, fiber);\n\t\t    processComponentStateFromProps(fiber);\n\t\t    // legacy lifeCycle\n\t\t    if (enableLegacyLifeCycle.current) {\n\t\t        beforeSyncFlush();\n\t\t        processComponentWillMountOnMount(fiber) && syncFlushComponentQueue(renderDispatch, fiber);\n\t\t        afterSyncFlush();\n\t\t    }\n\t\t    var children = processComponentRenderOnMountAndUpdate(fiber);\n\t\t    processComponentDidMountOnMount(renderDispatch, fiber);\n\t\t    return children;\n\t\t};\n\t\t// TODO\n\t\tvar processClassComponentActive = function (renderDispatch, fiber) {\n\t\t    processComponentFiberOnUpdate(renderDispatch, fiber);\n\t\t    processComponentPropsAndContextOnActive(renderDispatch, fiber);\n\t\t    var children = processComponentRenderOnMountAndUpdate(fiber);\n\t\t    processComponentDidMountOnMount(renderDispatch, fiber);\n\t\t    return children;\n\t\t};\n\t\t// TODO\n\t\tvar classComponentUpdateImpl = function (renderDispatch, fiber) {\n\t\t    processComponentFiberOnUpdate(renderDispatch, fiber);\n\t\t    processComponentStateFromProps(fiber);\n\t\t    if (enableLegacyLifeCycle.current) {\n\t\t        beforeSyncFlush();\n\t\t        processComponentWillReceiveProps(fiber) && syncFlushComponentQueue(renderDispatch, fiber);\n\t\t        afterSyncFlush();\n\t\t    }\n\t\t    var typedInstance = fiber.instance;\n\t\t    var baseState = typedInstance.state;\n\t\t    var baseProps = typedInstance.props;\n\t\t    // const baseContext = typedInstance.context;\n\t\t    var nextState = Object.assign({}, fiber.pendingState);\n\t\t    var nextProps = Object.assign({}, fiber.pendingProps);\n\t\t    var nextContext = processComponentContextOnUpdate(renderDispatch, fiber);\n\t\t    var shouldUpdate = Boolean(include(fiber.state, STATE_TYPE.__triggerSyncForce__ | STATE_TYPE.__triggerConcurrentForce__));\n\t\t    if (!shouldUpdate) {\n\t\t        shouldUpdate = processComponentShouldUpdateOnUpdate(fiber, {\n\t\t            nextState: nextState,\n\t\t            nextProps: nextProps,\n\t\t            nextContext: nextContext,\n\t\t        });\n\t\t    }\n\t\t    if (shouldUpdate && enableLegacyLifeCycle.current) {\n\t\t        processComponentWillUpdate(fiber, { nextProps: nextProps, nextState: nextState });\n\t\t    }\n\t\t    typedInstance.state = nextState;\n\t\t    typedInstance.props = nextProps;\n\t\t    typedInstance.context = nextContext;\n\t\t    if (shouldUpdate) {\n\t\t        var children = processComponentRenderOnMountAndUpdate(fiber);\n\t\t        var snapshot = processComponentGetSnapshotOnUpdate(fiber, { baseState: baseState, baseProps: baseProps });\n\t\t        processComponentDidUpdateOnUpdate(renderDispatch, fiber, {\n\t\t            snapshot: snapshot,\n\t\t            baseProps: baseProps,\n\t\t            baseState: baseState,\n\t\t        });\n\t\t        return { updated: true, children: children };\n\t\t    }\n\t\t    else {\n\t\t        return { updated: false };\n\t\t    }\n\t\t};\n\t\tvar syncComponentStateToFiber = function (fiber) {\n\t\t    var typedInstance = fiber.instance;\n\t\t    // sync pendingState\n\t\t    fiber.pendingState = Object.assign({}, typedInstance.state);\n\t\t};\n\t\tvar processClassComponentUpdate = function (renderDispatch, fiber) {\n\t\t    var res = classComponentUpdateImpl(renderDispatch, fiber);\n\t\t    syncComponentStateToFiber(fiber);\n\t\t    return res;\n\t\t};\n\t\tvar processClassComponentUnmount = function (renderDispatch, fiber) {\n\t\t    var typedInstance = fiber.instance;\n\t\t    if (!typedInstance)\n\t\t        return;\n\t\t    var classField = getInstanceFieldByInstance(typedInstance);\n\t\t    safeCallWithCurrentFiber({\n\t\t        fiber: fiber,\n\t\t        action: function safeCallInstanceUnmountListener() {\n\t\t            renderDispatch.callOnInstanceUnmount(typedInstance, fiber);\n\t\t        },\n\t\t    });\n\t\t    safeCallWithCurrentFiber({\n\t\t        fiber: fiber,\n\t\t        action: function safeCallComponentWillUnmountOnInstance() {\n\t\t            var _a;\n\t\t            if (classField.isMounted) {\n\t\t                (_a = typedInstance === null || typedInstance === void 0 ? void 0 : typedInstance.componentWillUnmount) === null || _a === void 0 ? void 0 : _a.call(typedInstance);\n\t\t            }\n\t\t        },\n\t\t    });\n\t\t};\n\n\t\t/* eslint-disable max-lines */\n\t\treact.__my_react_shared__.enableDebugFiled;\n\t\tvar currentScheduler$c = react.__my_react_internal__.currentScheduler;\n\t\t// TODO \n\t\tvar processClassComponentUpdateQueueLatest = function (renderDispatch, fiber, enableTaskPriority) {\n\t\t    if (include(fiber.state, STATE_TYPE.__unmount__))\n\t\t        return;\n\t\t    if (exclude(fiber.type, exports.NODE_TYPE.__class__))\n\t\t        throw new Error(\"[@my-react/react] current fiber is not a class component, look like a bug for @my-react\");\n\t\t    var renderScheduler = currentScheduler$c.current;\n\t\t    var allQueue = fiber.updateQueue;\n\t\t    var node = allQueue === null || allQueue === void 0 ? void 0 : allQueue.head;\n\t\t    var needUpdate = true;\n\t\t    var isSync = false;\n\t\t    var isForce = false;\n\t\t    var isImmediate = false;\n\t\t    var isRetrigger = false;\n\t\t    var callbacks = [];\n\t\t    var processedNodes = [];\n\t\t    var typedInstance = fiber.instance;\n\t\t    var baseState = Object.assign({}, fiber.pendingState);\n\t\t    var baseProps = Object.assign({}, typedInstance.props);\n\t\t    var pendingState = Object.assign({}, fiber.pendingState);\n\t\t    if (enableTaskPriority && allQueue.some(function (l) { return l.isSync; })) {\n\t\t        var _loop_1 = function () {\n\t\t            var updater = node.value;\n\t\t            var nextNode = node.next;\n\t\t            if (updater.type === UpdateQueueType.component && updater.isSync) {\n\t\t                allQueue.delete(node);\n\t\t                processedNodes.push(updater);\n\t\t                var payLoad_1 = updater.payLoad;\n\t\t                fiber.pendingState = safeCallWithCurrentFiber({\n\t\t                    fiber: fiber,\n\t\t                    fallback: function safeFallbackForState() {\n\t\t                        return pendingState;\n\t\t                    },\n\t\t                    action: function safeGetNextState() {\n\t\t                        return Object.assign({}, fiber.pendingState, typeof payLoad_1 === \"function\" ? payLoad_1(baseState, baseProps) : payLoad_1);\n\t\t                    },\n\t\t                });\n\t\t                isSync = isSync || updater.isSync;\n\t\t                isForce = isForce || updater.isForce;\n\t\t                isImmediate = isImmediate || updater.isImmediate;\n\t\t                isRetrigger = isRetrigger || updater.isRetrigger;\n\t\t                updater.callback && callbacks.push(updater.callback);\n\t\t            }\n\t\t            else if (updater.isSync) {\n\t\t                allQueue.delete(node);\n\t\t                processedNodes.push(updater);\n\t\t                isSync = isSync || updater.isSync;\n\t\t                isForce = isForce || updater.isForce;\n\t\t                isImmediate = isImmediate || updater.isImmediate;\n\t\t                isRetrigger = isRetrigger || updater.isRetrigger;\n\t\t                updater.callback && callbacks.push(updater.callback);\n\t\t            }\n\t\t            node = nextNode;\n\t\t        };\n\t\t        while (node) {\n\t\t            _loop_1();\n\t\t        }\n\t\t        if (allQueue.length) {\n\t\t            renderScheduler.microTask(function prepareUpdateOnFiberTask() {\n\t\t                prepareUpdateOnFiber(renderDispatch, fiber, true);\n\t\t            });\n\t\t        }\n\t\t        var invokeCallbackArray = callbacks.length\n\t\t            ? function invokeCallbackArray() {\n\t\t                return callbacks.forEach(function (cb) { return cb === null || cb === void 0 ? void 0 : cb(); });\n\t\t            }\n\t\t            : void 0;\n\t\t        return {\n\t\t            needUpdate: needUpdate,\n\t\t            nodes: processedNodes,\n\t\t            isSync: isSync,\n\t\t            isForce: isForce,\n\t\t            isImmediate: isImmediate,\n\t\t            isRetrigger: isRetrigger,\n\t\t            callback: invokeCallbackArray,\n\t\t        };\n\t\t    }\n\t\t    else {\n\t\t        var _loop_2 = function () {\n\t\t            var updater = node.value;\n\t\t            var nextNode = node.next;\n\t\t            if (updater.type === UpdateQueueType.component) {\n\t\t                allQueue.delete(node);\n\t\t                processedNodes.push(updater);\n\t\t                var payLoad_2 = updater.payLoad;\n\t\t                fiber.pendingState = safeCallWithCurrentFiber({\n\t\t                    fiber: fiber,\n\t\t                    fallback: function safeFallbackForState() {\n\t\t                        return pendingState;\n\t\t                    },\n\t\t                    action: function safeGetNextState() {\n\t\t                        return Object.assign({}, fiber.pendingState, typeof payLoad_2 === \"function\" ? payLoad_2(baseState, baseProps) : payLoad_2);\n\t\t                    },\n\t\t                });\n\t\t                isSync = isSync || updater.isSync;\n\t\t                isForce = isForce || updater.isForce;\n\t\t                isImmediate = isImmediate || updater.isImmediate;\n\t\t                isRetrigger = isRetrigger || updater.isRetrigger;\n\t\t                updater.callback && callbacks.push(updater.callback);\n\t\t            }\n\t\t            else {\n\t\t                allQueue.delete(node);\n\t\t                processedNodes.push(updater);\n\t\t                isSync = isSync || updater.isSync;\n\t\t                isForce = isForce || updater.isForce;\n\t\t                isImmediate = isImmediate || updater.isImmediate;\n\t\t                isRetrigger = isRetrigger || updater.isRetrigger;\n\t\t                updater.callback && callbacks.push(updater.callback);\n\t\t            }\n\t\t            node = nextNode;\n\t\t        };\n\t\t        while (node) {\n\t\t            _loop_2();\n\t\t        }\n\t\t        var invokeCallbackArray = callbacks.length\n\t\t            ? function invokeCallbackArray() {\n\t\t                return callbacks.forEach(function (cb) { return cb === null || cb === void 0 ? void 0 : cb(); });\n\t\t            }\n\t\t            : void 0;\n\t\t        return {\n\t\t            needUpdate: needUpdate,\n\t\t            nodes: processedNodes,\n\t\t            isSync: isSync,\n\t\t            isForce: isForce,\n\t\t            isImmediate: isImmediate,\n\t\t            isRetrigger: isRetrigger,\n\t\t            callback: invokeCallbackArray,\n\t\t        };\n\t\t    }\n\t\t};\n\t\tvar processClassComponentUpdateQueueLegacy = function (renderDispatch, fiber) {\n\t\t    if (include(fiber.state, STATE_TYPE.__unmount__))\n\t\t        return;\n\t\t    if (exclude(fiber.type, exports.NODE_TYPE.__class__))\n\t\t        throw new Error(\"[@my-react/react] current fiber is not a class component, look like a bug for @my-react\");\n\t\t    var renderScheduler = currentScheduler$c.current;\n\t\t    var allQueue = fiber.updateQueue;\n\t\t    var node = allQueue === null || allQueue === void 0 ? void 0 : allQueue.head;\n\t\t    var needUpdate = true;\n\t\t    var isSync = true;\n\t\t    var isForce = false;\n\t\t    var isImmediate = false;\n\t\t    var isRetrigger = false;\n\t\t    var callbacks = [];\n\t\t    var processedNodes = [];\n\t\t    var typedInstance = fiber.instance;\n\t\t    var baseState = Object.assign({}, fiber.pendingState);\n\t\t    var baseProps = Object.assign({}, typedInstance.props);\n\t\t    var pendingState = Object.assign({}, fiber.pendingState);\n\t\t    if (node) {\n\t\t        var updater = node.value;\n\t\t        if (updater.type === UpdateQueueType.component) {\n\t\t            allQueue.delete(node);\n\t\t            processedNodes.push(updater);\n\t\t            var payLoad_3 = updater.payLoad;\n\t\t            fiber.pendingState = safeCallWithCurrentFiber({\n\t\t                fiber: fiber,\n\t\t                fallback: function safeFallbackForState() {\n\t\t                    return pendingState;\n\t\t                },\n\t\t                action: function safeGetNextState() {\n\t\t                    return Object.assign({}, fiber.pendingState, typeof payLoad_3 === \"function\" ? payLoad_3(baseState, baseProps) : payLoad_3);\n\t\t                },\n\t\t            });\n\t\t            isSync = isSync || updater.isSync;\n\t\t            isForce = isForce || updater.isForce;\n\t\t            isImmediate = isImmediate || updater.isImmediate;\n\t\t            isRetrigger = isRetrigger || updater.isRetrigger;\n\t\t            updater.callback && callbacks.push(updater.callback);\n\t\t        }\n\t\t        else {\n\t\t            allQueue.delete(node);\n\t\t            processedNodes.push(updater);\n\t\t            isSync = isSync || updater.isSync;\n\t\t            isForce = isForce || updater.isForce;\n\t\t            isImmediate = isImmediate || updater.isImmediate;\n\t\t            isRetrigger = isRetrigger || updater.isRetrigger;\n\t\t            updater.callback && callbacks.push(updater.callback);\n\t\t        }\n\t\t    }\n\t\t    if (allQueue.length) {\n\t\t        renderScheduler.microTask(function prepareUpdateOnFiberTask() {\n\t\t            prepareUpdateOnFiber(renderDispatch, fiber, true);\n\t\t        });\n\t\t    }\n\t\t    var invokeCallbackArray = callbacks.length\n\t\t        ? function invokeCallbackArray() {\n\t\t            return callbacks.forEach(function (cb) { return cb === null || cb === void 0 ? void 0 : cb(); });\n\t\t        }\n\t\t        : void 0;\n\t\t    return {\n\t\t        needUpdate: needUpdate,\n\t\t        nodes: processedNodes,\n\t\t        isSync: isSync,\n\t\t        isForce: isForce,\n\t\t        isImmediate: isImmediate,\n\t\t        isRetrigger: isRetrigger,\n\t\t        callback: invokeCallbackArray,\n\t\t    };\n\t\t};\n\t\tvar processFunctionComponentUpdateQueueLatest = function (renderDispatch, fiber, enableTaskPriority) {\n\t\t    var _a, _b;\n\t\t    if (include(fiber.state, STATE_TYPE.__unmount__))\n\t\t        return;\n\t\t    if (exclude(fiber.type, exports.NODE_TYPE.__function__)) {\n\t\t        throw new Error(\"[@my-react/react] current fiber is not a function component, look like a bug for @my-react\");\n\t\t    }\n\t\t    var renderScheduler = currentScheduler$c.current;\n\t\t    var allQueue = fiber.updateQueue;\n\t\t    var node = allQueue === null || allQueue === void 0 ? void 0 : allQueue.head;\n\t\t    var needUpdate = false;\n\t\t    var isSync = false;\n\t\t    var isForce = false;\n\t\t    var isImmediate = false;\n\t\t    var isRetrigger = false;\n\t\t    var processedNodes = [];\n\t\t    var callbacks = [];\n\t\t    if (enableTaskPriority && allQueue.some(function (l) { return l.isSync; })) {\n\t\t        var _loop_3 = function () {\n\t\t            var updater = node.value;\n\t\t            var nextNode = node.next;\n\t\t            if (updater.type === UpdateQueueType.hook && updater.isSync) {\n\t\t                allQueue.delete(node);\n\t\t                processedNodes.push(updater);\n\t\t                var trigger = updater.trigger, payLoad_4 = updater.payLoad, reducer_1 = updater.reducer;\n\t\t                var typedTrigger_1 = trigger;\n\t\t                var lastResult_1 = typedTrigger_1.result;\n\t\t                if (typedTrigger_1.type === HOOK_TYPE.useSyncExternalStore) {\n\t\t                    lastResult_1 = (_a = trigger.value) === null || _a === void 0 ? void 0 : _a.result;\n\t\t                }\n\t\t                var hasError_1 = false;\n\t\t                typedTrigger_1.result = safeCallWithCurrentFiber({\n\t\t                    fiber: fiber,\n\t\t                    fallback: function safeFallbackForState() {\n\t\t                        hasError_1 = true;\n\t\t                        return lastResult_1;\n\t\t                    },\n\t\t                    action: function safeGetNextState() {\n\t\t                        if (reducer_1 && typeof reducer_1 === \"function\") {\n\t\t                            return reducer_1(lastResult_1, payLoad_4);\n\t\t                        }\n\t\t                        else {\n\t\t                            return typedTrigger_1.reducer(lastResult_1, payLoad_4);\n\t\t                        }\n\t\t                    },\n\t\t                });\n\t\t                isSync = isSync || updater.isSync;\n\t\t                isForce = isForce || updater.isForce;\n\t\t                isImmediate = isImmediate || updater.isImmediate;\n\t\t                isRetrigger = isRetrigger || updater.isRetrigger;\n\t\t                updater.callback && callbacks.push(updater.callback);\n\t\t                if (!needUpdate && (isForce || hasError_1 || callbacks.length || !Object.is(lastResult_1, typedTrigger_1.result)))\n\t\t                    needUpdate = true;\n\t\t            }\n\t\t            else if (updater.isSync) {\n\t\t                allQueue.delete(node);\n\t\t                processedNodes.push(updater);\n\t\t                updater.payLoad;\n\t\t                isSync = isSync || updater.isSync;\n\t\t                isForce = isForce || updater.isForce;\n\t\t                isImmediate = isImmediate || updater.isImmediate;\n\t\t                isRetrigger = isRetrigger || updater.isRetrigger;\n\t\t                updater.callback && callbacks.push(updater.callback);\n\t\t                needUpdate = true;\n\t\t            }\n\t\t            node = nextNode;\n\t\t        };\n\t\t        while (node) {\n\t\t            _loop_3();\n\t\t        }\n\t\t        if (allQueue.length) {\n\t\t            renderScheduler.microTask(function prepareUpdateOnFiberTask() {\n\t\t                prepareUpdateOnFiber(renderDispatch, fiber, true);\n\t\t            });\n\t\t        }\n\t\t        var invokeCallbackArray = callbacks.length\n\t\t            ? function invokeCallbackArray() {\n\t\t                return callbacks.forEach(function (cb) { return cb === null || cb === void 0 ? void 0 : cb(); });\n\t\t            }\n\t\t            : void 0;\n\t\t        return {\n\t\t            needUpdate: needUpdate,\n\t\t            nodes: processedNodes,\n\t\t            isSync: isSync,\n\t\t            isForce: isForce,\n\t\t            isImmediate: isImmediate,\n\t\t            isRetrigger: isRetrigger,\n\t\t            callback: invokeCallbackArray,\n\t\t        };\n\t\t    }\n\t\t    else {\n\t\t        var _loop_4 = function () {\n\t\t            var updater = node.value;\n\t\t            var nextNode = node.next;\n\t\t            if (updater.type === UpdateQueueType.hook) {\n\t\t                allQueue.delete(node);\n\t\t                processedNodes.push(updater);\n\t\t                var trigger = updater.trigger, payLoad_5 = updater.payLoad, reducer_2 = updater.reducer;\n\t\t                var typedTrigger_2 = trigger;\n\t\t                var lastResult_2 = typedTrigger_2.result;\n\t\t                if (typedTrigger_2.type === HOOK_TYPE.useSyncExternalStore) {\n\t\t                    lastResult_2 = (_b = trigger.value) === null || _b === void 0 ? void 0 : _b.result;\n\t\t                }\n\t\t                var hasError_2 = false;\n\t\t                typedTrigger_2.result = safeCallWithCurrentFiber({\n\t\t                    fiber: fiber,\n\t\t                    fallback: function safeFallbackForState() {\n\t\t                        hasError_2 = true;\n\t\t                        return lastResult_2;\n\t\t                    },\n\t\t                    action: function safeGetNextState() {\n\t\t                        if (reducer_2 && typeof reducer_2 === \"function\") {\n\t\t                            return reducer_2(lastResult_2, payLoad_5);\n\t\t                        }\n\t\t                        else {\n\t\t                            return typedTrigger_2.reducer(lastResult_2, payLoad_5);\n\t\t                        }\n\t\t                    },\n\t\t                });\n\t\t                isSync = isSync || updater.isSync;\n\t\t                isForce = isForce || updater.isForce;\n\t\t                isImmediate = isImmediate || updater.isImmediate;\n\t\t                isRetrigger = isRetrigger || updater.isRetrigger;\n\t\t                updater.callback && callbacks.push(updater.callback);\n\t\t                if (!needUpdate && (isForce || hasError_2 || callbacks.length || !Object.is(lastResult_2, typedTrigger_2.result)))\n\t\t                    needUpdate = true;\n\t\t            }\n\t\t            else {\n\t\t                allQueue.delete(node);\n\t\t                processedNodes.push(updater);\n\t\t                updater.payLoad;\n\t\t                isSync = isSync || updater.isSync;\n\t\t                isForce = isForce || updater.isForce;\n\t\t                isImmediate = isImmediate || updater.isImmediate;\n\t\t                isRetrigger = isRetrigger || updater.isRetrigger;\n\t\t                updater.callback && callbacks.push(updater.callback);\n\t\t                needUpdate = true;\n\t\t            }\n\t\t            node = nextNode;\n\t\t        };\n\t\t        while (node) {\n\t\t            _loop_4();\n\t\t        }\n\t\t        var invokeCallbackArray = callbacks.length\n\t\t            ? function invokeCallbackArray() {\n\t\t                return callbacks.forEach(function (cb) { return cb === null || cb === void 0 ? void 0 : cb(); });\n\t\t            }\n\t\t            : void 0;\n\t\t        return {\n\t\t            needUpdate: needUpdate,\n\t\t            nodes: processedNodes,\n\t\t            isSync: isSync,\n\t\t            isForce: isForce,\n\t\t            isImmediate: isImmediate,\n\t\t            isRetrigger: isRetrigger,\n\t\t            callback: invokeCallbackArray,\n\t\t        };\n\t\t    }\n\t\t};\n\t\tvar processFunctionComponentUpdateQueueLegacy = function (renderDispatch, fiber) {\n\t\t    var _a;\n\t\t    if (include(fiber.state, STATE_TYPE.__unmount__))\n\t\t        return;\n\t\t    if (exclude(fiber.type, exports.NODE_TYPE.__function__)) {\n\t\t        throw new Error(\"[@my-react/react] current fiber is not a function component, look like a bug for @my-react\");\n\t\t    }\n\t\t    var renderScheduler = currentScheduler$c.current;\n\t\t    var allQueue = fiber.updateQueue;\n\t\t    var node = allQueue === null || allQueue === void 0 ? void 0 : allQueue.head;\n\t\t    var needUpdate = false;\n\t\t    var isSync = true;\n\t\t    var isForce = false;\n\t\t    var isImmediate = false;\n\t\t    var isRetrigger = false;\n\t\t    var processedNodes = [];\n\t\t    var callbacks = [];\n\t\t    if (node) {\n\t\t        var updater = node.value;\n\t\t        if (updater.type === UpdateQueueType.hook) {\n\t\t            allQueue.delete(node);\n\t\t            processedNodes.push(updater);\n\t\t            var trigger = updater.trigger, payLoad_6 = updater.payLoad, reducer_3 = updater.reducer;\n\t\t            var typedTrigger_3 = trigger;\n\t\t            var lastResult_3 = typedTrigger_3.result;\n\t\t            if (typedTrigger_3.type === HOOK_TYPE.useSyncExternalStore) {\n\t\t                lastResult_3 = (_a = trigger.value) === null || _a === void 0 ? void 0 : _a.result;\n\t\t            }\n\t\t            var hasError_3 = false;\n\t\t            typedTrigger_3.result = safeCallWithCurrentFiber({\n\t\t                fiber: fiber,\n\t\t                fallback: function safeFallbackForState() {\n\t\t                    hasError_3 = true;\n\t\t                    return lastResult_3;\n\t\t                },\n\t\t                action: function safeGetNextState() {\n\t\t                    if (reducer_3 && typeof reducer_3 === \"function\") {\n\t\t                        return reducer_3(lastResult_3, payLoad_6);\n\t\t                    }\n\t\t                    else {\n\t\t                        return typedTrigger_3.reducer(lastResult_3, payLoad_6);\n\t\t                    }\n\t\t                },\n\t\t            });\n\t\t            isSync = isSync || updater.isSync;\n\t\t            isForce = isForce || updater.isForce;\n\t\t            isImmediate = isImmediate || updater.isImmediate;\n\t\t            isRetrigger = isRetrigger || updater.isRetrigger;\n\t\t            updater.callback && callbacks.push(updater.callback);\n\t\t            if (!needUpdate && (isForce || hasError_3 || callbacks.length || !Object.is(lastResult_3, typedTrigger_3.result)))\n\t\t                needUpdate = true;\n\t\t        }\n\t\t        else {\n\t\t            allQueue.delete(node);\n\t\t            processedNodes.push(updater);\n\t\t            updater.payLoad;\n\t\t            isSync = isSync || updater.isSync;\n\t\t            isForce = isForce || updater.isForce;\n\t\t            isImmediate = isImmediate || updater.isImmediate;\n\t\t            isRetrigger = isRetrigger || updater.isRetrigger;\n\t\t            updater.callback && callbacks.push(updater.callback);\n\t\t            needUpdate = true;\n\t\t        }\n\t\t    }\n\t\t    if (allQueue.length) {\n\t\t        renderScheduler.microTask(function prepareUpdateOnFiberTask() {\n\t\t            prepareUpdateOnFiber(renderDispatch, fiber, true);\n\t\t        });\n\t\t    }\n\t\t    var invokeCallbackArray = callbacks.length\n\t\t        ? function invokeCallbackArray() {\n\t\t            return callbacks.forEach(function (cb) { return cb === null || cb === void 0 ? void 0 : cb(); });\n\t\t        }\n\t\t        : void 0;\n\t\t    return {\n\t\t        needUpdate: needUpdate,\n\t\t        nodes: processedNodes,\n\t\t        isSync: isSync,\n\t\t        isForce: isForce,\n\t\t        isImmediate: isImmediate,\n\t\t        isRetrigger: isRetrigger,\n\t\t        callback: invokeCallbackArray,\n\t\t    };\n\t\t};\n\t\tvar processNormalComponentUpdateLatest = function (renderDispatch, fiber) {\n\t\t    if (include(fiber.state, STATE_TYPE.__unmount__))\n\t\t        return;\n\t\t    var allQueue = fiber.updateQueue;\n\t\t    var node = allQueue === null || allQueue === void 0 ? void 0 : allQueue.head;\n\t\t    var needUpdate = true;\n\t\t    var isSync = false;\n\t\t    var isForce = false;\n\t\t    var isImmediate = false;\n\t\t    var isRetrigger = false;\n\t\t    var processedNodes = [];\n\t\t    var callbacks = [];\n\t\t    while (node) {\n\t\t        var updater = node.value;\n\t\t        var nextNode = node.next;\n\t\t        allQueue.delete(node);\n\t\t        processedNodes.push(updater);\n\t\t        updater.payLoad;\n\t\t        isSync = isSync || updater.isSync;\n\t\t        isForce = isForce || updater.isForce;\n\t\t        isImmediate = isImmediate || updater.isImmediate;\n\t\t        isRetrigger = isRetrigger || updater.isRetrigger;\n\t\t        updater.callback && callbacks.push(updater.callback);\n\t\t        node = nextNode;\n\t\t    }\n\t\t    var invokeCallbackArray = callbacks.length\n\t\t        ? function invokeCallbackArray() {\n\t\t            return callbacks.forEach(function (cb) { return cb === null || cb === void 0 ? void 0 : cb(); });\n\t\t        }\n\t\t        : void 0;\n\t\t    return {\n\t\t        needUpdate: needUpdate,\n\t\t        nodes: processedNodes,\n\t\t        isSync: isSync,\n\t\t        isForce: isForce,\n\t\t        isImmediate: isImmediate,\n\t\t        isRetrigger: isRetrigger,\n\t\t        callback: invokeCallbackArray,\n\t\t    };\n\t\t};\n\t\tvar processNormalComponentUpdateLegacy = function (renderDispatch, fiber) {\n\t\t    if (include(fiber.state, STATE_TYPE.__unmount__))\n\t\t        return;\n\t\t    var allQueue = fiber.updateQueue;\n\t\t    var renderScheduler = currentScheduler$c.current;\n\t\t    var node = allQueue === null || allQueue === void 0 ? void 0 : allQueue.head;\n\t\t    var needUpdate = true;\n\t\t    var isSync = true;\n\t\t    var isForce = false;\n\t\t    var isImmediate = false;\n\t\t    var isRetrigger = false;\n\t\t    var processedNodes = [];\n\t\t    var callbacks = [];\n\t\t    if (node) {\n\t\t        var updater = node.value;\n\t\t        allQueue.delete(node);\n\t\t        processedNodes.push(updater);\n\t\t        updater.payLoad;\n\t\t        isSync = isSync || updater.isSync;\n\t\t        isForce = isForce || updater.isForce;\n\t\t        isImmediate = isImmediate || updater.isImmediate;\n\t\t        isRetrigger = isRetrigger || updater.isRetrigger;\n\t\t        updater.callback && callbacks.push(updater.callback);\n\t\t    }\n\t\t    if (allQueue.length) {\n\t\t        renderScheduler.microTask(function prepareUpdateOnFiberTask() {\n\t\t            prepareUpdateOnFiber(renderDispatch, fiber, true);\n\t\t        });\n\t\t    }\n\t\t    var invokeCallbackArray = callbacks.length\n\t\t        ? function invokeCallbackArray() {\n\t\t            return callbacks.forEach(function (cb) { return cb === null || cb === void 0 ? void 0 : cb(); });\n\t\t        }\n\t\t        : void 0;\n\t\t    return {\n\t\t        needUpdate: needUpdate,\n\t\t        nodes: processedNodes,\n\t\t        isSync: isSync,\n\t\t        isForce: isForce,\n\t\t        isImmediate: isImmediate,\n\t\t        isRetrigger: isRetrigger,\n\t\t        callback: invokeCallbackArray,\n\t\t    };\n\t\t};\n\t\t/**\n\t\t * @deprecated\n\t\t */\n\t\tvar syncFiberStateToComponent = function (renderDispatch, fiber, callback) {\n\t\t    var typedInstance = fiber.instance;\n\t\t    var typedPendingState = fiber.pendingState;\n\t\t    typedInstance.state = Object.assign({}, typedInstance.state, typedPendingState);\n\t\t    callback && renderDispatch.pendingLayoutEffect(fiber, callback, { stickyToFoot: true });\n\t\t};\n\t\t/**\n\t\t * @deprecated\n\t\t */\n\t\tvar syncFlushComponentQueue = function (renderDispatch, fiber) {\n\t\t    var _a = processClassComponentUpdateQueueLatest(renderDispatch, fiber), needUpdate = _a.needUpdate, callback = _a.callback;\n\t\t    needUpdate && syncFiberStateToComponent(renderDispatch, fiber, callback);\n\t\t    syncComponentStateToFiber(fiber);\n\t\t};\n\n\t\treact.__my_react_internal__.currentComponentFiber; var currentRunningFiber$1 = react.__my_react_internal__.currentRunningFiber;\n\t\treact.__my_react_shared__.enableDebugFiled;\n\t\tvar processState = function (renderDispatch, _params) {\n\t\t    var ownerFiber = getInstanceOwnerFiber(_params.trigger);\n\t\t    if (!renderDispatch)\n\t\t        return;\n\t\t    _params.isRetrigger = currentRunningFiber$1.current === ownerFiber || !!_params.isRetrigger;\n\t\t    _params.isImmediate =\n\t\t        typeof _params.isImmediate === \"boolean\"\n\t\t            ? _params.isImmediate\n\t\t            : _params.isRetrigger || (renderDispatch.isAppMounted ? !!currentRunningFiber$1.current : false);\n\t\t    safeCallWithCurrentFiber({\n\t\t        fiber: ownerFiber,\n\t\t        action: function safeCallFiberStateListener() {\n\t\t            renderDispatch.callOnFiberState(ownerFiber, _params);\n\t\t        },\n\t\t    });\n\t\t    var isImmediate = _params.isImmediate;\n\t\t    _params.isRetrigger;\n\t\t    if (_params.type === UpdateQueueType.component) {\n\t\t        if (!ownerFiber || include(ownerFiber.state, STATE_TYPE.__unmount__))\n\t\t            return;\n\t\t        var trigger_1 = _params.trigger;\n\t\t        safeCallWithCurrentFiber({\n\t\t            fiber: ownerFiber,\n\t\t            action: function safeCallInstanceStateListener() {\n\t\t                renderDispatch.callOnInstanceState(trigger_1, ownerFiber, _params);\n\t\t            },\n\t\t        });\n\t\t        ownerFiber.updateQueue = ownerFiber.updateQueue || new ListTree();\n\t\t        ownerFiber.updateQueue.push(_params);\n\t\t        prepareUpdateOnFiber(renderDispatch, ownerFiber, isImmediate);\n\t\t    }\n\t\t    else if (_params.type === UpdateQueueType.hook) {\n\t\t        if (!ownerFiber || include(ownerFiber === null || ownerFiber === void 0 ? void 0 : ownerFiber.state, STATE_TYPE.__unmount__))\n\t\t            return;\n\t\t        var trigger_2 = _params.trigger;\n\t\t        safeCallWithCurrentFiber({\n\t\t            fiber: ownerFiber,\n\t\t            action: function safeCallHookStateListener() {\n\t\t                renderDispatch.callOnHookState(trigger_2, ownerFiber, _params);\n\t\t            },\n\t\t        });\n\t\t        ownerFiber.updateQueue = ownerFiber.updateQueue || new ListTree();\n\t\t        ownerFiber.updateQueue.push(_params);\n\t\t        prepareUpdateOnFiber(renderDispatch, ownerFiber, isImmediate);\n\t\t    }\n\t\t    else {\n\t\t        var ownerFiber_1 = _params.trigger;\n\t\t        if (!ownerFiber_1 || include(ownerFiber_1.state, STATE_TYPE.__unmount__))\n\t\t            return;\n\t\t        ownerFiber_1.updateQueue = ownerFiber_1.updateQueue || new ListTree();\n\t\t        ownerFiber_1.updateQueue.push(_params);\n\t\t        prepareUpdateOnFiber(renderDispatch, ownerFiber_1, isImmediate);\n\t\t    }\n\t\t};\n\n\t\tvar defaultGenerateUnmountMap = function (fiber, unmount, map) {\n\t\t    var list = map.get(fiber);\n\t\t    if (!list) {\n\t\t        list = new ListTree();\n\t\t        map.set(fiber, list);\n\t\t    }\n\t\t    list.push(unmount);\n\t\t};\n\t\tvar defaultDispatchUnmount = function (renderDispatch) {\n\t\t    if (renderDispatch.isAppUnmounted)\n\t\t        return;\n\t\t    var rootFiber = renderDispatch.rootFiber;\n\t\t    unmountFiber(renderDispatch, rootFiber);\n\t\t    clearContainer(renderDispatch);\n\t\t};\n\t\tvar defaultInvokeUnmountList = function (renderDispatch, fiber) {\n\t\t    if (include(fiber.patch, PATCH_TYPE.__unmount__)) {\n\t\t        var unmountMap = renderDispatch.runtimeMap.unmountMap;\n\t\t        var allUnmount = unmountMap.get(fiber);\n\t\t        unmountMap.delete(fiber);\n\t\t        if (allUnmount && allUnmount.length) {\n\t\t            allUnmount.listToFoot(function invokeUnmountFromCurrent(unmount) {\n\t\t                safeCallWithCurrentFiber({\n\t\t                    fiber: unmount,\n\t\t                    action: function safeCallUnmountFromCurrent() {\n\t\t                        unmountFiber(renderDispatch, unmount);\n\t\t                    },\n\t\t                });\n\t\t            });\n\t\t        }\n\t\t        fiber.patch = remove(fiber.patch, PATCH_TYPE.__unmount__);\n\t\t    }\n\t\t};\n\n\t\t// unmount current fiber\n\t\tvar unmountFiber = function (renderDispatch, fiber) {\n\t\t    if (include(fiber.state, STATE_TYPE.__unmount__))\n\t\t        return;\n\t\t    var list = generateFiberToListWithAction(fiber, function invokeUnmountPending(f) {\n\t\t        defaultInvokeUnmountList(renderDispatch, f);\n\t\t    });\n\t\t    list.listToFoot(function invokeFiberUnmountList(f) {\n\t\t        unmountFiberNode(renderDispatch, f);\n\t\t    });\n\t\t};\n\t\t// unmount current container with safe\n\t\tvar unmountContainer = function (renderDispatch, cb) {\n\t\t    renderDispatch.reconcileUnmount();\n\t\t    cb === null || cb === void 0 ? void 0 : cb();\n\t\t};\n\t\tvar clearContainer = function (renderDispatch) {\n\t\t    var _a, _b, _c, _d;\n\t\t    renderDispatch.pendingCommitFiberPatch = PATCH_TYPE.__initial__;\n\t\t    (_a = renderDispatch.pendingUpdateFiberArray) === null || _a === void 0 ? void 0 : _a.clear();\n\t\t    (_b = renderDispatch.pendingSuspenseFiberArray) === null || _b === void 0 ? void 0 : _b.clear();\n\t\t    (_c = renderDispatch.pendingCommitFiberList) === null || _c === void 0 ? void 0 : _c.clear();\n\t\t    (_d = renderDispatch.pendingChangedFiberList) === null || _d === void 0 ? void 0 : _d.clear();\n\t\t    renderDispatch.resetUpdateFlowRuntimeFiber();\n\t\t    renderDispatch.isAppMounted = false;\n\t\t    renderDispatch.isAppUnmounted = true;\n\t\t};\n\n\t\tvar globalLoop$3 = react.__my_react_internal__.globalLoop, currentScheduler$b = react.__my_react_internal__.currentScheduler, currentError = react.__my_react_internal__.currentError;\n\t\tvar applyTriggerFiberCb = function (renderDispatch, fiber) {\n\t\t    var _a, _b;\n\t\t    var cbArray = renderDispatch.runtimeMap.triggerCallbackMap.get(fiber);\n\t\t    if (include(fiber.type, exports.NODE_TYPE.__class__)) {\n\t\t        (_a = cbArray === null || cbArray === void 0 ? void 0 : cbArray.listToFoot) === null || _a === void 0 ? void 0 : _a.call(cbArray, function (cb) {\n\t\t            renderDispatch.pendingLayoutEffect(fiber, cb, { stickyToFoot: true });\n\t\t        });\n\t\t    }\n\t\t    else {\n\t\t        (_b = cbArray === null || cbArray === void 0 ? void 0 : cbArray.listToFoot) === null || _b === void 0 ? void 0 : _b.call(cbArray, function (cb) {\n\t\t            renderDispatch.pendingEffect(fiber, cb, { stickyToFoot: true });\n\t\t        });\n\t\t    }\n\t\t    renderDispatch.runtimeMap.triggerCallbackMap.delete(fiber);\n\t\t};\n\t\t/**\n\t\t * only used for dev HMR\n\t\t * only invoke on the errorCatchFiber\n\t\t */\n\t\tvar triggerRevert = function (renderDispatch, fiber, cb) {\n\t\t    {\n\t\t        console.error(\"[@my-react/react] can not call revert on prod mode\");\n\t\t    }\n\t\t};\n\t\tvar triggerUpdate = function (renderDispatch, fiber, state, cb) {\n\t\t    if (include(fiber.state, STATE_TYPE.__unmount__))\n\t\t        return;\n\t\t    var renderScheduler = currentScheduler$b.current;\n\t\t    if (!renderDispatch || !renderDispatch.enableUpdate)\n\t\t        return;\n\t\t    if (renderDispatch.isAppCrashed)\n\t\t        return;\n\t\t    if (renderDispatch.isAppUnmounted)\n\t\t        return;\n\t\t    // TODO\n\t\t    if (!renderDispatch.isAppMounted) {\n\t\t        renderScheduler.macroTask(function scheduleUpdateBeforeMount() {\n\t\t            triggerUpdate(renderDispatch, fiber, state, cb);\n\t\t        });\n\t\t        return;\n\t\t    }\n\t\t    if (typeof state === \"function\") {\n\t\t        cb = state;\n\t\t        state = STATE_TYPE.__triggerConcurrent__;\n\t\t    }\n\t\t    state = state || STATE_TYPE.__triggerSync__;\n\t\t    if (fiber.state === STATE_TYPE.__stable__) {\n\t\t        fiber.state = state;\n\t\t    }\n\t\t    else {\n\t\t        fiber.state = merge(fiber.state, state);\n\t\t    }\n\t\t    renderDispatch.pendingUpdateFiberArray.uniPush(fiber);\n\t\t    if (cb) {\n\t\t        var map = renderDispatch.runtimeMap.triggerCallbackMap;\n\t\t        var exist = map.get(fiber) || new ListTree();\n\t\t        exist.push(cb);\n\t\t        map.set(fiber, exist);\n\t\t    }\n\t\t    // if (globalLoop.current) {\n\t\t    //   const nextFiber = renderDispatch.runtimeFiber.nextWorkingFiber;\n\t\t    //   if (!nextFiber) return;\n\t\t    //   if (nextFiber.state !== STATE_TYPE.__stable__) {\n\t\t    //     nextFiber.state = merge(nextFiber.state, state);\n\t\t    //   }\n\t\t    //   return;\n\t\t    // }\n\t\t    if (globalLoop$3.current)\n\t\t        return;\n\t\t    globalLoop$3.current = true;\n\t\t    scheduleUpdate(renderDispatch);\n\t\t};\n\t\t// TODO: error flow\n\t\t// currently only work render flow\n\t\t// commit flow not work as expected\n\t\tvar triggerError = function (renderDispatch, fiber, error, cb) {\n\t\t    var _a;\n\t\t    var renderScheduler = currentScheduler$b.current;\n\t\t    var errorBoundariesFiber = renderDispatch.resolveErrorBoundaries(fiber);\n\t\t    if (errorBoundariesFiber) {\n\t\t        defaultDeleteChildEffect(renderDispatch, fiber);\n\t\t        var typedComponent = errorBoundariesFiber.elementType;\n\t\t        var typedInstance_1 = errorBoundariesFiber.instance;\n\t\t        var payloadState = (_a = typedComponent.getDerivedStateFromError) === null || _a === void 0 ? void 0 : _a.call(typedComponent, error);\n\t\t        if (!errorBoundariesFiber.memoizedState) {\n\t\t            errorBoundariesFiber.memoizedState = Object.assign({}, errorBoundariesFiber.pendingState);\n\t\t        }\n\t\t        if (renderDispatch.runtimeFiber.nextWorkingFiber) {\n\t\t            var updateQueue = {\n\t\t                type: UpdateQueueType.component,\n\t\t                trigger: typedInstance_1,\n\t\t                payLoad: payloadState,\n\t\t                isSync: true,\n\t\t                isForce: true,\n\t\t                isRetrigger: true,\n\t\t                isImmediate: true,\n\t\t                callback: function finishTriggerErrorOnFiber() {\n\t\t                    var _a;\n\t\t                    (_a = typedInstance_1.componentDidCatch) === null || _a === void 0 ? void 0 : _a.call(typedInstance_1, error, { componentStack: renderScheduler.getFiberTree(fiber) });\n\t\t                    renderDispatch.runtimeFiber.errorCatchFiber = errorBoundariesFiber;\n\t\t                    cb === null || cb === void 0 ? void 0 : cb();\n\t\t                    currentError.current = null;\n\t\t                },\n\t\t            };\n\t\t            errorBoundariesFiber.state = merge(errorBoundariesFiber.state, STATE_TYPE.__create__);\n\t\t            errorBoundariesFiber.state = merge(errorBoundariesFiber.state, STATE_TYPE.__triggerSyncForce__);\n\t\t            processState(renderDispatch, updateQueue);\n\t\t            syncFiberStateToComponent(renderDispatch, errorBoundariesFiber);\n\t\t        }\n\t\t        else {\n\t\t            var updateQueue = {\n\t\t                type: UpdateQueueType.component,\n\t\t                trigger: typedInstance_1,\n\t\t                payLoad: payloadState,\n\t\t                isSync: true,\n\t\t                isForce: true,\n\t\t                isRetrigger: false,\n\t\t                isImmediate: false,\n\t\t                callback: function finishTriggerErrorOnFiber() {\n\t\t                    var _a;\n\t\t                    (_a = typedInstance_1.componentDidCatch) === null || _a === void 0 ? void 0 : _a.call(typedInstance_1, error, { componentStack: renderScheduler.getFiberTree(fiber) });\n\t\t                    renderDispatch.runtimeFiber.errorCatchFiber = errorBoundariesFiber;\n\t\t                    cb === null || cb === void 0 ? void 0 : cb();\n\t\t                    currentError.current = null;\n\t\t                },\n\t\t            };\n\t\t            processState(renderDispatch, updateQueue);\n\t\t        }\n\t\t    }\n\t\t    else {\n\t\t        if (renderDispatch.isAppCrashed)\n\t\t            return;\n\t\t        renderDispatch.pendingUpdateFiberArray.clear();\n\t\t        renderDispatch.resetUpdateFlowRuntimeFiber();\n\t\t        renderDispatch.isAppCrashed = true;\n\t\t        globalLoop$3.current = false;\n\t\t        {\n\t\t            console.error(\"[@my-react/react] a uncaught exception have been throw\", error);\n\t\t            throw error;\n\t\t        }\n\t\t    }\n\t\t};\n\n\t\tvar globalLoop$2 = react.__my_react_internal__.globalLoop, currentScheduler$a = react.__my_react_internal__.currentScheduler;\n\t\tvar scheduleUpdateFromRoot = function (renderDispatch) {\n\t\t    flushEffectCallback();\n\t\t    var allLive = renderDispatch.pendingUpdateFiberArray.getAll().filter(function (f) { return exclude(f.state, STATE_TYPE.__unmount__); });\n\t\t    renderDispatch.pendingUpdateFiberArray.clear();\n\t\t    if (allLive.length) {\n\t\t        renderDispatch.runtimeFiber.scheduledFiber = renderDispatch.rootFiber;\n\t\t        renderDispatch.runtimeFiber.nextWorkingFiber = renderDispatch.rootFiber;\n\t\t        allLive.forEach(function (fiber) { return applyTriggerFiberCb(renderDispatch, fiber); });\n\t\t        if (!renderDispatch.enableConcurrentMode || allLive.some(function (f) { return include(f.state, STATE_TYPE.__triggerSync__ | STATE_TYPE.__triggerSyncForce__); })) {\n\t\t            updateSyncFromRoot(renderDispatch);\n\t\t        }\n\t\t        else {\n\t\t            renderDispatch.resetYield();\n\t\t            updateConcurrentFromRoot(renderDispatch);\n\t\t        }\n\t\t    }\n\t\t    else {\n\t\t        scheduleNext(renderDispatch);\n\t\t    }\n\t\t};\n\t\tvar scheduleOther = function (renderDispatch) {\n\t\t    var _a;\n\t\t    var renderScheduler = currentScheduler$a.current;\n\t\t    if (!renderScheduler.dispatchSet || ((_a = renderScheduler.dispatchSet) === null || _a === void 0 ? void 0 : _a.length) === 1)\n\t\t        return;\n\t\t    var allDispatch = renderScheduler.dispatchSet;\n\t\t    var hasPending = allDispatch\n\t\t        .getAll()\n\t\t        .find(function (d) { return d !== renderDispatch && d.isAppMounted && d.enableUpdate && !d.isAppCrashed && !d.isAppUnmounted && d.pendingUpdateFiberArray.length; });\n\t\t    if (hasPending) {\n\t\t        scheduleUpdate(hasPending);\n\t\t    }\n\t\t    else {\n\t\t        globalLoop$2.current = false;\n\t\t    }\n\t\t};\n\t\tvar scheduleNext = function (renderDispatch) {\n\t\t    var _a;\n\t\t    if (!renderDispatch.isAppUnmounted && !renderDispatch.isAppCrashed && renderDispatch.enableUpdate && renderDispatch.pendingUpdateFiberArray.length) {\n\t\t        scheduleUpdate(renderDispatch);\n\t\t        return;\n\t\t    }\n\t\t    var renderScheduler = currentScheduler$a.current;\n\t\t    if (!renderScheduler.dispatchSet || ((_a = renderScheduler.dispatchSet) === null || _a === void 0 ? void 0 : _a.length) === 1)\n\t\t        return;\n\t\t    var allDispatch = renderScheduler.dispatchSet;\n\t\t    var hasPending = allDispatch\n\t\t        .getAll()\n\t\t        .find(function (d) { return d !== renderDispatch && d.isAppMounted && d.enableUpdate && !d.isAppCrashed && !d.isAppUnmounted && d.pendingUpdateFiberArray.length; });\n\t\t    if (hasPending) {\n\t\t        scheduleUpdate(hasPending);\n\t\t    }\n\t\t    else {\n\t\t        globalLoop$2.current = false;\n\t\t    }\n\t\t};\n\t\tvar scheduleUpdate = function (renderDispatch) {\n\t\t    react.__my_react_internal__.recentlyCreatedOwnerStacks.current = 0;\n\t\t    if (renderDispatch.isAppUnmounted) {\n\t\t        scheduleOther(renderDispatch);\n\t\t        return;\n\t\t    }\n\t\t    scheduleUpdateFromRoot(renderDispatch);\n\t\t};\n\n\t\tvar globalLoop$1 = react.__my_react_internal__.globalLoop, currentScheduler$9 = react.__my_react_internal__.currentScheduler;\n\t\treact.__my_react_shared__.enableScopeTreeLog;\n\t\tfunction finishUpdateSyncFromRoot(renderDispatch) {\n\t\t    var commitList = renderDispatch.pendingCommitFiberList;\n\t\t    var changedList = renderDispatch.pendingChangedFiberList;\n\t\t    renderDispatch.resetUpdateFlowRuntimeFiber();\n\t\t    renderDispatch.pendingCommitFiberList = null;\n\t\t    renderDispatch.pendingChangedFiberList = null;\n\t\t    (commitList === null || commitList === void 0 ? void 0 : commitList.length) && renderDispatch.reconcileUpdate(commitList, true);\n\t\t    (changedList === null || changedList === void 0 ? void 0 : changedList.length) &&\n\t\t        safeCall(function safeCallFiberHasChangeListener() {\n\t\t            renderDispatch.callOnFiberChange(changedList);\n\t\t        });\n\t\t}\n\t\tvar updateSyncFromRoot = function (renderDispatch) {\n\t\t    globalLoop$1.current = true;\n\t\t    var renderScheduler = currentScheduler$9.current;\n\t\t    updateLoopSyncFromRoot(renderDispatch);\n\t\t    processAsyncLoadListOnUpdate(renderDispatch);\n\t\t    finishUpdateSyncFromRoot(renderDispatch);\n\t\t    renderScheduler.microTask(function callScheduleNext() {\n\t\t        globalLoop$1.current = false;\n\t\t        scheduleNext(renderDispatch);\n\t\t    });\n\t\t};\n\t\tfunction finishUpdateConcurrentFromRoot(renderDispatch) {\n\t\t    var commitList = renderDispatch.pendingCommitFiberList;\n\t\t    var changedList = renderDispatch.pendingChangedFiberList;\n\t\t    renderDispatch.resetUpdateFlowRuntimeFiber();\n\t\t    renderDispatch.pendingCommitFiberList = null;\n\t\t    renderDispatch.pendingChangedFiberList = null;\n\t\t    (commitList === null || commitList === void 0 ? void 0 : commitList.length) && renderDispatch.reconcileUpdate(commitList);\n\t\t    (changedList === null || changedList === void 0 ? void 0 : changedList.length) &&\n\t\t        safeCall(function safeCallFiberHasChangeListener() {\n\t\t            renderDispatch.callOnFiberChange(changedList);\n\t\t        });\n\t\t}\n\t\tfunction checkNextFiberIsSync(renderDispatch) {\n\t\t    return include(renderDispatch.runtimeFiber.nextWorkingFiber.state, STATE_TYPE.__triggerSync__ | STATE_TYPE.__triggerSyncForce__);\n\t\t    // include(renderDispatch.runtimeFiber.nextWorkingFiber.state, STATE_TYPE.__retrigger__)\n\t\t}\n\t\tfunction updateConcurrentNextFrame(renderDispatch) {\n\t\t    var renderScheduler = currentScheduler$9.current;\n\t\t    var hasSync = updateLoopConcurrentFromRoot(renderDispatch);\n\t\t    if (renderDispatch.runtimeFiber.nextWorkingFiber) {\n\t\t        if (hasSync || checkNextFiberIsSync(renderDispatch)) {\n\t\t            updateSyncFromRoot(renderDispatch);\n\t\t        }\n\t\t        else {\n\t\t            renderScheduler.yieldTask(function resumeUpdateConcurrentFromRoot() {\n\t\t                if (hasSync || checkNextFiberIsSync(renderDispatch)) {\n\t\t                    updateSyncFromRoot(renderDispatch);\n\t\t                }\n\t\t                else {\n\t\t                    updateConcurrentNextFrame(renderDispatch);\n\t\t                }\n\t\t            });\n\t\t        }\n\t\t    }\n\t\t    else {\n\t\t        processAsyncLoadListOnUpdate(renderDispatch);\n\t\t        finishUpdateConcurrentFromRoot(renderDispatch);\n\t\t        renderScheduler.microTask(function callScheduleNext() {\n\t\t            globalLoop$1.current = false;\n\t\t            scheduleNext(renderDispatch);\n\t\t        });\n\t\t    }\n\t\t}\n\t\tvar updateConcurrentFromRoot = function (renderDispatch) {\n\t\t    globalLoop$1.current = true;\n\t\t    var renderScheduler = currentScheduler$9.current;\n\t\t    var hasSync = updateLoopConcurrentFromRoot(renderDispatch);\n\t\t    if (renderDispatch.runtimeFiber.nextWorkingFiber) {\n\t\t        if (hasSync || checkNextFiberIsSync(renderDispatch)) {\n\t\t            updateSyncFromRoot(renderDispatch);\n\t\t        }\n\t\t        else {\n\t\t            renderScheduler.yieldTask(function resumeUpdateConcurrentFromRoot() {\n\t\t                if (hasSync || checkNextFiberIsSync(renderDispatch)) {\n\t\t                    updateSyncFromRoot(renderDispatch);\n\t\t                }\n\t\t                else {\n\t\t                    updateConcurrentNextFrame(renderDispatch);\n\t\t                }\n\t\t            });\n\t\t        }\n\t\t    }\n\t\t    else {\n\t\t        processAsyncLoadListOnUpdate(renderDispatch);\n\t\t        finishUpdateConcurrentFromRoot(renderDispatch);\n\t\t        renderScheduler.microTask(function callScheduleNext() {\n\t\t            globalLoop$1.current = false;\n\t\t            scheduleNext(renderDispatch);\n\t\t        });\n\t\t    }\n\t\t};\n\n\t\tvar MyReactInternalInstance$4 = react.__my_react_internal__.MyReactInternalInstance, currentScheduler$8 = react.__my_react_internal__.currentScheduler;\n\t\tvar enableSyncFlush = react.__my_react_shared__.enableSyncFlush;\n\t\tvar defaultPayLoad = function (a) { return a; };\n\t\tvar MyReactHookNode = /** @class */ (function (_super) {\n\t\t    __extends(MyReactHookNode, _super);\n\t\t    function MyReactHookNode(type, value, reducer, deps) {\n\t\t        var _this = _super.call(this) || this;\n\t\t        _this.hasEffect = false;\n\t\t        _this.type = type;\n\t\t        _this.deps = deps;\n\t\t        _this.value = value;\n\t\t        _this.reducer = reducer;\n\t\t        return _this;\n\t\t    }\n\t\t    Object.defineProperty(MyReactHookNode.prototype, \"isMyReactHook\", {\n\t\t        get: function () {\n\t\t            return true;\n\t\t        },\n\t\t        enumerable: false,\n\t\t        configurable: true\n\t\t    });\n\t\t    MyReactHookNode.prototype._update = function (params) {\n\t\t        if (params === void 0) { params = {}; }\n\t\t        var updater = __assign({ type: UpdateQueueType.hook, trigger: this, payLoad: defaultPayLoad, isSync: false, isForce: false }, params);\n\t\t        var renderScheduler = currentScheduler$8.current;\n\t\t        renderScheduler === null || renderScheduler === void 0 ? void 0 : renderScheduler.dispatchState(updater);\n\t\t    };\n\t\t    return MyReactHookNode;\n\t\t}(MyReactInternalInstance$4));\n\t\tvar initHookInstance = function (hookNode) {\n\t\t    var field = getInstanceFieldByInstance(hookNode);\n\t\t    if (!field)\n\t\t        throw new Error(\"[@my-react/react] hook instance not found, look like a bug for @my-react\");\n\t\t    var typedField = field;\n\t\t    typedField.dispatch = function dispatchAction(action) {\n\t\t        hookNode._update({ payLoad: action, isForce: false, isSync: enableSyncFlush.current });\n\t\t    };\n\t\t};\n\n\t\tvar currentComponentFiber$3 = react.__my_react_internal__.currentComponentFiber;\n\t\tvar MyReactSignal = /** @class */ (function () {\n\t\t    function MyReactSignal(_rawValue, _renderDispatch) {\n\t\t        var _this = this;\n\t\t        this._renderDispatch = _renderDispatch;\n\t\t        this._depsSet = new Set();\n\t\t        this.getValue = function () {\n\t\t            if (currentComponentFiber$3.current) {\n\t\t                _this._depsSet.add(currentComponentFiber$3.current);\n\t\t            }\n\t\t            return _this._value;\n\t\t        };\n\t\t        this.setValue = function (newValue) {\n\t\t            if (!Object.is(_this._value, newValue)) {\n\t\t                var allDeps = new Set(_this._depsSet);\n\t\t                _this._depsSet.clear();\n\t\t                _this._value = newValue;\n\t\t                allDeps.forEach(function (f) { return exclude(f.state, STATE_TYPE.__unmount__) && (f.state = STATE_TYPE.__triggerConcurrent__); });\n\t\t                triggerUpdateOnFiber(_this._renderDispatch.rootFiber, STATE_TYPE.__triggerConcurrent__);\n\t\t            }\n\t\t        };\n\t\t        this._value = _rawValue;\n\t\t    }\n\t\t    return MyReactSignal;\n\t\t}());\n\n\t\tvar enableDebugLog$1 = react.__my_react_shared__.enableDebugLog; react.__my_react_shared__.enableDebugFiled;\n\t\tvar currentHookTreeNode$2 = react.__my_react_internal__.currentHookTreeNode, currentHookNodeIndex$2 = react.__my_react_internal__.currentHookNodeIndex;\n\t\tvar defaultReducer = function (state, action) {\n\t\t    return typeof action === \"function\" ? action(state) : action;\n\t\t};\n\t\tvar defaultOptimisticReducer = function (state) { return state; };\n\t\tvar createHookNode = function (renderDispatch, _a, fiber) {\n\t\t    var _b, _c;\n\t\t    var type = _a.type, value = _a.value, reducer = _a.reducer, deps = _a.deps;\n\t\t    var currentHook = (_b = currentHookTreeNode$2.current) === null || _b === void 0 ? void 0 : _b.value;\n\t\t    var currentHookIndex = currentHookNodeIndex$2.current;\n\t\t    var currentIsReCreate = include(fiber.state, STATE_TYPE.__recreate__);\n\t\t    if (currentHook) {\n\t\t        if (currentIsReCreate) {\n\t\t            if (currentHookIndex === 0) {\n\t\t                defaultDeleteChildEffect(renderDispatch, fiber);\n\t\t                defaultDeleteCurrentEffect(renderDispatch, fiber);\n\t\t                fiber.hookList.clear();\n\t\t            }\n\t\t        }\n\t\t        else {\n\t\t            throw new Error(\"[@my-react/react] should not have a hookList for current node, this is a bug for @my-react\");\n\t\t        }\n\t\t    }\n\t\t    var hookNode = new MyReactHookNode(type, value, reducer || defaultReducer, deps);\n\t\t    initInstance(hookNode);\n\t\t    initHookInstance(hookNode);\n\t\t    setOwnerForInstance(hookNode, fiber);\n\t\t    fiber.hookList.push(hookNode);\n\t\t    if (hookNode.type === HOOK_TYPE.useMemo || hookNode.type === HOOK_TYPE.useState || hookNode.type === HOOK_TYPE.useReducer) {\n\t\t        hookNode.result = hookNode.value.call(null);\n\t\t        // hack code\n\t\t        var a = function () {\n\t\t        };\n\t\t        a.bind(null, fiber);\n\t\t    }\n\t\t    if (hookNode.type === HOOK_TYPE.useEffect ||\n\t\t        hookNode.type === HOOK_TYPE.useLayoutEffect ||\n\t\t        hookNode.type === HOOK_TYPE.useInsertionEffect ||\n\t\t        hookNode.type === HOOK_TYPE.useImperativeHandle) {\n\t\t        hookNode.result = hookNode.value;\n\t\t        hookNode.hasEffect = true;\n\t\t    }\n\t\t    if (hookNode.type === HOOK_TYPE.useRef ||\n\t\t        hookNode.type === HOOK_TYPE.useCallback ||\n\t\t        hookNode.type === HOOK_TYPE.useDeferredValue ||\n\t\t        hookNode.type === HOOK_TYPE.useEffectEvent) {\n\t\t        hookNode.result = hookNode.value;\n\t\t    }\n\t\t    // cache ref state from recreate\n\t\t    if (hookNode.type === HOOK_TYPE.useRef && currentHook && currentHook.type === HOOK_TYPE.useRef) {\n\t\t        hookNode.result = currentHook.result;\n\t\t    }\n\t\t    if (hookNode.type === HOOK_TYPE.useId) {\n\t\t        hookNode.result = \"\\u00AB-\".concat(currentHookIndex, \"-\").concat(renderDispatch.uniqueIdCount++, \"-\\u00BB\");\n\t\t        hookNode.cancel = function () { return renderDispatch.uniqueIdCount--; };\n\t\t    }\n\t\t    if (hookNode.type === HOOK_TYPE.useDebugValue) {\n\t\t        hookNode.result = hookNode.value;\n\t\t        if (enableDebugLog$1.current) {\n\t\t            console.warn.apply(console, __spreadArray([\"[debug]\"], hookNode.value, false));\n\t\t        }\n\t\t    }\n\t\t    if (hookNode.type === HOOK_TYPE.useContext) {\n\t\t        var providerFiber = renderDispatch.resolveContextFiber(fiber, hookNode.value);\n\t\t        var context = renderDispatch.resolveContextValue(providerFiber, hookNode.value);\n\t\t        setContextForInstance(hookNode, providerFiber);\n\t\t        hookNode.result = context;\n\t\t    }\n\t\t    if (hookNode.type === HOOK_TYPE.useSyncExternalStore) {\n\t\t        var storeApi_1 = hookNode.value;\n\t\t        var getNextResult = function () {\n\t\t            return safeCallWithCurrentFiber({\n\t\t                fiber: fiber,\n\t\t                action: function safeCallGetSnapshot() {\n\t\t                    return renderDispatch.isAppMounted\n\t\t                        ? storeApi_1.getSnapshot.call(null)\n\t\t                        : // SEE https://github.com/facebook/react/blob/main/packages/use-sync-external-store/src/useSyncExternalStoreShimClient.js#L33\n\t\t                            // : storeApi.getServerSnapshot\n\t\t                            // ? storeApi.getServerSnapshot?.call(null)\n\t\t                            // : storeApi.getSnapshot.call(null);\n\t\t                            storeApi_1.getSnapshot.call(null);\n\t\t                },\n\t\t            });\n\t\t        };\n\t\t        var nextResult = getNextResult();\n\t\t        if (!Object.is(nextResult, getNextResult())) {\n\t\t            throw new Error(\"[@my-react/react] syncExternalStore getSnapshot not stable!\");\n\t\t        }\n\t\t        storeApi_1.result = nextResult;\n\t\t        hookNode.result = nextResult;\n\t\t        var checkResultUpdate_1 = function checkResultUpdate() {\n\t\t            var prevResult = storeApi_1.result;\n\t\t            var nextResult = null;\n\t\t            var hasChange = true;\n\t\t            try {\n\t\t                nextResult = storeApi_1.getSnapshot.call(null);\n\t\t                hasChange = !Object.is(prevResult, nextResult);\n\t\t            }\n\t\t            catch (_a) {\n\t\t                hasChange = true;\n\t\t            }\n\t\t            if (hasChange) {\n\t\t                hookNode._update({ isForce: true, isSync: true, payLoad: function () { return nextResult; } });\n\t\t            }\n\t\t        };\n\t\t        renderDispatch.pendingLayoutEffect(fiber, function invokeLayoutEffectOnHook() {\n\t\t            checkResultUpdate_1();\n\t\t        });\n\t\t        renderDispatch.pendingEffect(fiber, function invokeEffectOnHook() {\n\t\t            hookNode.cancel && hookNode.cancel();\n\t\t            checkResultUpdate_1();\n\t\t            hookNode.cancel = storeApi_1.subscribe(checkResultUpdate_1);\n\t\t        });\n\t\t    }\n\t\t    // if (hookNode.type === HOOK_TYPE.useSyncExternalStore) {\n\t\t    //   const storeApi = hookNode.value;\n\t\t    //   const getNextResult = () =>\n\t\t    //     safeCallWithCurrentFiber({\n\t\t    //       fiber,\n\t\t    //       action: function safeCallGetSnapshot() {\n\t\t    //         return renderDispatch.isAppMounted\n\t\t    //           ? storeApi.getSnapshot.call(null)\n\t\t    //           : storeApi.getServerSnapshot\n\t\t    //             ? storeApi.getServerSnapshot?.call(null)\n\t\t    //             : storeApi.getSnapshot.call(null);\n\t\t    //       },\n\t\t    //     });\n\t\t    //   const nextResult = getNextResult();\n\t\t    //   if (!Object.is(nextResult, getNextResult())) {\n\t\t    //     throw new Error(`[@my-react/react] syncExternalStore getSnapshot not stable!`);\n\t\t    //   }\n\t\t    //   storeApi.result = nextResult;\n\t\t    //   hookNode.result = nextResult;\n\t\t    //   hookNode.hasEffect = true;\n\t\t    // }\n\t\t    if (hookNode.type === HOOK_TYPE.useSignal) {\n\t\t        hookNode.result = new MyReactSignal(hookNode.value.call(null), renderDispatch);\n\t\t    }\n\t\t    if (hookNode.type === HOOK_TYPE.useTransition) {\n\t\t        hookNode.result = {\n\t\t            value: false,\n\t\t            start: function startTransitionByHook(cb) {\n\t\t                var loadingCallback = function (cb) {\n\t\t                    react.startTransition(function () {\n\t\t                        hookNode._update({ isForce: true, isSync: true, callback: cb, payLoad: function (last) { return ({ value: true, start: last.start }); } });\n\t\t                    });\n\t\t                };\n\t\t                var loadedCallback = function () {\n\t\t                    react.startTransition(function () {\n\t\t                        hookNode._update({ isForce: true, isSync: true, payLoad: function (last) { return ({ value: false, start: last.start }); } });\n\t\t                    });\n\t\t                };\n\t\t                var taskCallback = function () {\n\t\t                    react.startTransition(function () {\n\t\t                        safeCallWithCurrentFiber({ fiber: fiber, action: cb });\n\t\t                        loadedCallback();\n\t\t                    });\n\t\t                };\n\t\t                loadingCallback(taskCallback);\n\t\t            },\n\t\t        };\n\t\t    }\n\t\t    if (hookNode.type === HOOK_TYPE.useOptimistic) {\n\t\t        hookNode.result = {\n\t\t            value: value.value,\n\t\t            start: function startOptimisticByHook(newValue) {\n\t\t                var mergeFunc = hookNode.value.reducer || defaultOptimisticReducer;\n\t\t                var nextValue = mergeFunc(newValue, hookNode.result.value.value);\n\t\t                var payloadRef = { current: function (last) { return ({ value: nextValue, start: last.start }); } };\n\t\t                hookNode._update({ isForce: true, isSync: true, payLoad: function (last) { return payloadRef.current(last); } });\n\t\t                hookNode.cancel = function () { return (payloadRef.current = function (last) { return last; }); };\n\t\t            },\n\t\t        };\n\t\t    }\n\t\t    currentHookTreeNode$2.current = (_c = currentHookTreeNode$2.current) === null || _c === void 0 ? void 0 : _c.next;\n\t\t    return hookNode;\n\t\t};\n\n\t\tvar effectHookNode = function (renderDispatch, fiber, hookNode, field) {\n\t\t    var effect = field.effect;\n\t\t    if (hookNode.hasEffect && effect === Effect_TYPE.__initial__) {\n\t\t        setEffectForInstance(hookNode, Effect_TYPE.__effect__);\n\t\t        if (hookNode.type === HOOK_TYPE.useEffect) {\n\t\t            renderDispatch.pendingEffect(fiber, function invokeEffectOnHook() {\n\t\t                hookNode.cancel && hookNode.cancel();\n\t\t                var ownerFiber = getInstanceOwnerFiber(hookNode);\n\t\t                if (ownerFiber && exclude(ownerFiber.state, STATE_TYPE.__unmount__))\n\t\t                    hookNode.cancel = hookNode.value();\n\t\t                hookNode.hasEffect = false;\n\t\t                setEffectForInstance(hookNode, Effect_TYPE.__initial__);\n\t\t            });\n\t\t        }\n\t\t        if (hookNode.type === HOOK_TYPE.useLayoutEffect) {\n\t\t            renderDispatch.pendingLayoutEffect(fiber, function invokeLayoutEffectOnHook() {\n\t\t                hookNode.cancel && hookNode.cancel();\n\t\t                hookNode.cancel = hookNode.value();\n\t\t                hookNode.hasEffect = false;\n\t\t                setEffectForInstance(hookNode, Effect_TYPE.__initial__);\n\t\t            });\n\t\t        }\n\t\t        if (hookNode.type === HOOK_TYPE.useInsertionEffect) {\n\t\t            renderDispatch.pendingInsertionEffect(fiber, function invokeInsertionEffectOnHook() {\n\t\t                hookNode.cancel && hookNode.cancel();\n\t\t                hookNode.cancel = hookNode.value();\n\t\t                hookNode.hasEffect = false;\n\t\t                setEffectForInstance(hookNode, Effect_TYPE.__initial__);\n\t\t            });\n\t\t        }\n\t\t        if (hookNode.type === HOOK_TYPE.useImperativeHandle) {\n\t\t            renderDispatch.pendingLayoutEffect(fiber, function invokeLayoutEffectOnHook() {\n\t\t                hookNode.cancel && hookNode.cancel();\n\t\t                // ref obj\n\t\t                if (hookNode.value && typeof hookNode.value === \"object\")\n\t\t                    hookNode.value.current = hookNode.reducer.call(null);\n\t\t                // ref function\n\t\t                if (hookNode.value && typeof hookNode.value === \"function\")\n\t\t                    hookNode.value(hookNode.reducer.call(null));\n\t\t                // TODO\n\t\t                // hookNode.cancel =\n\t\t                hookNode.hasEffect = false;\n\t\t                setEffectForInstance(hookNode, Effect_TYPE.__initial__);\n\t\t            });\n\t\t        }\n\t\t        if (hookNode.type === HOOK_TYPE.useSyncExternalStore) {\n\t\t            renderDispatch.pendingEffect(fiber, function invokeEffectOnHook() {\n\t\t                hookNode.cancel && hookNode.cancel();\n\t\t                var storeApi = hookNode.value;\n\t\t                hookNode.cancel = storeApi.subscribe(function triggerHookUpdate() {\n\t\t                    hookNode._update({ payLoad: function () { return storeApi.getSnapshot.call(null); } });\n\t\t                });\n\t\t                hookNode.hasEffect = false;\n\t\t                setEffectForInstance(hookNode, Effect_TYPE.__initial__);\n\t\t            });\n\t\t        }\n\t\t    }\n\t\t};\n\n\t\tvar enableDebugLog = react.__my_react_shared__.enableDebugLog;\n\t\tvar currentHookTreeNode$1 = react.__my_react_internal__.currentHookTreeNode, currentScheduler$7 = react.__my_react_internal__.currentScheduler;\n\t\tvar updateHookNode = function (renderDispatch, _a, fiber, isHMR) {\n\t\t    var _b, _c, _d;\n\t\t    var type = _a.type, value = _a.value, reducer = _a.reducer, deps = _a.deps;\n\t\t    var renderScheduler = currentScheduler$7.current;\n\t\t    var currentHook = (_b = currentHookTreeNode$1.current) === null || _b === void 0 ? void 0 : _b.value;\n\t\t    if (!currentHook) {\n\t\t        throw new Error(\"[@my-react/react] should have a hookList for current node, this is a bug for @my-react\");\n\t\t    }\n\t\t    if (type !== (currentHook === null || currentHook === void 0 ? void 0 : currentHook.type)) {\n\t\t        throw new Error(getHookTree(currentHookTreeNode$1.current.prev, {\n\t\t            lastRender: currentHook === null || currentHook === void 0 ? void 0 : currentHook.type,\n\t\t            nextRender: type,\n\t\t        }));\n\t\t    }\n\t\t    setOwnerForInstance(currentHook, fiber);\n\t\t    currentHookTreeNode$1.current = currentHookTreeNode$1.current.next;\n\t\t    if (currentHook.type === HOOK_TYPE.useMemo ||\n\t\t        currentHook.type === HOOK_TYPE.useEffect ||\n\t\t        currentHook.type === HOOK_TYPE.useCallback ||\n\t\t        currentHook.type === HOOK_TYPE.useLayoutEffect ||\n\t\t        currentHook.type === HOOK_TYPE.useInsertionEffect ||\n\t\t        currentHook.type === HOOK_TYPE.useImperativeHandle) {\n\t\t        if (deps && !currentHook.deps) {\n\t\t            throw new Error(\"[@my-react/react] deps state change\");\n\t\t        }\n\t\t        if (!deps && currentHook.deps) {\n\t\t            throw new Error(\"[@my-react/react] deps state change\");\n\t\t        }\n\t\t    }\n\t\t    if (currentHook.type === HOOK_TYPE.useEffect || currentHook.type === HOOK_TYPE.useLayoutEffect || currentHook.type === HOOK_TYPE.useInsertionEffect) {\n\t\t        if (isHMR || !deps || !isArrayEquals(currentHook.deps, deps)) {\n\t\t            currentHook.value = value;\n\t\t            currentHook.result = value;\n\t\t            currentHook.reducer = reducer || currentHook.reducer;\n\t\t            currentHook.deps = deps;\n\t\t            currentHook.hasEffect = true;\n\t\t        }\n\t\t        return currentHook;\n\t\t    }\n\t\t    if (currentHook.type === HOOK_TYPE.useImperativeHandle) {\n\t\t        var depsChanged = false;\n\t\t        // ref changed also need to trigger effect\n\t\t        if (isHMR || !deps || !isNormalEquals(currentHook.value, value) || ((depsChanged = !isArrayEquals(currentHook.deps, deps)), depsChanged)) {\n\t\t            currentHook.value = value;\n\t\t            currentHook.result = value;\n\t\t            currentHook.reducer = depsChanged ? reducer || currentHook.reducer : currentHook.reducer;\n\t\t            currentHook.deps = deps;\n\t\t            currentHook.hasEffect = true;\n\t\t        }\n\t\t        return currentHook;\n\t\t    }\n\t\t    if (currentHook.type === HOOK_TYPE.useSyncExternalStore) {\n\t\t        var storeApi_1 = currentHook.value;\n\t\t        var newStoreApi_1 = value;\n\t\t        var prevResult = storeApi_1.result;\n\t\t        var nextResult_1 = safeCallWithCurrentFiber({\n\t\t            fiber: fiber,\n\t\t            action: function safeCallGetSnapshot() {\n\t\t                return newStoreApi_1.getSnapshot.call(null);\n\t\t            },\n\t\t        });\n\t\t        if (!Object.is(nextResult_1, newStoreApi_1.getSnapshot.call(null))) {\n\t\t            throw new Error(\"[@my-react/react] syncExternalStore getSnapshot not stable!\");\n\t\t        }\n\t\t        currentHook.result = nextResult_1;\n\t\t        var checkResultUpdate_1 = function checkResultUpdate() {\n\t\t            var prevResult = storeApi_1.result;\n\t\t            var nextResult = null;\n\t\t            var hasChange = true;\n\t\t            try {\n\t\t                nextResult = storeApi_1.getSnapshot.call(null);\n\t\t                hasChange = !Object.is(prevResult, nextResult);\n\t\t            }\n\t\t            catch (_a) {\n\t\t                hasChange = true;\n\t\t            }\n\t\t            if (hasChange) {\n\t\t                currentHook._update({ isForce: true, isSync: true, payLoad: function () { return nextResult; } });\n\t\t            }\n\t\t        };\n\t\t        if (!Object.is(prevResult, nextResult_1) ||\n\t\t            !Object.is(storeApi_1.getSnapshot, newStoreApi_1.getSnapshot) ||\n\t\t            !Object.is(storeApi_1.subscribe, newStoreApi_1.subscribe)) {\n\t\t            renderDispatch.pendingLayoutEffect(fiber, function invokeLayoutEffectOnHook() {\n\t\t                storeApi_1.result = nextResult_1;\n\t\t                storeApi_1.getSnapshot = newStoreApi_1.getSnapshot;\n\t\t                checkResultUpdate_1();\n\t\t            });\n\t\t        }\n\t\t        if (isHMR || !Object.is(storeApi_1.subscribe, newStoreApi_1.subscribe)) {\n\t\t            renderDispatch.pendingEffect(fiber, function invokeEffectOnHook() {\n\t\t                currentHook.cancel && currentHook.cancel();\n\t\t                checkResultUpdate_1();\n\t\t                currentHook.cancel = storeApi_1.subscribe(checkResultUpdate_1);\n\t\t            });\n\t\t        }\n\t\t        return currentHook;\n\t\t    }\n\t\t    // if (currentHook.type === HOOK_TYPE.useSyncExternalStore) {\n\t\t    //   const storeApi = currentHook.value;\n\t\t    //   const newStoreApi = value;\n\t\t    //   const nextResult = safeCallWithCurrentFiber({\n\t\t    //     fiber,\n\t\t    //     action: function safeCallGetSnapshot() {\n\t\t    //       return newStoreApi.getSnapshot.call(null);\n\t\t    //     },\n\t\t    //   });\n\t\t    //   if (!Object.is(nextResult, newStoreApi.getSnapshot.call(null))) {\n\t\t    //     throw new Error(`[@my-react/react] syncExternalStore getSnapshot not stable!`);\n\t\t    //   }\n\t\t    //   currentHook.result = nextResult;\n\t\t    //   if (isHMR || !Object.is(storeApi.subscribe, newStoreApi.subscribe)) {\n\t\t    //     storeApi.subscribe = newStoreApi.subscribe;\n\t\t    //     currentHook.hasEffect = true;\n\t\t    //   }\n\t\t    //   storeApi.getSnapshot = newStoreApi.getSnapshot;\n\t\t    //   return currentHook;\n\t\t    // }\n\t\t    if (currentHook.type === HOOK_TYPE.useCallback) {\n\t\t        if (isHMR || !deps || !isArrayEquals(currentHook.deps, deps)) {\n\t\t            currentHook.value = value;\n\t\t            currentHook.result = value;\n\t\t            currentHook.deps = deps;\n\t\t        }\n\t\t        return currentHook;\n\t\t    }\n\t\t    if (currentHook.type === HOOK_TYPE.useMemo) {\n\t\t        if (isHMR || !deps || !isArrayEquals(currentHook.deps, deps)) {\n\t\t            currentHook.value = value;\n\t\t            currentHook.result = safeCallWithCurrentFiber({\n\t\t                fiber: fiber,\n\t\t                action: function safeCallMemoOnHook() {\n\t\t                    return value.call(null);\n\t\t                },\n\t\t            });\n\t\t            currentHook.deps = deps;\n\t\t        }\n\t\t        return currentHook;\n\t\t    }\n\t\t    if (currentHook.type === HOOK_TYPE.useContext) {\n\t\t        var contextFiber = getInstanceContextFiber(currentHook);\n\t\t        if (!contextFiber || include(contextFiber.state, STATE_TYPE.__unmount__) || !Object.is(currentHook.value, value)) {\n\t\t            currentHook.value = value;\n\t\t            var providerFiber = renderDispatch.resolveContextFiber(fiber, currentHook.value);\n\t\t            var context = renderDispatch.resolveContextValue(providerFiber, currentHook.value);\n\t\t            setContextForInstance(currentHook, providerFiber);\n\t\t            currentHook.result = context;\n\t\t        }\n\t\t        else {\n\t\t            var context = renderDispatch.resolveContextValue(contextFiber, currentHook.value);\n\t\t            currentHook.result = context;\n\t\t        }\n\t\t        return currentHook;\n\t\t    }\n\t\t    if (currentHook.type === HOOK_TYPE.useReducer) {\n\t\t        currentHook.value = value;\n\t\t        currentHook.reducer = reducer;\n\t\t        return currentHook;\n\t\t    }\n\t\t    if (currentHook.type === HOOK_TYPE.useDeferredValue) {\n\t\t        (_c = currentHook.cancel) === null || _c === void 0 ? void 0 : _c.call(currentHook);\n\t\t        currentHook.value = value;\n\t\t        if (!Object.is(currentHook.value, currentHook.result)) {\n\t\t            currentHook.cancel = renderScheduler.yieldTask(function triggerHookUpdate() {\n\t\t                currentHook._update({ isForce: true, payLoad: function () { return currentHook.value; } });\n\t\t                currentHook.cancel = null;\n\t\t            });\n\t\t        }\n\t\t    }\n\t\t    if (currentHook.type === HOOK_TYPE.useOptimistic) {\n\t\t        (_d = currentHook.cancel) === null || _d === void 0 ? void 0 : _d.call(currentHook);\n\t\t        currentHook.value = value;\n\t\t        if (!Object.is(currentHook.result.value, value.value)) {\n\t\t            currentHook.result.value = value.value;\n\t\t            // currentHook._update({ isForce: true, payLoad: (last) => ({ value: value.value, start: last.start }) });\n\t\t        }\n\t\t    }\n\t\t    if (currentHook.type === HOOK_TYPE.useEffectEvent) {\n\t\t        if (typeof value !== \"function\") {\n\t\t            throw new Error(\"[@my-react/react] useEffectEvent should be a function\");\n\t\t        }\n\t\t        currentHook.value = value;\n\t\t        currentHook.result = value;\n\t\t    }\n\t\t    if (currentHook.type === HOOK_TYPE.useDebugValue) {\n\t\t        if (!isArrayEquals(currentHook.value, value)) {\n\t\t            currentHook.value = value;\n\t\t            currentHook.result = value;\n\t\t            if (enableDebugLog.current) {\n\t\t                console.warn.apply(console, __spreadArray([\"[debug]\"], currentHook.value, false));\n\t\t            }\n\t\t        }\n\t\t    }\n\t\t    return currentHook;\n\t\t};\n\n\t\tvar hookListUnmount = function (renderDispatch, fiber) {\n\t\t    var _a, _b;\n\t\t    (_b = (_a = fiber.hookList) === null || _a === void 0 ? void 0 : _a.listToFoot) === null || _b === void 0 ? void 0 : _b.call(_a, function invokeHookUnmount(hookNode) {\n\t\t        safeCallWithCurrentFiber({\n\t\t            fiber: fiber,\n\t\t            action: function safeCallHookUnmountListener() {\n\t\t                renderDispatch.callOnHookUnmount(hookNode, fiber);\n\t\t            },\n\t\t        });\n\t\t        safeCallWithCurrentFiber({\n\t\t            fiber: fiber,\n\t\t            action: function safeCallHookNodeUnmount() {\n\t\t                hookNode.hasEffect = false;\n\t\t                hookNode.cancel && hookNode.cancel();\n\t\t                unmountInstance(hookNode);\n\t\t            },\n\t\t        });\n\t\t    });\n\t\t};\n\n\t\treact.__my_react_shared__.enableDebugFiled;\n\t\tvar clearFiberNode = function (renderDispatch, fiber) {\n\t\t    hookListUnmount(renderDispatch, fiber);\n\t\t    processClassComponentUnmount(renderDispatch, fiber);\n\t\t    defaultDeleteCurrentEffect(renderDispatch, fiber);\n\t\t    fiber.instance = null;\n\t\t    fiber.hookList = null;\n\t\t    fiber.updateQueue = null;\n\t\t    renderDispatch.commitUnsetRef(fiber);\n\t\t};\n\n\t\tvar currentScheduler$6 = react.__my_react_internal__.currentScheduler;\n\t\tvar hmr = function (fiber, nextType, forceRefresh) {\n\t\t    {\n\t\t        throw new Error(\"[@my-react/react] can not try to dev refresh this app in prod env!\");\n\t\t    }\n\t\t};\n\t\tfunction hmrRevert(cb) {\n\t\t    if (include(this.state, STATE_TYPE.__unmount__))\n\t\t        return;\n\t\t    getCurrentDispatchFromFiber(this);\n\t\t    triggerRevert();\n\t\t}\n\t\tfunction hmrUpdate(state, cb) {\n\t\t    if (include(this.state, STATE_TYPE.__unmount__))\n\t\t        return;\n\t\t    var renderScheduler = currentScheduler$6.current;\n\t\t    var updater = {\n\t\t        type: UpdateQueueType.hmr,\n\t\t        trigger: this,\n\t\t        isSync: true,\n\t\t        isForce: false,\n\t\t        isImmediate: true,\n\t\t        isRetrigger: false,\n\t\t        callback: cb,\n\t\t    };\n\t\t    renderScheduler.dispatchState(updater);\n\t\t}\n\n\t\tvar checkIsMyReactFiberNode = function (fiber) {\n\t\t    return (fiber &&\n\t\t        typeof fiber === \"object\" &&\n\t\t        fiber.constructor &&\n\t\t        fiber.constructor.prototype &&\n\t\t        Object.prototype.hasOwnProperty.call(fiber.constructor.prototype, \"isMyReactFiberNode\") &&\n\t\t        fiber.constructor.prototype.isMyReactFiberNode);\n\t\t};\n\n\t\tvar currentScheduler$5 = react.__my_react_internal__.currentScheduler;\n\t\tvar processUpdateOnFiber = function (renderDispatch, fiber, _isImmediate, _isRetrigger) {\n\t\t    var renderScheduler = currentScheduler$5.current;\n\t\t    var flag = renderDispatch.enableConcurrentMode;\n\t\t    var updateState = null;\n\t\t    if (include(fiber.type, exports.NODE_TYPE.__class__)) {\n\t\t        updateState = flag ? processClassComponentUpdateQueueLatest(renderDispatch, fiber, flag) : processClassComponentUpdateQueueLegacy(renderDispatch, fiber);\n\t\t    }\n\t\t    else if (include(fiber.type, exports.NODE_TYPE.__function__)) {\n\t\t        updateState = flag\n\t\t            ? processFunctionComponentUpdateQueueLatest(renderDispatch, fiber, flag)\n\t\t            : processFunctionComponentUpdateQueueLegacy(renderDispatch, fiber);\n\t\t    }\n\t\t    else {\n\t\t        updateState = flag ? processNormalComponentUpdateLatest(renderDispatch, fiber) : processNormalComponentUpdateLegacy(renderDispatch, fiber);\n\t\t    }\n\t\t    if (updateState === null || updateState === void 0 ? void 0 : updateState.needUpdate) {\n\t\t        safeCallWithCurrentFiber({\n\t\t            fiber: fiber,\n\t\t            action: function safeCallFiberTriggerListener() {\n\t\t                renderDispatch.callOnFiberTrigger(fiber, updateState);\n\t\t            },\n\t\t        });\n\t\t        // TODO get from updateState ?\n\t\t        if (updateState.isRetrigger) {\n\t\t            fiber.state = remove(fiber.state, STATE_TYPE.__stable__);\n\t\t            fiber.state = merge(fiber.state, STATE_TYPE.__retrigger__);\n\t\t            if (updateState.callback) {\n\t\t                renderDispatch.pendingLayoutEffect(fiber, updateState.callback, { stickyToFoot: true });\n\t\t            }\n\t\t            renderDispatch.runtimeFiber.retriggerFiber = fiber;\n\t\t            // render flow is done, here should trigger a new render flow\n\t\t            if (!renderDispatch.runtimeFiber.nextWorkingFiber) {\n\t\t                renderDispatch.runtimeFiber.nextWorkingFiber = fiber;\n\t\t                mountLoopAllFromScheduler(renderDispatch);\n\t\t            }\n\t\t            return;\n\t\t        }\n\t\t        if (updateState.isSync) {\n\t\t            if (updateState.isImmediate) {\n\t\t                triggerUpdate(renderDispatch, fiber, updateState.isForce ? STATE_TYPE.__triggerSyncForce__ : STATE_TYPE.__triggerSync__, updateState.callback);\n\t\t            }\n\t\t            else {\n\t\t                renderScheduler.microTask(function triggerSyncUpdateOnFiber() {\n\t\t                    triggerUpdate(renderDispatch, fiber, updateState.isForce ? STATE_TYPE.__triggerSyncForce__ : STATE_TYPE.__triggerSync__, updateState.callback);\n\t\t                });\n\t\t            }\n\t\t        }\n\t\t        else {\n\t\t            if (updateState.isImmediate) {\n\t\t                triggerUpdate(renderDispatch, fiber, updateState.isForce ? STATE_TYPE.__triggerConcurrentForce__ : STATE_TYPE.__triggerConcurrent__, updateState.callback);\n\t\t            }\n\t\t            else {\n\t\t                renderScheduler.microTask(function triggerConcurrentUpdateOnFiber() {\n\t\t                    triggerUpdate(renderDispatch, fiber, updateState.isForce ? STATE_TYPE.__triggerConcurrentForce__ : STATE_TYPE.__triggerConcurrent__, updateState.callback);\n\t\t                });\n\t\t            }\n\t\t        }\n\t\t    }\n\t\t};\n\t\tvar prepareUpdateOnFiber = function (renderDispatch, fiber, isImmediate, isRetrigger) {\n\t\t    if (include(fiber.state, STATE_TYPE.__unmount__))\n\t\t        return;\n\t\t    var renderScheduler = currentScheduler$5.current;\n\t\t    if (isImmediate) {\n\t\t        processUpdateOnFiber(renderDispatch, fiber);\n\t\t    }\n\t\t    else {\n\t\t        renderScheduler.microTask(function asyncProcessUpdateOnFiber() {\n\t\t            processUpdateOnFiber(renderDispatch, fiber);\n\t\t        });\n\t\t    }\n\t\t};\n\t\tvar SyncState = merge(STATE_TYPE.__triggerSyncForce__, STATE_TYPE.__triggerSync__);\n\t\tvar ForceState = merge(STATE_TYPE.__triggerSyncForce__, STATE_TYPE.__triggerConcurrentForce__);\n\t\tvar triggerUpdateOnFiber = function (fiber, state, callback) {\n\t\t    if (include(fiber.state, STATE_TYPE.__unmount__))\n\t\t        return;\n\t\t    var renderScheduler = currentScheduler$5.current;\n\t\t    var updater = {\n\t\t        type: UpdateQueueType.trigger,\n\t\t        trigger: fiber,\n\t\t        isSync: include(state, SyncState),\n\t\t        isForce: include(state, ForceState),\n\t\t        callback: callback,\n\t\t    };\n\t\t    renderScheduler.dispatchState(updater);\n\t\t};\n\n\t\tvar emptyProps = {};\n\t\tvar MyReactFiberNode = /** @class */ (function () {\n\t\t    function MyReactFiberNode(element) {\n\t\t        this.state = STATE_TYPE.__initial__;\n\t\t        this.patch = PATCH_TYPE.__initial__;\n\t\t        this.type = exports.NODE_TYPE.__initial__;\n\t\t        this.child = null;\n\t\t        this.parent = null;\n\t\t        this.sibling = null;\n\t\t        this.pendingProps = emptyProps;\n\t\t        this.memoizedProps = emptyProps;\n\t\t        this.state = STATE_TYPE.__create__;\n\t\t        this._installElement(element);\n\t\t    }\n\t\t    MyReactFiberNode.prototype._installElement = function (element) {\n\t\t        var _a = getTypeFromElementNode(element), key = _a.key, ref = _a.ref, nodeType = _a.nodeType, elementType = _a.elementType, pendingProps = _a.pendingProps, pendingText = _a.pendingText;\n\t\t        this.ref = ref;\n\t\t        this.key = key;\n\t\t        this.type = nodeType;\n\t\t        this.elementType = elementType;\n\t\t        if (include(nodeType, exports.NODE_TYPE.__function__)) {\n\t\t            this.elementRawType = element === null || element === void 0 ? void 0 : element.type;\n\t\t        }\n\t\t        this.pendingProps = pendingProps;\n\t\t        if (typeof pendingText === \"string\") {\n\t\t            this.pendingText = pendingText;\n\t\t        }\n\t\t        return element;\n\t\t    };\n\t\t    MyReactFiberNode.prototype._addDependence = function (instance) {\n\t\t        this.dependence = this.dependence || new Set();\n\t\t        this.dependence.add(instance);\n\t\t    };\n\t\t    MyReactFiberNode.prototype._delDependence = function (instance) {\n\t\t        var _a;\n\t\t        (_a = this.dependence) === null || _a === void 0 ? void 0 : _a.delete(instance);\n\t\t    };\n\t\t    MyReactFiberNode.prototype._update = function (state) {\n\t\t        triggerUpdateOnFiber(this, state);\n\t\t    };\n\t\t    return MyReactFiberNode;\n\t\t}());\n\t\tObject.defineProperty(MyReactFiberNode.prototype, \"isMyReactFiberNode\", {\n\t\t    value: true,\n\t\t    configurable: true,\n\t\t});\n\t\tObject.defineProperty(MyReactFiberNode.prototype, \"return\", {\n\t\t    get: function () {\n\t\t        return this.parent;\n\t\t    },\n\t\t    configurable: true,\n\t\t});\n\t\tObject.defineProperty(MyReactFiberNode.prototype, \"stateNode\", {\n\t\t    get: function () {\n\t\t        return this.nativeNode || this.containerNode;\n\t\t    },\n\t\t    configurable: true,\n\t\t});\n\n\t\tvar createFiberNode = function (renderDispatch, _a, element) {\n\t\t    var parent = _a.parent, _b = _a.type, type = _b === void 0 ? \"append\" : _b;\n\t\t    var newFiberNode = new MyReactFiberNode(element);\n\t\t    fiberToDispatchMap.set(newFiberNode, renderDispatch);\n\t\t    newFiberNode.parent = parent;\n\t\t    parent.child = parent.child || newFiberNode;\n\t\t    renderDispatch.pendingCreate(newFiberNode);\n\t\t    renderDispatch.pendingUpdate(newFiberNode);\n\t\t    if (type === \"position\") {\n\t\t        renderDispatch.pendingPosition(newFiberNode);\n\t\t    }\n\t\t    else {\n\t\t        renderDispatch.pendingAppend(newFiberNode);\n\t\t    }\n\t\t    renderDispatch.pendingRef(newFiberNode);\n\t\t    safeCallWithCurrentFiber({\n\t\t        fiber: newFiberNode,\n\t\t        action: function safeCallPatchToFiberInitial() {\n\t\t            var _a;\n\t\t            (_a = renderDispatch.patchToFiberInitial) === null || _a === void 0 ? void 0 : _a.call(renderDispatch, newFiberNode);\n\t\t        },\n\t\t    });\n\t\t    safeCallWithCurrentFiber({\n\t\t        fiber: newFiberNode,\n\t\t        action: function safeCallFiberInitialListener() {\n\t\t            renderDispatch.callOnFiberInitial(newFiberNode);\n\t\t        },\n\t\t    });\n\t\t    if (exclude(newFiberNode.patch, PATCH_TYPE.__update__)) {\n\t\t        newFiberNode.memoizedProps = newFiberNode.pendingProps;\n\t\t    }\n\t\t    return newFiberNode;\n\t\t};\n\n\t\tvar updateFiberNode = function (renderDispatch, _a, nextElement) {\n\t\t    var fiber = _a.fiber, parent = _a.parent, prevFiber = _a.prevFiber;\n\t\t    var prevElementType = fiber.elementType;\n\t\t    var prevProps = fiber.memoizedProps;\n\t\t    var prevRef = fiber.ref;\n\t\t    fiber.parent = parent;\n\t\t    fiber.sibling = null;\n\t\t    parent.child = parent.child || fiber;\n\t\t    nextElement = fiber._installElement(nextElement);\n\t\t    var nextElementType = fiber.elementType;\n\t\t    var nextProps = fiber.pendingProps;\n\t\t    var nextRef = fiber.ref;\n\t\t    if (prevElementType !== nextElementType || prevProps !== nextProps) {\n\t\t        if (include(fiber.type, exports.NODE_TYPE.__memo__)) {\n\t\t            var typedElement = nextElement;\n\t\t            var typedElementType = typedElement.type;\n\t\t            var compare = typedElementType.compare || isNormalEquals;\n\t\t            if (exclude(fiber.state, STATE_TYPE.__triggerSync__ | STATE_TYPE.__triggerConcurrent__ | STATE_TYPE.__triggerSyncForce__ | STATE_TYPE.__triggerConcurrentForce__) &&\n\t\t                compare(fiber.pendingProps, fiber.memoizedProps)) {\n\t\t                fiber.state = STATE_TYPE.__stable__;\n\t\t            }\n\t\t            else {\n\t\t                fiber.state = remove(fiber.state, STATE_TYPE.__stable__);\n\t\t                fiber.state = merge(fiber.state, STATE_TYPE.__inherit__);\n\t\t            }\n\t\t        }\n\t\t        else {\n\t\t            fiber.state = remove(fiber.state, STATE_TYPE.__stable__);\n\t\t            fiber.state = merge(fiber.state, STATE_TYPE.__inherit__);\n\t\t        }\n\t\t    }\n\t\t    if (fiber.state !== STATE_TYPE.__stable__) {\n\t\t        if (include(fiber.type, exports.NODE_TYPE.__plain__)) {\n\t\t            if (!isNormalEquals(fiber.pendingProps, fiber.memoizedProps, function (key) { return key === \"children\"; })) {\n\t\t                renderDispatch.pendingUpdate(fiber);\n\t\t            }\n\t\t        }\n\t\t        if (include(fiber.type, exports.NODE_TYPE.__text__)) {\n\t\t            renderDispatch.pendingUpdate(fiber);\n\t\t        }\n\t\t    }\n\t\t    if (prevRef !== nextRef) {\n\t\t        renderDispatch.pendingRef(fiber);\n\t\t    }\n\t\t    if (fiber !== prevFiber) {\n\t\t        renderDispatch.pendingPosition(fiber);\n\t\t    }\n\t\t    // if (exclude(fiber.patch, PATCH_TYPE.__update__)) {\n\t\t    //   fiber.memoizedProps = fiber.pendingProps;\n\t\t    // }\n\t\t    return fiber;\n\t\t};\n\n\t\t// no need to resolve map for this fiber, this code only used for fiberRoot init\n\t\tvar initialFiberNode = function (renderDispatch, fiber) {\n\t\t    fiberToDispatchMap.set(fiber, renderDispatch);\n\t\t    renderDispatch.pendingCreate(fiber);\n\t\t    renderDispatch.pendingUpdate(fiber);\n\t\t    renderDispatch.pendingAppend(fiber);\n\t\t    renderDispatch.pendingRef(fiber);\n\t\t    safeCallWithCurrentFiber({\n\t\t        fiber: fiber,\n\t\t        action: function safeCallPatchToFiberInitial() {\n\t\t            var _a;\n\t\t            (_a = renderDispatch.patchToFiberInitial) === null || _a === void 0 ? void 0 : _a.call(renderDispatch, fiber);\n\t\t        },\n\t\t    });\n\t\t    safeCallWithCurrentFiber({\n\t\t        fiber: fiber,\n\t\t        action: function safeCallFiberInitialListener() {\n\t\t            renderDispatch.callOnFiberInitial(fiber);\n\t\t        },\n\t\t    });\n\t\t    if (exclude(fiber.patch, PATCH_TYPE.__update__)) {\n\t\t        fiber.memoizedProps = fiber.pendingProps;\n\t\t    }\n\t\t    return fiber;\n\t\t};\n\n\t\treact.__my_react_shared__.enableDebugFiled;\n\t\tvar unmountFiberNode = function (renderDispatch, fiber) {\n\t\t    if (include(fiber.state, STATE_TYPE.__unmount__))\n\t\t        return;\n\t\t    hookListUnmount(renderDispatch, fiber);\n\t\t    processClassComponentUnmount(renderDispatch, fiber);\n\t\t    unmountInstance(fiber.instance);\n\t\t    safeCallWithCurrentFiber({\n\t\t        fiber: fiber,\n\t\t        action: function safeCallCommitUnsetRef() {\n\t\t            renderDispatch.commitUnsetRef(fiber);\n\t\t        },\n\t\t    });\n\t\t    safeCallWithCurrentFiber({\n\t\t        fiber: fiber,\n\t\t        action: function safeCallCommitClear() {\n\t\t            renderDispatch.commitClear(fiber);\n\t\t        },\n\t\t    });\n\t\t    safeCallWithCurrentFiber({\n\t\t        fiber: fiber,\n\t\t        action: function safeCallPatchToFiberUnmount() {\n\t\t            var _a;\n\t\t            (_a = renderDispatch.patchToFiberUnmount) === null || _a === void 0 ? void 0 : _a.call(renderDispatch, fiber);\n\t\t        },\n\t\t    });\n\t\t    safeCallWithCurrentFiber({\n\t\t        fiber: fiber,\n\t\t        action: function safeCallFiberUnmountListener() {\n\t\t            renderDispatch.callOnFiberUnmount(fiber);\n\t\t        },\n\t\t    });\n\t\t    fiberToDispatchMap.delete(fiber);\n\t\t    renderDispatch.runtimeMap.insertionEffectMap.delete(fiber);\n\t\t    renderDispatch.runtimeMap.effectMap.delete(fiber);\n\t\t    renderDispatch.runtimeMap.layoutEffectMap.delete(fiber);\n\t\t    renderDispatch.runtimeMap.unmountMap.delete(fiber);\n\t\t    renderDispatch.runtimeMap.eventMap.delete(fiber);\n\t\t    renderDispatch.runtimeMap.triggerCallbackMap.delete(fiber);\n\t\t    if (Boolean(false) === false) {\n\t\t        // fiber.child = null;\n\t\t        // fiber.parent = null;\n\t\t        // fiber.sibling = null;\n\t\t        fiber.instance = null;\n\t\t        fiber.hookList = null;\n\t\t        fiber.dependence = null;\n\t\t        fiber.nativeNode = null;\n\t\t        fiber.updateQueue = null;\n\t\t    }\n\t\t    fiber.patch = PATCH_TYPE.__initial__;\n\t\t    fiber.state = STATE_TYPE.__unmount__;\n\t\t};\n\n\t\treact.__my_react_shared__.enableDebugFiled;\n\t\tvar getIsSameTypeNode = function (newChild, draftFiber) {\n\t\t    if (!draftFiber)\n\t\t        return false;\n\t\t    var result = checkIsSameType(draftFiber, newChild);\n\t\t    return result;\n\t\t};\n\t\tvar getExistingChildren = function (parentFiber) {\n\t\t    var existingChildrenMap = new Map();\n\t\t    var existingChildrenArray = [];\n\t\t    var child = parentFiber.child;\n\t\t    var index = 0;\n\t\t    while (child) {\n\t\t        var key = typeof child.key === \"string\" ? child.key : index;\n\t\t        var existingChild = existingChildrenMap.get(key) || new ListTree();\n\t\t        existingChild.push(child);\n\t\t        existingChildrenMap.set(key, existingChild);\n\t\t        existingChildrenArray.push(child);\n\t\t        child = child.sibling;\n\t\t        index++;\n\t\t    }\n\t\t    return { existingChildrenMap: existingChildrenMap, existingChildrenArray: existingChildrenArray };\n\t\t};\n\t\tvar dynamicFragmentProps = { wrap: true };\n\t\tvar createFragmentWithInitial = function (renderDispatch, newChild, parentFiber) {\n\t\t    // TODO make there are not a element\n\t\t    var newElement = react.createElement(Fragment, dynamicFragmentProps, newChild);\n\t\t    var newFiber = createFiberNode(renderDispatch, { parent: parentFiber }, newElement);\n\t\t    return newFiber;\n\t\t};\n\t\tvar createFragmentWithUpdate = function (renderDispatch, newChild, parentFiber) {\n\t\t    var newElement = react.createElement(Fragment, dynamicFragmentProps, newChild);\n\t\t    var newFiber = createFiberNode(renderDispatch, { parent: parentFiber, type: \"position\" }, newElement);\n\t\t    return newFiber;\n\t\t};\n\t\tvar deleteIfNeed = function (renderDispatch, parentFiber, existingChildren) {\n\t\t    if (existingChildren.size) {\n\t\t        existingChildren.forEach(function forEachInvokePendingUnmountList(list) {\n\t\t            list.listToFoot(function invokePendingUnmountList(f) {\n\t\t                renderDispatch.pendingUnmount(parentFiber, f);\n\t\t            });\n\t\t        });\n\t\t        renderDispatch.generateChangedList(parentFiber, true);\n\t\t    }\n\t\t};\n\t\tvar getNewFiberWithUpdate = function (renderDispatch, newChild, parentFiber, existingChildren, prevFiberChild, index) {\n\t\t    if (Array.isArray(newChild)) {\n\t\t        var draftList_1 = existingChildren.get(index);\n\t\t        // TODO try to get the same type node?\n\t\t        var draftFiber_1 = draftList_1 === null || draftList_1 === void 0 ? void 0 : draftList_1.shift();\n\t\t        if (draftList_1 && !draftList_1.length) {\n\t\t            existingChildren.delete(index);\n\t\t        }\n\t\t        // same type\n\t\t        if (include(draftFiber_1 === null || draftFiber_1 === void 0 ? void 0 : draftFiber_1.type, exports.NODE_TYPE.__fragment__)) {\n\t\t            var newElement = react.createElement(Fragment, dynamicFragmentProps, newChild);\n\t\t            draftFiber_1 !== prevFiberChild && renderDispatch.generateChangedList(parentFiber);\n\t\t            return updateFiberNode(renderDispatch, { fiber: draftFiber_1, parent: parentFiber, prevFiber: prevFiberChild }, newElement);\n\t\t        }\n\t\t        else {\n\t\t            draftFiber_1 && renderDispatch.generateChangedList(parentFiber);\n\t\t            draftFiber_1 && renderDispatch.pendingUnmount(parentFiber, draftFiber_1);\n\t\t            return createFragmentWithUpdate(renderDispatch, newChild, parentFiber);\n\t\t        }\n\t\t    }\n\t\t    var keyToGet = react.isValidElement(newChild) && typeof newChild.key === \"string\" ? newChild.key : index;\n\t\t    var draftList = existingChildren.get(keyToGet);\n\t\t    var draftFiber = draftList === null || draftList === void 0 ? void 0 : draftList.shift();\n\t\t    if (draftList && !draftList.length) {\n\t\t        existingChildren.delete(keyToGet);\n\t\t    }\n\t\t    var isSameType = getIsSameTypeNode(newChild, draftFiber);\n\t\t    if (isSameType) {\n\t\t        draftFiber !== prevFiberChild && renderDispatch.generateChangedList(parentFiber);\n\t\t        return updateFiberNode(renderDispatch, { fiber: draftFiber, parent: parentFiber, prevFiber: prevFiberChild }, newChild);\n\t\t    }\n\t\t    else {\n\t\t        draftFiber && renderDispatch.pendingUnmount(parentFiber, draftFiber);\n\t\t        draftFiber && renderDispatch.generateChangedList(parentFiber);\n\t\t        return createFiberNode(renderDispatch, { parent: parentFiber, type: \"position\" }, newChild);\n\t\t    }\n\t\t};\n\t\tvar getNewFiberWithInitial = function (renderDispatch, newChild, parentFiber) {\n\t\t    // wrapper array child item as a Fragment fiber node, so all of the children will be a fiber node\n\t\t    // and could be add to the child list\n\t\t    if (Array.isArray(newChild))\n\t\t        return createFragmentWithInitial(renderDispatch, newChild, parentFiber);\n\t\t    return createFiberNode(renderDispatch, { parent: parentFiber }, newChild);\n\t\t};\n\t\tvar transformChildrenFiber = function (renderDispatch, parentFiber, children) {\n\t\t    var isUpdate = exclude(parentFiber.state, STATE_TYPE.__create__);\n\t\t    var isHMR = include(parentFiber.state, STATE_TYPE.__hmr__);\n\t\t    var isRetrigger = include(parentFiber.state, STATE_TYPE.__retrigger__);\n\t\t    var isSuspense = include(parentFiber.state, STATE_TYPE.__suspense__);\n\t\t    // if current is retrigger update, skip update children\n\t\t    if (isRetrigger)\n\t\t        return;\n\t\t    // if current is suspense, skip update children\n\t\t    if (isSuspense)\n\t\t        return;\n\t\t    if (isUpdate || isHMR) {\n\t\t        var _a = getExistingChildren(parentFiber), existingChildrenMap = _a.existingChildrenMap, existingChildrenArray = _a.existingChildrenArray;\n\t\t        parentFiber.child = null;\n\t\t        if (Array.isArray(children)) {\n\t\t            var newChildren = children;\n\t\t            var index = 0;\n\t\t            var lastFiber = null;\n\t\t            while (index < newChildren.length) {\n\t\t                var newChild = newChildren[index];\n\t\t                var newFiber = getNewFiberWithUpdate(renderDispatch, newChild, parentFiber, existingChildrenMap, existingChildrenArray[index] || null, index);\n\t\t                lastFiber && (lastFiber.sibling = newFiber);\n\t\t                lastFiber = newFiber;\n\t\t                index++;\n\t\t            }\n\t\t        }\n\t\t        else {\n\t\t            getNewFiberWithUpdate(renderDispatch, children, parentFiber, existingChildrenMap, existingChildrenArray[0], 0);\n\t\t        }\n\t\t        deleteIfNeed(renderDispatch, parentFiber, existingChildrenMap);\n\t\t    }\n\t\t    else {\n\t\t        renderDispatch.generateChangedList(parentFiber);\n\t\t        var existingChildrenMap = getExistingChildren(parentFiber).existingChildrenMap;\n\t\t        deleteIfNeed(renderDispatch, parentFiber, existingChildrenMap);\n\t\t        parentFiber.child = null;\n\t\t        if (Array.isArray(children)) {\n\t\t            var newChildren = children;\n\t\t            var lastFiber = null;\n\t\t            var index = 0;\n\t\t            while (index < newChildren.length) {\n\t\t                var newChild = newChildren[index];\n\t\t                var newFiber = getNewFiberWithInitial(renderDispatch, newChild, parentFiber);\n\t\t                lastFiber && (lastFiber.sibling = newFiber);\n\t\t                lastFiber = newFiber;\n\t\t                index++;\n\t\t            }\n\t\t        }\n\t\t        else {\n\t\t            getNewFiberWithInitial(renderDispatch, children, parentFiber);\n\t\t        }\n\t\t    }\n\t\t};\n\n\t\t// TODO\n\t\tvar processActivity = function (fiber) {\n\t\t    var props = fiber.pendingProps;\n\t\t    if (props.mode === \"visible\")\n\t\t        return props.children;\n\t\t    return null;\n\t\t};\n\n\t\tvar currentComponentFiber$2 = react.__my_react_internal__.currentComponentFiber, MyReactInternalInstance$3 = react.__my_react_internal__.MyReactInternalInstance;\n\t\tvar processProvider = function (renderDispatch, fiber) {\n\t\t    if (renderDispatch.isAppMounted) {\n\t\t        var prevProps = fiber.memoizedProps.value;\n\t\t        var nextProps = fiber.pendingProps.value;\n\t\t        if (!isNormalEquals(prevProps, nextProps)) {\n\t\t            prepareUpdateAllDependence(renderDispatch, fiber, prevProps, nextProps);\n\t\t        }\n\t\t    }\n\t\t};\n\t\tvar processConsumer = function (renderDispatch, fiber) {\n\t\t    var typedElementType = fiber.elementType;\n\t\t    var isUpdate = !!fiber.instance;\n\t\t    fiber.instance = fiber.instance || new MyReactInternalInstance$3();\n\t\t    !isUpdate && initInstance(fiber.instance);\n\t\t    !isUpdate && setOwnerForInstance(fiber.instance, fiber);\n\t\t    var Context = typedElementType.Context;\n\t\t    currentComponentFiber$2.current = fiber;\n\t\t    var contextFiber = getInstanceContextFiber(fiber.instance);\n\t\t    var finalContext = null;\n\t\t    if (!contextFiber || include(contextFiber.state, STATE_TYPE.__unmount__)) {\n\t\t        var providerFiber = renderDispatch.resolveContextFiber(fiber, Context);\n\t\t        var context = renderDispatch.resolveContextValue(providerFiber, Context);\n\t\t        finalContext = context;\n\t\t        setContextForInstance(fiber.instance, providerFiber);\n\t\t    }\n\t\t    else {\n\t\t        var context = renderDispatch.resolveContextValue(contextFiber, Context);\n\t\t        finalContext = context;\n\t\t    }\n\t\t    var typedChildren = fiber.pendingProps.children;\n\t\t    var children = safeCallWithCurrentFiber({\n\t\t        fiber: fiber,\n\t\t        action: function safeCallConsumerChildren() {\n\t\t            return typedChildren(finalContext);\n\t\t        },\n\t\t    });\n\t\t    currentComponentFiber$2.current = null;\n\t\t    return children;\n\t\t};\n\n\t\tvar currentHookTreeNode = react.__my_react_internal__.currentHookTreeNode, currentHookNodeIndex$1 = react.__my_react_internal__.currentHookNodeIndex, currentScheduler$4 = react.__my_react_internal__.currentScheduler;\n\t\tvar triggerState = STATE_TYPE.__triggerSync__ |\n\t\t    STATE_TYPE.__triggerSyncForce__ |\n\t\t    STATE_TYPE.__triggerConcurrent__ |\n\t\t    STATE_TYPE.__triggerConcurrentForce__ |\n\t\t    STATE_TYPE.__retrigger__;\n\t\tvar processFunction = function (fiber) {\n\t\t    var _a;\n\t\t    currentHookTreeNode.current = (_a = fiber.hookList) === null || _a === void 0 ? void 0 : _a.head;\n\t\t    currentHookNodeIndex$1.current = 0;\n\t\t    var typedElementType = fiber.elementType;\n\t\t    var children = null;\n\t\t    if (include(fiber.type, exports.NODE_TYPE.__forwardRef__)) {\n\t\t        var typedElementTypeWithRef_1 = typedElementType;\n\t\t        children = safeCallWithCurrentFiber({\n\t\t            fiber: fiber,\n\t\t            action: function safeCallForwardRefFunctionalComponent() {\n\t\t                var _a, _b, _c, _d;\n\t\t                var re = undefined;\n\t\t                try {\n\t\t                    re = typedElementTypeWithRef_1(fiber.pendingProps, fiber.ref);\n\t\t                }\n\t\t                catch (e) {\n\t\t                    if (isPromise(e)) {\n\t\t                        var currentIsTrigger = include(fiber.state, triggerState);\n\t\t                        if (currentIsTrigger) {\n\t\t                            re = (_b = (_a = currentScheduler$4.current) === null || _a === void 0 ? void 0 : _a.dispatchSuspensePromise) === null || _b === void 0 ? void 0 : _b.call(_a, { fiber: fiber, promise: e });\n\t\t                        }\n\t\t                        else {\n\t\t                            re = (_d = (_c = currentScheduler$4.current) === null || _c === void 0 ? void 0 : _c.dispatchPromise) === null || _d === void 0 ? void 0 : _d.call(_c, { fiber: fiber, promise: e });\n\t\t                        }\n\t\t                    }\n\t\t                    else {\n\t\t                        throw e;\n\t\t                    }\n\t\t                }\n\t\t                return re;\n\t\t            },\n\t\t        });\n\t\t    }\n\t\t    else {\n\t\t        children = safeCallWithCurrentFiber({\n\t\t            fiber: fiber,\n\t\t            action: function safeCallFunctionalComponent() {\n\t\t                var _a, _b, _c, _d;\n\t\t                var re = undefined;\n\t\t                try {\n\t\t                    re = typedElementType(fiber.pendingProps);\n\t\t                }\n\t\t                catch (e) {\n\t\t                    if (isPromise(e)) {\n\t\t                        var currentIsTrigger = include(fiber.state, triggerState);\n\t\t                        if (currentIsTrigger) {\n\t\t                            re = (_b = (_a = currentScheduler$4.current) === null || _a === void 0 ? void 0 : _a.dispatchSuspensePromise) === null || _b === void 0 ? void 0 : _b.call(_a, { fiber: fiber, promise: e });\n\t\t                        }\n\t\t                        else {\n\t\t                            re = (_d = (_c = currentScheduler$4.current) === null || _c === void 0 ? void 0 : _c.dispatchPromise) === null || _d === void 0 ? void 0 : _d.call(_c, { fiber: fiber, promise: e });\n\t\t                        }\n\t\t                    }\n\t\t                    else {\n\t\t                        throw e;\n\t\t                    }\n\t\t                }\n\t\t                return re;\n\t\t            },\n\t\t        });\n\t\t    }\n\t\t    currentHookNodeIndex$1.current = 0;\n\t\t    currentHookTreeNode.current = null;\n\t\t    return children;\n\t\t};\n\n\t\tvar WrapperByLazyScope = function (children) { return react.createElement(ScopeLazy, null, children); };\n\t\tvar WrapperBySuspenseScope = function (children) {\n\t\t    return react.createElement(ScopeSuspense, null, react.createElement(Comment, { mode: \"s\" }), children, react.createElement(Comment, { mode: \"e\" }));\n\t\t};\n\t\tvar isCommentElement = function (fiber) { return include(fiber.type, exports.NODE_TYPE.__comment__); };\n\t\tvar isCommentStartElement = function (fiber) {\n\t\t    if (isCommentElement(fiber)) {\n\t\t        return fiber.pendingProps[\"mode\"] === \"s\";\n\t\t    }\n\t\t    return false;\n\t\t};\n\t\tvar isCommentEndElement = function (fiber) {\n\t\t    if (isCommentElement(fiber)) {\n\t\t        return fiber.pendingProps[\"mode\"] === \"e\";\n\t\t    }\n\t\t    return false;\n\t\t};\n\n\t\tvar enableSuspenseRoot$1 = react.__my_react_shared__.enableSuspenseRoot;\n\t\tvar currentScheduler$3 = react.__my_react_internal__.currentScheduler;\n\t\tvar loadLazy = function (renderDispatch, typedElementType) { return __awaiter(void 0, void 0, void 0, function () {\n\t\t    var loadedPromise, loaded, render, e_1;\n\t\t    return __generator(this, function (_a) {\n\t\t        switch (_a.label) {\n\t\t            case 0:\n\t\t                if (typedElementType._loaded)\n\t\t                    return [2 /*return*/];\n\t\t                _a.label = 1;\n\t\t            case 1:\n\t\t                _a.trys.push([1, 3, 4, 5]);\n\t\t                typedElementType._loading = true;\n\t\t                loadedPromise = typedElementType.loader();\n\t\t                return [4 /*yield*/, Promise.resolve(loadedPromise)];\n\t\t            case 2:\n\t\t                loaded = _a.sent();\n\t\t                render = typeof loaded === \"object\" && (typeof (loaded === null || loaded === void 0 ? void 0 : loaded.default) === \"function\" || typeof (loaded === null || loaded === void 0 ? void 0 : loaded.default) === \"object\") ? loaded.default : loaded;\n\t\t                typedElementType.render = render;\n\t\t                return [3 /*break*/, 5];\n\t\t            case 3:\n\t\t                e_1 = _a.sent();\n\t\t                typedElementType._error = e_1;\n\t\t                return [3 /*break*/, 5];\n\t\t            case 4:\n\t\t                typedElementType._loaded = true;\n\t\t                typedElementType._loading = false;\n\t\t                return [7 /*endfinally*/];\n\t\t            case 5: return [2 /*return*/];\n\t\t        }\n\t\t    });\n\t\t}); };\n\t\tvar processLazy = function (renderDispatch, fiber) {\n\t\t    var _a, _b;\n\t\t    var typedElementType = fiber.elementType;\n\t\t    if (typedElementType._error) {\n\t\t        (_b = (_a = currentScheduler$3.current).dispatchError) === null || _b === void 0 ? void 0 : _b.call(_a, { fiber: fiber, error: typedElementType._error });\n\t\t        return null;\n\t\t    }\n\t\t    if (typedElementType._loaded === true) {\n\t\t        var render = typedElementType.render;\n\t\t        return WrapperByLazyScope(react.createElement(render, fiber.pendingProps));\n\t\t    }\n\t\t    typedElementType._list = typedElementType._list || new Set();\n\t\t    typedElementType._list.add(fiber);\n\t\t    var suspenseFiber = renderDispatch.resolveSuspenseFiber(fiber);\n\t\t    if (suspenseFiber) {\n\t\t        var suspenseField = getInstanceFieldByInstance(suspenseFiber.instance);\n\t\t        suspenseField.asyncLoadList.uniPush(typedElementType);\n\t\t        renderDispatch.pendingSuspenseFiberArray.uniPush(suspenseFiber);\n\t\t        return null;\n\t\t    }\n\t\t    else {\n\t\t        // TODO update flow\n\t\t        if (enableSuspenseRoot$1.current && !renderDispatch.isAppMounted) {\n\t\t            var suspenseField = getInstanceFieldByInstance(renderDispatch);\n\t\t            suspenseField.asyncLoadList.uniPush(typedElementType);\n\t\t            return null;\n\t\t        }\n\t\t        devWarnWithFiber(fiber, \"[@my-react/react] lazy() must be used inside a Suspense component, otherwise it will not work as expected\");\n\t\t        if (typedElementType._loading)\n\t\t            return null;\n\t\t        typedElementType._loading = true;\n\t\t        var renderScheduler_1 = currentScheduler$3.current;\n\t\t        renderDispatch.processLazy(typedElementType).then(function () {\n\t\t            fiber.state = STATE_TYPE.__recreate__;\n\t\t            typedElementType._list.delete(fiber);\n\t\t            var updater = {\n\t\t                type: UpdateQueueType.lazy,\n\t\t                trigger: fiber,\n\t\t                isSync: true,\n\t\t                isForce: true,\n\t\t                payLoad: typedElementType,\n\t\t            };\n\t\t            renderScheduler_1.dispatchState(updater);\n\t\t        });\n\t\t        return null;\n\t\t    }\n\t\t};\n\n\t\tvar initSuspenseInstance = function (instance) {\n\t\t    var field = getInstanceFieldByInstance(instance);\n\t\t    if (!field)\n\t\t        throw new Error(\"[@my-react/react] can not get field for instance, this is a bug for @my-react\");\n\t\t    var typedField = field;\n\t\t    typedField.isHidden = false;\n\t\t    typedField.asyncLoadList = new UniqueArray();\n\t\t};\n\n\t\tvar MyReactInternalInstance$2 = react.__my_react_internal__.MyReactInternalInstance;\n\t\tvar processSuspense = function (fiber) {\n\t\t    var isUpdate = !!fiber.instance;\n\t\t    fiber.instance = fiber.instance || new MyReactInternalInstance$2();\n\t\t    !isUpdate && initInstance(fiber.instance);\n\t\t    !isUpdate && initVisibleInstance(fiber.instance);\n\t\t    !isUpdate && initSuspenseInstance(fiber.instance);\n\t\t    !isUpdate && setOwnerForInstance(fiber.instance, fiber);\n\t\t    var instanceField = getInstanceFieldByInstance(fiber.instance);\n\t\t    var children = WrapperBySuspenseScope(instanceField.isHidden ? fiber.pendingProps.fallback : fiber.pendingProps.children);\n\t\t    return children;\n\t\t};\n\n\t\treact.__my_react_internal__.MyReactInternalInstance; var instanceToInitialFieldMap = react.__my_react_internal__.instanceToInitialFieldMap;\n\t\t// support private instance field\n\t\tvar instanceMap = instanceToInitialFieldMap;\n\t\tvar initInstance = function (instance) {\n\t\t    var exist = instanceMap.get(instance);\n\t\t    if (exist)\n\t\t        return exist;\n\t\t    var field = {\n\t\t        _owner: null,\n\t\t        _context: null,\n\t\t        _subscribe: null,\n\t\t        effect: Effect_TYPE.__initial__,\n\t\t    };\n\t\t    instanceMap.set(instance, field);\n\t\t    return field;\n\t\t};\n\t\tvar initVisibleInstance = function (instance) {\n\t\t    var field = getInstanceFieldByInstance(instance);\n\t\t    if (!field)\n\t\t        throw new Error(\"[@my-react/react] can not get field for instance, this is a bug for @my-react\");\n\t\t    var typedField = field;\n\t\t    typedField.isHidden = false;\n\t\t};\n\t\tvar setOwnerForInstance = function (instance, fiber, instanceField) {\n\t\t    var field = instanceField || instanceMap.get(instance);\n\t\t    instance._reactInternals = fiber;\n\t\t    // unmount instance\n\t\t    if (!field)\n\t\t        return;\n\t\t    field._owner = fiber;\n\t\t};\n\t\tvar setContextForInstance = function (instance, fiber, instanceField) {\n\t\t    var _a, _b;\n\t\t    var field = instanceField || instanceMap.get(instance);\n\t\t    // unmount instance\n\t\t    if (!field)\n\t\t        return;\n\t\t    (_a = field._context) === null || _a === void 0 ? void 0 : _a._delDependence(instance);\n\t\t    field._context = fiber;\n\t\t    (_b = field._context) === null || _b === void 0 ? void 0 : _b._addDependence(instance);\n\t\t};\n\t\tvar setSubscribeForInstance = function (instance, fiber, instanceField) {\n\t\t    var field = instanceField || instanceMap.get(instance);\n\t\t    // unmount instance\n\t\t    if (!field)\n\t\t        return;\n\t\t    if (!field._subscribe) {\n\t\t        field._subscribe = new Set();\n\t\t    }\n\t\t    if (fiber) {\n\t\t        field._subscribe.add(fiber);\n\t\t        fiber._addDependence(instance);\n\t\t    }\n\t\t};\n\t\tvar setEffectForInstance = function (instance, effect, instanceField) {\n\t\t    var field = instanceField || instanceMap.get(instance);\n\t\t    // unmount instance\n\t\t    if (!field)\n\t\t        return;\n\t\t    field.effect = effect;\n\t\t};\n\t\tvar unmountInstance = function (instance) {\n\t\t    var _a, _b, _c;\n\t\t    if (!instance || !instance.isMyReactInstance)\n\t\t        return;\n\t\t    var field = instanceMap.get(instance);\n\t\t    if (!field)\n\t\t        return;\n\t\t    (_a = field._context) === null || _a === void 0 ? void 0 : _a._delDependence(instance);\n\t\t    field.effect = Effect_TYPE.__unmount__;\n\t\t    field._owner = null;\n\t\t    field._context = null;\n\t\t    (_c = (_b = field._subscribe) === null || _b === void 0 ? void 0 : _b.forEach) === null || _c === void 0 ? void 0 : _c.call(_b, function (fiber) {\n\t\t        var _a;\n\t\t        (_a = fiber === null || fiber === void 0 ? void 0 : fiber._delDependence) === null || _a === void 0 ? void 0 : _a.call(fiber, instance);\n\t\t    });\n\t\t    instanceMap.delete(instance);\n\t\t};\n\t\tvar getInstanceFieldByInstance = function (instance) {\n\t\t    var field = instanceMap.get(instance);\n\t\t    if (!field)\n\t\t        throw new Error(\"[@my-react/react] instance not found, look like a bug for @my-react\");\n\t\t    return field;\n\t\t};\n\t\tvar getInstanceOwnerFiber = function (instance) {\n\t\t    var typedInstance = instance;\n\t\t    if (typedInstance.isMyReactInstance) {\n\t\t        var field = instanceMap.get(typedInstance);\n\t\t        return field === null || field === void 0 ? void 0 : field._owner;\n\t\t    }\n\t\t    else {\n\t\t        if (checkIsMyReactFiberNode(instance)) {\n\t\t            return instance;\n\t\t        }\n\t\t        throw new Error(\"instance is not a MyReactInternalInstance or MyReactFiberNode\");\n\t\t    }\n\t\t};\n\t\tvar getInstanceContextFiber = function (instance) {\n\t\t    var field = instanceMap.get(instance);\n\t\t    return field === null || field === void 0 ? void 0 : field._context;\n\t\t};\n\t\tvar getInstanceEffectState = function (instance) {\n\t\t    var field = instanceMap.get(instance);\n\t\t    return field === null || field === void 0 ? void 0 : field.effect;\n\t\t};\n\n\t\tvar currentComponentFiber$1 = react.__my_react_internal__.currentComponentFiber, MyReactInternalInstance$1 = react.__my_react_internal__.MyReactInternalInstance;\n\t\tvar enablePerformanceLog = react.__my_react_shared__.enablePerformanceLog, enableDebugFiled = react.__my_react_shared__.enableDebugFiled;\n\t\tvar nextWorkCommon = function (renderDispatch, fiber, children) {\n\t\t    if (exclude(fiber.patch, PATCH_TYPE.__update__)) {\n\t\t        fiber.memoizedProps = fiber.pendingProps;\n\t\t    }\n\t\t    safeCallWithCurrentFiber({\n\t\t        fiber: fiber,\n\t\t        action: function safeCallTransformChildrenFiber() {\n\t\t            transformChildrenFiber(renderDispatch, fiber, children);\n\t\t        },\n\t\t    });\n\t\t};\n\t\tvar nextWorkNormal = function (renderDispatch, fiber) {\n\t\t    if (\"children\" in fiber.pendingProps ||\n\t\t        \"children\" in fiber.memoizedProps ||\n\t\t        \"dangerouslySetInnerHTML\" in fiber.pendingProps ||\n\t\t        \"dangerouslySetInnerHTML\" in fiber.memoizedProps) {\n\t\t        var children = fiber.pendingProps.children;\n\t\t        nextWorkCommon(renderDispatch, fiber, children);\n\t\t    }\n\t\t};\n\t\tvar nextWorkClassComponent = function (renderDispatch, fiber) {\n\t\t    if (!fiber.instance) {\n\t\t        var children = processClassComponentMount(renderDispatch, fiber);\n\t\t        nextWorkCommon(renderDispatch, fiber, children);\n\t\t    }\n\t\t    else {\n\t\t        var field = getClassInstanceFieldByInstance(fiber.instance);\n\t\t        if (!field.isMounted)\n\t\t            return;\n\t\t        var _a = processClassComponentUpdate(renderDispatch, fiber), updated = _a.updated, children = _a.children;\n\t\t        if (updated)\n\t\t            nextWorkCommon(renderDispatch, fiber, children);\n\t\t    }\n\t\t};\n\t\tvar nextWorkFunctionComponent = function (renderDispatch, fiber) {\n\t\t    var children = processFunction(fiber);\n\t\t    nextWorkCommon(renderDispatch, fiber, children);\n\t\t};\n\t\tvar nextWorkComponent = function (renderDispatch, fiber) {\n\t\t    if (include(fiber.type, exports.NODE_TYPE.__function__)) {\n\t\t        currentComponentFiber$1.current = fiber;\n\t\t        nextWorkFunctionComponent(renderDispatch, fiber);\n\t\t        currentComponentFiber$1.current = null;\n\t\t    }\n\t\t    else {\n\t\t        currentComponentFiber$1.current = fiber;\n\t\t        nextWorkClassComponent(renderDispatch, fiber);\n\t\t        currentComponentFiber$1.current = null;\n\t\t    }\n\t\t};\n\t\tvar nextWorkLazy = function (renderDispatch, fiber) {\n\t\t    var children = processLazy(renderDispatch, fiber);\n\t\t    nextWorkCommon(renderDispatch, fiber, children);\n\t\t};\n\t\tvar nextWorkSuspense = function (renderDispatch, fiber) {\n\t\t    var children = processSuspense(fiber);\n\t\t    nextWorkCommon(renderDispatch, fiber, children);\n\t\t};\n\t\tvar nextWorkProvider = function (renderDispatch, fiber) {\n\t\t    processProvider(renderDispatch, fiber);\n\t\t    nextWorkNormal(renderDispatch, fiber);\n\t\t};\n\t\tvar nextWorkConsumer = function (renderDispatch, fiber) {\n\t\t    var children = processConsumer(renderDispatch, fiber);\n\t\t    nextWorkCommon(renderDispatch, fiber, children);\n\t\t};\n\t\tvar nextWorkActivity = function (renderDispatch, fiber) {\n\t\t    var children = processActivity(fiber);\n\t\t    nextWorkCommon(renderDispatch, fiber, children);\n\t\t};\n\t\tvar nextWorkRoot = function (renderDispatch, fiber) {\n\t\t    var isUpdate = !!fiber.instance;\n\t\t    fiber.instance = fiber.instance || new MyReactInternalInstance$1();\n\t\t    !isUpdate && initInstance(fiber.instance);\n\t\t    !isUpdate && initVisibleInstance(fiber.instance);\n\t\t    !isUpdate && setOwnerForInstance(fiber.instance, fiber);\n\t\t    var instanceField = getInstanceFieldByInstance(fiber.instance);\n\t\t    if (instanceField.isHidden) {\n\t\t        nextWorkCommon(renderDispatch, fiber, null);\n\t\t    }\n\t\t    else {\n\t\t        nextWorkNormal(renderDispatch, fiber);\n\t\t    }\n\t\t};\n\t\tvar runtimeNextWork = function (renderDispatch, fiber) {\n\t\t    renderDispatch.dispatchFiber(fiber);\n\t\t};\n\t\tvar runtimeNextWorkDev = function (renderDispatch, fiber) {\n\t\t    safeCallWithCurrentFiber({\n\t\t        fiber: fiber,\n\t\t        action: function safeCallFiberRunListener() {\n\t\t            renderDispatch.callOnBeforeFiberRun(fiber);\n\t\t        },\n\t\t    });\n\t\t    setRefreshTypeMap(fiber);\n\t\t    var typedFiber = fiber;\n\t\t    var start = Date.now();\n\t\t    runtimeNextWork(renderDispatch, fiber);\n\t\t    var end = Date.now();\n\t\t    var renderTime = end - start;\n\t\t    var hasPerformanceWarn = renderTime > renderDispatch.performanceLogTimeLimit;\n\t\t    if (enablePerformanceLog.current && hasPerformanceWarn) {\n\t\t        onceWarnWithKeyAndFiber(fiber, \"performance\", \"[@my-react/react] render current component take a lot of time, there have a performance warning\");\n\t\t    }\n\t\t    if (hasPerformanceWarn) {\n\t\t        safeCallWithCurrentFiber({\n\t\t            fiber: fiber,\n\t\t            action: function safeCallPerformanceWarnListener() {\n\t\t                renderDispatch.callOnPerformanceWarn(fiber, renderTime);\n\t\t            },\n\t\t        });\n\t\t    }\n\t\t    var timeNow = end;\n\t\t    if (enableDebugFiled.current) {\n\t\t        if (typedFiber.state === STATE_TYPE.__create__) {\n\t\t            typedFiber._debugRenderState = {\n\t\t                mountTimeStep: timeNow,\n\t\t                timeForRender: renderTime,\n\t\t                maxTimeForRender: renderTime,\n\t\t            };\n\t\t            typedFiber._debugIsMount = true;\n\t\t        }\n\t\t        else {\n\t\t            var prevRenderState = Object.assign({}, typedFiber._debugRenderState);\n\t\t            var prevRenderTime = prevRenderState.updateTimeStep || prevRenderState.mountTimeStep;\n\t\t            typedFiber._debugRenderState = {\n\t\t                renderCount: (prevRenderState.renderCount || 0) + 1,\n\t\t                mountTimeStep: prevRenderState.mountTimeStep,\n\t\t                updateTimeStep: timeNow,\n\t\t                trigger: currentTriggerFiber.current,\n\t\t                timeForRender: renderTime,\n\t\t                timeForUpdate: timeNow - prevRenderTime,\n\t\t                maxTimeForRender: Math.max(prevRenderState.maxTimeForRender, renderTime),\n\t\t            };\n\t\t        }\n\t\t    }\n\t\t    safeCallWithCurrentFiber({\n\t\t        fiber: fiber,\n\t\t        action: function safeCallFiberRunListener() {\n\t\t            renderDispatch.callOnAfterFiberRun(fiber);\n\t\t        },\n\t\t    });\n\t\t};\n\n\t\treact.__my_react_shared__.enableDebugFiled;\n\t\tvar currentRunningFiber = react.__my_react_internal__.currentRunningFiber, MyReactInternalInstance = react.__my_react_internal__.MyReactInternalInstance;\n\t\tvar defaultGetContextValue = function (fiber, ContextObject) {\n\t\t    var _a;\n\t\t    if (fiber) {\n\t\t        return fiber.pendingProps[\"value\"];\n\t\t    }\n\t\t    else {\n\t\t        return (_a = ContextObject === null || ContextObject === void 0 ? void 0 : ContextObject.Provider) === null || _a === void 0 ? void 0 : _a[\"value\"];\n\t\t    }\n\t\t};\n\t\tvar defaultGetContextFiber = function (fiber, ContextObject) {\n\t\t    if ((fiber === null || fiber === void 0 ? void 0 : fiber.parent) && ContextObject) {\n\t\t        var parent_1 = fiber.parent;\n\t\t        while (parent_1) {\n\t\t            if (include(parent_1.type, exports.NODE_TYPE.__provider__)) {\n\t\t                var typedElementType = parent_1.elementType;\n\t\t                var contextObj = typedElementType[\"Context\"];\n\t\t                if (contextObj === ContextObject) {\n\t\t                    return parent_1;\n\t\t                }\n\t\t            }\n\t\t            if (include(parent_1.type, exports.NODE_TYPE.__context__)) {\n\t\t                var typedElementType = parent_1.elementType;\n\t\t                var contextObj = typedElementType;\n\t\t                if (contextObj === ContextObject) {\n\t\t                    return parent_1;\n\t\t                }\n\t\t            }\n\t\t            parent_1 = parent_1.parent;\n\t\t        }\n\t\t    }\n\t\t    else {\n\t\t        return null;\n\t\t    }\n\t\t};\n\t\tvar defaultReadContext = function (Context) {\n\t\t    var fiber = currentRunningFiber.current;\n\t\t    if (!Context) {\n\t\t        throw new Error(\"the Context what you read is not exist\");\n\t\t    }\n\t\t    if (!fiber) {\n\t\t        throw new Error('current environment is not support \"readContext\"');\n\t\t    }\n\t\t    var isUpdate = !!fiber.instance;\n\t\t    fiber.instance = fiber.instance || new MyReactInternalInstance();\n\t\t    !isUpdate && initInstance(fiber.instance);\n\t\t    !isUpdate && setOwnerForInstance(fiber.instance, fiber);\n\t\t    var contextFiber = defaultGetContextFiber(fiber, Context);\n\t\t    setSubscribeForInstance(fiber.instance, contextFiber);\n\t\t    return defaultGetContextValue(contextFiber, Context);\n\t\t};\n\t\tvar prepareUpdateAllDependence = function (renderDispatch, fiber, beforeValue, afterValue) {\n\t\t    var consumerList = new Set((fiber === null || fiber === void 0 ? void 0 : fiber.dependence) || []);\n\t\t    consumerList.forEach(function prepareUpdateSingleConsumer(i) {\n\t\t        var owner = getInstanceOwnerFiber(i);\n\t\t        if (owner && exclude(owner.state, STATE_TYPE.__unmount__)) {\n\t\t            var typedFiber_1 = owner;\n\t\t            typedFiber_1.state = STATE_TYPE.__triggerSyncForce__;\n\t\t        }\n\t\t    });\n\t\t    var processedNodes = [];\n\t\t    var updater = {\n\t\t        type: UpdateQueueType.context,\n\t\t        trigger: fiber,\n\t\t        payLoad: afterValue,\n\t\t        isSync: true,\n\t\t        isForce: true,\n\t\t        isImmediate: true,\n\t\t        isRetrigger: true,\n\t\t    };\n\t\t    processedNodes.push(updater);\n\t\t    var updateState = {\n\t\t        needUpdate: true,\n\t\t        nodes: processedNodes,\n\t\t        isSync: true,\n\t\t        isForce: true,\n\t\t        isImmediate: true,\n\t\t        isRetrigger: true,\n\t\t    };\n\t\t    safeCallWithCurrentFiber({\n\t\t        fiber: fiber,\n\t\t        action: function safeCallFiberTriggerListener() {\n\t\t            renderDispatch.callOnFiberTrigger(fiber, updateState);\n\t\t        },\n\t\t    });\n\t\t};\n\n\t\tvar currentScheduler$2 = react.__my_react_internal__.currentScheduler;\n\t\treact.__my_react_shared__.enableScopeTreeLog;\n\t\t// TODO improve\n\t\tvar defaultDispatchMountLatest = function (_dispatch, _fiber) {\n\t\t    beforeSyncUpdate();\n\t\t    var _list = generateFiberToListWithAction(_fiber, function invokeUnmountPendingList(_fiber) {\n\t\t        defaultInvokeUnmountList(_dispatch, _fiber);\n\t\t    });\n\t\t    _list.listToFoot(function invokeInsertionEffectList(_fiber) {\n\t\t        insertionEffect(_dispatch, _fiber);\n\t\t    });\n\t\t    afterSyncUpdate();\n\t\t    _list.listToFoot(function invokeCreateAndUpdateList(_fiber) {\n\t\t        safeCallWithCurrentFiber({\n\t\t            fiber: _fiber,\n\t\t            action: function safeCallCreateAndUpdate() {\n\t\t                _dispatch.commitCreate(_fiber);\n\t\t                _dispatch.commitUpdate(_fiber);\n\t\t            },\n\t\t        });\n\t\t    });\n\t\t    _list.listToFoot(function invokeAppendList(_fiber) {\n\t\t        safeCallWithCurrentFiber({\n\t\t            fiber: _fiber,\n\t\t            action: function safeCallAppendList() {\n\t\t                _dispatch.commitAppend(_fiber);\n\t\t            },\n\t\t        });\n\t\t    });\n\t\t    _list.listToFoot(function invokeSetRefList(_fiber) {\n\t\t        safeCallWithCurrentFiber({\n\t\t            fiber: _fiber,\n\t\t            action: function safeCallSetRefList() {\n\t\t                _dispatch.commitSetRef(_fiber);\n\t\t            },\n\t\t        });\n\t\t    });\n\t\t    beforeSyncUpdate();\n\t\t    _list.listToFoot(function invokeLayoutEffectList(_fiber) {\n\t\t        layoutEffect(_dispatch, _fiber);\n\t\t    });\n\t\t    afterSyncUpdate();\n\t\t    function invokeEffectListTask() {\n\t\t        _list.listToFoot(function invokeEffectList(_fiber) {\n\t\t            effect(_dispatch, _fiber);\n\t\t        });\n\t\t    }\n\t\t    addEffectCallback(invokeEffectListTask);\n\t\t    var renderScheduler = currentScheduler$2.current;\n\t\t    if (_dispatch.enableConcurrentMode) {\n\t\t        renderScheduler.macroTask(function flushEffect() {\n\t\t            flushEffectCallback();\n\t\t        });\n\t\t    }\n\t\t    else {\n\t\t        renderScheduler.microTask(function flushEffect() {\n\t\t            flushEffectCallback();\n\t\t        });\n\t\t    }\n\t\t};\n\t\tvar defaultDispatchMount = defaultDispatchMountLatest;\n\n\t\tvar defaultResolveScope = function (fiber) {\n\t\t    var parent = fiber.parent;\n\t\t    while (parent) {\n\t\t        if (include(parent.type, exports.NODE_TYPE.__scope__) || include(parent.type, exports.NODE_TYPE.__scopeSuspense__)) {\n\t\t            return parent;\n\t\t        }\n\t\t        parent = parent.parent;\n\t\t    }\n\t\t    return null;\n\t\t};\n\n\t\treact.__my_react_shared__.enableDebugFiled;\n\t\tvar defaultGenerateStrict = function (fiber) {\n\t\t    return false;\n\t\t};\n\n\t\tvar currentScheduler$1 = react.__my_react_internal__.currentScheduler;\n\t\treact.__my_react_shared__.enableScopeTreeLog;\n\t\tvar defaultDispatchUpdate = function (_dispatch, _list, sync) {\n\t\t    // TODO maybe need call `insertionEffect` in another function\n\t\t    beforeSyncUpdate();\n\t\t    _list.listToFoot(function invokeUnmountPendingAndInsertionEffectList(_fiber) {\n\t\t        if (exclude(_fiber.state, STATE_TYPE.__unmount__) && !_dispatch.isAppUnmounted) {\n\t\t            defaultInvokeUnmountList(_dispatch, _fiber);\n\t\t        }\n\t\t    });\n\t\t    _list.listToFoot(function invokeUnmountPendingAndInsertionEffectList(_fiber) {\n\t\t        if (exclude(_fiber.state, STATE_TYPE.__unmount__) && !_dispatch.isAppUnmounted) {\n\t\t            insertionEffect(_dispatch, _fiber);\n\t\t        }\n\t\t    });\n\t\t    afterSyncUpdate();\n\t\t    _list.listToFoot(function invokeCreateAndUpdateList(_fiber) {\n\t\t        if (exclude(_fiber.state, STATE_TYPE.__unmount__) && !_dispatch.isAppUnmounted) {\n\t\t            safeCallWithCurrentFiber({\n\t\t                fiber: _fiber,\n\t\t                action: function safeCallCreateAndUpdate() {\n\t\t                    _dispatch.commitCreate(_fiber);\n\t\t                    _dispatch.commitUpdate(_fiber);\n\t\t                },\n\t\t            });\n\t\t        }\n\t\t    });\n\t\t    _list.listToHead(function invokePositionList(_fiber) {\n\t\t        if (exclude(_fiber.state, STATE_TYPE.__unmount__) && !_dispatch.isAppUnmounted) {\n\t\t            safeCallWithCurrentFiber({\n\t\t                fiber: _fiber,\n\t\t                action: function safeCallPosition() {\n\t\t                    _dispatch.commitPosition(_fiber);\n\t\t                },\n\t\t            });\n\t\t        }\n\t\t    });\n\t\t    _list.listToFoot(function invokeAppendList(_fiber) {\n\t\t        if (exclude(_fiber.state, STATE_TYPE.__unmount__) && !_dispatch.isAppUnmounted) {\n\t\t            safeCallWithCurrentFiber({\n\t\t                fiber: _fiber,\n\t\t                action: function safeCallAppendList() {\n\t\t                    _dispatch.commitAppend(_fiber);\n\t\t                },\n\t\t            });\n\t\t        }\n\t\t    });\n\t\t    _list.listToFoot(function invokeSetRefList(_fiber) {\n\t\t        if (exclude(_fiber.state, STATE_TYPE.__unmount__) && !_dispatch.isAppUnmounted) {\n\t\t            safeCallWithCurrentFiber({\n\t\t                fiber: _fiber,\n\t\t                action: function safeCallSetRefList() {\n\t\t                    _dispatch.commitSetRef(_fiber);\n\t\t                },\n\t\t            });\n\t\t        }\n\t\t    });\n\t\t    beforeSyncUpdate();\n\t\t    _list.listToFoot(function invokeLayoutEffectList(_fiber) {\n\t\t        if (exclude(_fiber.state, STATE_TYPE.__unmount__) && !_dispatch.isAppUnmounted) {\n\t\t            layoutEffect(_dispatch, _fiber);\n\t\t        }\n\t\t    });\n\t\t    afterSyncUpdate();\n\t\t    function invokeEffectListTask() {\n\t\t        _list.listToFoot(function invokeEffectList(_fiber) {\n\t\t            if (exclude(_fiber.state, STATE_TYPE.__unmount__) && !_dispatch.isAppUnmounted) {\n\t\t                effect(_dispatch, _fiber);\n\t\t            }\n\t\t        });\n\t\t    }\n\t\t    addEffectCallback(invokeEffectListTask);\n\t\t    var renderScheduler = currentScheduler$1.current;\n\t\t    if (_dispatch.enableConcurrentMode && !sync) {\n\t\t        renderScheduler.macroTask(function flushEffect() {\n\t\t            flushEffectCallback();\n\t\t        });\n\t\t    }\n\t\t    else {\n\t\t        renderScheduler.microTask(function flushEffect() {\n\t\t            flushEffectCallback();\n\t\t        });\n\t\t    }\n\t\t};\n\n\t\tvar currentComponentFiber = react.__my_react_internal__.currentComponentFiber, currentHookNodeIndex = react.__my_react_internal__.currentHookNodeIndex;\n\t\tvar resolveHookValue = function (hookNode, field) {\n\t\t    if (hookNode) {\n\t\t        switch (hookNode.type) {\n\t\t            case HOOK_TYPE.useState:\n\t\t            case HOOK_TYPE.useReducer:\n\t\t                return [hookNode.result, field.dispatch];\n\t\t            case HOOK_TYPE.useId:\n\t\t            case HOOK_TYPE.useRef:\n\t\t            case HOOK_TYPE.useMemo:\n\t\t            case HOOK_TYPE.useContext:\n\t\t            case HOOK_TYPE.useCallback:\n\t\t            case HOOK_TYPE.useDeferredValue:\n\t\t            case HOOK_TYPE.useSyncExternalStore:\n\t\t            case HOOK_TYPE.useEffectEvent:\n\t\t                return hookNode.result;\n\t\t            case HOOK_TYPE.useOptimistic:\n\t\t            case HOOK_TYPE.useTransition:\n\t\t                return [hookNode.result.value, hookNode.result.start];\n\t\t            case HOOK_TYPE.useSignal:\n\t\t                return [hookNode.result.getValue, hookNode.result.setValue];\n\t\t        }\n\t\t    }\n\t\t};\n\t\tvar processHook = function (renderDispatch, _a) {\n\t\t    var type = _a.type, reducer = _a.reducer, value = _a.value, deps = _a.deps;\n\t\t    var fiber = currentComponentFiber.current;\n\t\t    if (!fiber)\n\t\t        throw new Error(\"[@my-react/react] can not use hook outside of component\");\n\t\t    if (!renderDispatch)\n\t\t        throw new Error(\"[@my-react/react] internal error, can not get 'renderDispatch' for current render\");\n\t\t    fiber.hookList = fiber.hookList || new ListTree();\n\t\t    var currentHook = null;\n\t\t    // initial\n\t\t    if (include(fiber.state, STATE_TYPE.__create__ | STATE_TYPE.__recreate__)) {\n\t\t        currentHook = createHookNode(renderDispatch, { type: type, reducer: reducer, value: value, deps: deps }, fiber);\n\t\t        safeCall(function safeCallHookInitialListener() {\n\t\t            renderDispatch.callOnHookInitial(currentHook, fiber);\n\t\t        });\n\t\t    }\n\t\t    else {\n\t\t        // update\n\t\t        currentHook = updateHookNode(renderDispatch, { type: type, reducer: reducer, value: value, deps: deps }, fiber, false);\n\t\t        safeCall(function safeCallHookUpdateListener() {\n\t\t            renderDispatch.callOnHookUpdate(currentHook, fiber);\n\t\t        });\n\t\t    }\n\t\t    currentHookNodeIndex.current++;\n\t\t    var field = getInstanceFieldByInstance(currentHook);\n\t\t    effectHookNode(renderDispatch, fiber, currentHook, field);\n\t\t    return resolveHookValue(currentHook, field);\n\t\t};\n\n\t\tvar enableSuspenseRoot = react.__my_react_shared__.enableSuspenseRoot;\n\t\tvar currentScheduler = react.__my_react_internal__.currentScheduler;\n\t\tvar loadPromise = function (renderDispatch, promise) { return __awaiter(void 0, void 0, void 0, function () {\n\t\t    var value, reason_1;\n\t\t    return __generator(this, function (_a) {\n\t\t        switch (_a.label) {\n\t\t            case 0:\n\t\t                if (promise.status === \"fulfilled\" || promise.status === \"rejected\")\n\t\t                    return [2 /*return*/];\n\t\t                _a.label = 1;\n\t\t            case 1:\n\t\t                _a.trys.push([1, 3, , 4]);\n\t\t                promise.status = \"pending\";\n\t\t                return [4 /*yield*/, Promise.resolve(promise)];\n\t\t            case 2:\n\t\t                value = _a.sent();\n\t\t                promise.status = \"fulfilled\";\n\t\t                promise._value = value;\n\t\t                return [3 /*break*/, 4];\n\t\t            case 3:\n\t\t                reason_1 = _a.sent();\n\t\t                promise.status = \"rejected\";\n\t\t                promise._reason = reason_1;\n\t\t                return [3 /*break*/, 4];\n\t\t            case 4: return [2 /*return*/];\n\t\t        }\n\t\t    });\n\t\t}); };\n\t\tvar processPromise = function (renderDispatch, fiber, promise) {\n\t\t    var _a, _b;\n\t\t    defaultDeleteCurrentEffect(renderDispatch, fiber);\n\t\t    if (promise.status === \"rejected\") {\n\t\t        (_b = (_a = currentScheduler.current).dispatchError) === null || _b === void 0 ? void 0 : _b.call(_a, { fiber: fiber, error: promise._reason });\n\t\t        return null;\n\t\t    }\n\t\t    if (promise.status === \"fulfilled\") ;\n\t\t    promise._list = promise._list || new Set();\n\t\t    promise._list.add(fiber);\n\t\t    var suspenseFiber = renderDispatch.resolveSuspenseFiber(fiber);\n\t\t    if (suspenseFiber) {\n\t\t        var suspenseField = getInstanceFieldByInstance(suspenseFiber.instance);\n\t\t        suspenseField.asyncLoadList.uniPush(promise);\n\t\t        renderDispatch.pendingSuspenseFiberArray.uniPush(suspenseFiber);\n\t\t        return null;\n\t\t    }\n\t\t    else {\n\t\t        // TODO update flow\n\t\t        if (enableSuspenseRoot.current && !renderDispatch.isAppMounted) {\n\t\t            var suspenseField = getInstanceFieldByInstance(renderDispatch);\n\t\t            suspenseField.asyncLoadList.uniPush(promise);\n\t\t            return null;\n\t\t        }\n\t\t        devWarnWithFiber(fiber, \"[@my-react/react] promise must be used inside a Suspense component, otherwise it will not work as expected\");\n\t\t        if (promise._loading)\n\t\t            return null;\n\t\t        promise._loading = true;\n\t\t        promise.status = \"pending\";\n\t\t        var renderScheduler_1 = currentScheduler.current;\n\t\t        renderDispatch\n\t\t            .processPromise(promise)\n\t\t            .then(function () {\n\t\t            fiber.state = STATE_TYPE.__recreate__;\n\t\t            promise._list.delete(fiber);\n\t\t            promise._loading = false;\n\t\t            var updater = {\n\t\t                type: UpdateQueueType.promise,\n\t\t                trigger: fiber,\n\t\t                isSync: true,\n\t\t                isForce: true,\n\t\t                payLoad: promise,\n\t\t            };\n\t\t            renderScheduler_1.dispatchState(updater);\n\t\t        })\n\t\t            .catch(function (e) { return renderScheduler_1.dispatchError({ fiber: fiber, error: e }); });\n\t\t        return null;\n\t\t    }\n\t\t};\n\t\tvar processSuspensePromise = function (renderDispatch, fiber, promise) {\n\t\t    var _a, _b;\n\t\t    defaultDeleteCurrentEffect(renderDispatch, fiber);\n\t\t    fiber.state = STATE_TYPE.__suspense__;\n\t\t    if (promise.status === \"rejected\") {\n\t\t        (_b = (_a = currentScheduler.current).dispatchError) === null || _b === void 0 ? void 0 : _b.call(_a, { fiber: fiber, error: promise._reason });\n\t\t        return null;\n\t\t    }\n\t\t    if (promise.status === \"fulfilled\") ;\n\t\t    promise._list = promise._list || new Set();\n\t\t    promise._list.add(fiber);\n\t\t    if (promise._loading)\n\t\t        return null;\n\t\t    promise._loading = true;\n\t\t    promise.status = \"pending\";\n\t\t    var renderScheduler = currentScheduler.current;\n\t\t    renderDispatch\n\t\t        .processPromise(promise)\n\t\t        .then(function () {\n\t\t        fiber.state = STATE_TYPE.__recreate__;\n\t\t        promise._list.delete(fiber);\n\t\t        promise._loading = false;\n\t\t        var updater = {\n\t\t            type: UpdateQueueType.promise,\n\t\t            trigger: fiber,\n\t\t            isSync: true,\n\t\t            isForce: true,\n\t\t            payLoad: promise,\n\t\t        };\n\t\t        renderScheduler.dispatchState(updater);\n\t\t    })\n\t\t        .catch(function (e) { return renderScheduler.dispatchError({ fiber: fiber, error: e }); });\n\t\t    return null;\n\t\t};\n\n\t\tvar Dispatcher = react.__my_react_internal__.Dispatcher, MyReactInternalInstanceClass = react.__my_react_internal__.MyReactInternalInstance, dispatchToListenerMap = react.__my_react_internal__.dispatchToListenerMap;\n\t\tvar getInitialListeners = function () {\n\t\t    return {\n\t\t            fiberInitial: new Set(),\n\t\t            fiberUpdate: new Set(),\n\t\t            fiberHasChange: new Set(),\n\t\t            fiberUnmount: new Set(),\n\t\t            fiberState: new Set(),\n\t\t            fiberTrigger: new Set(),\n\t\t            instanceInitial: new Set(),\n\t\t            instanceUpdate: new Set(),\n\t\t            instanceState: new Set(),\n\t\t            instanceUnmount: new Set(),\n\t\t            hookInitial: new Set(),\n\t\t            hookUpdate: new Set(),\n\t\t            hookState: new Set(),\n\t\t            hookUnmount: new Set(),\n\t\t            beforeCommitMount: new Set(),\n\t\t            afterCommitMount: new Set(),\n\t\t            beforeCommitUpdate: new Set(),\n\t\t            afterCommitUpdate: new Set(),\n\t\t            beforeCommitUnmount: new Set(),\n\t\t            afterCommitUnmount: new Set(),\n\t\t        };\n\t\t};\n\t\tvar getInitialMap = function () { return ({\n\t\t    effectMap: new MyWeakMap(),\n\t\t    layoutEffectMap: new MyWeakMap(),\n\t\t    insertionEffectMap: new MyWeakMap(),\n\t\t    unmountMap: new MyWeakMap(),\n\t\t    eventMap: new MyWeakMap(),\n\t\t    triggerCallbackMap: new MyWeakMap(),\n\t\t}); };\n\t\tvar getInitialFiber = function () { return ({\n\t\t    scheduledFiber: null,\n\t\t    errorCatchFiber: null,\n\t\t    nextWorkingFiber: null,\n\t\t    retriggerFiber: null,\n\t\t}); };\n\t\tvar initialRef = {\n\t\t    typeForRef: exports.NODE_TYPE.__plain__ | exports.NODE_TYPE.__class__,\n\t\t    typeForCreate: exports.NODE_TYPE.__text__ | exports.NODE_TYPE.__plain__ | exports.NODE_TYPE.__portal__ | exports.NODE_TYPE.__comment__,\n\t\t    typeForUpdate: exports.NODE_TYPE.__text__ | exports.NODE_TYPE.__plain__ | exports.NODE_TYPE.__comment__,\n\t\t    typeForAppend: exports.NODE_TYPE.__text__ | exports.NODE_TYPE.__plain__ | exports.NODE_TYPE.__comment__,\n\t\t    typeForNativeNode: exports.NODE_TYPE.__text__ | exports.NODE_TYPE.__plain__ | exports.NODE_TYPE.__portal__ | exports.NODE_TYPE.__comment__,\n\t\t};\n\t\tvar listenerMap = dispatchToListenerMap;\n\t\tvar RenderDispatchEvent = /** @class */ (function (_super) {\n\t\t    __extends(RenderDispatchEvent, _super);\n\t\t    function RenderDispatchEvent() {\n\t\t        var _this = _super.call(this) || this;\n\t\t        _this.dispatcher = Dispatcher;\n\t\t        _this.runtimeRef = initialRef;\n\t\t        _this.runtimeMap = getInitialMap();\n\t\t        _this.runtimeFiber = getInitialFiber();\n\t\t        listenerMap.set(_this, getInitialListeners());\n\t\t        initInstance(_this);\n\t\t        initVisibleInstance(_this);\n\t\t        initSuspenseInstance(_this);\n\t\t        Object.defineProperty(_this, \"dispatcher\", {\n\t\t            value: Dispatcher,\n\t\t            writable: false,\n\t\t            enumerable: false,\n\t\t            configurable: false,\n\t\t        });\n\t\t        return _this;\n\t\t    }\n\t\t    RenderDispatchEvent.prototype.getFiberTree = function (_fiber) {\n\t\t        throw new Error(\"Method not implemented.\");\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.readPromise = function (_params) {\n\t\t        throw new Error(\"Method not implemented.\");\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.readContext = function (_params) {\n\t\t        throw new Error(\"Method not implemented.\");\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.dispatchHook = function (_params) {\n\t\t        throw new Error(\"Method not implemented.\");\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.dispatchState = function (_params) {\n\t\t        throw new Error(\"Method not implemented.\");\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.dispatchError = function (_params) {\n\t\t        throw new Error(\"Method not implemented.\");\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.dispatchPromise = function (_params) {\n\t\t        throw new Error(\"Method not implemented.\");\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.dispatchSuspensePromise = function (_params) {\n\t\t        throw new Error(\"Method not implemented.\");\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.trigger = function (_fiber, _state, cb) {\n\t\t        return triggerUpdateOnFiber(_fiber, _state, cb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.generateCommitList = function (_fiber) { };\n\t\t    RenderDispatchEvent.prototype.pendingCreate = function (_fiber) { };\n\t\t    RenderDispatchEvent.prototype.pendingUpdate = function (_fiber) { };\n\t\t    RenderDispatchEvent.prototype.pendingAppend = function (_fiber) { };\n\t\t    RenderDispatchEvent.prototype.pendingPosition = function (_fiber) { };\n\t\t    RenderDispatchEvent.prototype.pendingRef = function (_fiber) { };\n\t\t    RenderDispatchEvent.prototype.pendingUnmount = function (_fiber, _pendingUnmount) { };\n\t\t    RenderDispatchEvent.prototype.pendingEffect = function (_fiber, _effect, _option) { };\n\t\t    RenderDispatchEvent.prototype.pendingLayoutEffect = function (_fiber, _layoutEffect, _option) { };\n\t\t    RenderDispatchEvent.prototype.pendingInsertionEffect = function (_fiber, _insertionEffect, _option) { };\n\t\t    RenderDispatchEvent.prototype.dispatchFiber = function (_fiber) { };\n\t\t    RenderDispatchEvent.prototype.processLazy = function (_elementType) {\n\t\t        return Promise.resolve();\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.processPromise = function (_promise) {\n\t\t        return Promise.resolve();\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.commitCreate = function (_fiber) { };\n\t\t    RenderDispatchEvent.prototype.commitUpdate = function (_fiber) { };\n\t\t    RenderDispatchEvent.prototype.commitAppend = function (_fiber) { };\n\t\t    RenderDispatchEvent.prototype.commitPosition = function (_fiber) { };\n\t\t    RenderDispatchEvent.prototype.commitSetRef = function (_fiber) { };\n\t\t    RenderDispatchEvent.prototype.commitUnsetRef = function (_fiber) { };\n\t\t    RenderDispatchEvent.prototype.commitClear = function (_fiber) { };\n\t\t    RenderDispatchEvent.prototype.resolveStrict = function (_fiber) {\n\t\t        return false;\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.resolveScope = function (_fiber) {\n\t\t        return null;\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.resolveSuspenseValue = function (_fiber) {\n\t\t        return null;\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.resolveSuspenseFiber = function (_fiber) {\n\t\t        return null;\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.resolveErrorBoundaries = function (_fiber) {\n\t\t        return null;\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.resolveContextFiber = function (_fiber, _contextObject) {\n\t\t        return null;\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.resolveContextValue = function (_fiber, _contextObject) {\n\t\t        return null;\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.reconcileCommit = function (_fiber) { };\n\t\t    RenderDispatchEvent.prototype.reconcileUpdate = function (_list) { };\n\t\t    RenderDispatchEvent.prototype.reconcileUnmount = function () { };\n\t\t    RenderDispatchEvent.prototype.shouldYield = function () {\n\t\t        return false;\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.resetYield = function () {\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onFiberInitial = function (cb) {\n\t\t        var set = listenerMap.get(this).fiberInitial;\n\t\t        set.add(cb);\n\t\t        return function () { return set.delete(cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceFiberInitial = function (cb) {\n\t\t        var set = listenerMap.get(this).fiberInitial;\n\t\t        var onceCb = function (_fiber) {\n\t\t            cb(_fiber);\n\t\t            set.delete(onceCb);\n\t\t        };\n\t\t        set.add(onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnFiberInitial = function (_fiber) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).fiberInitial;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(_fiber); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onFiberUpdate = function (cb) {\n\t\t        var set = listenerMap.get(this).fiberUpdate;\n\t\t        set.add(cb);\n\t\t        return function () { return set.delete(cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceFiberUpdate = function (cb) {\n\t\t        var set = listenerMap.get(this).fiberUpdate;\n\t\t        var onceCb = function (_fiber) {\n\t\t            cb(_fiber);\n\t\t            set.delete(onceCb);\n\t\t        };\n\t\t        set.add(onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnFiberUpdate = function (_fiber) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).fiberUpdate;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(_fiber); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onFiberChange = function (cb) {\n\t\t        var set = listenerMap.get(this).fiberHasChange;\n\t\t        set.add(cb);\n\t\t        return function () { return set.delete(cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceFiberChange = function (cb) {\n\t\t        var set = listenerMap.get(this).fiberHasChange;\n\t\t        var onceCb = function (_list) {\n\t\t            cb(_list);\n\t\t            set.delete(onceCb);\n\t\t        };\n\t\t        set.add(onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnFiberChange = function (_list) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).fiberHasChange;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(_list); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onFiberUnmount = function (cb) {\n\t\t        var set = listenerMap.get(this).fiberUnmount;\n\t\t        set.add(cb);\n\t\t        return function () { return set.delete(cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceFiberUnmount = function (cb) {\n\t\t        var set = listenerMap.get(this).fiberUnmount;\n\t\t        var onceCb = function (_fiber) {\n\t\t            cb(_fiber);\n\t\t            set.delete(onceCb);\n\t\t        };\n\t\t        set.add(onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnFiberUnmount = function (_fiber) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).fiberUnmount;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(_fiber); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onFiberState = function (cb) {\n\t\t        var set = listenerMap.get(this).fiberState;\n\t\t        set.add(cb);\n\t\t        return function () { return set.delete(cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceFiberState = function (cb) {\n\t\t        var set = listenerMap.get(this).fiberState;\n\t\t        var onceCb = function (_fiber, _updater) {\n\t\t            cb(_fiber, _updater);\n\t\t            set.delete(onceCb);\n\t\t        };\n\t\t        set.add(onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnFiberState = function (_fiber, _updater) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).fiberState;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(_fiber, _updater); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onFiberTrigger = function (cb) {\n\t\t        var set = listenerMap.get(this).fiberTrigger;\n\t\t        set.add(cb);\n\t\t        return function () { return set.delete(cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceFiberTrigger = function (cb) {\n\t\t        var set = listenerMap.get(this).fiberTrigger;\n\t\t        var onceCb = function (_fiber, _state) {\n\t\t            cb(_fiber, _state);\n\t\t            set.delete(onceCb);\n\t\t        };\n\t\t        set.add(onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnFiberTrigger = function (_fiber, _state) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).fiberTrigger;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(_fiber, _state); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onFiberHMR = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).fiberHMR;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, cb);\n\t\t        return function () { var _a; return (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceFiberHMR = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).fiberHMR;\n\t\t        var onceCb = function (_fiber, _forceRefresh) {\n\t\t            var _a;\n\t\t            cb(_fiber, _forceRefresh);\n\t\t            (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t        };\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnFiberHMR = function (_fiber, _forceRefresh) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).fiberHMR;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(_fiber, _forceRefresh); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onFiberWarn = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).fiberWarn;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, cb);\n\t\t        return function () { var _a; return (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceFiberWarn = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).fiberWarn;\n\t\t        var onceCb = function (_fiber) {\n\t\t            var _a;\n\t\t            cb(_fiber);\n\t\t            (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t        };\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnFiberWarn = function (_fiber) {\n\t\t        var _a;\n\t\t        var args = [];\n\t\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t\t            args[_i - 1] = arguments[_i];\n\t\t        }\n\t\t        var set = listenerMap.get(this).fiberWarn;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb.apply(void 0, __spreadArray([_fiber], args, false)); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onFiberError = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).fiberError;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, cb);\n\t\t        return function () { var _a; return (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceFiberError = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).fiberError;\n\t\t        var onceCb = function (_fiber) {\n\t\t            var _a;\n\t\t            cb(_fiber);\n\t\t            (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t        };\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnFiberError = function (_fiber) {\n\t\t        var _a;\n\t\t        var args = [];\n\t\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t\t            args[_i - 1] = arguments[_i];\n\t\t        }\n\t\t        var set = listenerMap.get(this).fiberError;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb.apply(void 0, __spreadArray([_fiber], args, false)); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onPerformanceWarn = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).performanceWarn;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, cb);\n\t\t        return function () { var _a; return (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.oncePerformanceWarn = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).performanceWarn;\n\t\t        var onceCb = function (_fiber, _renderTime) {\n\t\t            var _a;\n\t\t            cb(_fiber, _renderTime);\n\t\t            (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t        };\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnPerformanceWarn = function (_fiber, _renderTime) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).performanceWarn;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(_fiber, _renderTime); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onBeforeFiberRun = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).beforeFiberRun;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, cb);\n\t\t        return function () { var _a; return (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceBeforeFiberRun = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).beforeFiberRun;\n\t\t        var onceCb = function (_fiber) {\n\t\t            var _a;\n\t\t            cb(_fiber);\n\t\t            (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t        };\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnBeforeFiberRun = function (_fiber) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).beforeFiberRun;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(_fiber); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onAfterFiberRun = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).afterFiberRun;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, cb);\n\t\t        return function () { var _a; return (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceAfterFiberRun = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).afterFiberRun;\n\t\t        var onceCb = function (_fiber) {\n\t\t            var _a;\n\t\t            cb(_fiber);\n\t\t            (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t        };\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnAfterFiberRun = function (_fiber) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).afterFiberRun;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(_fiber); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onAfterFiberDone = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).afterFiberDone;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, cb);\n\t\t        return function () { var _a; return (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceAfterFiberDone = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).afterFiberDone;\n\t\t        var onceCb = function (_fiber) {\n\t\t            var _a;\n\t\t            cb(_fiber);\n\t\t            (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t        };\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnAfterFiberDone = function (_fiber) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).afterFiberDone;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(_fiber); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onBeforeDispatchRender = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).beforeDispatchRender;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, cb);\n\t\t        return function () { var _a; return (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceBeforeDispatchRender = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).beforeDispatchRender;\n\t\t        var onceCb = function (renderDispatch, fiber) {\n\t\t            var _a;\n\t\t            cb(renderDispatch, fiber);\n\t\t            (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t        };\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnBeforeDispatchRender = function (renderDispatch, fiber) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).beforeDispatchRender;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(renderDispatch, fiber); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onAfterDispatchRender = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).afterDispatchRender;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, cb);\n\t\t        return function () { var _a; return (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceAfterDispatchRender = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).afterDispatchRender;\n\t\t        var onceCb = function (renderDispatch) {\n\t\t            var _a;\n\t\t            cb(renderDispatch);\n\t\t            (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t        };\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnAfterDispatchRender = function (renderDispatch) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).afterDispatchRender;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(renderDispatch); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onBeforeDispatchUpdate = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).beforeDispatchUpdate;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, cb);\n\t\t        return function () { var _a; return (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceBeforeDispatchUpdate = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).beforeDispatchUpdate;\n\t\t        var onceCb = function (renderDispatch, list) {\n\t\t            var _a;\n\t\t            cb(renderDispatch, list);\n\t\t            (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t        };\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnBeforeDispatchUpdate = function (renderDispatch, list) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).beforeDispatchUpdate;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(renderDispatch, list); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onAfterDispatchUpdate = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).afterDispatchUpdate;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, cb);\n\t\t        return function () { var _a; return (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceAfterDispatchUpdate = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).afterDispatchUpdate;\n\t\t        var onceCb = function (renderDispatch) {\n\t\t            var _a;\n\t\t            cb(renderDispatch);\n\t\t            (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t        };\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnAfterDispatchUpdate = function (renderDispatch) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).afterDispatchUpdate;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(renderDispatch); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onInstanceInitial = function (cb) {\n\t\t        var set = listenerMap.get(this).instanceInitial;\n\t\t        set.add(cb);\n\t\t        return function () { return set.delete(cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceInstanceInitial = function (cb) {\n\t\t        var set = listenerMap.get(this).instanceInitial;\n\t\t        var onceCb = function (_instance, _fiber) {\n\t\t            cb(_instance, _fiber);\n\t\t            set.delete(onceCb);\n\t\t        };\n\t\t        set.add(onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnInstanceInitial = function (_instance, _fiber) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).instanceInitial;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(_instance, _fiber); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onInstanceUpdate = function (cb) {\n\t\t        var set = listenerMap.get(this).instanceUpdate;\n\t\t        set.add(cb);\n\t\t        return function () { return set.delete(cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceInstanceUpdate = function (cb) {\n\t\t        var set = listenerMap.get(this).instanceUpdate;\n\t\t        var onceCb = function (_instance, _fiber) {\n\t\t            cb(_instance, _fiber);\n\t\t            set.delete(onceCb);\n\t\t        };\n\t\t        set.add(onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnInstanceUpdate = function (_instance, _fiber) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).instanceUpdate;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(_instance, _fiber); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onInstanceState = function (cb) {\n\t\t        var set = listenerMap.get(this).instanceState;\n\t\t        set.add(cb);\n\t\t        return function () { return set.delete(cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceInstanceState = function (cb) {\n\t\t        var set = listenerMap.get(this).instanceState;\n\t\t        var onceCb = function (_instance, _fiber, _updater) {\n\t\t            cb(_instance, _fiber, _updater);\n\t\t            set.delete(onceCb);\n\t\t        };\n\t\t        set.add(onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnInstanceState = function (_instance, _fiber, _updater) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).instanceState;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(_instance, _fiber, _updater); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onInstanceUnmount = function (cb) {\n\t\t        var set = listenerMap.get(this).instanceUnmount;\n\t\t        set.add(cb);\n\t\t        return function () { return set.delete(cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceInstanceUnmount = function (cb) {\n\t\t        var set = listenerMap.get(this).instanceUnmount;\n\t\t        var onceCb = function (_instance, _fiber) {\n\t\t            cb(_instance, _fiber);\n\t\t            set.delete(onceCb);\n\t\t        };\n\t\t        set.add(onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnInstanceUnmount = function (_instance, _fiber) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).instanceUnmount;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(_instance, _fiber); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onHookInitial = function (cb) {\n\t\t        var set = listenerMap.get(this).hookInitial;\n\t\t        set.add(cb);\n\t\t        return function () { return set.delete(cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceHookInitial = function (cb) {\n\t\t        var set = listenerMap.get(this).hookInitial;\n\t\t        var onceCb = function (_hook, _fiber) {\n\t\t            cb(_hook, _fiber);\n\t\t            set.delete(onceCb);\n\t\t        };\n\t\t        set.add(onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnHookInitial = function (_hook, _fiber) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).hookInitial;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(_hook, _fiber); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onHookUpdate = function (cb) {\n\t\t        var set = listenerMap.get(this).hookUpdate;\n\t\t        set.add(cb);\n\t\t        return function () { return set.delete(cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceHookUpdate = function (cb) {\n\t\t        var set = listenerMap.get(this).hookUpdate;\n\t\t        var onceCb = function (_hook, _fiber) {\n\t\t            cb(_hook, _fiber);\n\t\t            set.delete(onceCb);\n\t\t        };\n\t\t        set.add(onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnHookUpdate = function (_hook, _fiber) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).hookUpdate;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(_hook, _fiber); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onHookUnmount = function (cb) {\n\t\t        var set = listenerMap.get(this).hookUnmount;\n\t\t        set.add(cb);\n\t\t        return function () { return set.delete(cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceHookUnmount = function (cb) {\n\t\t        var set = listenerMap.get(this).hookUnmount;\n\t\t        var onceCb = function (_hook, _fiber) {\n\t\t            cb(_hook, _fiber);\n\t\t            set.delete(onceCb);\n\t\t        };\n\t\t        set.add(onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnHookUnmount = function (_hook, _fiber) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).hookUnmount;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(_hook, _fiber); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onHookState = function (cb) {\n\t\t        var set = listenerMap.get(this).hookState;\n\t\t        set.add(cb);\n\t\t        return function () { return set.delete(cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceHookTrigger = function (cb) {\n\t\t        var set = listenerMap.get(this).hookState;\n\t\t        var onceCb = function (_hook, _fiber, _updater) {\n\t\t            cb(_hook, _fiber, _updater);\n\t\t            set.delete(onceCb);\n\t\t        };\n\t\t        set.add(onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnHookState = function (_hook, _fiber, _updater) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).hookState;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(_hook, _fiber, _updater); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onBeforeCommitMount = function (cb) {\n\t\t        var set = listenerMap.get(this).beforeCommitMount;\n\t\t        set.add(cb);\n\t\t        return function () { return set.delete(cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceBeforeCommitMount = function (cb) {\n\t\t        var set = listenerMap.get(this).beforeCommitMount;\n\t\t        var onceCb = function (renderDispatch) {\n\t\t            cb(renderDispatch);\n\t\t            set.delete(onceCb);\n\t\t        };\n\t\t        set.add(onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnBeforeCommitMount = function (renderDispatch) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).beforeCommitMount;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(renderDispatch); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onAfterCommitMount = function (cb) {\n\t\t        var set = listenerMap.get(this).afterCommitMount;\n\t\t        set.add(cb);\n\t\t        return function () { return set.delete(cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceAfterCommitMount = function (cb) {\n\t\t        var set = listenerMap.get(this).afterCommitMount;\n\t\t        var onceCb = function (renderDispatch) {\n\t\t            cb(renderDispatch);\n\t\t            set.delete(onceCb);\n\t\t        };\n\t\t        set.add(onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnAfterCommitMount = function (renderDispatch) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).afterCommitMount;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(renderDispatch); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onBeforeCommitUpdate = function (cb) {\n\t\t        var set = listenerMap.get(this).beforeCommitUpdate;\n\t\t        set.add(cb);\n\t\t        return function () { return set.delete(cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceBeforeCommitUpdate = function (cb) {\n\t\t        var set = listenerMap.get(this).beforeCommitUpdate;\n\t\t        var onceCb = function (renderDispatch) {\n\t\t            cb(renderDispatch);\n\t\t            set.delete(onceCb);\n\t\t        };\n\t\t        set.add(onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnBeforeCommitUpdate = function (renderDispatch) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).beforeCommitUpdate;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(renderDispatch); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onAfterCommitUpdate = function (cb) {\n\t\t        var set = listenerMap.get(this).afterCommitUpdate;\n\t\t        set.add(cb);\n\t\t        return function () { return set.delete(cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceAfterCommitUpdate = function (cb) {\n\t\t        var set = listenerMap.get(this).afterCommitUpdate;\n\t\t        var onceCb = function (renderDispatch) {\n\t\t            cb(renderDispatch);\n\t\t            set.delete(onceCb);\n\t\t        };\n\t\t        set.add(onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnAfterCommitUpdate = function (renderDispatch) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).afterCommitUpdate;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(renderDispatch); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onBeforeCommitUnmount = function (cb) {\n\t\t        var set = listenerMap.get(this).beforeCommitUnmount;\n\t\t        set.add(cb);\n\t\t        return function () { return set.delete(cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceBeforeCommitUnmount = function (cb) {\n\t\t        var set = listenerMap.get(this).beforeCommitUnmount;\n\t\t        var onceCb = function (renderDispatch) {\n\t\t            cb(renderDispatch);\n\t\t            set.delete(onceCb);\n\t\t        };\n\t\t        set.add(onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnBeforeCommitUnmount = function (renderDispatch) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).beforeCommitUnmount;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(renderDispatch); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onAfterCommitUnmount = function (cb) {\n\t\t        var set = listenerMap.get(this).afterCommitUnmount;\n\t\t        set.add(cb);\n\t\t        return function () { return set.delete(cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceAfterCommitUnmount = function (cb) {\n\t\t        var set = listenerMap.get(this).afterCommitUnmount;\n\t\t        var onceCb = function (renderDispatch) {\n\t\t            cb(renderDispatch);\n\t\t            set.delete(onceCb);\n\t\t        };\n\t\t        set.add(onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnAfterCommitUnmount = function (renderDispatch) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).afterCommitUnmount;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(renderDispatch); });\n\t\t    };\n\t\t    return RenderDispatchEvent;\n\t\t}(MyReactInternalInstanceClass));\n\n\t\tvar defaultDispatchFiber = function (renderDispatch, fiber) {\n\t\t    if (include(fiber.type, exports.NODE_TYPE.__root__)) {\n\t\t        // TODO\n\t\t        nextWorkRoot(renderDispatch, fiber);\n\t\t    }\n\t\t    else if (include(fiber.type, exports.NODE_TYPE.__class__ | exports.NODE_TYPE.__function__)) {\n\t\t        nextWorkComponent(renderDispatch, fiber);\n\t\t    }\n\t\t    else if (include(fiber.type, exports.NODE_TYPE.__lazy__)) {\n\t\t        nextWorkLazy(renderDispatch, fiber);\n\t\t    }\n\t\t    else if (include(fiber.type, exports.NODE_TYPE.__suspense__)) {\n\t\t        nextWorkSuspense(renderDispatch, fiber);\n\t\t    }\n\t\t    else if (include(fiber.type, exports.NODE_TYPE.__consumer__)) {\n\t\t        nextWorkConsumer(renderDispatch, fiber);\n\t\t    }\n\t\t    else if (include(fiber.type, exports.NODE_TYPE.__provider__ | exports.NODE_TYPE.__context__)) {\n\t\t        nextWorkProvider(renderDispatch, fiber);\n\t\t    }\n\t\t    else if (include(fiber.type, exports.NODE_TYPE.__activity__)) {\n\t\t        nextWorkActivity(renderDispatch, fiber);\n\t\t    }\n\t\t    else {\n\t\t        nextWorkNormal(renderDispatch, fiber);\n\t\t    }\n\t\t};\n\n\t\tvar CustomRenderDispatch = /** @class */ (function (_super) {\n\t\t    __extends(CustomRenderDispatch, _super);\n\t\t    function CustomRenderDispatch(rootNode, rootFiber, rootElement) {\n\t\t        var _this = _super.call(this) || this;\n\t\t        _this.rootNode = rootNode;\n\t\t        _this.rootFiber = rootFiber;\n\t\t        _this.isAppMounted = false;\n\t\t        _this.isAppCrashed = false;\n\t\t        _this.isAppUnmounted = false;\n\t\t        _this.version = \"0.3.21\";\n\t\t        _this.id = Math.random().toString(16).slice(2);\n\t\t        _this.mode = \"production\";\n\t\t        _this.renderMode = \"render\";\n\t\t        _this.pendingCommitFiberList = null;\n\t\t        _this.pendingCommitFiberPatch = PATCH_TYPE.__initial__;\n\t\t        _this.pendingChangedFiberList = null;\n\t\t        _this.pendingUpdateFiberArray = new UniqueArray();\n\t\t        _this.pendingSuspenseFiberArray = new UniqueArray();\n\t\t        _this.uniqueIdCount = 0;\n\t\t        _this.rootElement = rootElement;\n\t\t        var typedFiber = rootFiber;\n\t\t        typedFiber.renderDispatch = _this;\n\t\t        return _this;\n\t\t    }\n\t\t    CustomRenderDispatch.prototype.generateCommitList = function (_fiber) {\n\t\t        if (!_fiber)\n\t\t            return;\n\t\t        this.pendingCommitFiberPatch = merge(this.pendingCommitFiberPatch, _fiber.patch);\n\t\t        if (_fiber.patch !== PATCH_TYPE.__initial__) {\n\t\t            this.pendingCommitFiberList = this.pendingCommitFiberList || new ListTree();\n\t\t            this.pendingCommitFiberList.push(_fiber);\n\t\t        }\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.generateChangedList = function (_fiber, withCheck) {\n\t\t        if (!_fiber)\n\t\t            return;\n\t\t        if (!this.isAppMounted)\n\t\t            return;\n\t\t        this.pendingChangedFiberList = this.pendingChangedFiberList || new ListTree();\n\t\t        if (withCheck && this.pendingChangedFiberList.hasValue(_fiber)) {\n\t\t            return;\n\t\t        }\n\t\t        this.pendingChangedFiberList.push(_fiber);\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.pendingCreate = function (_fiber) {\n\t\t        if (include(_fiber.type, this.runtimeRef.typeForCreate)) {\n\t\t            _fiber.patch = merge(_fiber.patch, PATCH_TYPE.__create__);\n\t\t        }\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.pendingUpdate = function (_fiber) {\n\t\t        if (include(_fiber.type, this.runtimeRef.typeForUpdate)) {\n\t\t            _fiber.patch = merge(_fiber.patch, PATCH_TYPE.__update__);\n\t\t        }\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.pendingAppend = function (_fiber) {\n\t\t        if (include(_fiber.type, this.runtimeRef.typeForAppend)) {\n\t\t            _fiber.patch = merge(_fiber.patch, PATCH_TYPE.__append__);\n\t\t        }\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.pendingPosition = function (_fiber) {\n\t\t        _fiber.patch = merge(_fiber.patch, PATCH_TYPE.__position__);\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.pendingRef = function (_fiber) {\n\t\t        if (_fiber.ref) {\n\t\t            if (include(_fiber.type, this.runtimeRef.typeForRef)) {\n\t\t                _fiber.patch = merge(_fiber.patch, PATCH_TYPE.__ref__);\n\t\t            }\n\t\t            else if (exclude(_fiber.type, exports.NODE_TYPE.__forwardRef__)) {\n\t\t                onceWarnWithKeyAndFiber(_fiber, \"ref\", \"[@my-react/react] set ref for current element will be ignored\");\n\t\t            }\n\t\t        }\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.pendingUnmount = function (_fiber, _pendingUnmount) {\n\t\t        _fiber.patch = merge(_fiber.patch, PATCH_TYPE.__unmount__);\n\t\t        defaultGenerateUnmountMap(_fiber, _pendingUnmount, this.runtimeMap.unmountMap);\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.pendingEffect = function (_fiber, _effect, option) {\n\t\t        _fiber.patch = merge(_fiber.patch, PATCH_TYPE.__effect__);\n\t\t        defaultGenerateEffectMap(_fiber, _effect, this.runtimeMap.effectMap, option);\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.pendingLayoutEffect = function (_fiber, _layoutEffect, option) {\n\t\t        _fiber.patch = merge(_fiber.patch, PATCH_TYPE.__layoutEffect__);\n\t\t        defaultGenerateEffectMap(_fiber, _layoutEffect, this.runtimeMap.layoutEffectMap, option);\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.pendingInsertionEffect = function (_fiber, _insertionEffect, option) {\n\t\t        _fiber.patch = merge(_fiber.patch, PATCH_TYPE.__insertionEffect__);\n\t\t        defaultGenerateEffectMap(_fiber, _insertionEffect, this.runtimeMap.insertionEffectMap, option);\n\t\t    };\n\t\t    /**\n\t\t     * @deprecated\n\t\t     */\n\t\t    CustomRenderDispatch.prototype.patchToFiberInitial = function (_fiber) {\n\t\t    };\n\t\t    /**\n\t\t     * @deprecated\n\t\t     */\n\t\t    CustomRenderDispatch.prototype.patchToFiberUpdate = function (_fiber) {\n\t\t    };\n\t\t    /**\n\t\t     * @deprecated\n\t\t     */\n\t\t    CustomRenderDispatch.prototype.patchToFiberUnmount = function (_fiber) {\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.dispatchFiber = function (_fiber) {\n\t\t        defaultDispatchFiber(this, _fiber);\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.processLazy = function (_elementType) {\n\t\t        return loadLazy(this, _elementType);\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.processPromise = function (_promise) {\n\t\t        return loadPromise(this, _promise);\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.commitCreate = function (_fiber) {\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.commitUpdate = function (_fiber) {\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.commitAppend = function (_fiber) {\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.commitPosition = function (_fiber) {\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.commitSetRef = function (_fiber) {\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.commitUnsetRef = function (_fiber) {\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.commitClear = function (_fiber) {\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.resolveStrict = function (_fiber) {\n\t\t        return defaultGenerateStrict();\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.resolveScope = function (_fiber) {\n\t\t        return defaultResolveScope(_fiber);\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.resolveSuspenseValue = function (_fiber) {\n\t\t        return defaultResolveSuspenseValue(_fiber);\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.resolveSuspenseFiber = function (_fiber) {\n\t\t        return defaultResolveSuspenseFiber(_fiber);\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.resolveErrorBoundaries = function (_fiber) {\n\t\t        return defaultResolveErrorBoundaries(_fiber);\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.resolveContextFiber = function (_fiber, _contextObject) {\n\t\t        return defaultGetContextFiber(_fiber, _contextObject);\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.resolveContextValue = function (_fiber, _contextObject) {\n\t\t        return defaultGetContextValue(_fiber, _contextObject);\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.reconcileCommit = function (_fiber) {\n\t\t        var instance = this;\n\t\t        safeCall(function safeCallBeforeCommit() {\n\t\t            var _a;\n\t\t            (_a = instance.beforeCommit) === null || _a === void 0 ? void 0 : _a.call(instance);\n\t\t        });\n\t\t        safeCall(function safeCallBeforeCommitListener() {\n\t\t            instance.callOnBeforeCommitMount(instance);\n\t\t        });\n\t\t        defaultDispatchMount(this, _fiber);\n\t\t        safeCall(function safeCallAfterCommitListener() {\n\t\t            instance.callOnAfterCommitMount(instance);\n\t\t        });\n\t\t        safeCall(function safeCallAfterCommit() {\n\t\t            var _a;\n\t\t            (_a = instance.afterCommit) === null || _a === void 0 ? void 0 : _a.call(instance);\n\t\t        });\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.reconcileUpdate = function (_list, sync) {\n\t\t        var instance = this;\n\t\t        safeCall(function safeCallBeforeUpdate() {\n\t\t            var _a;\n\t\t            (_a = instance.beforeUpdate) === null || _a === void 0 ? void 0 : _a.call(instance);\n\t\t        });\n\t\t        safeCall(function safeCallBeforeUpdateListener() {\n\t\t            instance.callOnBeforeCommitUpdate(instance);\n\t\t        });\n\t\t        defaultDispatchUpdate(this, _list, sync);\n\t\t        safeCall(function safeCallAfterUpdateListener() {\n\t\t            instance.callOnAfterCommitUpdate(instance);\n\t\t        });\n\t\t        safeCall(function safeCallAfterUpdate() {\n\t\t            var _a;\n\t\t            (_a = instance.afterUpdate) === null || _a === void 0 ? void 0 : _a.call(instance);\n\t\t        });\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.reconcileUnmount = function () {\n\t\t        var instance = this;\n\t\t        safeCall(function safeCallBeforeUnmount() {\n\t\t            var _a;\n\t\t            (_a = instance.beforeUnmount) === null || _a === void 0 ? void 0 : _a.call(instance);\n\t\t        });\n\t\t        safeCall(function safeCallBeforeUnmountListener() {\n\t\t            instance.callOnBeforeCommitUnmount(instance);\n\t\t        });\n\t\t        defaultDispatchUnmount(this);\n\t\t        safeCall(function safeCallAfterUnmountListener() {\n\t\t            instance.callOnAfterCommitUnmount(instance);\n\t\t        });\n\t\t        safeCall(function safeCallAfterUnmount() {\n\t\t            var _a;\n\t\t            (_a = instance.afterUnmount) === null || _a === void 0 ? void 0 : _a.call(instance);\n\t\t        });\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.shouldYield = function () {\n\t\t        return false;\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.resetYield = function () {\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.resetUpdateFlowRuntimeFiber = function () {\n\t\t        this.runtimeFiber.scheduledFiber = null;\n\t\t        this.runtimeFiber.nextWorkingFiber = null;\n\t\t        this.runtimeFiber.retriggerFiber = null;\n\t\t        this.pendingCommitFiberPatch = PATCH_TYPE.__initial__;\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.getFiberTree = function (_fiber) {\n\t\t        return getFiberTree$1(_fiber);\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.readPromise = function (_params) {\n\t\t        return defaultReadPromise(_params);\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.readContext = function (_params) {\n\t\t        return defaultReadContext(_params);\n\t\t    };\n\t\t    return CustomRenderDispatch;\n\t\t}(RenderDispatchEvent));\n\n\t\tvar globalLoop = react.__my_react_internal__.globalLoop;\n\t\treact.__my_react_shared__.enableScopeTreeLog;\n\t\tfunction finishMountSync(renderDispatch, fiber) {\n\t\t    renderDispatch.reconcileCommit(fiber);\n\t\t    var changedList = renderDispatch.pendingChangedFiberList;\n\t\t    renderDispatch.resetUpdateFlowRuntimeFiber();\n\t\t    renderDispatch.pendingCommitFiberList = null;\n\t\t    renderDispatch.pendingChangedFiberList = null;\n\t\t    (changedList === null || changedList === void 0 ? void 0 : changedList.length) &&\n\t\t        safeCallWithCurrentFiber({\n\t\t            fiber: fiber,\n\t\t            action: function safeCallFiberHasChangeListener() {\n\t\t                renderDispatch.callOnFiberChange(changedList);\n\t\t            },\n\t\t        });\n\t\t}\n\t\tvar mountSync = function (renderDispatch, fiber) {\n\t\t    globalLoop.current = true;\n\t\t    mountLoopAll(renderDispatch, fiber);\n\t\t    processAsyncLoadListOnSyncMount(renderDispatch);\n\t\t    finishMountSync(renderDispatch, fiber);\n\t\t    globalLoop.current = false;\n\t\t};\n\t\tfunction finishMountAsync(renderDispatch, fiber) {\n\t\t    renderDispatch.reconcileCommit(fiber);\n\t\t    var changedList = renderDispatch.pendingChangedFiberList;\n\t\t    renderDispatch.resetUpdateFlowRuntimeFiber();\n\t\t    renderDispatch.pendingCommitFiberList = null;\n\t\t    renderDispatch.pendingChangedFiberList = null;\n\t\t    (changedList === null || changedList === void 0 ? void 0 : changedList.length) &&\n\t\t        safeCallWithCurrentFiber({\n\t\t            fiber: fiber,\n\t\t            action: function safeCallFiberHasChangeListener() {\n\t\t                renderDispatch.callOnFiberChange(changedList);\n\t\t            },\n\t\t        });\n\t\t}\n\t\tvar mountAsync = function (renderDispatch, fiber) { return __awaiter(void 0, void 0, void 0, function () {\n\t\t    return __generator(this, function (_a) {\n\t\t        switch (_a.label) {\n\t\t            case 0:\n\t\t                globalLoop.current = true;\n\t\t                mountLoopAll(renderDispatch, fiber);\n\t\t                return [4 /*yield*/, processAsyncLoadListOnAsyncMount(renderDispatch)];\n\t\t            case 1:\n\t\t                _a.sent();\n\t\t                finishMountAsync(renderDispatch, fiber);\n\t\t                globalLoop.current = false;\n\t\t                return [2 /*return*/];\n\t\t        }\n\t\t    });\n\t\t}); };\n\n\t\tvar version = \"0.3.21\";\n\n\t\texports.CustomRenderDispatch = CustomRenderDispatch;\n\t\texports.MyReactFiberNode = MyReactFiberNode;\n\t\texports.MyReactHookNode = MyReactHookNode;\n\t\texports.MyWeakMap = MyWeakMap;\n\t\texports.RenderDispatchEvent = RenderDispatchEvent;\n\t\texports.WrapperByLazyScope = WrapperByLazyScope;\n\t\texports.WrapperBySuspenseScope = WrapperBySuspenseScope;\n\t\texports.addEffectCallback = addEffectCallback;\n\t\texports.afterSyncFlush = afterSyncFlush;\n\t\texports.afterSyncUpdate = afterSyncUpdate;\n\t\texports.applyTriggerFiberCb = applyTriggerFiberCb;\n\t\texports.beforeSyncFlush = beforeSyncFlush;\n\t\texports.beforeSyncUpdate = beforeSyncUpdate;\n\t\texports.callWithFiber = callWithFiber;\n\t\texports.checkIsMyReactFiberNode = checkIsMyReactFiberNode;\n\t\texports.checkIsSameType = checkIsSameType;\n\t\texports.clearContainer = clearContainer;\n\t\texports.clearFiberNode = clearFiberNode;\n\t\texports.createFiberNode = createFiberNode;\n\t\texports.createHookNode = createHookNode;\n\t\texports.currentRefreshHandler = currentRefreshHandler;\n\t\texports.currentTriggerFiber = currentTriggerFiber;\n\t\texports.debugWithNode = debugWithNode;\n\t\texports.defaultDeleteChildEffect = defaultDeleteChildEffect;\n\t\texports.defaultDeleteCurrentEffect = defaultDeleteCurrentEffect;\n\t\texports.defaultDispatchMount = defaultDispatchMount;\n\t\texports.defaultDispatchMountLatest = defaultDispatchMountLatest;\n\t\texports.defaultDispatchUnmount = defaultDispatchUnmount;\n\t\texports.defaultDispatchUpdate = defaultDispatchUpdate;\n\t\texports.defaultGenerateEffectMap = defaultGenerateEffectMap;\n\t\texports.defaultGenerateStrict = defaultGenerateStrict;\n\t\texports.defaultGenerateUnmountMap = defaultGenerateUnmountMap;\n\t\texports.defaultGetContextFiber = defaultGetContextFiber;\n\t\texports.defaultGetContextValue = defaultGetContextValue;\n\t\texports.defaultInvokeEffect = defaultInvokeEffect;\n\t\texports.defaultInvokeInsertionEffect = defaultInvokeInsertionEffect;\n\t\texports.defaultInvokeLayoutEffect = defaultInvokeLayoutEffect;\n\t\texports.defaultInvokeUnmountList = defaultInvokeUnmountList;\n\t\texports.defaultReadContext = defaultReadContext;\n\t\texports.defaultReadPromise = defaultReadPromise;\n\t\texports.defaultResolveAliveSuspenseFiber = defaultResolveAliveSuspenseFiber;\n\t\texports.defaultResolveErrorBoundaries = defaultResolveErrorBoundaries;\n\t\texports.defaultResolveScope = defaultResolveScope;\n\t\texports.defaultResolveSuspenseFiber = defaultResolveSuspenseFiber;\n\t\texports.defaultResolveSuspenseValue = defaultResolveSuspenseValue;\n\t\texports.devError = devError;\n\t\texports.devErrorWithFiber = devErrorWithFiber;\n\t\texports.devWarn = devWarn;\n\t\texports.devWarnWithFiber = devWarnWithFiber;\n\t\texports.effect = effect;\n\t\texports.effectHookNode = effectHookNode;\n\t\texports.emptyProps = emptyProps;\n\t\texports.enableDebugUpdateQueue = enableDebugUpdateQueue;\n\t\texports.enableFiberForLog = enableFiberForLog;\n\t\texports.enableLogForCurrentFlowIsRunning = enableLogForCurrentFlowIsRunning;\n\t\texports.enableValidMyReactElement = enableValidMyReactElement;\n\t\texports.fiberToDispatchMap = fiberToDispatchMap;\n\t\texports.flushEffectCallback = flushEffectCallback;\n\t\texports.generateFiberToListWithAction = generateFiberToListWithAction;\n\t\texports.generateFiberToMountList = generateFiberToMountList;\n\t\texports.generateFiberToUnmountList = generateFiberToUnmountList;\n\t\texports.getClassInstanceFieldByInstance = getClassInstanceFieldByInstance;\n\t\texports.getCurrentDispatchFromFiber = getCurrentDispatchFromFiber;\n\t\texports.getCurrentDispatchFromType = getCurrentDispatchFromType;\n\t\texports.getCurrentFibersFromType = getCurrentFibersFromType;\n\t\texports.getCurrentTypeFromRefresh = getCurrentTypeFromRefresh;\n\t\texports.getCurrentTypeFromRefreshOnly = getCurrentTypeFromRefreshOnly;\n\t\texports.getElementFromRefreshIfExist = getElementFromRefreshIfExist;\n\t\texports.getElementName = getElementName;\n\t\texports.getElementTypeFromType = getElementTypeFromType;\n\t\texports.getFiberTree = getFiberTree$1;\n\t\texports.getFiberTreeWithFiber = getFiberTreeWithFiber;\n\t\texports.getHookTree = getHookTree;\n\t\texports.getInstanceContextFiber = getInstanceContextFiber;\n\t\texports.getInstanceEffectState = getInstanceEffectState;\n\t\texports.getInstanceFieldByInstance = getInstanceFieldByInstance;\n\t\texports.getInstanceOwnerFiber = getInstanceOwnerFiber;\n\t\texports.getPlainFiberName = getPlainFiberName;\n\t\texports.getStackTree = getStackTree;\n\t\texports.getTypeFromElement = getTypeFromElement;\n\t\texports.getTypeFromElementNode = getTypeFromElementNode;\n\t\texports.hmr = hmr;\n\t\texports.hmrRevert = hmrRevert;\n\t\texports.hmrUpdate = hmrUpdate;\n\t\texports.hookListUnmount = hookListUnmount;\n\t\texports.initClassInstance = initClassInstance;\n\t\texports.initHMR = initHMR;\n\t\texports.initHookInstance = initHookInstance;\n\t\texports.initInstance = initInstance;\n\t\texports.initScheduler = initScheduler;\n\t\texports.initSuspenseInstance = initSuspenseInstance;\n\t\texports.initVisibleInstance = initVisibleInstance;\n\t\texports.initialFiberNode = initialFiberNode;\n\t\texports.insertionEffect = insertionEffect;\n\t\texports.isCommentElement = isCommentElement;\n\t\texports.isCommentEndElement = isCommentEndElement;\n\t\texports.isCommentStartElement = isCommentStartElement;\n\t\texports.isErrorBoundariesComponent = isErrorBoundariesComponent;\n\t\texports.isErrorBoundariesInstance = isErrorBoundariesInstance;\n\t\texports.layoutEffect = layoutEffect;\n\t\texports.loadLazy = loadLazy;\n\t\texports.loadPromise = loadPromise;\n\t\texports.mountAsync = mountAsync;\n\t\texports.mountClassInstance = mountClassInstance;\n\t\texports.mountLoopAll = mountLoopAll;\n\t\texports.mountLoopAllFromScheduler = mountLoopAllFromScheduler;\n\t\texports.mountSync = mountSync;\n\t\texports.mountToNextFiberFromRoot = mountToNextFiberFromRoot;\n\t\texports.nextWorkActivity = nextWorkActivity;\n\t\texports.nextWorkClassComponent = nextWorkClassComponent;\n\t\texports.nextWorkCommon = nextWorkCommon;\n\t\texports.nextWorkComponent = nextWorkComponent;\n\t\texports.nextWorkConsumer = nextWorkConsumer;\n\t\texports.nextWorkFunctionComponent = nextWorkFunctionComponent;\n\t\texports.nextWorkLazy = nextWorkLazy;\n\t\texports.nextWorkNormal = nextWorkNormal;\n\t\texports.nextWorkProvider = nextWorkProvider;\n\t\texports.nextWorkRoot = nextWorkRoot;\n\t\texports.nextWorkSuspense = nextWorkSuspense;\n\t\texports.onceErrorWithKeyAndFiber = onceErrorWithKeyAndFiber;\n\t\texports.onceWarnWithKeyAndFiber = onceWarnWithKeyAndFiber;\n\t\texports.originalError = originalError;\n\t\texports.originalWarn = originalWarn;\n\t\texports.performToNextFiberFromRoot = performToNextFiberFromRoot;\n\t\texports.prepareUpdateAllDependence = prepareUpdateAllDependence;\n\t\texports.prepareUpdateOnFiber = prepareUpdateOnFiber;\n\t\texports.processAsyncLoadListOnAsyncMount = processAsyncLoadListOnAsyncMount;\n\t\texports.processAsyncLoadListOnSyncMount = processAsyncLoadListOnSyncMount;\n\t\texports.processAsyncLoadListOnUpdate = processAsyncLoadListOnUpdate;\n\t\texports.processClassComponentActive = processClassComponentActive;\n\t\texports.processClassComponentMount = processClassComponentMount;\n\t\texports.processClassComponentUnmount = processClassComponentUnmount;\n\t\texports.processClassComponentUpdate = processClassComponentUpdate;\n\t\texports.processClassComponentUpdateQueueLatest = processClassComponentUpdateQueueLatest;\n\t\texports.processClassComponentUpdateQueueLegacy = processClassComponentUpdateQueueLegacy;\n\t\texports.processConsumer = processConsumer;\n\t\texports.processFunction = processFunction;\n\t\texports.processFunctionComponentUpdateQueueLatest = processFunctionComponentUpdateQueueLatest;\n\t\texports.processFunctionComponentUpdateQueueLegacy = processFunctionComponentUpdateQueueLegacy;\n\t\texports.processHook = processHook;\n\t\texports.processLazy = processLazy;\n\t\texports.processNormalComponentUpdateLatest = processNormalComponentUpdateLatest;\n\t\texports.processNormalComponentUpdateLegacy = processNormalComponentUpdateLegacy;\n\t\texports.processPromise = processPromise;\n\t\texports.processProvider = processProvider;\n\t\texports.processState = processState;\n\t\texports.processSuspense = processSuspense;\n\t\texports.processSuspensePromise = processSuspensePromise;\n\t\texports.resetLogScope = resetLogScope;\n\t\texports.runtimeNextWork = runtimeNextWork;\n\t\texports.runtimeNextWorkDev = runtimeNextWorkDev;\n\t\texports.safeCall = safeCall;\n\t\texports.safeCallWithCurrentFiber = safeCallWithCurrentFiber;\n\t\texports.safeCallWithSync = safeCallWithSync;\n\t\texports.scheduleNext = scheduleNext;\n\t\texports.scheduleUpdate = scheduleUpdate;\n\t\texports.setContextForInstance = setContextForInstance;\n\t\texports.setEffectForInstance = setEffectForInstance;\n\t\texports.setLogScope = setLogScope;\n\t\texports.setOwnerForInstance = setOwnerForInstance;\n\t\texports.setRefreshHandler = setRefreshHandler;\n\t\texports.setRefreshTypeMap = setRefreshTypeMap;\n\t\texports.setSubscribeForInstance = setSubscribeForInstance;\n\t\texports.syncComponentStateToFiber = syncComponentStateToFiber;\n\t\texports.syncFiberStateToComponent = syncFiberStateToComponent;\n\t\texports.syncFlushComponentQueue = syncFlushComponentQueue;\n\t\texports.transformChildrenFiber = transformChildrenFiber;\n\t\texports.triggerError = triggerError;\n\t\texports.triggerFiberUpdateListener = triggerFiberUpdateListener;\n\t\texports.triggerRevert = triggerRevert;\n\t\texports.triggerUpdate = triggerUpdate;\n\t\texports.triggerUpdateOnFiber = triggerUpdateOnFiber;\n\t\texports.typeToFibersMap = typeToFibersMap;\n\t\texports.unmountContainer = unmountContainer;\n\t\texports.unmountFiber = unmountFiber;\n\t\texports.unmountFiberNode = unmountFiberNode;\n\t\texports.unmountInstance = unmountInstance;\n\t\texports.updateConcurrentFromRoot = updateConcurrentFromRoot;\n\t\texports.updateFiberNode = updateFiberNode;\n\t\texports.updateHookNode = updateHookNode;\n\t\texports.updateLoopConcurrentFromRoot = updateLoopConcurrentFromRoot;\n\t\texports.updateLoopSyncFromRoot = updateLoopSyncFromRoot;\n\t\texports.updateSyncFromRoot = updateSyncFromRoot;\n\t\texports.version = version; \n\t} (index_production));\n\treturn index_production;\n}\n\nvar index_development = {};\n\nvar hasRequiredIndex_development;\n\nfunction requireIndex_development () {\n\tif (hasRequiredIndex_development) return index_development;\n\thasRequiredIndex_development = 1;\n\t(function (exports) {\n\n\t\tvar react = React__default;\n\n\t\tvar merge = function (src, rest) {\n\t\t    return src | rest;\n\t\t};\n\t\tvar remove = function (src, rest) {\n\t\t    if (src & rest) {\n\t\t        return src ^ rest;\n\t\t    }\n\t\t    else {\n\t\t        return src;\n\t\t    }\n\t\t};\n\t\tvar include = function (src, rest) {\n\t\t    return !!(src & rest);\n\t\t};\n\t\tvar exclude = function (src, rest) {\n\t\t    return !(src & rest);\n\t\t};\n\r\n\t\ttypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n\t\t    var e = new Error(message);\r\n\t\t    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n\t\t};\n\n\t\tvar TYPEKEY = \"$$typeof\";\n\t\tvar Memo = Symbol.for(\"react.memo\");\n\t\tvar ForwardRef = Symbol.for(\"react.forward_ref\");\n\t\tvar Portal = Symbol.for(\"react.portal\");\n\t\tvar Fragment = Symbol.for(\"react.fragment\");\n\t\tvar Context = Symbol.for(\"react.context\");\n\t\tvar Provider = Symbol.for(\"react.provider\");\n\t\tvar Consumer = Symbol.for(\"react.consumer\");\n\t\tvar Lazy = Symbol.for(\"react.lazy\");\n\t\tvar Suspense = Symbol.for(\"react.suspense\");\n\t\tvar Strict = Symbol.for(\"react.strict_mode\");\n\t\tvar Root = Symbol.for(\"react.root\");\n\t\tvar Scope = Symbol.for(\"react.scope\");\n\t\tvar ScopeLazy = Symbol.for(\"react.scope_lazy\");\n\t\tvar ScopeSuspense = Symbol.for(\"react.scope_suspense\");\n\t\tvar Comment = Symbol.for(\"react.comment\");\n\t\tvar Activity = Symbol.for(\"react.activity\");\n\t\tvar Profiler = Symbol.for(\"react.profiler\");\n\n\t\tfunction isObject(target) {\n\t\t    return typeof target === \"object\" && target !== null;\n\t\t}\n\t\tfunction isFunction(target) {\n\t\t    return typeof target === \"function\";\n\t\t}\n\t\tvar isPromise = function (val) {\n\t\t    return (isObject(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);\n\t\t};\n\n\t\tvar UniqueArray = /** @class */ (function () {\n\t\t    function UniqueArray() {\n\t\t        this.set = new Set();\n\t\t        this.arr = new Array();\n\t\t        this.length = 0;\n\t\t    }\n\t\t    UniqueArray.prototype.uniPop = function () {\n\t\t        var v = this.arr.pop();\n\t\t        this.set.delete(v);\n\t\t        this.length--;\n\t\t        return v;\n\t\t    };\n\t\t    UniqueArray.prototype.uniPush = function (v) {\n\t\t        if (this.set.has(v))\n\t\t            return 0;\n\t\t        this.set.add(v);\n\t\t        this.arr.push(v);\n\t\t        this.length++;\n\t\t    };\n\t\t    UniqueArray.prototype.uniShift = function () {\n\t\t        var v = this.arr.shift();\n\t\t        this.set.delete(v);\n\t\t        this.length--;\n\t\t        return v;\n\t\t    };\n\t\t    UniqueArray.prototype.uniUnshift = function (v) {\n\t\t        if (this.set.has(v))\n\t\t            return 0;\n\t\t        this.set.add(v);\n\t\t        this.arr.unshift(v);\n\t\t        this.length++;\n\t\t    };\n\t\t    UniqueArray.prototype.uniDelete = function (v) {\n\t\t        if (this.set.has(v)) {\n\t\t            this.set.delete(v);\n\t\t            this.arr = this.arr.filter(function (i) { return i !== v; });\n\t\t            this.length--;\n\t\t        }\n\t\t    };\n\t\t    UniqueArray.prototype.clear = function () {\n\t\t        this.length = 0;\n\t\t        this.set.clear();\n\t\t        this.arr.length = 0;\n\t\t    };\n\t\t    UniqueArray.prototype.getAll = function () {\n\t\t        return Array.from(this.arr);\n\t\t    };\n\t\t    return UniqueArray;\n\t\t}());\n\n\t\tvar HOOK_TYPE;\n\t\t(function (HOOK_TYPE) {\n\t\t    HOOK_TYPE[HOOK_TYPE[\"useId\"] = 0] = \"useId\";\n\t\t    HOOK_TYPE[HOOK_TYPE[\"useRef\"] = 1] = \"useRef\";\n\t\t    HOOK_TYPE[HOOK_TYPE[\"useMemo\"] = 2] = \"useMemo\";\n\t\t    HOOK_TYPE[HOOK_TYPE[\"useState\"] = 3] = \"useState\";\n\t\t    HOOK_TYPE[HOOK_TYPE[\"useSignal\"] = 4] = \"useSignal\";\n\t\t    HOOK_TYPE[HOOK_TYPE[\"useEffect\"] = 5] = \"useEffect\";\n\t\t    HOOK_TYPE[HOOK_TYPE[\"useContext\"] = 6] = \"useContext\";\n\t\t    HOOK_TYPE[HOOK_TYPE[\"useReducer\"] = 7] = \"useReducer\";\n\t\t    HOOK_TYPE[HOOK_TYPE[\"useCallback\"] = 8] = \"useCallback\";\n\t\t    HOOK_TYPE[HOOK_TYPE[\"useTransition\"] = 9] = \"useTransition\";\n\t\t    HOOK_TYPE[HOOK_TYPE[\"useDebugValue\"] = 10] = \"useDebugValue\";\n\t\t    HOOK_TYPE[HOOK_TYPE[\"useLayoutEffect\"] = 11] = \"useLayoutEffect\";\n\t\t    HOOK_TYPE[HOOK_TYPE[\"useDeferredValue\"] = 12] = \"useDeferredValue\";\n\t\t    HOOK_TYPE[HOOK_TYPE[\"useInsertionEffect\"] = 13] = \"useInsertionEffect\";\n\t\t    HOOK_TYPE[HOOK_TYPE[\"useImperativeHandle\"] = 14] = \"useImperativeHandle\";\n\t\t    HOOK_TYPE[HOOK_TYPE[\"useSyncExternalStore\"] = 15] = \"useSyncExternalStore\";\n\t\t    HOOK_TYPE[HOOK_TYPE[\"useOptimistic\"] = 16] = \"useOptimistic\";\n\t\t    HOOK_TYPE[HOOK_TYPE[\"useEffectEvent\"] = 17] = \"useEffectEvent\";\n\t\t})(HOOK_TYPE || (HOOK_TYPE = {}));\n\n\t\tvar UpdateQueueType;\n\t\t(function (UpdateQueueType) {\n\t\t    UpdateQueueType[UpdateQueueType[\"component\"] = 1] = \"component\";\n\t\t    UpdateQueueType[UpdateQueueType[\"hook\"] = 2] = \"hook\";\n\t\t    UpdateQueueType[UpdateQueueType[\"context\"] = 3] = \"context\";\n\t\t    UpdateQueueType[UpdateQueueType[\"hmr\"] = 4] = \"hmr\";\n\t\t    UpdateQueueType[UpdateQueueType[\"trigger\"] = 5] = \"trigger\";\n\t\t    UpdateQueueType[UpdateQueueType[\"suspense\"] = 6] = \"suspense\";\n\t\t    UpdateQueueType[UpdateQueueType[\"lazy\"] = 7] = \"lazy\";\n\t\t    UpdateQueueType[UpdateQueueType[\"promise\"] = 8] = \"promise\";\n\t\t})(UpdateQueueType || (UpdateQueueType = {}));\n\n\t\tvar STATE_TYPE;\n\t\t(function (STATE_TYPE) {\n\t\t    STATE_TYPE[STATE_TYPE[\"__initial__\"] = 0] = \"__initial__\";\n\t\t    STATE_TYPE[STATE_TYPE[\"__create__\"] = 1] = \"__create__\";\n\t\t    STATE_TYPE[STATE_TYPE[\"__stable__\"] = 2] = \"__stable__\";\n\t\t    STATE_TYPE[STATE_TYPE[\"__inherit__\"] = 4] = \"__inherit__\";\n\t\t    STATE_TYPE[STATE_TYPE[\"__triggerConcurrent__\"] = 8] = \"__triggerConcurrent__\";\n\t\t    STATE_TYPE[STATE_TYPE[\"__triggerConcurrentForce__\"] = 16] = \"__triggerConcurrentForce__\";\n\t\t    STATE_TYPE[STATE_TYPE[\"__triggerSync__\"] = 32] = \"__triggerSync__\";\n\t\t    STATE_TYPE[STATE_TYPE[\"__triggerSyncForce__\"] = 64] = \"__triggerSyncForce__\";\n\t\t    STATE_TYPE[STATE_TYPE[\"__unmount__\"] = 128] = \"__unmount__\";\n\t\t    STATE_TYPE[STATE_TYPE[\"__hmr__\"] = 256] = \"__hmr__\";\n\t\t    STATE_TYPE[STATE_TYPE[\"__retrigger__\"] = 512] = \"__retrigger__\";\n\t\t    STATE_TYPE[STATE_TYPE[\"__reschedule__\"] = 1024] = \"__reschedule__\";\n\t\t    STATE_TYPE[STATE_TYPE[\"__recreate__\"] = 2048] = \"__recreate__\";\n\t\t    STATE_TYPE[STATE_TYPE[\"__suspense__\"] = 4096] = \"__suspense__\";\n\t\t})(STATE_TYPE || (STATE_TYPE = {}));\n\n\t\tvar PATCH_TYPE;\n\t\t(function (PATCH_TYPE) {\n\t\t    PATCH_TYPE[PATCH_TYPE[\"__initial__\"] = 0] = \"__initial__\";\n\t\t    PATCH_TYPE[PATCH_TYPE[\"__create__\"] = 1] = \"__create__\";\n\t\t    PATCH_TYPE[PATCH_TYPE[\"__update__\"] = 2] = \"__update__\";\n\t\t    PATCH_TYPE[PATCH_TYPE[\"__append__\"] = 4] = \"__append__\";\n\t\t    PATCH_TYPE[PATCH_TYPE[\"__position__\"] = 8] = \"__position__\";\n\t\t    PATCH_TYPE[PATCH_TYPE[\"__effect__\"] = 16] = \"__effect__\";\n\t\t    PATCH_TYPE[PATCH_TYPE[\"__layoutEffect__\"] = 32] = \"__layoutEffect__\";\n\t\t    PATCH_TYPE[PATCH_TYPE[\"__insertionEffect__\"] = 64] = \"__insertionEffect__\";\n\t\t    PATCH_TYPE[PATCH_TYPE[\"__unmount__\"] = 128] = \"__unmount__\";\n\t\t    PATCH_TYPE[PATCH_TYPE[\"__ref__\"] = 256] = \"__ref__\";\n\t\t})(PATCH_TYPE || (PATCH_TYPE = {}));\n\n\t\tvar Effect_TYPE;\n\t\t(function (Effect_TYPE) {\n\t\t    Effect_TYPE[Effect_TYPE[\"__initial__\"] = 0] = \"__initial__\";\n\t\t    Effect_TYPE[Effect_TYPE[\"__effect__\"] = 1] = \"__effect__\";\n\t\t    Effect_TYPE[Effect_TYPE[\"__unmount__\"] = 2] = \"__unmount__\";\n\t\t})(Effect_TYPE || (Effect_TYPE = {}));\n\n\t\tvar isNormalEquals = function (src, target, isSkipKey) {\n\t\t    var isEquals = Object.is(src, target);\n\t\t    if (isEquals)\n\t\t        return true;\n\t\t    var hasSkipKeyFunction = typeof isSkipKey === \"function\";\n\t\t    if (typeof src === \"object\" && typeof target === \"object\" && src !== null && target !== null) {\n\t\t        var srcKeys = Object.keys(src);\n\t\t        var targetKeys = Object.keys(target);\n\t\t        if (srcKeys.length !== targetKeys.length)\n\t\t            return false;\n\t\t        var res = true;\n\t\t        if (hasSkipKeyFunction) {\n\t\t            for (var _i = 0, srcKeys_1 = srcKeys; _i < srcKeys_1.length; _i++) {\n\t\t                var key = srcKeys_1[_i];\n\t\t                if (isSkipKey(key) && key in target) {\n\t\t                    continue;\n\t\t                }\n\t\t                else {\n\t\t                    res = res && Object.is(src[key], target[key]);\n\t\t                }\n\t\t                if (!res)\n\t\t                    return res;\n\t\t            }\n\t\t        }\n\t\t        else {\n\t\t            for (var _a = 0, srcKeys_2 = srcKeys; _a < srcKeys_2.length; _a++) {\n\t\t                var key = srcKeys_2[_a];\n\t\t                res = res && Object.is(src[key], target[key]);\n\t\t                if (!res)\n\t\t                    return res;\n\t\t            }\n\t\t        }\n\t\t        return res;\n\t\t    }\n\t\t    return false;\n\t\t};\n\t\tvar isArrayEquals = function (src, target) {\n\t\t    var isEquals = Object.is(src, target);\n\t\t    if (isEquals)\n\t\t        return true;\n\t\t    if (Array.isArray(src) && Array.isArray(target) && src.length === target.length) {\n\t\t        var re = true;\n\t\t        for (var key in src) {\n\t\t            re = re && Object.is(src[key], target[key]);\n\t\t            if (!re)\n\t\t                return re;\n\t\t        }\n\t\t        return re;\n\t\t    }\n\t\t    return false;\n\t\t};\n\n\t\tvar ListTreeNode = /** @class */ (function () {\n\t\t    function ListTreeNode(value) {\n\t\t        this.prev = null;\n\t\t        this.next = null;\n\t\t        this.value = value;\n\t\t    }\n\t\t    return ListTreeNode;\n\t\t}());\n\t\tvar ListTree = /** @class */ (function () {\n\t\t    function ListTree() {\n\t\t        this.length = 0;\n\t\t        var _stickyHead = null;\n\t\t        Object.defineProperty(this, \"stickyHead\", {\n\t\t            get: function () {\n\t\t                return _stickyHead;\n\t\t            },\n\t\t            set: function (v) {\n\t\t                _stickyHead = v;\n\t\t            },\n\t\t        });\n\t\t        var _stickyFoot = null;\n\t\t        Object.defineProperty(this, \"stickyFoot\", {\n\t\t            get: function () {\n\t\t                return _stickyFoot;\n\t\t            },\n\t\t            set: function (v) {\n\t\t                _stickyFoot = v;\n\t\t            },\n\t\t        });\n\t\t        var _head = null;\n\t\t        Object.defineProperty(this, \"head\", {\n\t\t            get: function () {\n\t\t                return _head;\n\t\t            },\n\t\t            set: function (v) {\n\t\t                _head = v;\n\t\t            },\n\t\t        });\n\t\t        var _foot = null;\n\t\t        Object.defineProperty(this, \"foot\", {\n\t\t            get: function () {\n\t\t                return _foot;\n\t\t            },\n\t\t            set: function (v) {\n\t\t                _foot = v;\n\t\t            },\n\t\t        });\n\t\t    }\n\t\t    ListTree.prototype.push = function (node) {\n\t\t        var listNode = new ListTreeNode(node);\n\t\t        this.length++;\n\t\t        if (!this.foot) {\n\t\t            this.head = listNode;\n\t\t            this.foot = listNode;\n\t\t        }\n\t\t        else {\n\t\t            this.foot.next = listNode;\n\t\t            listNode.prev = this.foot;\n\t\t            this.foot = listNode;\n\t\t        }\n\t\t    };\n\t\t    ListTree.prototype.pushToLast = function (node) {\n\t\t        if (this.stickyFoot) {\n\t\t            var node_1 = this.stickyFoot;\n\t\t            this.push(node_1.value);\n\t\t            this.stickyFoot = null;\n\t\t        }\n\t\t        else {\n\t\t            this.length++;\n\t\t        }\n\t\t        var listNode = new ListTreeNode(node);\n\t\t        this.stickyFoot = listNode;\n\t\t    };\n\t\t    ListTree.prototype.pushToHead = function (node) {\n\t\t        if (this.stickyHead) {\n\t\t            var node_2 = this.stickyHead;\n\t\t            this.unshift(node_2.value);\n\t\t            this.stickyHead = null;\n\t\t        }\n\t\t        else {\n\t\t            this.length++;\n\t\t        }\n\t\t        var listNode = new ListTreeNode(node);\n\t\t        this.stickyHead = listNode;\n\t\t    };\n\t\t    ListTree.prototype.pop = function () {\n\t\t        var foot = this.stickyFoot || this.foot || this.stickyHead;\n\t\t        if (foot) {\n\t\t            this.delete(foot);\n\t\t            return foot.value;\n\t\t        }\n\t\t        else {\n\t\t            return null;\n\t\t        }\n\t\t    };\n\t\t    ListTree.prototype.unshift = function (node) {\n\t\t        var listNode = new ListTreeNode(node);\n\t\t        this.length++;\n\t\t        if (!this.head) {\n\t\t            this.head = listNode;\n\t\t            this.foot = listNode;\n\t\t        }\n\t\t        else {\n\t\t            this.head.prev = listNode;\n\t\t            listNode.next = this.head;\n\t\t            this.head = listNode;\n\t\t        }\n\t\t    };\n\t\t    ListTree.prototype.unshiftToHead = function (node) {\n\t\t        if (this.stickyHead) {\n\t\t            var node_3 = this.stickyHead;\n\t\t            this.unshift(node_3.value);\n\t\t            this.stickyHead = null;\n\t\t        }\n\t\t        else {\n\t\t            this.length++;\n\t\t        }\n\t\t        var listNode = new ListTreeNode(node);\n\t\t        this.stickyHead = listNode;\n\t\t    };\n\t\t    ListTree.prototype.unshiftToFoot = function (node) {\n\t\t        if (this.stickyFoot) {\n\t\t            var node_4 = this.stickyFoot;\n\t\t            this.push(node_4.value);\n\t\t            this.stickyFoot = null;\n\t\t        }\n\t\t        else {\n\t\t            this.length++;\n\t\t        }\n\t\t        var listNode = new ListTreeNode(node);\n\t\t        this.stickyFoot = listNode;\n\t\t    };\n\t\t    ListTree.prototype.shift = function () {\n\t\t        var head = this.stickyHead || this.head || this.stickyFoot;\n\t\t        if (head) {\n\t\t            this.delete(head);\n\t\t            return head.value;\n\t\t        }\n\t\t        else {\n\t\t            return null;\n\t\t        }\n\t\t    };\n\t\t    ListTree.prototype.pickHead = function () {\n\t\t        var _a, _b;\n\t\t        return ((_a = this.stickyHead) === null || _a === void 0 ? void 0 : _a.value) || ((_b = this.head) === null || _b === void 0 ? void 0 : _b.value);\n\t\t    };\n\t\t    ListTree.prototype.pickFoot = function () {\n\t\t        var _a, _b;\n\t\t        return ((_a = this.stickyFoot) === null || _a === void 0 ? void 0 : _a.value) || ((_b = this.foot) === null || _b === void 0 ? void 0 : _b.value);\n\t\t    };\n\t\t    ListTree.prototype.listToFoot = function (action) {\n\t\t        if (this.stickyHead) {\n\t\t            action(this.stickyHead.value);\n\t\t        }\n\t\t        var node = this.head;\n\t\t        while (node) {\n\t\t            action(node.value);\n\t\t            node = node.next;\n\t\t        }\n\t\t        if (this.stickyFoot) {\n\t\t            action(this.stickyFoot.value);\n\t\t        }\n\t\t    };\n\t\t    ListTree.prototype.listToHead = function (action) {\n\t\t        if (this.stickyFoot) {\n\t\t            action(this.stickyFoot.value);\n\t\t        }\n\t\t        var node = this.foot;\n\t\t        while (node) {\n\t\t            action(node.value);\n\t\t            node = node.prev;\n\t\t        }\n\t\t        if (this.stickyHead) {\n\t\t            action(this.stickyHead.value);\n\t\t        }\n\t\t    };\n\t\t    ListTree.prototype.toArray = function () {\n\t\t        var re = [];\n\t\t        this.listToFoot(function (v) { return re.push(v); });\n\t\t        return re;\n\t\t    };\n\t\t    ListTree.prototype.delete = function (node) {\n\t\t        if (this.stickyHead === node) {\n\t\t            this.stickyHead = null;\n\t\t            this.length--;\n\t\t        }\n\t\t        else if (this.stickyFoot === node) {\n\t\t            this.stickyFoot = null;\n\t\t            this.length--;\n\t\t        }\n\t\t        else if (this.head === node) {\n\t\t            var next = node.next;\n\t\t            node.next = null;\n\t\t            if (next) {\n\t\t                this.head = next;\n\t\t                next.prev = null;\n\t\t            }\n\t\t            else {\n\t\t                this.head = null;\n\t\t                this.foot = null;\n\t\t            }\n\t\t            this.length--;\n\t\t        }\n\t\t        else if (this.foot === node) {\n\t\t            var prev = node.prev;\n\t\t            node.prev = null;\n\t\t            if (prev) {\n\t\t                this.foot = prev;\n\t\t                prev.next = null;\n\t\t            }\n\t\t            else {\n\t\t                this.head = null;\n\t\t                this.foot = null;\n\t\t            }\n\t\t            this.length--;\n\t\t        }\n\t\t        else if (this.hasNode(node)) {\n\t\t            var prev = node.prev;\n\t\t            var next = node.next;\n\t\t            node.prev = null;\n\t\t            node.next = null;\n\t\t            prev.next = next;\n\t\t            next.prev = prev;\n\t\t            this.length--;\n\t\t        }\n\t\t    };\n\t\t    ListTree.prototype.size = function () {\n\t\t        return this.length;\n\t\t    };\n\t\t    ListTree.prototype.hasNode = function (node) {\n\t\t        if (this.stickyHead && Object.is(this.stickyHead, node))\n\t\t            return true;\n\t\t        if (this.stickyFoot && Object.is(this.stickyFoot, node))\n\t\t            return true;\n\t\t        var listNode = this.head;\n\t\t        while (listNode) {\n\t\t            if (Object.is(listNode, node))\n\t\t                return true;\n\t\t            listNode = listNode.next;\n\t\t        }\n\t\t        return false;\n\t\t    };\n\t\t    ListTree.prototype.hasValue = function (node) {\n\t\t        if (this.stickyHead && Object.is(this.stickyHead.value, node))\n\t\t            return true;\n\t\t        if (this.stickyFoot && Object.is(this.stickyFoot.value, node))\n\t\t            return true;\n\t\t        var listNode = this.head;\n\t\t        while (listNode) {\n\t\t            if (Object.is(listNode.value, node))\n\t\t                return true;\n\t\t            listNode = listNode.next;\n\t\t        }\n\t\t        return false;\n\t\t    };\n\t\t    ListTree.prototype.some = function (iterator) {\n\t\t        var re = false;\n\t\t        this.listToFoot(function (node) {\n\t\t            re = re || iterator(node);\n\t\t        });\n\t\t        return re;\n\t\t    };\n\t\t    ListTree.prototype.every = function (iterator) {\n\t\t        var re = true;\n\t\t        this.listToFoot(function (node) {\n\t\t            re = re && iterator(node);\n\t\t        });\n\t\t        return re;\n\t\t    };\n\t\t    ListTree.prototype.concat = function (list) {\n\t\t        var newList = new ListTree();\n\t\t        this.listToFoot(function (node) { return newList.push(node); });\n\t\t        list.listToFoot(function (node) { return newList.push(node); });\n\t\t        return newList;\n\t\t    };\n\t\t    ListTree.prototype.clone = function () {\n\t\t        var newList = new ListTree();\n\t\t        this.listToFoot(function (v) { return newList.push(v); });\n\t\t        return newList;\n\t\t    };\n\t\t    ListTree.prototype.clear = function () {\n\t\t        this.length = 0;\n\t\t        this.head = null;\n\t\t        this.foot = null;\n\t\t        this.stickyHead = null;\n\t\t        this.stickyFoot = null;\n\t\t    };\n\t\t    return ListTree;\n\t\t}());\n\t\t{\n\t\t    Object.defineProperty(ListTree.prototype, \"_debugToArray\", {\n\t\t        get: function () {\n\t\t            return this.toArray();\n\t\t        },\n\t\t    });\n\t\t}\n\n\t\t/******************************************************************************\r\n\t\tCopyright (c) Microsoft Corporation.\r\n\r\n\t\tPermission to use, copy, modify, and/or distribute this software for any\r\n\t\tpurpose with or without fee is hereby granted.\r\n\r\n\t\tTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n\t\tREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n\t\tAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n\t\tINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n\t\tLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n\t\tOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n\t\tPERFORMANCE OF THIS SOFTWARE.\r\n\t\t***************************************************************************** */\r\n\t\t/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\n\t\tvar extendStatics = function(d, b) {\r\n\t\t    extendStatics = Object.setPrototypeOf ||\r\n\t\t        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n\t\t        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n\t\t    return extendStatics(d, b);\r\n\t\t};\r\n\r\n\t\tfunction __extends(d, b) {\r\n\t\t    if (typeof b !== \"function\" && b !== null)\r\n\t\t        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n\t\t    extendStatics(d, b);\r\n\t\t    function __() { this.constructor = d; }\r\n\t\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t\t}\r\n\r\n\t\tvar __assign = function() {\r\n\t\t    __assign = Object.assign || function __assign(t) {\r\n\t\t        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n\t\t            s = arguments[i];\r\n\t\t            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n\t\t        }\r\n\t\t        return t;\r\n\t\t    };\r\n\t\t    return __assign.apply(this, arguments);\r\n\t\t};\r\n\r\n\t\tfunction __awaiter(thisArg, _arguments, P, generator) {\r\n\t\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n\t\t    return new (P || (P = Promise))(function (resolve, reject) {\r\n\t\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n\t\t        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n\t\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n\t\t        step((generator = generator.apply(thisArg, [])).next());\r\n\t\t    });\r\n\t\t}\r\n\r\n\t\tfunction __generator(thisArg, body) {\r\n\t\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\r\n\t\t    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n\t\t    function verb(n) { return function (v) { return step([n, v]); }; }\r\n\t\t    function step(op) {\r\n\t\t        if (f) throw new TypeError(\"Generator is already executing.\");\r\n\t\t        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n\t\t            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n\t\t            if (y = 0, t) op = [op[0] & 2, t.value];\r\n\t\t            switch (op[0]) {\r\n\t\t                case 0: case 1: t = op; break;\r\n\t\t                case 4: _.label++; return { value: op[1], done: false };\r\n\t\t                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n\t\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n\t\t                default:\r\n\t\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n\t\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n\t\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n\t\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n\t\t                    if (t[2]) _.ops.pop();\r\n\t\t                    _.trys.pop(); continue;\r\n\t\t            }\r\n\t\t            op = body.call(thisArg, _);\r\n\t\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n\t\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n\t\t    }\r\n\t\t}\r\n\r\n\t\tfunction __spreadArray(to, from, pack) {\r\n\t\t    if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n\t\t        if (ar || !(i in from)) {\r\n\t\t            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n\t\t            ar[i] = from[i];\r\n\t\t        }\r\n\t\t    }\r\n\t\t    return to.concat(ar || Array.prototype.slice.call(from));\r\n\t\t}\r\n\r\n\t\ttypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n\t\t    var e = new Error(message);\r\n\t\t    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n\t\t};\n\n\t\tvar MyWeakMap = typeof WeakMap !== \"undefined\" ? WeakMap : Map;\n\n\t\tvar currentRefreshHandler = react.createRef(null);\n\t\t// TODO\n\t\t// need improve\n\t\tvar currentTriggerFiber = react.createRef(null);\n\t\tvar fiberToDispatchMap = react.__my_react_internal__.fiberToDispatchMap;\n\t\tvar enableFiberForLog = react.createRef(false);\n\t\tvar enableDebugUpdateQueue = react.createRef(false);\n\t\tvar enableValidMyReactElement = react.createRef(false);\n\t\tvar enableLogForCurrentFlowIsRunning = react.createRef(false);\n\n\t\texports.NODE_TYPE = void 0;\n\t\t(function (NODE_TYPE) {\n\t\t    NODE_TYPE[NODE_TYPE[\"__initial__\"] = 0] = \"__initial__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__class__\"] = 1] = \"__class__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__function__\"] = 2] = \"__function__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__lazy__\"] = 4] = \"__lazy__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__memo__\"] = 8] = \"__memo__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__forwardRef__\"] = 16] = \"__forwardRef__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__provider__\"] = 32] = \"__provider__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__consumer__\"] = 64] = \"__consumer__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__portal__\"] = 128] = \"__portal__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__null__\"] = 256] = \"__null__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__text__\"] = 512] = \"__text__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__empty__\"] = 1024] = \"__empty__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__plain__\"] = 2048] = \"__plain__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__strict__\"] = 4096] = \"__strict__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__suspense__\"] = 8192] = \"__suspense__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__fragment__\"] = 16384] = \"__fragment__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__root__\"] = 32768] = \"__root__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__scope__\"] = 65536] = \"__scope__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__comment__\"] = 131072] = \"__comment__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__profiler__\"] = 262144] = \"__profiler__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__context__\"] = 524288] = \"__context__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__scopeLazy__\"] = 1048576] = \"__scopeLazy__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__scopeSuspense__\"] = 2097152] = \"__scopeSuspense__\";\n\t\t    NODE_TYPE[NODE_TYPE[\"__activity__\"] = 4194304] = \"__activity__\";\n\t\t})(exports.NODE_TYPE || (exports.NODE_TYPE = {}));\n\n\t\tvar enableSyncFlush$1 = react.__my_react_shared__.enableSyncFlush;\n\t\t/**\n\t\t * @deprecated\n\t\t */\n\t\texports.syncFlush = false;\n\t\t/**\n\t\t * @deprecated\n\t\t */\n\t\tvar beforeSyncFlush = function () {\n\t\t    exports.syncFlush = true;\n\t\t};\n\t\t/**\n\t\t * @deprecated\n\t\t */\n\t\tvar afterSyncFlush = function () {\n\t\t    exports.syncFlush = false;\n\t\t};\n\t\tvar stack = [enableSyncFlush$1.current];\n\t\tvar beforeSyncUpdate = function () {\n\t\t    stack.push(enableSyncFlush$1.current);\n\t\t    enableSyncFlush$1.current = true;\n\t\t};\n\t\tvar afterSyncUpdate = function () {\n\t\t    enableSyncFlush$1.current = stack.pop();\n\t\t};\n\n\t\tvar currentRunningFiber$5 = react.__my_react_internal__.currentRunningFiber, currentScheduler$h = react.__my_react_internal__.currentScheduler, currentScopeFiber$1 = react.__my_react_internal__.currentScopeFiber, currentError$1 = react.__my_react_internal__.currentError, currentCallingFiber$1 = react.__my_react_internal__.currentCallingFiber;\n\t\tvar safeCall = function (action) {\n\t\t    var args = [];\n\t\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t\t        args[_i - 1] = arguments[_i];\n\t\t    }\n\t\t    try {\n\t\t        return action.call.apply(action, __spreadArray([null], args, false));\n\t\t    }\n\t\t    catch (e) {\n\t\t        var fiber = (currentCallingFiber$1 === null || currentCallingFiber$1 === void 0 ? void 0 : currentCallingFiber$1[(currentCallingFiber$1 === null || currentCallingFiber$1 === void 0 ? void 0 : currentCallingFiber$1.length) - 1]) || currentScopeFiber$1.current || currentRunningFiber$5.current;\n\t\t        var renderScheduler = currentScheduler$h.current;\n\t\t        currentError$1.current = currentError$1.current || e;\n\t\t        renderScheduler.dispatchError({ fiber: fiber, error: currentError$1.current });\n\t\t    }\n\t\t};\n\t\tvar safeCallWithCurrentFiber = function (_a) {\n\t\t    var action = _a.action, fiber = _a.fiber, fallback = _a.fallback;\n\t\t    var args = [];\n\t\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t\t        args[_i - 1] = arguments[_i];\n\t\t    }\n\t\t    currentCallingFiber$1.push(fiber);\n\t\t    try {\n\t\t        return action.call.apply(action, __spreadArray([null], args, false));\n\t\t    }\n\t\t    catch (e) {\n\t\t        if (fallback) {\n\t\t            return fallback();\n\t\t        }\n\t\t        else {\n\t\t            var renderScheduler = currentScheduler$h.current;\n\t\t            currentError$1.current = currentError$1.current || e;\n\t\t            renderScheduler.dispatchError({ fiber: fiber, error: currentError$1.current });\n\t\t        }\n\t\t    }\n\t\t    finally {\n\t\t        currentCallingFiber$1.pop();\n\t\t    }\n\t\t};\n\t\tvar callWithFiber = function (_a) {\n\t\t    var action = _a.action, fiber = _a.fiber;\n\t\t    var args = [];\n\t\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t\t        args[_i - 1] = arguments[_i];\n\t\t    }\n\t\t    currentScopeFiber$1.current = fiber;\n\t\t    try {\n\t\t        return action.call.apply(action, __spreadArray([null], args, false));\n\t\t    }\n\t\t    finally {\n\t\t        currentScopeFiber$1.current = null;\n\t\t    }\n\t\t};\n\t\tvar safeCallWithSync = function (action) {\n\t\t    var args = [];\n\t\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t\t        args[_i - 1] = arguments[_i];\n\t\t    }\n\t\t    try {\n\t\t        beforeSyncUpdate();\n\t\t        return action.call.apply(action, __spreadArray([null], args, false));\n\t\t    }\n\t\t    catch (e) {\n\t\t        var fiber = (currentCallingFiber$1 === null || currentCallingFiber$1 === void 0 ? void 0 : currentCallingFiber$1[(currentCallingFiber$1 === null || currentCallingFiber$1 === void 0 ? void 0 : currentCallingFiber$1.length) - 1]) || currentScopeFiber$1.current || currentRunningFiber$5.current;\n\t\t        var renderScheduler = currentScheduler$h.current;\n\t\t        currentError$1.current = currentError$1.current || e;\n\t\t        renderScheduler.dispatchError({ fiber: fiber, error: currentError$1.current });\n\t\t    }\n\t\t    finally {\n\t\t        afterSyncUpdate();\n\t\t    }\n\t\t};\n\n\t\tvar currentScheduler$g = react.__my_react_internal__.currentScheduler, currentRunningFiber$4 = react.__my_react_internal__.currentRunningFiber, currentScopeFiber = react.__my_react_internal__.currentScopeFiber, currentCallingFiber = react.__my_react_internal__.currentCallingFiber;\n\t\tvar enableOptimizeTreeLog = react.__my_react_shared__.enableOptimizeTreeLog;\n\t\tvar typeColor = {\n\t\t    normal: \"rgba(10, 190, 235, 0.8)\",\n\t\t    plain: \"rgba(100, 230, 40, 0.8)\",\n\t\t    unmount: \"rgba(230, 40, 40, 0.8)\",\n\t\t};\n\t\tvar warnMap = {};\n\t\tvar errorMap = {};\n\t\tvar fiberWarn = function (fiber) {\n\t\t    var args = [];\n\t\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t\t        args[_i - 1] = arguments[_i];\n\t\t    }\n\t\t    var renderDispatch = getCurrentDispatchFromFiber(fiber);\n\t\t    safeCallWithCurrentFiber({\n\t\t        fiber: fiber,\n\t\t        action: function () {\n\t\t            renderDispatch.callOnFiberWarn.apply(renderDispatch, __spreadArray([fiber], args, false));\n\t\t        },\n\t\t    });\n\t\t};\n\t\tvar fiberError = function (fiber) {\n\t\t    var args = [];\n\t\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t\t        args[_i - 1] = arguments[_i];\n\t\t    }\n\t\t    var renderDispatch = getCurrentDispatchFromFiber(fiber);\n\t\t    safeCallWithCurrentFiber({\n\t\t        fiber: fiber,\n\t\t        action: function () {\n\t\t            renderDispatch.callOnFiberError.apply(renderDispatch, __spreadArray([fiber], args, false));\n\t\t        },\n\t\t    });\n\t\t};\n\t\t// TODO! improve log\n\t\tvar originalWarn = console.warn;\n\t\tvar originalError = console.error;\n\t\tvar warnFiber = null;\n\t\tvar errorFiber = null;\n\t\tvar devWarn = function () {\n\t\t    var args = [];\n\t\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t\t        args[_i] = arguments[_i];\n\t\t    }\n\t\t    var renderScheduler = currentScheduler$g.current;\n\t\t    var startWithPlain = typeof args[0] === \"string\";\n\t\t    var renderFiber = warnFiber || (currentCallingFiber === null || currentCallingFiber === void 0 ? void 0 : currentCallingFiber[(currentCallingFiber === null || currentCallingFiber === void 0 ? void 0 : currentCallingFiber.length) - 1]) || currentScopeFiber.current || currentRunningFiber$4.current;\n\t\t    renderFiber && fiberWarn.apply(void 0, __spreadArray([renderFiber], args, false));\n\t\t    var treeLog = renderFiber ? renderScheduler.getFiberTree(renderFiber) : \"\";\n\t\t    if (enableFiberForLog.current && renderFiber) {\n\t\t        if (startWithPlain) {\n\t\t            originalWarn.call.apply(originalWarn, __spreadArray(__spreadArray([console], args, false), [treeLog, \"\\n\", renderFiber], false));\n\t\t        }\n\t\t        else {\n\t\t            originalWarn.call.apply(originalWarn, __spreadArray(__spreadArray([console, \"\"], args, false), [treeLog, \"\\n\", renderFiber], false));\n\t\t        }\n\t\t    }\n\t\t    else {\n\t\t        if (startWithPlain) {\n\t\t            originalWarn.call.apply(originalWarn, __spreadArray(__spreadArray([console], args, false), [treeLog], false));\n\t\t        }\n\t\t        else {\n\t\t            originalWarn.call.apply(originalWarn, __spreadArray(__spreadArray([console, \"\"], args, false), [treeLog], false));\n\t\t        }\n\t\t    }\n\t\t};\n\t\tvar devWarnWithFiber = function (fiber) {\n\t\t    var args = [];\n\t\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t\t        args[_i - 1] = arguments[_i];\n\t\t    }\n\t\t    warnFiber = fiber;\n\t\t    devWarn.apply(void 0, args);\n\t\t    // TODO\n\t\t    warnFiber = null;\n\t\t};\n\t\tvar devError = function () {\n\t\t    var args = [];\n\t\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t\t        args[_i] = arguments[_i];\n\t\t    }\n\t\t    var renderScheduler = currentScheduler$g.current;\n\t\t    var startWithPlain = typeof args[0] === \"string\";\n\t\t    var renderFiber = errorFiber || (currentCallingFiber === null || currentCallingFiber === void 0 ? void 0 : currentCallingFiber[(currentCallingFiber === null || currentCallingFiber === void 0 ? void 0 : currentCallingFiber.length) - 1]) || currentScopeFiber.current || currentRunningFiber$4.current;\n\t\t    renderFiber && fiberError.apply(void 0, __spreadArray([renderFiber], args, false));\n\t\t    var treeLog = renderFiber ? renderScheduler.getFiberTree(renderFiber) : \"\";\n\t\t    if (enableFiberForLog.current && renderFiber) {\n\t\t        if (startWithPlain) {\n\t\t            originalError.call.apply(originalError, __spreadArray(__spreadArray([console], args, false), [treeLog, \"\\n\", renderFiber], false));\n\t\t        }\n\t\t        else {\n\t\t            originalError.call.apply(originalError, __spreadArray(__spreadArray([console, \"\"], args, false), [treeLog, \"\\n\", renderFiber], false));\n\t\t        }\n\t\t    }\n\t\t    else {\n\t\t        if (startWithPlain) {\n\t\t            originalError.call.apply(originalError, __spreadArray(__spreadArray([console], args, false), [treeLog], false));\n\t\t        }\n\t\t        else {\n\t\t            originalError.call.apply(originalError, __spreadArray(__spreadArray([console, \"\"], args, false), [treeLog], false));\n\t\t        }\n\t\t    }\n\t\t};\n\t\tvar devErrorWithFiber = function (fiber) {\n\t\t    var args = [];\n\t\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t\t        args[_i - 1] = arguments[_i];\n\t\t    }\n\t\t    errorFiber = fiber;\n\t\t    devError.apply(void 0, args);\n\t\t    errorFiber = null;\n\t\t};\n\t\tvar setLogScope = function () {\n\t\t    {\n\t\t        console.warn = devWarn;\n\t\t        console.error = devError;\n\t\t    }\n\t\t};\n\t\tvar resetLogScope = function () {\n\t\t    {\n\t\t        console.warn = originalWarn;\n\t\t        console.error = originalError;\n\t\t    }\n\t\t};\n\t\tvar debugWithNode = function (fiber) {\n\t\t    var mayFiberContainer = fiber;\n\t\t    if (fiber.nativeNode || mayFiberContainer.containerNode) {\n\t\t        var node = (fiber.nativeNode || mayFiberContainer.containerNode);\n\t\t        node.__fiber__ = fiber;\n\t\t        node.__props__ = fiber.pendingProps;\n\t\t    }\n\t\t};\n\t\tvar getTrackDevLog = function (fiber) {\n\t\t    {\n\t\t        var typedFiber = fiber;\n\t\t        var element = typedFiber._debugElement;\n\t\t        var source = typeof element === \"object\" ? element === null || element === void 0 ? void 0 : element[\"_source\"] : null;\n\t\t        var owner = typeof element === \"object\" ? element === null || element === void 0 ? void 0 : element[\"_owner\"] : null;\n\t\t        var preString = \"\";\n\t\t        if (source) {\n\t\t            var _a = source || {}, fileName = _a.fileName, lineNumber = _a.lineNumber;\n\t\t            preString = \"\".concat(preString, \"(\").concat(fileName, \":\").concat(lineNumber, \") \");\n\t\t        }\n\t\t        if (owner) {\n\t\t            var ownerFiber = owner;\n\t\t            var ownerFiberElementType = ownerFiber.elementType;\n\t\t            if (include(ownerFiber.type, exports.NODE_TYPE.__class__ | exports.NODE_TYPE.__function__)) {\n\t\t                var ownerElement = ownerFiber._debugElement;\n\t\t                var typedOwnerElementType = ownerFiberElementType;\n\t\t                var name_1 = typedOwnerElementType.displayName || typedOwnerElementType.name;\n\t\t                name_1 = typeof ownerElement.type === \"object\" ? ownerElement.type.displayName : name_1;\n\t\t                preString = name_1 ? \"\".concat(preString, \"(render dy \").concat(name_1, \")\") : preString;\n\t\t            }\n\t\t        }\n\t\t        return preString;\n\t\t    }\n\t\t};\n\t\tvar shouldIncludeLog = function (fiber) {\n\t\t    if (include(fiber.type, exports.NODE_TYPE.__class__ | exports.NODE_TYPE.__function__)) {\n\t\t        return true;\n\t\t    }\n\t\t    return false;\n\t\t};\n\t\tvar getFiberTagName = function (fiber) {\n\t\t    var tag = [];\n\t\t    if (fiber.type & exports.NODE_TYPE.__memo__) {\n\t\t        tag.push(\"memo\");\n\t\t    }\n\t\t    if (fiber.type & exports.NODE_TYPE.__forwardRef__) {\n\t\t        tag.push(\"forwardRef\");\n\t\t    }\n\t\t    if (fiber.type & exports.NODE_TYPE.__lazy__) {\n\t\t        tag.push(\"lazy\");\n\t\t    }\n\t\t    if (fiber.type & exports.NODE_TYPE.__fragment__ && fiber.pendingProps[\"wrap\"]) {\n\t\t        tag.push(\"auto-wrap\");\n\t\t    }\n\t\t    return tag.join(\"-\");\n\t\t};\n\t\tvar getPlainFiberName = function (fiber) {\n\t\t    var typedFiber = fiber;\n\t\t    if (fiber.type & exports.NODE_TYPE.__provider__) {\n\t\t        var typedElementType = fiber.elementType;\n\t\t        var name_2 = typedElementType.Context.displayName;\n\t\t        return \"\".concat(name_2 || \"Context\", \".Provider\");\n\t\t    }\n\t\t    if (fiber.type & exports.NODE_TYPE.__context__) {\n\t\t        var typedElementType = fiber.elementType;\n\t\t        var name_3 = typedElementType.displayName;\n\t\t        return \"\".concat(name_3 || \"Context\");\n\t\t    }\n\t\t    if (fiber.type & exports.NODE_TYPE.__consumer__) {\n\t\t        var typedElementType = fiber.elementType;\n\t\t        var name_4 = typedElementType.Context.displayName;\n\t\t        return \"\".concat(name_4 || \"Context\", \".Consumer\");\n\t\t    }\n\t\t    if (fiber.type & exports.NODE_TYPE.__lazy__) {\n\t\t        var typedElementType = fiber.elementType;\n\t\t        var typedRender = typedElementType === null || typedElementType === void 0 ? void 0 : typedElementType.render;\n\t\t        var name_5 = (typedRender === null || typedRender === void 0 ? void 0 : typedRender.displayName) || (typedRender === null || typedRender === void 0 ? void 0 : typedRender.name) || \"\";\n\t\t        {\n\t\t            var element = typedFiber._debugElement;\n\t\t            // may be a Suspense element\n\t\t            var type = element === null || element === void 0 ? void 0 : element.type;\n\t\t            name_5 = (type === null || type === void 0 ? void 0 : type.displayName) || name_5;\n\t\t        }\n\t\t        return \"\".concat(name_5 || \"Anonymous\");\n\t\t    }\n\t\t    if (fiber.type & exports.NODE_TYPE.__portal__)\n\t\t        return \"Portal\";\n\t\t    if (fiber.type & exports.NODE_TYPE.__null__)\n\t\t        return \"Null\";\n\t\t    if (fiber.type & exports.NODE_TYPE.__empty__)\n\t\t        return \"Empty\";\n\t\t    if (fiber.type & exports.NODE_TYPE.__scope__)\n\t\t        return \"Scope\";\n\t\t    if (fiber.type & exports.NODE_TYPE.__scopeLazy__)\n\t\t        return \"ScopeLazy\";\n\t\t    if (fiber.type & exports.NODE_TYPE.__scopeSuspense__)\n\t\t        return \"ScopeSuspense\";\n\t\t    if (fiber.type & exports.NODE_TYPE.__strict__)\n\t\t        return \"Strict\";\n\t\t    if (fiber.type & exports.NODE_TYPE.__profiler__)\n\t\t        return \"Profiler\";\n\t\t    if (fiber.type & exports.NODE_TYPE.__suspense__)\n\t\t        return \"Suspense\";\n\t\t    if (fiber.type & exports.NODE_TYPE.__comment__)\n\t\t        return \"Comment\";\n\t\t    if (fiber.type & exports.NODE_TYPE.__root__)\n\t\t        return \"Root\";\n\t\t    if (fiber.type & exports.NODE_TYPE.__fragment__)\n\t\t        return \"Fragment\";\n\t\t    if (fiber.type & exports.NODE_TYPE.__text__)\n\t\t        return \"text\";\n\t\t    if (typeof fiber.elementType === \"string\")\n\t\t        return \"\".concat(fiber.elementType);\n\t\t    if (typeof fiber.elementType === \"function\") {\n\t\t        var typedElementType = fiber.elementType;\n\t\t        var name_6 = typedElementType.displayName || typedElementType.name || \"Anonymous\";\n\t\t        {\n\t\t            var element = typedFiber._debugElement;\n\t\t            var type = element === null || element === void 0 ? void 0 : element.type;\n\t\t            name_6 = (type === null || type === void 0 ? void 0 : type.displayName) || name_6;\n\t\t        }\n\t\t        return \"\".concat(name_6);\n\t\t    }\n\t\t    return \"unknown\";\n\t\t};\n\t\t// TODO\n\t\tvar getElementName = function (fiber) {\n\t\t    var name = getPlainFiberName(fiber);\n\t\t    var tag = getFiberTagName(fiber);\n\t\t    return \"<\".concat(name).concat(tag ? \" - (\".concat(tag, \")\") : \"\", \" />\");\n\t\t};\n\t\tvar getFiberNodeName = function (fiber) { return \"\".concat(getElementName(fiber), \" \").concat(getTrackDevLog(fiber)); };\n\t\tvar getFiberNodeNameWithFiber = function (fiber) { return \"%c\".concat(getElementName(fiber), \"%c (%o)\"); };\n\t\tvar getFiberTree$1 = function (fiber) {\n\t\t    if (fiber) {\n\t\t        var preString = \"\".padEnd(4) + \"at\".padEnd(3);\n\t\t        var res = \"\";\n\t\t        var temp = fiber;\n\t\t        if (enableOptimizeTreeLog.current) {\n\t\t            while (temp) {\n\t\t                if (shouldIncludeLog(temp)) {\n\t\t                    res ? (res += \"\\n\".concat(preString).concat(getFiberNodeName(temp))) : (res = \"\".concat(preString).concat(getFiberNodeName(temp)));\n\t\t                }\n\t\t                temp = temp.parent;\n\t\t            }\n\t\t        }\n\t\t        else {\n\t\t            while (temp) {\n\t\t                res ? (res += \"\\n\".concat(preString).concat(getFiberNodeName(temp))) : (res = \"\".concat(preString).concat(getFiberNodeName(temp)));\n\t\t                temp = temp.parent;\n\t\t            }\n\t\t        }\n\t\t        return \"\\n\".concat(res);\n\t\t    }\n\t\t    return \"\";\n\t\t};\n\t\tvar getStackTree = function (fiber) {\n\t\t    var preString = \"\".padEnd(4) + \"at\".padEnd(3);\n\t\t    var res = \"\";\n\t\t    var temp = fiber;\n\t\t    while (temp) {\n\t\t        res ? (res += \"\\n\".concat(preString).concat(getElementName(temp))) : (res = \"\".concat(preString).concat(getElementName(temp)));\n\t\t        temp = temp.parent;\n\t\t    }\n\t\t    return \"\\n\".concat(res);\n\t\t};\n\t\tvar getFiberTreeWithFiber = function (fiber) {\n\t\t    var preString = \"at\".padEnd(3);\n\t\t    var res = \"\";\n\t\t    var arr = [];\n\t\t    var temp = fiber;\n\t\t    while (temp) {\n\t\t        res ? (res += \"\\n\".concat(preString).concat(getFiberNodeNameWithFiber(temp))) : (res = \"\".concat(preString).concat(getFiberNodeNameWithFiber(temp)));\n\t\t        var isMount = temp._debugIsMount;\n\t\t        var isPlain = temp.type & exports.NODE_TYPE.__plain__;\n\t\t        arr.push(\"color: white;background-color: \".concat(isMount ? (isPlain ? typeColor.plain : typeColor.normal) : typeColor.unmount, \"; border-radius: 2px; padding: 1px 5px; margin: 1px 0px\"));\n\t\t        arr.push(\"\");\n\t\t        arr.push(temp);\n\t\t        temp = temp.parent;\n\t\t    }\n\t\t    return { str: \"\".concat(res), arr: arr };\n\t\t};\n\t\tvar getHookTree = function (treeHookNode, errorType) {\n\t\t    var pre = \"\".toString().padEnd(3);\n\t\t    var message = \"[@my-react/react] hook for current component has a different state on current render and previous render, this is not a valid usage.\";\n\t\t    var re = \"\\n\" + pre + \"Last render:\".padEnd(28) + \"Next render:\".padEnd(10) + \"\\n\" + pre + \"-\".repeat(44) + \"\\n\";\n\t\t    var stack = pre + HOOK_TYPE[errorType.lastRender].padEnd(28) + HOOK_TYPE[errorType.nextRender].padEnd(10) + \"\\n\";\n\t\t    while (treeHookNode && treeHookNode.value) {\n\t\t        var t = treeHookNode.value.type;\n\t\t        stack = pre + HOOK_TYPE[t].padEnd(28) + HOOK_TYPE[t].padEnd(10) + \"\\n\" + stack;\n\t\t        treeHookNode = treeHookNode.prev;\n\t\t    }\n\t\t    stack += pre + \"^\".repeat(44);\n\t\t    return message + re + stack;\n\t\t};\n\t\tvar onceWarnWithKeyAndFiber = function (fiber, key) {\n\t\t    var _a;\n\t\t    var _b;\n\t\t    var args = [];\n\t\t    for (var _i = 2; _i < arguments.length; _i++) {\n\t\t        args[_i - 2] = arguments[_i];\n\t\t    }\n\t\t    var renderScheduler = currentScheduler$g.current;\n\t\t    var tree = renderScheduler.getFiberTree(fiber);\n\t\t    if ((_b = warnMap === null || warnMap === void 0 ? void 0 : warnMap[tree]) === null || _b === void 0 ? void 0 : _b[key])\n\t\t        return;\n\t\t    warnMap[tree] = __assign(__assign({}, warnMap === null || warnMap === void 0 ? void 0 : warnMap[tree]), (_a = {}, _a[key] = true, _a));\n\t\t    warnFiber = fiber;\n\t\t    devWarn.apply(void 0, args);\n\t\t    warnFiber = null;\n\t\t};\n\t\tvar onceErrorWithKeyAndFiber = function (fiber, key) {\n\t\t    var _a;\n\t\t    var _b;\n\t\t    var args = [];\n\t\t    for (var _i = 2; _i < arguments.length; _i++) {\n\t\t        args[_i - 2] = arguments[_i];\n\t\t    }\n\t\t    var renderScheduler = currentScheduler$g.current;\n\t\t    var tree = renderScheduler.getFiberTree(fiber);\n\t\t    if ((_b = errorMap === null || errorMap === void 0 ? void 0 : errorMap[tree]) === null || _b === void 0 ? void 0 : _b[key])\n\t\t        return;\n\t\t    errorMap[tree] = __assign(__assign({}, errorMap === null || errorMap === void 0 ? void 0 : errorMap[tree]), (_a = {}, _a[key] = true, _a));\n\t\t    errorFiber = fiber;\n\t\t    devError.apply(void 0, args);\n\t\t    errorFiber = null;\n\t\t};\n\n\t\tvar enableHMRForDev$1 = react.__my_react_shared__.enableHMRForDev;\n\t\tvar emptyProps$1 = {};\n\t\tvar checkIsMyReactElement = function (element) {\n\t\t    if (react.isValidElement(element)) {\n\t\t        var isMyReactElement = element._jsx || element._legacy;\n\t\t        if (!isMyReactElement) {\n\t\t            devWarn(\"[@my-react/react] look like current element is not a valid @my-react element %o\", element);\n\t\t        }\n\t\t    }\n\t\t};\n\t\tvar getElementTypeFromType = function (type) {\n\t\t    if (typeof type === \"object\") {\n\t\t        switch (type[TYPEKEY]) {\n\t\t            case ForwardRef:\n\t\t            case Memo:\n\t\t                return getElementTypeFromType(type.render);\n\t\t        }\n\t\t    }\n\t\t    return type;\n\t\t};\n\t\tvar getTypeFromElementNode = function (element) {\n\t\t    var nodeType = exports.NODE_TYPE.__initial__;\n\t\t    if (enableValidMyReactElement.current) {\n\t\t        checkIsMyReactElement(element);\n\t\t    }\n\t\t    if (react.isValidElement(element)) {\n\t\t        return getTypeFromElement(element);\n\t\t    }\n\t\t    else {\n\t\t        if (typeof element === \"object\" && element !== null) {\n\t\t            {\n\t\t                devWarn(\"[@my-react/react] invalid object element type \\\"\".concat(JSON.stringify(element), \"\\\"\"));\n\t\t            }\n\t\t            nodeType = merge(nodeType, exports.NODE_TYPE.__empty__);\n\t\t        }\n\t\t        else if (element === null || element === undefined || typeof element === \"boolean\" || typeof element === \"function\" || element === \"\") {\n\t\t            nodeType = merge(nodeType, exports.NODE_TYPE.__null__);\n\t\t        }\n\t\t        else {\n\t\t            // text element\n\t\t            return {\n\t\t                key: null,\n\t\t                ref: null,\n\t\t                nodeType: exports.NODE_TYPE.__text__,\n\t\t                elementType: String(element),\n\t\t                pendingProps: emptyProps$1,\n\t\t                finalElement: element,\n\t\t                pendingText: String(element),\n\t\t            };\n\t\t        }\n\t\t    }\n\t\t    return { key: null, ref: null, nodeType: nodeType, elementType: null, pendingProps: emptyProps$1, finalElement: element };\n\t\t};\n\t\tvar getTypeFromElement = function (element) {\n\t\t    var _a, _b, _c, _d, _e, _f, _g;\n\t\t    var nodeType = exports.NODE_TYPE.__initial__;\n\t\t    var elementType = element.type;\n\t\t    var finalElement = element;\n\t\t    var pendingProps = element.props;\n\t\t    var ref = (_a = element.ref) !== null && _a !== void 0 ? _a : undefined;\n\t\t    var key = (_b = element.key) !== null && _b !== void 0 ? _b : undefined;\n\t\t    if (enableHMRForDev$1.current) {\n\t\t        finalElement = getElementFromRefreshIfExist(element);\n\t\t        elementType = finalElement.type;\n\t\t        pendingProps = finalElement.props;\n\t\t        ref = (_c = finalElement.ref) !== null && _c !== void 0 ? _c : undefined;\n\t\t        key = (_d = finalElement.key) !== null && _d !== void 0 ? _d : undefined;\n\t\t    }\n\t\t    if (typeof elementType === \"object\" && elementType !== null) {\n\t\t        var typedElementType = elementType;\n\t\t        switch (typedElementType[TYPEKEY]) {\n\t\t            case Provider:\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__provider__);\n\t\t                break;\n\t\t            // support react 19 context api\n\t\t            case Context:\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__context__);\n\t\t                break;\n\t\t            case Consumer:\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__consumer__);\n\t\t                break;\n\t\t            case Memo:\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__memo__);\n\t\t                elementType = typedElementType.render;\n\t\t                break;\n\t\t            case ForwardRef:\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__forwardRef__);\n\t\t                elementType = typedElementType.render;\n\t\t                break;\n\t\t            case Lazy:\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__lazy__);\n\t\t                break;\n\t\t            default:\n\t\t                throw new Error(\"[@my-react/react] invalid object element type \\\"\".concat((_e = typedElementType[TYPEKEY]) === null || _e === void 0 ? void 0 : _e.toString(), \"\\\"\"));\n\t\t        }\n\t\t        if (typeof elementType === \"object\") {\n\t\t            if (elementType[TYPEKEY] === ForwardRef) {\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__forwardRef__);\n\t\t                elementType = elementType.render;\n\t\t            }\n\t\t            if (elementType[TYPEKEY] === Provider) {\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__provider__);\n\t\t            }\n\t\t            if (elementType[TYPEKEY] === Context) {\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__context__);\n\t\t            }\n\t\t            if (elementType[TYPEKEY] === Consumer) {\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__consumer__);\n\t\t            }\n\t\t        }\n\t\t        if (typeof elementType === \"function\") {\n\t\t            if ((_f = elementType.prototype) === null || _f === void 0 ? void 0 : _f.isMyReactComponent) {\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__class__);\n\t\t            }\n\t\t            else {\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__function__);\n\t\t            }\n\t\t        }\n\t\t    }\n\t\t    else if (typeof elementType === \"function\") {\n\t\t        if ((_g = elementType.prototype) === null || _g === void 0 ? void 0 : _g.isMyReactComponent) {\n\t\t            nodeType = merge(nodeType, exports.NODE_TYPE.__class__);\n\t\t        }\n\t\t        else {\n\t\t            nodeType = merge(nodeType, exports.NODE_TYPE.__function__);\n\t\t        }\n\t\t    }\n\t\t    else if (typeof elementType === \"symbol\") {\n\t\t        switch (elementType) {\n\t\t            case Root:\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__root__);\n\t\t                break;\n\t\t            case Fragment:\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__fragment__);\n\t\t                break;\n\t\t            case Strict:\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__strict__);\n\t\t                break;\n\t\t            case Suspense:\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__suspense__);\n\t\t                break;\n\t\t            case Scope:\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__scope__);\n\t\t                break;\n\t\t            case ScopeLazy:\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__scopeLazy__);\n\t\t                break;\n\t\t            case ScopeSuspense:\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__scopeSuspense__);\n\t\t                break;\n\t\t            case Comment:\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__comment__);\n\t\t                break;\n\t\t            case Portal:\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__portal__);\n\t\t                break;\n\t\t            case Profiler:\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__profiler__);\n\t\t                break;\n\t\t            case Activity:\n\t\t                nodeType = merge(nodeType, exports.NODE_TYPE.__activity__);\n\t\t                break;\n\t\t            default:\n\t\t                throw new Error(\"[@my-react/react] invalid symbol element type \\\"\".concat(elementType === null || elementType === void 0 ? void 0 : elementType.toString(), \"\\\"\"));\n\t\t        }\n\t\t    }\n\t\t    else if (typeof elementType === \"string\" && elementType !== \"\") {\n\t\t        nodeType = merge(nodeType, exports.NODE_TYPE.__plain__);\n\t\t    }\n\t\t    else {\n\t\t        {\n\t\t            devWarn(\"[@my-react/react] invalid element type \\\"\".concat(elementType === null || elementType === void 0 ? void 0 : elementType.toString(), \"\\\"\"));\n\t\t        }\n\t\t        nodeType = merge(nodeType, exports.NODE_TYPE.__empty__);\n\t\t    }\n\t\t    return { key: key, ref: ref, nodeType: nodeType, elementType: elementType, pendingProps: pendingProps, finalElement: finalElement };\n\t\t};\n\n\t\tvar refreshHandler = null;\n\t\t// used for hmr\n\t\tvar typeToFibersMap = new MyWeakMap();\n\t\tvar setRefreshHandler = function (handler) {\n\t\t    {\n\t\t        if (refreshHandler) {\n\t\t            throw new Error(\"[@my-react/react] \\\"refreshHandler\\\" can be only set once\");\n\t\t        }\n\t\t        currentRefreshHandler.current = handler;\n\t\t        refreshHandler = handler;\n\t\t    }\n\t\t};\n\t\tvar setRefreshTypeMap = function (fiber) {\n\t\t    if (include(fiber.type, exports.NODE_TYPE.__class__ | exports.NODE_TYPE.__function__)) {\n\t\t        var elementType = fiber.elementType;\n\t\t        var exist = typeToFibersMap.get(elementType) || new Set();\n\t\t        exist.add(fiber);\n\t\t        typeToFibersMap.set(elementType, exist);\n\t\t    }\n\t\t};\n\t\tvar getCurrentTypeFromRefresh = function (type) {\n\t\t    var _a;\n\t\t    return ((_a = refreshHandler === null || refreshHandler === void 0 ? void 0 : refreshHandler(type)) === null || _a === void 0 ? void 0 : _a.current) || type;\n\t\t};\n\t\tvar getCurrentTypeFromRefreshOnly = function (type) {\n\t\t    var _a;\n\t\t    return (_a = refreshHandler === null || refreshHandler === void 0 ? void 0 : refreshHandler(type)) === null || _a === void 0 ? void 0 : _a.current;\n\t\t};\n\t\tvar getCurrentFibersFromType = function (type) {\n\t\t    return typeToFibersMap.get(type);\n\t\t};\n\t\tvar getCurrentDispatchFromType = function (type) {\n\t\t    var fibers = getCurrentFibersFromType(type);\n\t\t    return new Set(Array.from(fibers || []).map(function (fiber) { return fiberToDispatchMap.get(fiber); }));\n\t\t};\n\t\tvar getCurrentDispatchFromFiber = function (fiber) {\n\t\t    var dispatch = fiberToDispatchMap.get(fiber);\n\t\t    if (dispatch)\n\t\t        return dispatch;\n\t\t    var parent = fiber.parent;\n\t\t    while (parent) {\n\t\t        var typedFiberRoot = parent;\n\t\t        if (typedFiberRoot.renderDispatch) {\n\t\t            return typedFiberRoot.renderDispatch;\n\t\t        }\n\t\t        parent = parent.parent;\n\t\t    }\n\t\t};\n\t\tvar getElementFromRefreshIfExist = function (element) {\n\t\t    var _a, _b;\n\t\t    var elementType = getElementTypeFromType(element.type);\n\t\t    // current element is React component\n\t\t    if (typeof elementType === \"function\") {\n\t\t        var typeFromRefresh = getCurrentTypeFromRefreshOnly(elementType);\n\t\t        // have a new version elementType from hmr runtime\n\t\t        if (typeFromRefresh) {\n\t\t            return react.createElement(typeFromRefresh, __assign(__assign({}, element.props), { key: (_a = element.key) !== null && _a !== void 0 ? _a : undefined, ref: (_b = element.ref) !== null && _b !== void 0 ? _b : undefined }));\n\t\t        }\n\t\t    }\n\t\t    return element;\n\t\t};\n\n\t\tvar currentComponentFiber$5 = react.__my_react_internal__.currentComponentFiber;\n\t\tvar initHMR = function (env) {\n\t\t    {\n\t\t        if (env[\"hmr\"] || env[\"setRefreshHandler\"] || env[\"currentComponentFiber\"] || env[\"getCurrentFibersFromType\"] || env[\"getCurrentDispatchFromType\"]) {\n\t\t            console.error(\"[@my-react/react] current HMR environment is invalid\");\n\t\t            return;\n\t\t        }\n\t\t        try {\n\t\t            env[\"hmr\"] = hmr;\n\t\t            env[\"typeToFibersMap\"] = typeToFibersMap;\n\t\t            env[\"setRefreshHandler\"] = setRefreshHandler;\n\t\t            env[\"currentComponentFiber\"] = currentComponentFiber$5;\n\t\t            env[\"getCurrentFibersFromType\"] = getCurrentFibersFromType;\n\t\t            env[\"getCurrentDispatchFromType\"] = getCurrentDispatchFromType;\n\t\t            env[\"getCurrentDispatchFromFiber\"] = getCurrentDispatchFromFiber;\n\t\t        }\n\t\t        catch (e) {\n\t\t            console.error(\"[@my-react/react] init HMR for current environment failed, \".concat(e.message));\n\t\t        }\n\t\t    }\n\t\t};\n\n\t\tvar currentRunningFiber$3 = react.__my_react_internal__.currentRunningFiber, currentScheduler$f = react.__my_react_internal__.currentScheduler;\n\t\tvar dispatchHook = function (params) {\n\t\t    var fiber = currentRunningFiber$3.current;\n\t\t    if (!fiber) {\n\t\t        throw new Error(\"No current running fiber found for dispatching hook.\");\n\t\t    }\n\t\t    if (include(fiber.state, STATE_TYPE.__unmount__))\n\t\t        return;\n\t\t    var dispatch = getCurrentDispatchFromFiber(fiber);\n\t\t    if (!dispatch) {\n\t\t        throw new Error(\"No dispatch found for the current running fiber.\");\n\t\t    }\n\t\t    return dispatch.dispatchHook(params);\n\t\t};\n\t\tvar dispatchState = function (_params) {\n\t\t    var trigger = _params.trigger;\n\t\t    var fiber = trigger._reactInternals || trigger;\n\t\t    if (!fiber) {\n\t\t        throw new Error(\"No fiber found for dispatching state.\");\n\t\t    }\n\t\t    if (include(fiber.state, STATE_TYPE.__unmount__))\n\t\t        return;\n\t\t    var dispatch = getCurrentDispatchFromFiber(fiber);\n\t\t    if (!dispatch) {\n\t\t        throw new Error(\"No dispatch found for the current running fiber.\");\n\t\t    }\n\t\t    return dispatch.dispatchState(_params);\n\t\t};\n\t\tvar dispatchError = function (_params) {\n\t\t    var fiber = _params.fiber || currentRunningFiber$3.current;\n\t\t    if (!fiber) {\n\t\t        // a normal error\n\t\t        throw _params.error;\n\t\t    }\n\t\t    // if (include(fiber.state, STATE_TYPE.__unmount__)) return;\n\t\t    var dispatch = getCurrentDispatchFromFiber(fiber);\n\t\t    if (!dispatch) {\n\t\t        throw new Error(\"No dispatch found for the current running fiber.\");\n\t\t    }\n\t\t    return dispatch.dispatchError(_params);\n\t\t};\n\t\tvar dispatchPromise = function (_params) {\n\t\t    var fiber = _params.fiber || currentRunningFiber$3.current;\n\t\t    if (!fiber) {\n\t\t        throw new Error(\"No fiber found for dispatching promise.\");\n\t\t    }\n\t\t    // if (include(fiber.state, STATE_TYPE.__unmount__)) return;\n\t\t    var dispatch = getCurrentDispatchFromFiber(fiber);\n\t\t    if (!dispatch) {\n\t\t        throw new Error(\"No dispatch found for the current running fiber.\");\n\t\t    }\n\t\t    return dispatch.dispatchPromise(_params);\n\t\t};\n\t\tvar dispatchSuspensePromise = function (_params) {\n\t\t    var fiber = _params.fiber || currentRunningFiber$3.current;\n\t\t    if (!fiber) {\n\t\t        throw new Error(\"No fiber found for dispatching suspense promise.\");\n\t\t    }\n\t\t    // if (include(fiber.state, STATE_TYPE.__unmount__)) return;\n\t\t    var dispatch = getCurrentDispatchFromFiber(fiber);\n\t\t    if (!dispatch) {\n\t\t        throw new Error(\"No dispatch found for the current running fiber.\");\n\t\t    }\n\t\t    return dispatch.dispatchSuspensePromise(_params);\n\t\t};\n\t\tvar readContext = function (_params) {\n\t\t    var fiber = currentRunningFiber$3.current;\n\t\t    if (!fiber) {\n\t\t        throw new Error(\"No current running fiber found for reading context.\");\n\t\t    }\n\t\t    if (include(fiber.state, STATE_TYPE.__unmount__))\n\t\t        return;\n\t\t    var dispatch = getCurrentDispatchFromFiber(fiber);\n\t\t    if (!dispatch) {\n\t\t        throw new Error(\"No dispatch found for the current running fiber.\");\n\t\t    }\n\t\t    return dispatch.readContext(_params);\n\t\t};\n\t\tvar readPromise = function (_params) {\n\t\t    var fiber = currentRunningFiber$3.current;\n\t\t    if (!fiber) {\n\t\t        throw new Error(\"No current running fiber found for reading promise.\");\n\t\t    }\n\t\t    if (include(fiber.state, STATE_TYPE.__unmount__))\n\t\t        return;\n\t\t    var dispatch = getCurrentDispatchFromFiber(fiber);\n\t\t    if (!dispatch) {\n\t\t        throw new Error(\"No dispatch found for the current running fiber.\");\n\t\t    }\n\t\t    return dispatch.readPromise(_params);\n\t\t};\n\t\tvar getFiberTree = function (fiber) {\n\t\t    var dispatch = getCurrentDispatchFromFiber(fiber);\n\t\t    if (dispatch) {\n\t\t        return dispatch.getFiberTree(fiber);\n\t\t    }\n\t\t    else {\n\t\t        return getFiberTree$1(fiber);\n\t\t    }\n\t\t};\n\t\tvar initScheduler = function () {\n\t\t    var scheduler = currentScheduler$f.current;\n\t\t    scheduler.getFiberTree = getFiberTree;\n\t\t    scheduler.readPromise = readPromise;\n\t\t    scheduler.readContext = readContext;\n\t\t    scheduler.dispatchState = dispatchState;\n\t\t    scheduler.dispatchHook = dispatchHook;\n\t\t    scheduler.dispatchError = dispatchError;\n\t\t    scheduler.dispatchPromise = dispatchPromise;\n\t\t    scheduler.dispatchSuspensePromise = dispatchSuspensePromise;\n\t\t};\n\n\t\tvar enableHMRForDev = react.__my_react_shared__.enableHMRForDev;\n\t\tfunction checkIsSameType(p, element) {\n\t\t    if (p instanceof MyReactFiberNode) {\n\t\t        var _a = getTypeFromElementNode(element), nodeType = _a.nodeType, elementType = _a.elementType;\n\t\t        if (p.type === nodeType) {\n\t\t            if (react.isValidElement(element)) {\n\t\t                if (enableHMRForDev.current && include(nodeType, exports.NODE_TYPE.__class__ | exports.NODE_TYPE.__function__)) {\n\t\t                    // type error\n\t\t                    return Object.is(getCurrentTypeFromRefresh(p.elementType), getCurrentTypeFromRefresh(elementType));\n\t\t                }\n\t\t                else {\n\t\t                    return Object.is(p.elementType, elementType);\n\t\t                }\n\t\t            }\n\t\t            else {\n\t\t                return true;\n\t\t            }\n\t\t        }\n\t\t        else {\n\t\t            return false;\n\t\t        }\n\t\t    }\n\t\t    else {\n\t\t        var existElementType = getTypeFromElementNode(p);\n\t\t        var incomingElementType = getTypeFromElementNode(element);\n\t\t        if (existElementType.nodeType === incomingElementType.nodeType) {\n\t\t            if (react.isValidElement(element)) {\n\t\t                var typedExistElement = p;\n\t\t                var typedIncomingElement = element;\n\t\t                if (enableHMRForDev.current && include(existElementType.nodeType, exports.NODE_TYPE.__class__ | exports.NODE_TYPE.__function__)) {\n\t\t                    return Object.is(getCurrentTypeFromRefresh(typedIncomingElement.type), getCurrentTypeFromRefresh(typedExistElement.type));\n\t\t                }\n\t\t                else {\n\t\t                    return Object.is(typedIncomingElement.type, typedExistElement.type);\n\t\t                }\n\t\t            }\n\t\t            else {\n\t\t                return true;\n\t\t            }\n\t\t        }\n\t\t        else {\n\t\t            return false;\n\t\t        }\n\t\t    }\n\t\t}\n\n\t\tvar generateFiberToMountList = function (fiber) {\n\t\t    var listTree = new ListTree();\n\t\t    var getNext = function (fiber, root) {\n\t\t        if (include(fiber.state, STATE_TYPE.__unmount__)) {\n\t\t            if (fiber.sibling)\n\t\t                return fiber.sibling;\n\t\t            return fiber.parent;\n\t\t        }\n\t\t        if (fiber.child)\n\t\t            return fiber.child;\n\t\t        while (fiber && fiber !== root) {\n\t\t            listTree.push(fiber);\n\t\t            if (fiber.sibling)\n\t\t                return fiber.sibling;\n\t\t            fiber = fiber.parent;\n\t\t        }\n\t\t        if (fiber === root) {\n\t\t            listTree.push(fiber);\n\t\t        }\n\t\t        return null;\n\t\t    };\n\t\t    var f = fiber;\n\t\t    while (f) {\n\t\t        f = getNext(f, fiber);\n\t\t    }\n\t\t    return listTree;\n\t\t};\n\t\tvar generateFiberToUnmountList = generateFiberToMountList;\n\t\t/**\n\t\t *\n\t\t * @param action listToFoot action for performance\n\t\t */\n\t\tvar generateFiberToListWithAction = function (fiber, action) {\n\t\t    var listTree = new ListTree();\n\t\t    var getNext = function (fiber, root) {\n\t\t        if (include(fiber.state, STATE_TYPE.__unmount__)) {\n\t\t            if (fiber.sibling)\n\t\t                return fiber.sibling;\n\t\t            return fiber.parent;\n\t\t        }\n\t\t        if (fiber.child)\n\t\t            return fiber.child;\n\t\t        while (fiber && fiber !== root) {\n\t\t            listTree.push(fiber);\n\t\t            action(fiber);\n\t\t            if (fiber.sibling)\n\t\t                return fiber.sibling;\n\t\t            fiber = fiber.parent;\n\t\t        }\n\t\t        if (fiber === root) {\n\t\t            listTree.push(fiber);\n\t\t            action(fiber);\n\t\t        }\n\t\t        return null;\n\t\t    };\n\t\t    var f = fiber;\n\t\t    while (f) {\n\t\t        f = getNext(f, fiber);\n\t\t    }\n\t\t    return listTree;\n\t\t};\n\n\t\tvar defaultGenerateEffectMap = function (fiber, effect, map, option) {\n\t\t    var list = map.get(fiber);\n\t\t    if (!list) {\n\t\t        list = new ListTree();\n\t\t        map.set(fiber, list);\n\t\t    }\n\t\t    if (option) {\n\t\t        if (option.stickyToHead) {\n\t\t            list.pushToHead(effect);\n\t\t        }\n\t\t        else if (option.stickyToFoot) {\n\t\t            list.pushToLast(effect);\n\t\t        }\n\t\t        else {\n\t\t            list.push(effect);\n\t\t        }\n\t\t    }\n\t\t    else {\n\t\t        list.push(effect);\n\t\t    }\n\t\t};\n\t\tvar defaultInvokeEffect = function (renderDispatch, fiber) {\n\t\t    if (include(fiber.patch, PATCH_TYPE.__effect__)) {\n\t\t        var effectMap = renderDispatch.runtimeMap.effectMap;\n\t\t        var allEffect = effectMap.get(fiber);\n\t\t        effectMap.delete(fiber);\n\t\t        if (allEffect && allEffect.length) {\n\t\t            allEffect.listToFoot(function invokeEffect(effect) {\n\t\t                safeCallWithCurrentFiber({\n\t\t                    fiber: fiber,\n\t\t                    action: function safeCallEffect() {\n\t\t                        effect.call(null);\n\t\t                    },\n\t\t                });\n\t\t            });\n\t\t        }\n\t\t        fiber.patch = remove(fiber.patch, PATCH_TYPE.__effect__);\n\t\t    }\n\t\t};\n\t\tvar defaultInvokeLayoutEffect = function (renderDispatch, fiber) {\n\t\t    if (include(fiber.patch, PATCH_TYPE.__layoutEffect__)) {\n\t\t        var layoutEffectMap = renderDispatch.runtimeMap.layoutEffectMap;\n\t\t        var allLayoutEffect = layoutEffectMap.get(fiber);\n\t\t        layoutEffectMap.delete(fiber);\n\t\t        if (allLayoutEffect && allLayoutEffect.length) {\n\t\t            allLayoutEffect.listToFoot(function invokeLayoutEffect(effect) {\n\t\t                safeCallWithCurrentFiber({\n\t\t                    fiber: fiber,\n\t\t                    action: function safeCallLayoutEffect() {\n\t\t                        effect.call(null);\n\t\t                    },\n\t\t                });\n\t\t            });\n\t\t        }\n\t\t        fiber.patch = remove(fiber.patch, PATCH_TYPE.__layoutEffect__);\n\t\t    }\n\t\t};\n\t\tvar defaultInvokeInsertionEffect = function (renderDispatch, fiber) {\n\t\t    if (include(fiber.patch, PATCH_TYPE.__insertionEffect__)) {\n\t\t        var insertionEffectMap = renderDispatch.runtimeMap.insertionEffectMap;\n\t\t        var allInsertionEffect = insertionEffectMap.get(fiber);\n\t\t        insertionEffectMap.delete(fiber);\n\t\t        if (allInsertionEffect && allInsertionEffect.length) {\n\t\t            allInsertionEffect.listToFoot(function invokeInsertionEffect(effect) {\n\t\t                safeCallWithCurrentFiber({\n\t\t                    fiber: fiber,\n\t\t                    action: function safeCallInsertionEffect() {\n\t\t                        effect.call(null);\n\t\t                    },\n\t\t                });\n\t\t            });\n\t\t        }\n\t\t        fiber.patch = remove(fiber.patch, PATCH_TYPE.__insertionEffect__);\n\t\t    }\n\t\t};\n\t\tvar defaultDeleteCurrentEffect = function (renderDispatch, fiber) {\n\t\t    if (include(fiber.patch, PATCH_TYPE.__insertionEffect__)) {\n\t\t        var insertionEffectMap = renderDispatch.runtimeMap.insertionEffectMap;\n\t\t        insertionEffectMap.delete(fiber);\n\t\t        fiber.patch = remove(fiber.patch, PATCH_TYPE.__insertionEffect__);\n\t\t    }\n\t\t    if (include(fiber.patch, PATCH_TYPE.__layoutEffect__)) {\n\t\t        var layoutEffectMap = renderDispatch.runtimeMap.layoutEffectMap;\n\t\t        layoutEffectMap.delete(fiber);\n\t\t        fiber.patch = remove(fiber.patch, PATCH_TYPE.__layoutEffect__);\n\t\t    }\n\t\t    if (include(fiber.patch, PATCH_TYPE.__effect__)) {\n\t\t        var effectMap = renderDispatch.runtimeMap.effectMap;\n\t\t        effectMap.delete(fiber);\n\t\t        fiber.patch = remove(fiber.patch, PATCH_TYPE.__effect__);\n\t\t    }\n\t\t};\n\t\tvar defaultDeleteChildEffect = function (renderDispatch, fiber) {\n\t\t    var child = fiber.child;\n\t\t    while (child) {\n\t\t        defaultDeleteCurrentEffect(renderDispatch, child);\n\t\t        defaultDeleteChildEffect(renderDispatch, child);\n\t\t        child = child.sibling;\n\t\t    }\n\t\t};\n\t\tvar effectCallbackList = new ListTree();\n\t\tvar addEffectCallback = function (cb) {\n\t\t    effectCallbackList.push(cb);\n\t\t};\n\t\tvar flushEffectCallback = function () {\n\t\t    effectCallbackList.listToFoot(function (cb) {\n\t\t        cb();\n\t\t    });\n\t\t    effectCallbackList.clear();\n\t\t};\n\t\tvar effect = defaultInvokeEffect;\n\t\tvar layoutEffect = defaultInvokeLayoutEffect;\n\t\tvar insertionEffect = defaultInvokeInsertionEffect;\n\n\t\t// TODO use Symbol to avoid conflict\n\t\tvar defaultReadPromise = function (_promise) {\n\t\t    if (_promise.status === \"fulfilled\") {\n\t\t        return _promise._value;\n\t\t    }\n\t\t    else if (_promise.status === \"rejected\") {\n\t\t        throw _promise._reason;\n\t\t    }\n\t\t    else {\n\t\t        throw _promise;\n\t\t    }\n\t\t};\n\t\tvar defaultResolveSuspenseValue = function (fiber) {\n\t\t    var _a;\n\t\t    var parent = fiber.parent;\n\t\t    while (parent) {\n\t\t        if (include(parent.type, exports.NODE_TYPE.__suspense__)) {\n\t\t            return (_a = parent.pendingProps) === null || _a === void 0 ? void 0 : _a[\"fallback\"];\n\t\t        }\n\t\t        parent = parent.parent;\n\t\t    }\n\t\t    return null;\n\t\t};\n\t\tvar defaultResolveSuspenseFiber = function (fiber) {\n\t\t    var parent = fiber.parent;\n\t\t    while (parent) {\n\t\t        if (include(parent.type, exports.NODE_TYPE.__suspense__)) {\n\t\t            return parent;\n\t\t        }\n\t\t        parent = parent.parent;\n\t\t    }\n\t\t    return null;\n\t\t};\n\t\tvar defaultResolveAliveSuspenseFiber = function (fiber) {\n\t\t    while (fiber) {\n\t\t        if (include(fiber.type, exports.NODE_TYPE.__suspense__) && exclude(fiber.state, STATE_TYPE.__unmount__)) {\n\t\t            return fiber;\n\t\t        }\n\t\t        fiber = fiber.parent;\n\t\t    }\n\t\t};\n\n\t\tvar currentRunningFiber$2 = react.__my_react_internal__.currentRunningFiber;\n\t\tvar mountToNextFiberFromRoot = function (renderDispatch, fiber) {\n\t\t    if (include(fiber.state, STATE_TYPE.__unmount__) || renderDispatch.isAppCrashed)\n\t\t        return null;\n\t\t    if (include(fiber.state, STATE_TYPE.__stable__) && fiber.state !== STATE_TYPE.__stable__) {\n\t\t        devErrorWithFiber(fiber, \"[@my-react/react] current fiber state not valid, look like a bug for @my-react\");\n\t\t    }\n\t\t    if (include(fiber.state, STATE_TYPE.__create__ |\n\t\t        STATE_TYPE.__inherit__ |\n\t\t        STATE_TYPE.__triggerSync__ |\n\t\t        STATE_TYPE.__triggerSyncForce__ |\n\t\t        STATE_TYPE.__triggerConcurrent__ |\n\t\t        STATE_TYPE.__triggerConcurrentForce__ |\n\t\t        STATE_TYPE.__retrigger__ |\n\t\t        STATE_TYPE.__reschedule__ |\n\t\t        STATE_TYPE.__recreate__)) {\n\t\t        fiber.state = remove(fiber.state, STATE_TYPE.__retrigger__);\n\t\t        currentRunningFiber$2.current = fiber;\n\t\t        {\n\t\t            runtimeNextWorkDev(renderDispatch, fiber);\n\t\t        }\n\t\t        currentRunningFiber$2.current = null;\n\t\t    }\n\t\t    if (include(fiber.state, STATE_TYPE.__suspense__)) {\n\t\t        fiber.state = STATE_TYPE.__recreate__;\n\t\t    }\n\t\t    else if (!include(fiber.state, STATE_TYPE.__retrigger__)) {\n\t\t        fiber.state = STATE_TYPE.__stable__;\n\t\t    }\n\t\t    else {\n\t\t        fiber.state = STATE_TYPE.__triggerSync__;\n\t\t    }\n\t\t    if (fiber.child)\n\t\t        return fiber.child;\n\t\t    var nextFiber = fiber;\n\t\t    while (nextFiber && nextFiber !== renderDispatch.runtimeFiber.scheduledFiber) {\n\t\t        renderDispatch.generateCommitList(nextFiber);\n\t\t        if (nextFiber.sibling)\n\t\t            return nextFiber.sibling;\n\t\t        // current nextFiber is all done, back to parent\n\t\t        if (nextFiber.parent) {\n\t\t            safeCallWithCurrentFiber({\n\t\t                fiber: nextFiber.parent,\n\t\t                action: function safeCallAfterFiberDone() {\n\t\t                    renderDispatch.callOnAfterFiberDone(nextFiber.parent);\n\t\t                },\n\t\t            });\n\t\t        }\n\t\t        nextFiber = nextFiber.parent;\n\t\t    }\n\t\t    if (nextFiber === renderDispatch.runtimeFiber.scheduledFiber) {\n\t\t        renderDispatch.generateCommitList(nextFiber);\n\t\t        {\n\t\t            safeCallWithCurrentFiber({\n\t\t                fiber: nextFiber,\n\t\t                action: function safeCallAfterFiberDone() {\n\t\t                    renderDispatch.callOnAfterFiberDone(nextFiber);\n\t\t                },\n\t\t            });\n\t\t        }\n\t\t    }\n\t\t    return null;\n\t\t};\n\t\tvar performToNextFiberFromRoot = function (renderDispatch, fiber) {\n\t\t    if (include(fiber.state, STATE_TYPE.__unmount__) || renderDispatch.isAppCrashed)\n\t\t        return null;\n\t\t    if (include(fiber.state, STATE_TYPE.__stable__) && fiber.state !== STATE_TYPE.__stable__) {\n\t\t        devErrorWithFiber(fiber, \"[@my-react/react] current fiber state not valid, look like a bug for @my-react\");\n\t\t    }\n\t\t    if (include(fiber.state, STATE_TYPE.__create__ |\n\t\t        STATE_TYPE.__inherit__ |\n\t\t        STATE_TYPE.__triggerSync__ |\n\t\t        STATE_TYPE.__triggerSyncForce__ |\n\t\t        STATE_TYPE.__triggerConcurrent__ |\n\t\t        STATE_TYPE.__triggerConcurrentForce__ |\n\t\t        STATE_TYPE.__retrigger__ |\n\t\t        STATE_TYPE.__reschedule__ |\n\t\t        STATE_TYPE.__recreate__)) {\n\t\t        fiber.state = remove(fiber.state, STATE_TYPE.__retrigger__);\n\t\t        currentRunningFiber$2.current = fiber;\n\t\t        {\n\t\t            runtimeNextWorkDev(renderDispatch, fiber);\n\t\t        }\n\t\t        currentRunningFiber$2.current = null;\n\t\t        triggerFiberUpdateListener(renderDispatch, fiber);\n\t\t    }\n\t\t    if (include(fiber.state, STATE_TYPE.__suspense__)) {\n\t\t        fiber.state = STATE_TYPE.__recreate__;\n\t\t    }\n\t\t    else if (!include(fiber.state, STATE_TYPE.__retrigger__)) {\n\t\t        fiber.state = STATE_TYPE.__stable__;\n\t\t    }\n\t\t    else {\n\t\t        fiber.state = STATE_TYPE.__triggerSync__;\n\t\t    }\n\t\t    if (fiber.child)\n\t\t        return fiber.child;\n\t\t    var nextFiber = fiber;\n\t\t    while (nextFiber && nextFiber !== renderDispatch.runtimeFiber.scheduledFiber) {\n\t\t        renderDispatch.generateCommitList(nextFiber);\n\t\t        if (nextFiber.sibling)\n\t\t            return nextFiber.sibling;\n\t\t        if (nextFiber.parent) {\n\t\t            safeCallWithCurrentFiber({\n\t\t                fiber: nextFiber.parent,\n\t\t                action: function safeCallAfterFiberDone() {\n\t\t                    renderDispatch.callOnAfterFiberDone(nextFiber.parent);\n\t\t                },\n\t\t            });\n\t\t        }\n\t\t        nextFiber = nextFiber.parent;\n\t\t    }\n\t\t    if (nextFiber === renderDispatch.runtimeFiber.scheduledFiber) {\n\t\t        renderDispatch.generateCommitList(nextFiber);\n\t\t        {\n\t\t            safeCallWithCurrentFiber({\n\t\t                fiber: nextFiber,\n\t\t                action: function safeCallAfterFiberDone() {\n\t\t                    renderDispatch.callOnAfterFiberDone(nextFiber);\n\t\t                },\n\t\t            });\n\t\t        }\n\t\t    }\n\t\t    return null;\n\t\t};\n\n\t\tvar enableSuspenseRoot$3 = react.__my_react_shared__.enableSuspenseRoot;\n\t\tvar currentScheduler$e = react.__my_react_internal__.currentScheduler;\n\t\tvar mountLoopAllFromScheduler = function (renderDispatch) {\n\t\t    while (renderDispatch.runtimeFiber.nextWorkingFiber) {\n\t\t        renderDispatch.runtimeFiber.retriggerFiber = null;\n\t\t        var currentFiber = renderDispatch.runtimeFiber.nextWorkingFiber;\n\t\t        var nextFiber = mountToNextFiberFromRoot(renderDispatch, currentFiber);\n\t\t        var retriggerFiber = renderDispatch.runtimeFiber.retriggerFiber;\n\t\t        renderDispatch.runtimeFiber.nextWorkingFiber = retriggerFiber || nextFiber;\n\t\t        renderDispatch.runtimeFiber.retriggerFiber = null;\n\t\t    }\n\t\t};\n\t\tvar mountLoopAll = function (renderDispatch, fiber) {\n\t\t    renderDispatch.runtimeFiber.scheduledFiber = fiber;\n\t\t    renderDispatch.runtimeFiber.nextWorkingFiber = fiber;\n\t\t    mountLoopAllFromScheduler(renderDispatch);\n\t\t};\n\t\tvar processAsyncLoadListOnAsyncMount = function (renderDispatch) { return __awaiter(void 0, void 0, void 0, function () {\n\t\t    var _loop_1, suspenseField_1, list;\n\t\t    return __generator(this, function (_a) {\n\t\t        switch (_a.label) {\n\t\t            case 0:\n\t\t                _loop_1 = function () {\n\t\t                    var node, suspenseField, list;\n\t\t                    return __generator(this, function (_b) {\n\t\t                        switch (_b.label) {\n\t\t                            case 0:\n\t\t                                node = renderDispatch.pendingSuspenseFiberArray.uniShift();\n\t\t                                suspenseField = getInstanceFieldByInstance(node.instance);\n\t\t                                renderDispatch.pendingSuspenseFiberArray.clear();\n\t\t                                list = suspenseField.asyncLoadList.getAll();\n\t\t                                return [4 /*yield*/, Promise.all(list.map(function (item) { return __awaiter(void 0, void 0, void 0, function () {\n\t\t                                        var set;\n\t\t                                        return __generator(this, function (_a) {\n\t\t                                            switch (_a.label) {\n\t\t                                                case 0:\n\t\t                                                    if (!isPromise(item)) return [3 /*break*/, 2];\n\t\t                                                    return [4 /*yield*/, renderDispatch.processPromise(item)];\n\t\t                                                case 1:\n\t\t                                                    _a.sent();\n\t\t                                                    return [3 /*break*/, 4];\n\t\t                                                case 2: return [4 /*yield*/, renderDispatch.processLazy(item)];\n\t\t                                                case 3:\n\t\t                                                    _a.sent();\n\t\t                                                    _a.label = 4;\n\t\t                                                case 4:\n\t\t                                                    set = new Set(item._list);\n\t\t                                                    item._list.clear();\n\t\t                                                    set.forEach(function (node) {\n\t\t                                                        node.state = remove(node.state, STATE_TYPE.__stable__);\n\t\t                                                        node.state = merge(node.state, STATE_TYPE.__create__);\n\t\t                                                        mountLoopAll(renderDispatch, node);\n\t\t                                                    });\n\t\t                                                    suspenseField.asyncLoadList.uniDelete(item);\n\t\t                                                    return [2 /*return*/];\n\t\t                                            }\n\t\t                                        });\n\t\t                                    }); }))];\n\t\t                            case 1:\n\t\t                                _b.sent();\n\t\t                                return [2 /*return*/];\n\t\t                        }\n\t\t                    });\n\t\t                };\n\t\t                _a.label = 1;\n\t\t            case 1:\n\t\t                if (!renderDispatch.pendingSuspenseFiberArray.length) return [3 /*break*/, 3];\n\t\t                return [5 /*yield**/, _loop_1()];\n\t\t            case 2:\n\t\t                _a.sent();\n\t\t                return [3 /*break*/, 1];\n\t\t            case 3:\n\t\t                if (!enableSuspenseRoot$3.current) return [3 /*break*/, 5];\n\t\t                suspenseField_1 = getInstanceFieldByInstance(renderDispatch);\n\t\t                list = suspenseField_1.asyncLoadList.getAll();\n\t\t                if (list.length === 0)\n\t\t                    return [2 /*return*/];\n\t\t                return [4 /*yield*/, Promise.all(list.map(function (item) { return __awaiter(void 0, void 0, void 0, function () {\n\t\t                        var set;\n\t\t                        return __generator(this, function (_a) {\n\t\t                            switch (_a.label) {\n\t\t                                case 0:\n\t\t                                    if (!isPromise(item)) return [3 /*break*/, 2];\n\t\t                                    return [4 /*yield*/, renderDispatch.processPromise(item)];\n\t\t                                case 1:\n\t\t                                    _a.sent();\n\t\t                                    return [3 /*break*/, 4];\n\t\t                                case 2: return [4 /*yield*/, renderDispatch.processLazy(item)];\n\t\t                                case 3:\n\t\t                                    _a.sent();\n\t\t                                    _a.label = 4;\n\t\t                                case 4:\n\t\t                                    set = new Set(item._list);\n\t\t                                    item._list.clear();\n\t\t                                    set.forEach(function (node) {\n\t\t                                        node.state = remove(node.state, STATE_TYPE.__stable__);\n\t\t                                        node.state = merge(node.state, STATE_TYPE.__create__);\n\t\t                                        mountLoopAll(renderDispatch, node);\n\t\t                                    });\n\t\t                                    suspenseField_1.asyncLoadList.uniDelete(item);\n\t\t                                    return [2 /*return*/];\n\t\t                            }\n\t\t                        });\n\t\t                    }); }))];\n\t\t            case 4:\n\t\t                _a.sent();\n\t\t                processAsyncLoadListOnAsyncMount(renderDispatch);\n\t\t                _a.label = 5;\n\t\t            case 5: return [2 /*return*/];\n\t\t        }\n\t\t    });\n\t\t}); };\n\t\tvar processAsyncLoadListOnSyncMount = function (renderDispatch) {\n\t\t    var _a;\n\t\t    if ((_a = renderDispatch.pendingSuspenseFiberArray) === null || _a === void 0 ? void 0 : _a.length) {\n\t\t        var allPendingSuspenseFiberArray = renderDispatch.pendingSuspenseFiberArray.getAll();\n\t\t        if (renderDispatch.enableAsyncLoad) {\n\t\t            var allField_1 = [];\n\t\t            allPendingSuspenseFiberArray.forEach(function (node) {\n\t\t                defaultDeleteChildEffect(renderDispatch, node);\n\t\t                var field = getInstanceFieldByInstance(node.instance);\n\t\t                var allPendingLoadArray = field.asyncLoadList.getAll().filter(function (item) {\n\t\t                    if (isPromise(item)) {\n\t\t                        return typeof item.status !== \"string\";\n\t\t                    }\n\t\t                    else {\n\t\t                        return !item._loading && !item._loaded && !item._error;\n\t\t                    }\n\t\t                });\n\t\t                if (allPendingLoadArray.length) {\n\t\t                    Promise.all(allPendingLoadArray.map(function (item) { return __awaiter(void 0, void 0, void 0, function () {\n\t\t                        var _a;\n\t\t                        return __generator(this, function (_b) {\n\t\t                            switch (_b.label) {\n\t\t                                case 0:\n\t\t                                    if (!isPromise(item)) return [3 /*break*/, 2];\n\t\t                                    return [4 /*yield*/, renderDispatch.processPromise(item)];\n\t\t                                case 1:\n\t\t                                    _b.sent();\n\t\t                                    return [3 /*break*/, 4];\n\t\t                                case 2: return [4 /*yield*/, renderDispatch.processLazy(item)];\n\t\t                                case 3:\n\t\t                                    _b.sent();\n\t\t                                    _b.label = 4;\n\t\t                                case 4:\n\t\t                                    (_a = item._list) === null || _a === void 0 ? void 0 : _a.clear();\n\t\t                                    field.asyncLoadList.uniDelete(item);\n\t\t                                    return [2 /*return*/];\n\t\t                            }\n\t\t                        });\n\t\t                    }); })).then(function () {\n\t\t                        var aliveNode = defaultResolveAliveSuspenseFiber(node) || renderDispatch.rootFiber;\n\t\t                        aliveNode.state = STATE_TYPE.__triggerSyncForce__;\n\t\t                        var renderScheduler = currentScheduler$e.current;\n\t\t                        var updater = {\n\t\t                            type: UpdateQueueType.suspense,\n\t\t                            trigger: aliveNode,\n\t\t                            isSync: true,\n\t\t                            isForce: true,\n\t\t                            payLoad: allPendingLoadArray,\n\t\t                        };\n\t\t                        renderScheduler.dispatchState(updater);\n\t\t                    });\n\t\t                }\n\t\t                node.state = STATE_TYPE.__create__;\n\t\t                field.isHidden = true;\n\t\t                allField_1.push(field);\n\t\t            });\n\t\t            var root = renderDispatch.rootFiber;\n\t\t            root.state = remove(root.state, STATE_TYPE.__stable__);\n\t\t            root.state = merge(root.state, STATE_TYPE.__retrigger__);\n\t\t            // TODO use hide tree to improve\n\t\t            mountLoopAll(renderDispatch, root);\n\t\t            allField_1.forEach(function (field) { return (field.isHidden = false); });\n\t\t            renderDispatch.pendingSuspenseFiberArray.clear();\n\t\t        }\n\t\t        else {\n\t\t            throw new Error(\"[@my-react/reconciler] should not process async load list on sync mount without enableAsyncLoad, you may use a wrong renderDispatch instance\");\n\t\t        }\n\t\t    }\n\t\t    if (enableSuspenseRoot$3.current) {\n\t\t        var suspenseField_2 = getInstanceFieldByInstance(renderDispatch);\n\t\t        var list = suspenseField_2.asyncLoadList.getAll();\n\t\t        if (list.length === 0)\n\t\t            return;\n\t\t        if (renderDispatch.enableAsyncLoad) {\n\t\t            var allPendingLoadArray = list.filter(function (item) {\n\t\t                if (isPromise(item)) {\n\t\t                    return typeof item.status !== \"string\";\n\t\t                }\n\t\t                else {\n\t\t                    return !item._loading && !item._loaded && !item._error;\n\t\t                }\n\t\t            });\n\t\t            if (allPendingLoadArray.length) {\n\t\t                allPendingLoadArray.forEach(function (item) { var _a; return (_a = item._list) === null || _a === void 0 ? void 0 : _a.forEach(function (node) { return defaultDeleteCurrentEffect(renderDispatch, node); }); });\n\t\t                Promise.all(allPendingLoadArray.map(function (item) { return __awaiter(void 0, void 0, void 0, function () {\n\t\t                    var allFiber;\n\t\t                    var _a;\n\t\t                    return __generator(this, function (_b) {\n\t\t                        switch (_b.label) {\n\t\t                            case 0:\n\t\t                                if (!isPromise(item)) return [3 /*break*/, 2];\n\t\t                                return [4 /*yield*/, renderDispatch.processPromise(item)];\n\t\t                            case 1:\n\t\t                                _b.sent();\n\t\t                                return [3 /*break*/, 4];\n\t\t                            case 2: return [4 /*yield*/, renderDispatch.processLazy(item)];\n\t\t                            case 3:\n\t\t                                _b.sent();\n\t\t                                _b.label = 4;\n\t\t                            case 4:\n\t\t                                allFiber = new Set(item._list);\n\t\t                                (_a = item._list) === null || _a === void 0 ? void 0 : _a.clear();\n\t\t                                allFiber.forEach(function (node) {\n\t\t                                    node.state = STATE_TYPE.__recreate__;\n\t\t                                    var renderScheduler = currentScheduler$e.current;\n\t\t                                    var updater = {\n\t\t                                        type: UpdateQueueType.suspense,\n\t\t                                        trigger: node,\n\t\t                                        isSync: true,\n\t\t                                        isForce: true,\n\t\t                                        payLoad: [item],\n\t\t                                    };\n\t\t                                    renderScheduler.dispatchState(updater);\n\t\t                                });\n\t\t                                suspenseField_2.asyncLoadList.uniDelete(item);\n\t\t                                return [2 /*return*/];\n\t\t                        }\n\t\t                    });\n\t\t                }); }));\n\t\t            }\n\t\t        }\n\t\t        else {\n\t\t            throw new Error(\"[@my-react/reconciler] should not process async load list on sync mount without enableAsyncLoad, you may use a wrong renderDispatch instance\");\n\t\t        }\n\t\t    }\n\t\t};\n\n\t\tvar enableSuspenseRoot$2 = react.__my_react_shared__.enableSuspenseRoot;\n\t\tvar currentScheduler$d = react.__my_react_internal__.currentScheduler;\n\t\texports.updateTypeEnum = void 0;\n\t\t(function (updateTypeEnum) {\n\t\t    updateTypeEnum[updateTypeEnum[\"syncFromRoot\"] = 0] = \"syncFromRoot\";\n\t\t    updateTypeEnum[updateTypeEnum[\"syncFromTrigger\"] = 1] = \"syncFromTrigger\";\n\t\t    updateTypeEnum[updateTypeEnum[\"concurrentFromRoot\"] = 2] = \"concurrentFromRoot\";\n\t\t    updateTypeEnum[updateTypeEnum[\"concurrentFromTrigger\"] = 3] = \"concurrentFromTrigger\";\n\t\t})(exports.updateTypeEnum || (exports.updateTypeEnum = {}));\n\t\tvar triggerFiberUpdateListener = function (renderDispatch, fiber) {\n\t\t    safeCallWithCurrentFiber({\n\t\t        fiber: fiber,\n\t\t        action: function safeCallPatchToFiberUpdate() {\n\t\t            var _a;\n\t\t            (_a = renderDispatch.patchToFiberUpdate) === null || _a === void 0 ? void 0 : _a.call(renderDispatch, fiber);\n\t\t        },\n\t\t    });\n\t\t    safeCallWithCurrentFiber({\n\t\t        fiber: fiber,\n\t\t        action: function safeCallFiberUpdateListener() {\n\t\t            renderDispatch.callOnFiberUpdate(fiber);\n\t\t        },\n\t\t    });\n\t\t};\n\t\tvar updateLoopSyncFromRoot = function (renderDispatch) {\n\t\t    while (renderDispatch.runtimeFiber.nextWorkingFiber) {\n\t\t        renderDispatch.runtimeFiber.retriggerFiber = null;\n\t\t        var currentFiber = renderDispatch.runtimeFiber.nextWorkingFiber;\n\t\t        var nextFiber = performToNextFiberFromRoot(renderDispatch, currentFiber);\n\t\t        var retriggerFiber = renderDispatch.runtimeFiber.retriggerFiber;\n\t\t        renderDispatch.runtimeFiber.nextWorkingFiber = retriggerFiber || nextFiber;\n\t\t        renderDispatch.runtimeFiber.retriggerFiber = null;\n\t\t    }\n\t\t};\n\t\tvar updateLoopConcurrentFromRoot = function (renderDispatch) {\n\t\t    var hasSync = false;\n\t\t    while (renderDispatch.runtimeFiber.nextWorkingFiber && !renderDispatch.shouldYield()) {\n\t\t        renderDispatch.runtimeFiber.retriggerFiber = null;\n\t\t        var currentFiber = renderDispatch.runtimeFiber.nextWorkingFiber;\n\t\t        hasSync = hasSync || include(currentFiber.state, STATE_TYPE.__triggerSync__ | STATE_TYPE.__triggerSyncForce__);\n\t\t        var nextFiber = performToNextFiberFromRoot(renderDispatch, currentFiber);\n\t\t        var retriggerFiber = renderDispatch.runtimeFiber.retriggerFiber;\n\t\t        renderDispatch.runtimeFiber.nextWorkingFiber = retriggerFiber || nextFiber;\n\t\t        renderDispatch.runtimeFiber.retriggerFiber = null;\n\t\t    }\n\t\t    return hasSync;\n\t\t};\n\t\tvar processAsyncLoadListOnUpdate = function (renderDispatch) {\n\t\t    var _a;\n\t\t    if ((_a = renderDispatch.pendingSuspenseFiberArray) === null || _a === void 0 ? void 0 : _a.length) {\n\t\t        var allPendingSuspenseFiberArray = renderDispatch.pendingSuspenseFiberArray.getAll();\n\t\t        if (renderDispatch.enableAsyncLoad) {\n\t\t            var allField_1 = [];\n\t\t            allPendingSuspenseFiberArray.forEach(function (node) {\n\t\t                defaultDeleteChildEffect(renderDispatch, node);\n\t\t                var field = getInstanceFieldByInstance(node.instance);\n\t\t                var allPendingLoadArray = field.asyncLoadList.getAll().filter(function (item) {\n\t\t                    if (isPromise(item)) {\n\t\t                        return typeof item.status !== \"string\";\n\t\t                    }\n\t\t                    else {\n\t\t                        return !item._loading && !item._loaded && !item._error;\n\t\t                    }\n\t\t                });\n\t\t                if (allPendingLoadArray.length) {\n\t\t                    Promise.all(allPendingLoadArray.map(function (item) { return __awaiter(void 0, void 0, void 0, function () {\n\t\t                        var _a;\n\t\t                        return __generator(this, function (_b) {\n\t\t                            switch (_b.label) {\n\t\t                                case 0:\n\t\t                                    if (!isPromise(item)) return [3 /*break*/, 2];\n\t\t                                    return [4 /*yield*/, renderDispatch.processPromise(item)];\n\t\t                                case 1:\n\t\t                                    _b.sent();\n\t\t                                    return [3 /*break*/, 4];\n\t\t                                case 2: return [4 /*yield*/, renderDispatch.processLazy(item)];\n\t\t                                case 3:\n\t\t                                    _b.sent();\n\t\t                                    _b.label = 4;\n\t\t                                case 4:\n\t\t                                    (_a = item._list) === null || _a === void 0 ? void 0 : _a.clear();\n\t\t                                    field.asyncLoadList.uniDelete(item);\n\t\t                                    return [2 /*return*/];\n\t\t                            }\n\t\t                        });\n\t\t                    }); })).then(function () {\n\t\t                        var aliveNode = defaultResolveAliveSuspenseFiber(node) || renderDispatch.rootFiber;\n\t\t                        aliveNode.state = STATE_TYPE.__triggerSyncForce__;\n\t\t                        var renderScheduler = currentScheduler$d.current;\n\t\t                        var updater = {\n\t\t                            type: UpdateQueueType.suspense,\n\t\t                            trigger: aliveNode,\n\t\t                            isSync: true,\n\t\t                            isForce: true,\n\t\t                            payLoad: allPendingLoadArray,\n\t\t                        };\n\t\t                        renderScheduler.dispatchState(updater);\n\t\t                    });\n\t\t                }\n\t\t                // fix hmr\n\t\t                node.state = STATE_TYPE.__reschedule__;\n\t\t                field.isHidden = true;\n\t\t                allField_1.push(field);\n\t\t            });\n\t\t            var root = renderDispatch.rootFiber;\n\t\t            root.state = remove(root.state, STATE_TYPE.__stable__);\n\t\t            root.state = merge(root.state, STATE_TYPE.__retrigger__);\n\t\t            // TODO use hide tree to improve\n\t\t            mountLoopAll(renderDispatch, root);\n\t\t            allField_1.forEach(function (field) { return (field.isHidden = false); });\n\t\t            renderDispatch.pendingSuspenseFiberArray.clear();\n\t\t        }\n\t\t        else {\n\t\t            throw new Error(\"[@my-react/reconciler] should not process async load list on sync mount without enableAsyncLoad, you may use a wrong renderDispatch instance\");\n\t\t        }\n\t\t    }\n\t\t    // TODO update flow\n\t\t    if (enableSuspenseRoot$2.current) {\n\t\t        var suspenseField = getInstanceFieldByInstance(renderDispatch);\n\t\t        var list = suspenseField.asyncLoadList.getAll();\n\t\t        if (list.length === 0)\n\t\t            return;\n\t\t        if (renderDispatch.enableAsyncLoad) {\n\t\t            throw new Error(\"[@my-react/reconciler] not implemented yet\");\n\t\t        }\n\t\t        else {\n\t\t            throw new Error(\"[@my-react/reconciler] should not process async load list on sync mount without enableAsyncLoad, you may use a wrong renderDispatch instance\");\n\t\t        }\n\t\t    }\n\t\t};\n\n\t\tvar isErrorBoundariesInstance = function (instance, Component) {\n\t\t    return typeof instance.componentDidCatch === \"function\" || typeof Component.getDerivedStateFromError === \"function\";\n\t\t};\n\t\tvar isErrorBoundariesComponent = function (fiber) {\n\t\t    if (include(fiber.type, exports.NODE_TYPE.__class__) && include(fiber.state, STATE_TYPE.__stable__)) {\n\t\t        var Component = fiber.elementType;\n\t\t        var typedComponent = Component;\n\t\t        var typedInstance = fiber.instance;\n\t\t        return isErrorBoundariesInstance(typedInstance, typedComponent);\n\t\t    }\n\t\t    return false;\n\t\t};\n\t\tvar defaultResolveErrorBoundaries = function (fiber) {\n\t\t    var parent = fiber.parent;\n\t\t    while (parent) {\n\t\t        if (isErrorBoundariesComponent(parent)) {\n\t\t            return parent;\n\t\t        }\n\t\t        parent = parent.parent;\n\t\t    }\n\t\t    return null;\n\t\t};\n\n\t\tvar initClassInstance = function (instance) {\n\t\t    var field = getInstanceFieldByInstance(instance);\n\t\t    if (!field)\n\t\t        throw new Error(\"[@my-react/react] can not find instance field for component, look like a bug for @my-react\");\n\t\t    var typedField = field;\n\t\t    typedField.isMounted = false;\n\t\t};\n\t\tvar mountClassInstance = function (instance) {\n\t\t    var field = getInstanceFieldByInstance(instance);\n\t\t    if (!field)\n\t\t        throw new Error(\"[@my-react/react] can not find instance field for component, look like a bug for @my-react\");\n\t\t    var typedField = field;\n\t\t    typedField.isMounted = true;\n\t\t};\n\t\tvar getClassInstanceFieldByInstance = function (instance) {\n\t\t    var field = getInstanceFieldByInstance(instance);\n\t\t    if (!field)\n\t\t        throw new Error(\"[@my-react/react] can not find instance field for component, look like a bug for @my-react\");\n\t\t    return field;\n\t\t};\n\n\t\t/* eslint-disable max-lines */\n\t\tvar enableLegacyLifeCycle = react.__my_react_shared__.enableLegacyLifeCycle;\n\t\t// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n\t\t// @ts-ignore\n\t\tif (!Object.prototype.hasOwnProperty.call(react.Component.prototype, \"_reactInternals\")) {\n\t\t    Object.defineProperty(react.Component.prototype, \"_reactInternals\", {\n\t\t        get: function () {\n\t\t            return getInstanceOwnerFiber(this);\n\t\t        },\n\t\t        set: function () {\n\t\t            // do nothing\n\t\t        },\n\t\t        configurable: false,\n\t\t    });\n\t\t}\n\t\tvar processComponentStateFromProps = function (fiber) {\n\t\t    var Component = fiber.elementType;\n\t\t    var typedComponent = Component;\n\t\t    var typedInstance = fiber.instance;\n\t\t    var pendingProps = fiber.pendingProps;\n\t\t    var pendingState = fiber.pendingState;\n\t\t    if (typedComponent.getDerivedStateFromProps) {\n\t\t        var payloadState = safeCallWithCurrentFiber({\n\t\t            fiber: fiber,\n\t\t            action: function safeCallGetDerivedStateFromProps() {\n\t\t                var _a;\n\t\t                return (_a = typedComponent.getDerivedStateFromProps) === null || _a === void 0 ? void 0 : _a.call(typedComponent, pendingProps, pendingState);\n\t\t            },\n\t\t        });\n\t\t        if (payloadState) {\n\t\t            var newState = Object.assign({}, pendingState, payloadState);\n\t\t            typedInstance.state = newState;\n\t\t            fiber.pendingState = newState;\n\t\t        }\n\t\t    }\n\t\t};\n\t\tvar processComponentInstanceOnMount = function (renderDispatch, fiber) {\n\t\t    var Component = fiber.elementType;\n\t\t    var typedComponent = Component;\n\t\t    var providerFiber = renderDispatch.resolveContextFiber(fiber, typedComponent.contextType);\n\t\t    var context = renderDispatch.resolveContextValue(providerFiber, typedComponent.contextType);\n\t\t    var props = Object.assign({}, fiber.pendingProps);\n\t\t    Object.freeze(props);\n\t\t    var instance = safeCallWithCurrentFiber({\n\t\t        fiber: fiber,\n\t\t        action: function safeCallCreateComponentInstance() {\n\t\t            return new typedComponent(props, context);\n\t\t        },\n\t\t    });\n\t\t    safeCallWithCurrentFiber({\n\t\t        fiber: fiber,\n\t\t        action: function safeCallInstanceInitialListener() {\n\t\t            renderDispatch.callOnInstanceInitial(instance, fiber);\n\t\t        },\n\t\t    });\n\t\t    Object.freeze(instance.state);\n\t\t    instance.props = props;\n\t\t    instance.context = context;\n\t\t    fiber.instance = instance;\n\t\t    initInstance(instance);\n\t\t    initClassInstance(instance);\n\t\t    setOwnerForInstance(instance, fiber);\n\t\t    setContextForInstance(instance, providerFiber);\n\t\t    fiber.pendingState = instance.state;\n\t\t};\n\t\tvar processComponentFiberOnUpdate = function (renderDispatch, fiber) {\n\t\t    var typedInstance = fiber.instance;\n\t\t    safeCallWithCurrentFiber({\n\t\t        fiber: fiber,\n\t\t        action: function safeCallInstanceUpdateListener() {\n\t\t            renderDispatch.callOnInstanceUpdate(typedInstance, fiber);\n\t\t        },\n\t\t    });\n\t\t    setOwnerForInstance(typedInstance, fiber);\n\t\t};\n\t\tvar processComponentRenderOnMountAndUpdate = function (fiber) {\n\t\t    var typedInstance = fiber.instance;\n\t\t    var children = safeCallWithCurrentFiber({\n\t\t        fiber: fiber,\n\t\t        action: function safeCallRender() {\n\t\t            return typedInstance.render();\n\t\t        },\n\t\t    });\n\t\t    return children;\n\t\t};\n\t\tvar processComponentDidMountOnMount = function (renderDispatch, fiber) {\n\t\t    var typedInstance = fiber.instance;\n\t\t    var effect = getInstanceEffectState(typedInstance);\n\t\t    if (exclude(effect, Effect_TYPE.__effect__)) {\n\t\t        setEffectForInstance(typedInstance, Effect_TYPE.__effect__);\n\t\t        renderDispatch.pendingLayoutEffect(fiber, function invokeComponentDidMountOnInstance() {\n\t\t            var _a;\n\t\t            setEffectForInstance(typedInstance, Effect_TYPE.__initial__);\n\t\t            (_a = typedInstance.componentDidMount) === null || _a === void 0 ? void 0 : _a.call(typedInstance);\n\t\t            mountClassInstance(typedInstance);\n\t\t        });\n\t\t    }\n\t\t};\n\t\tvar processComponentContextOnUpdate = function (renderDispatch, fiber) {\n\t\t    var Component = fiber.elementType;\n\t\t    var typedComponent = Component;\n\t\t    var typedInstance = fiber.instance;\n\t\t    if (typedComponent.contextType) {\n\t\t        var contextFiber = getInstanceContextFiber(typedInstance);\n\t\t        if (!contextFiber || include(contextFiber.state, STATE_TYPE.__unmount__)) {\n\t\t            var providerFiber = renderDispatch.resolveContextFiber(fiber, typedComponent.contextType);\n\t\t            var context = renderDispatch.resolveContextValue(providerFiber, typedComponent.contextType);\n\t\t            setContextForInstance(typedInstance, providerFiber);\n\t\t            return context;\n\t\t        }\n\t\t        else {\n\t\t            var context = renderDispatch.resolveContextValue(contextFiber, typedComponent.contextType);\n\t\t            setContextForInstance(typedInstance, contextFiber);\n\t\t            return context;\n\t\t        }\n\t\t    }\n\t\t};\n\t\tvar processComponentPropsAndContextOnActive = function (renderDispatch, fiber) {\n\t\t    var props = Object.assign({}, fiber.pendingProps);\n\t\t    var context = processComponentContextOnUpdate(renderDispatch, fiber);\n\t\t    var typedInstance = fiber.instance;\n\t\t    typedInstance.props = props;\n\t\t    typedInstance.context = context;\n\t\t};\n\t\tvar processComponentShouldUpdateOnUpdate = function (fiber, _a) {\n\t\t    var nextState = _a.nextState, nextProps = _a.nextProps, nextContext = _a.nextContext;\n\t\t    var typedInstance = fiber.instance;\n\t\t    // if (include(fiber.state, STATE_TYPE.__triggerSync__ | STATE_TYPE.__triggerConcurrent__)) return true;\n\t\t    if (typedInstance.shouldComponentUpdate) {\n\t\t        return safeCallWithCurrentFiber({\n\t\t            fiber: fiber,\n\t\t            action: function safeCallShouldComponentUpdateOnInstance() {\n\t\t                var _a;\n\t\t                return (_a = typedInstance.shouldComponentUpdate) === null || _a === void 0 ? void 0 : _a.call(typedInstance, nextProps, nextState, nextContext);\n\t\t            },\n\t\t        });\n\t\t    }\n\t\t    return true;\n\t\t};\n\t\tvar processComponentGetSnapshotOnUpdate = function (fiber, _a) {\n\t\t    var baseState = _a.baseState, baseProps = _a.baseProps;\n\t\t    var typedInstance = fiber.instance;\n\t\t    if (typedInstance.getSnapshotBeforeUpdate) {\n\t\t        return safeCallWithCurrentFiber({\n\t\t            fiber: fiber,\n\t\t            action: function safeCallGetSnapshotBeforeUpdateOnInstance() {\n\t\t                var _a;\n\t\t                return (_a = typedInstance.getSnapshotBeforeUpdate) === null || _a === void 0 ? void 0 : _a.call(typedInstance, baseProps, baseState);\n\t\t            },\n\t\t        });\n\t\t    }\n\t\t    return null;\n\t\t};\n\t\tvar processComponentDidUpdateOnUpdate = function (renderDispatch, fiber, _a) {\n\t\t    var baseState = _a.baseState, baseProps = _a.baseProps, snapshot = _a.snapshot;\n\t\t    var typedInstance = fiber.instance;\n\t\t    var effect = getInstanceEffectState(typedInstance);\n\t\t    if (typedInstance.componentDidUpdate && exclude(effect, Effect_TYPE.__effect__)) {\n\t\t        setEffectForInstance(typedInstance, Effect_TYPE.__effect__);\n\t\t        renderDispatch.pendingLayoutEffect(fiber, function invokeComponentDidUpdateOnInstance() {\n\t\t            var _a;\n\t\t            setEffectForInstance(typedInstance, Effect_TYPE.__initial__);\n\t\t            (_a = typedInstance.componentDidUpdate) === null || _a === void 0 ? void 0 : _a.call(typedInstance, baseProps, baseState, snapshot);\n\t\t        });\n\t\t    }\n\t\t};\n\t\t/**\n\t\t * @deprecated\n\t\t */\n\t\tvar processComponentWillMountOnMount = function (fiber) {\n\t\t    var typedInstance = fiber.instance;\n\t\t    var hasLegacyLifeFunction = false;\n\t\t    if (typedInstance.UNSAFE_componentWillMount) {\n\t\t        hasLegacyLifeFunction = true;\n\t\t        safeCallWithCurrentFiber({\n\t\t            fiber: fiber,\n\t\t            action: function safeCallUNSAFE_componentWillMountOnInstance() {\n\t\t                var _a;\n\t\t                (_a = typedInstance.UNSAFE_componentWillMount) === null || _a === void 0 ? void 0 : _a.call(typedInstance);\n\t\t            },\n\t\t        });\n\t\t        {\n\t\t            onceWarnWithKeyAndFiber(fiber, \"UNSAFE_componentWillMount\", \"[@my-react/react] current component have legacy lifeCycle function 'UNSAFE_componentWillMount'\");\n\t\t        }\n\t\t    }\n\t\t    if (typedInstance.componentWillMount) {\n\t\t        hasLegacyLifeFunction = true;\n\t\t        safeCallWithCurrentFiber({\n\t\t            fiber: fiber,\n\t\t            action: function safeCallComponentWillMountOnInstance() {\n\t\t                var _a;\n\t\t                (_a = typedInstance.componentWillMount) === null || _a === void 0 ? void 0 : _a.call(typedInstance);\n\t\t            },\n\t\t        });\n\t\t        {\n\t\t            onceWarnWithKeyAndFiber(fiber, \"componentWillMount\", \"[@my-react/react] current component have legacy lifeCycle function 'componentWillMount'\");\n\t\t        }\n\t\t    }\n\t\t    return hasLegacyLifeFunction;\n\t\t};\n\t\t/**\n\t\t * @deprecated\n\t\t */\n\t\tvar processComponentWillReceiveProps = function (fiber) {\n\t\t    var typedInstance = fiber.instance;\n\t\t    var hasLegacyLifeFunction = false;\n\t\t    // only trigger on parent component update\n\t\t    if (include(fiber.state, STATE_TYPE.__inherit__)) {\n\t\t        if (typedInstance.UNSAFE_componentWillReceiveProps) {\n\t\t            hasLegacyLifeFunction = true;\n\t\t            var nextProps_1 = Object.assign({}, fiber.pendingProps);\n\t\t            safeCallWithCurrentFiber({\n\t\t                fiber: fiber,\n\t\t                action: function safeCallUNSAFE_componentWillReceivePropsOnInstance() {\n\t\t                    var _a;\n\t\t                    (_a = typedInstance.UNSAFE_componentWillReceiveProps) === null || _a === void 0 ? void 0 : _a.call(typedInstance, nextProps_1);\n\t\t                },\n\t\t            });\n\t\t            {\n\t\t                onceWarnWithKeyAndFiber(fiber, \"UNSAFE_componentWillReceiveProps\", \"[@my-react/react] current component have legacy lifeCycle function 'UNSAFE_componentWillReceiveProps'\");\n\t\t            }\n\t\t        }\n\t\t        if (typedInstance.componentWillReceiveProps) {\n\t\t            hasLegacyLifeFunction = true;\n\t\t            var nextProps_2 = Object.assign({}, fiber.pendingProps);\n\t\t            safeCallWithCurrentFiber({\n\t\t                fiber: fiber,\n\t\t                action: function safeCallComponentWillReceivePropsOnInstance() {\n\t\t                    var _a;\n\t\t                    (_a = typedInstance.componentWillReceiveProps) === null || _a === void 0 ? void 0 : _a.call(typedInstance, nextProps_2);\n\t\t                },\n\t\t            });\n\t\t            {\n\t\t                onceWarnWithKeyAndFiber(fiber, \"componentWillReceiveProps\", \"[@my-react/react] current component have legacy lifeCycle function 'componentWillReceiveProps'\");\n\t\t            }\n\t\t        }\n\t\t    }\n\t\t    return hasLegacyLifeFunction;\n\t\t};\n\t\t/**\n\t\t * @deprecated\n\t\t */\n\t\tvar processComponentWillUpdate = function (fiber, _a) {\n\t\t    var nextProps = _a.nextProps, nextState = _a.nextState;\n\t\t    var typedInstance = fiber.instance;\n\t\t    if (typedInstance.UNSAFE_componentWillUpdate) {\n\t\t        safeCallWithCurrentFiber({\n\t\t            fiber: fiber,\n\t\t            action: function safeCallUNSAFE_componentWillUpdateOnInstance() {\n\t\t                var _a;\n\t\t                (_a = typedInstance.UNSAFE_componentWillUpdate) === null || _a === void 0 ? void 0 : _a.call(typedInstance, nextProps, nextState);\n\t\t            },\n\t\t        });\n\t\t        {\n\t\t            onceWarnWithKeyAndFiber(fiber, \"UNSAFE_componentWillUpdate\", \"[@my-react/react] current component have legacy lifeCycle function 'UNSAFE_componentWillUpdate'\");\n\t\t        }\n\t\t    }\n\t\t    if (typedInstance.componentWillUpdate) {\n\t\t        safeCallWithCurrentFiber({\n\t\t            fiber: fiber,\n\t\t            action: function safeCallComponentWillUpdateOnInstance() {\n\t\t                var _a;\n\t\t                (_a = typedInstance.componentWillUpdate) === null || _a === void 0 ? void 0 : _a.call(typedInstance, nextProps, nextState);\n\t\t            },\n\t\t        });\n\t\t        {\n\t\t            onceWarnWithKeyAndFiber(fiber, \"componentWillUpdate\", \"[@my-react/react] current component have legacy lifeCycle function 'componentWillUpdate'\");\n\t\t        }\n\t\t    }\n\t\t};\n\t\tvar processClassComponentMount = function (renderDispatch, fiber) {\n\t\t    processComponentInstanceOnMount(renderDispatch, fiber);\n\t\t    processComponentStateFromProps(fiber);\n\t\t    // legacy lifeCycle\n\t\t    if (enableLegacyLifeCycle.current) {\n\t\t        beforeSyncFlush();\n\t\t        processComponentWillMountOnMount(fiber) && syncFlushComponentQueue(renderDispatch, fiber);\n\t\t        afterSyncFlush();\n\t\t    }\n\t\t    var children = processComponentRenderOnMountAndUpdate(fiber);\n\t\t    processComponentDidMountOnMount(renderDispatch, fiber);\n\t\t    return children;\n\t\t};\n\t\t// TODO\n\t\tvar processClassComponentActive = function (renderDispatch, fiber) {\n\t\t    processComponentFiberOnUpdate(renderDispatch, fiber);\n\t\t    processComponentPropsAndContextOnActive(renderDispatch, fiber);\n\t\t    var children = processComponentRenderOnMountAndUpdate(fiber);\n\t\t    processComponentDidMountOnMount(renderDispatch, fiber);\n\t\t    return children;\n\t\t};\n\t\t// TODO\n\t\tvar classComponentUpdateImpl = function (renderDispatch, fiber) {\n\t\t    processComponentFiberOnUpdate(renderDispatch, fiber);\n\t\t    processComponentStateFromProps(fiber);\n\t\t    if (enableLegacyLifeCycle.current) {\n\t\t        beforeSyncFlush();\n\t\t        processComponentWillReceiveProps(fiber) && syncFlushComponentQueue(renderDispatch, fiber);\n\t\t        afterSyncFlush();\n\t\t    }\n\t\t    var typedInstance = fiber.instance;\n\t\t    var baseState = typedInstance.state;\n\t\t    var baseProps = typedInstance.props;\n\t\t    // const baseContext = typedInstance.context;\n\t\t    var nextState = Object.assign({}, fiber.pendingState);\n\t\t    var nextProps = Object.assign({}, fiber.pendingProps);\n\t\t    var nextContext = processComponentContextOnUpdate(renderDispatch, fiber);\n\t\t    var shouldUpdate = Boolean(include(fiber.state, STATE_TYPE.__triggerSyncForce__ | STATE_TYPE.__triggerConcurrentForce__));\n\t\t    if (!shouldUpdate) {\n\t\t        shouldUpdate = processComponentShouldUpdateOnUpdate(fiber, {\n\t\t            nextState: nextState,\n\t\t            nextProps: nextProps,\n\t\t            nextContext: nextContext,\n\t\t        });\n\t\t    }\n\t\t    if (shouldUpdate && enableLegacyLifeCycle.current) {\n\t\t        processComponentWillUpdate(fiber, { nextProps: nextProps, nextState: nextState });\n\t\t    }\n\t\t    typedInstance.state = nextState;\n\t\t    typedInstance.props = nextProps;\n\t\t    typedInstance.context = nextContext;\n\t\t    if (shouldUpdate) {\n\t\t        var children = processComponentRenderOnMountAndUpdate(fiber);\n\t\t        var snapshot = processComponentGetSnapshotOnUpdate(fiber, { baseState: baseState, baseProps: baseProps });\n\t\t        processComponentDidUpdateOnUpdate(renderDispatch, fiber, {\n\t\t            snapshot: snapshot,\n\t\t            baseProps: baseProps,\n\t\t            baseState: baseState,\n\t\t        });\n\t\t        return { updated: true, children: children };\n\t\t    }\n\t\t    else {\n\t\t        return { updated: false };\n\t\t    }\n\t\t};\n\t\tvar syncComponentStateToFiber = function (fiber) {\n\t\t    var typedInstance = fiber.instance;\n\t\t    // sync pendingState\n\t\t    fiber.pendingState = Object.assign({}, typedInstance.state);\n\t\t};\n\t\tvar processClassComponentUpdate = function (renderDispatch, fiber) {\n\t\t    var res = classComponentUpdateImpl(renderDispatch, fiber);\n\t\t    syncComponentStateToFiber(fiber);\n\t\t    return res;\n\t\t};\n\t\tvar processClassComponentUnmount = function (renderDispatch, fiber) {\n\t\t    var typedInstance = fiber.instance;\n\t\t    if (!typedInstance)\n\t\t        return;\n\t\t    var classField = getInstanceFieldByInstance(typedInstance);\n\t\t    safeCallWithCurrentFiber({\n\t\t        fiber: fiber,\n\t\t        action: function safeCallInstanceUnmountListener() {\n\t\t            renderDispatch.callOnInstanceUnmount(typedInstance, fiber);\n\t\t        },\n\t\t    });\n\t\t    safeCallWithCurrentFiber({\n\t\t        fiber: fiber,\n\t\t        action: function safeCallComponentWillUnmountOnInstance() {\n\t\t            var _a;\n\t\t            if (classField.isMounted) {\n\t\t                (_a = typedInstance === null || typedInstance === void 0 ? void 0 : typedInstance.componentWillUnmount) === null || _a === void 0 ? void 0 : _a.call(typedInstance);\n\t\t            }\n\t\t        },\n\t\t    });\n\t\t};\n\n\t\t/* eslint-disable max-lines */\n\t\tvar enableDebugFiled$8 = react.__my_react_shared__.enableDebugFiled;\n\t\tvar currentScheduler$c = react.__my_react_internal__.currentScheduler;\n\t\t// TODO \n\t\tvar processClassComponentUpdateQueueLatest = function (renderDispatch, fiber, enableTaskPriority) {\n\t\t    if (include(fiber.state, STATE_TYPE.__unmount__))\n\t\t        return;\n\t\t    if (exclude(fiber.type, exports.NODE_TYPE.__class__))\n\t\t        throw new Error(\"[@my-react/react] current fiber is not a class component, look like a bug for @my-react\");\n\t\t    var renderScheduler = currentScheduler$c.current;\n\t\t    var allQueue = fiber.updateQueue;\n\t\t    var typedFiber = fiber;\n\t\t    var node = allQueue === null || allQueue === void 0 ? void 0 : allQueue.head;\n\t\t    var needUpdate = true;\n\t\t    var isSync = false;\n\t\t    var isForce = false;\n\t\t    var isImmediate = false;\n\t\t    var isRetrigger = false;\n\t\t    var callbacks = [];\n\t\t    var processedNodes = [];\n\t\t    var typedInstance = fiber.instance;\n\t\t    var baseState = Object.assign({}, fiber.pendingState);\n\t\t    var baseProps = Object.assign({}, typedInstance.props);\n\t\t    var pendingState = Object.assign({}, fiber.pendingState);\n\t\t    if (enableTaskPriority && allQueue.some(function (l) { return l.isSync; })) {\n\t\t        var _loop_1 = function () {\n\t\t            var updater = node.value;\n\t\t            var nextNode = node.next;\n\t\t            if (updater.type === UpdateQueueType.component && updater.isSync) {\n\t\t                if (updater.trigger !== typedInstance) {\n\t\t                    throw new Error(\"[@my-react/react] current update not valid, look like a bug for @my-react\");\n\t\t                }\n\t\t                allQueue.delete(node);\n\t\t                processedNodes.push(updater);\n\t\t                var payLoad_1 = updater.payLoad;\n\t\t                fiber.pendingState = safeCallWithCurrentFiber({\n\t\t                    fiber: fiber,\n\t\t                    fallback: function safeFallbackForState() {\n\t\t                        return pendingState;\n\t\t                    },\n\t\t                    action: function safeGetNextState() {\n\t\t                        return Object.assign({}, fiber.pendingState, typeof payLoad_1 === \"function\" ? payLoad_1(baseState, baseProps) : payLoad_1);\n\t\t                    },\n\t\t                });\n\t\t                isSync = isSync || updater.isSync;\n\t\t                isForce = isForce || updater.isForce;\n\t\t                isImmediate = isImmediate || updater.isImmediate;\n\t\t                isRetrigger = isRetrigger || updater.isRetrigger;\n\t\t                updater.callback && callbacks.push(updater.callback);\n\t\t                if (enableDebugFiled$8.current) {\n\t\t                    var typedNode = updater;\n\t\t                    typedNode._debugRunTime = Date.now();\n\t\t                    typedNode._debugBeforeValue = pendingState;\n\t\t                    typedNode._debugBaseValue = baseState;\n\t\t                    typedNode._debugAfterValue = fiber.pendingState;\n\t\t                    if (enableDebugUpdateQueue.current) {\n\t\t                        typedFiber._debugUpdateQueue = typedFiber._debugUpdateQueue || new ListTree();\n\t\t                        typedFiber._debugUpdateQueue.push(typedNode);\n\t\t                    }\n\t\t                }\n\t\t            }\n\t\t            else if (updater.isSync) {\n\t\t                allQueue.delete(node);\n\t\t                processedNodes.push(updater);\n\t\t                isSync = isSync || updater.isSync;\n\t\t                isForce = isForce || updater.isForce;\n\t\t                isImmediate = isImmediate || updater.isImmediate;\n\t\t                isRetrigger = isRetrigger || updater.isRetrigger;\n\t\t                updater.callback && callbacks.push(updater.callback);\n\t\t                if (enableDebugFiled$8.current) {\n\t\t                    var typedNode = updater;\n\t\t                    typedNode._debugRunTime = Date.now();\n\t\t                    typedNode._debugBeforeValue = pendingState;\n\t\t                    typedNode._debugBaseValue = baseState;\n\t\t                    typedNode._debugAfterValue = fiber.pendingState;\n\t\t                    if (enableDebugUpdateQueue.current) {\n\t\t                        typedFiber._debugUpdateQueue = typedFiber._debugUpdateQueue || new ListTree();\n\t\t                        typedFiber._debugUpdateQueue.push(typedNode);\n\t\t                    }\n\t\t                }\n\t\t            }\n\t\t            node = nextNode;\n\t\t        };\n\t\t        while (node) {\n\t\t            _loop_1();\n\t\t        }\n\t\t        if (allQueue.length) {\n\t\t            renderScheduler.microTask(function prepareUpdateOnFiberTask() {\n\t\t                prepareUpdateOnFiber(renderDispatch, fiber, true);\n\t\t            });\n\t\t        }\n\t\t        var invokeCallbackArray = callbacks.length\n\t\t            ? function invokeCallbackArray() {\n\t\t                return callbacks.forEach(function (cb) { return cb === null || cb === void 0 ? void 0 : cb(); });\n\t\t            }\n\t\t            : void 0;\n\t\t        return {\n\t\t            needUpdate: needUpdate,\n\t\t            nodes: processedNodes,\n\t\t            isSync: isSync,\n\t\t            isForce: isForce,\n\t\t            isImmediate: isImmediate,\n\t\t            isRetrigger: isRetrigger,\n\t\t            callback: invokeCallbackArray,\n\t\t        };\n\t\t    }\n\t\t    else {\n\t\t        var _loop_2 = function () {\n\t\t            var updater = node.value;\n\t\t            var nextNode = node.next;\n\t\t            if (updater.type === UpdateQueueType.component) {\n\t\t                if (updater.trigger !== typedInstance)\n\t\t                    throw new Error(\"[@my-react/react] current update not valid, look like a bug for @my-react\");\n\t\t                allQueue.delete(node);\n\t\t                processedNodes.push(updater);\n\t\t                var payLoad_2 = updater.payLoad;\n\t\t                fiber.pendingState = safeCallWithCurrentFiber({\n\t\t                    fiber: fiber,\n\t\t                    fallback: function safeFallbackForState() {\n\t\t                        return pendingState;\n\t\t                    },\n\t\t                    action: function safeGetNextState() {\n\t\t                        return Object.assign({}, fiber.pendingState, typeof payLoad_2 === \"function\" ? payLoad_2(baseState, baseProps) : payLoad_2);\n\t\t                    },\n\t\t                });\n\t\t                isSync = isSync || updater.isSync;\n\t\t                isForce = isForce || updater.isForce;\n\t\t                isImmediate = isImmediate || updater.isImmediate;\n\t\t                isRetrigger = isRetrigger || updater.isRetrigger;\n\t\t                updater.callback && callbacks.push(updater.callback);\n\t\t                if (enableDebugFiled$8.current) {\n\t\t                    var typedNode = updater;\n\t\t                    typedNode._debugRunTime = Date.now();\n\t\t                    typedNode._debugBeforeValue = pendingState;\n\t\t                    typedNode._debugBaseValue = baseState;\n\t\t                    typedNode._debugAfterValue = fiber.pendingState;\n\t\t                    if (enableDebugUpdateQueue.current) {\n\t\t                        typedFiber._debugUpdateQueue = typedFiber._debugUpdateQueue || new ListTree();\n\t\t                        typedFiber._debugUpdateQueue.push(typedNode);\n\t\t                    }\n\t\t                }\n\t\t            }\n\t\t            else {\n\t\t                allQueue.delete(node);\n\t\t                processedNodes.push(updater);\n\t\t                isSync = isSync || updater.isSync;\n\t\t                isForce = isForce || updater.isForce;\n\t\t                isImmediate = isImmediate || updater.isImmediate;\n\t\t                isRetrigger = isRetrigger || updater.isRetrigger;\n\t\t                updater.callback && callbacks.push(updater.callback);\n\t\t                if (enableDebugFiled$8.current) {\n\t\t                    var typedNode = updater;\n\t\t                    typedNode._debugRunTime = Date.now();\n\t\t                    typedNode._debugBeforeValue = pendingState;\n\t\t                    typedNode._debugBaseValue = baseState;\n\t\t                    typedNode._debugAfterValue = fiber.pendingState;\n\t\t                    if (enableDebugUpdateQueue.current) {\n\t\t                        typedFiber._debugUpdateQueue = typedFiber._debugUpdateQueue || new ListTree();\n\t\t                        typedFiber._debugUpdateQueue.push(typedNode);\n\t\t                    }\n\t\t                }\n\t\t            }\n\t\t            node = nextNode;\n\t\t        };\n\t\t        while (node) {\n\t\t            _loop_2();\n\t\t        }\n\t\t        var invokeCallbackArray = callbacks.length\n\t\t            ? function invokeCallbackArray() {\n\t\t                return callbacks.forEach(function (cb) { return cb === null || cb === void 0 ? void 0 : cb(); });\n\t\t            }\n\t\t            : void 0;\n\t\t        return {\n\t\t            needUpdate: needUpdate,\n\t\t            nodes: processedNodes,\n\t\t            isSync: isSync,\n\t\t            isForce: isForce,\n\t\t            isImmediate: isImmediate,\n\t\t            isRetrigger: isRetrigger,\n\t\t            callback: invokeCallbackArray,\n\t\t        };\n\t\t    }\n\t\t};\n\t\tvar processClassComponentUpdateQueueLegacy = function (renderDispatch, fiber) {\n\t\t    if (include(fiber.state, STATE_TYPE.__unmount__))\n\t\t        return;\n\t\t    if (exclude(fiber.type, exports.NODE_TYPE.__class__))\n\t\t        throw new Error(\"[@my-react/react] current fiber is not a class component, look like a bug for @my-react\");\n\t\t    var renderScheduler = currentScheduler$c.current;\n\t\t    var allQueue = fiber.updateQueue;\n\t\t    var typedFiber = fiber;\n\t\t    var node = allQueue === null || allQueue === void 0 ? void 0 : allQueue.head;\n\t\t    var needUpdate = true;\n\t\t    var isSync = true;\n\t\t    var isForce = false;\n\t\t    var isImmediate = false;\n\t\t    var isRetrigger = false;\n\t\t    var callbacks = [];\n\t\t    var processedNodes = [];\n\t\t    var typedInstance = fiber.instance;\n\t\t    var baseState = Object.assign({}, fiber.pendingState);\n\t\t    var baseProps = Object.assign({}, typedInstance.props);\n\t\t    var pendingState = Object.assign({}, fiber.pendingState);\n\t\t    if (node) {\n\t\t        var updater = node.value;\n\t\t        if (updater.type === UpdateQueueType.component) {\n\t\t            if (updater.trigger !== typedInstance)\n\t\t                throw new Error(\"[@my-react/react] current update not valid, look like a bug for @my-react\");\n\t\t            allQueue.delete(node);\n\t\t            processedNodes.push(updater);\n\t\t            var payLoad_3 = updater.payLoad;\n\t\t            fiber.pendingState = safeCallWithCurrentFiber({\n\t\t                fiber: fiber,\n\t\t                fallback: function safeFallbackForState() {\n\t\t                    return pendingState;\n\t\t                },\n\t\t                action: function safeGetNextState() {\n\t\t                    return Object.assign({}, fiber.pendingState, typeof payLoad_3 === \"function\" ? payLoad_3(baseState, baseProps) : payLoad_3);\n\t\t                },\n\t\t            });\n\t\t            isSync = isSync || updater.isSync;\n\t\t            isForce = isForce || updater.isForce;\n\t\t            isImmediate = isImmediate || updater.isImmediate;\n\t\t            isRetrigger = isRetrigger || updater.isRetrigger;\n\t\t            updater.callback && callbacks.push(updater.callback);\n\t\t            if (enableDebugFiled$8.current) {\n\t\t                var typedNode = updater;\n\t\t                typedNode._debugRunTime = Date.now();\n\t\t                typedNode._debugBeforeValue = pendingState;\n\t\t                typedNode._debugBaseValue = baseState;\n\t\t                typedNode._debugAfterValue = fiber.pendingState;\n\t\t                if (enableDebugUpdateQueue.current) {\n\t\t                    typedFiber._debugUpdateQueue = typedFiber._debugUpdateQueue || new ListTree();\n\t\t                    typedFiber._debugUpdateQueue.push(typedNode);\n\t\t                }\n\t\t            }\n\t\t        }\n\t\t        else {\n\t\t            allQueue.delete(node);\n\t\t            processedNodes.push(updater);\n\t\t            isSync = isSync || updater.isSync;\n\t\t            isForce = isForce || updater.isForce;\n\t\t            isImmediate = isImmediate || updater.isImmediate;\n\t\t            isRetrigger = isRetrigger || updater.isRetrigger;\n\t\t            updater.callback && callbacks.push(updater.callback);\n\t\t            if (enableDebugFiled$8.current) {\n\t\t                var typedNode = updater;\n\t\t                typedNode._debugRunTime = Date.now();\n\t\t                typedNode._debugBeforeValue = pendingState;\n\t\t                typedNode._debugBaseValue = baseState;\n\t\t                typedNode._debugAfterValue = fiber.pendingState;\n\t\t                if (enableDebugUpdateQueue.current) {\n\t\t                    typedFiber._debugUpdateQueue = typedFiber._debugUpdateQueue || new ListTree();\n\t\t                    typedFiber._debugUpdateQueue.push(typedNode);\n\t\t                }\n\t\t            }\n\t\t        }\n\t\t    }\n\t\t    if (allQueue.length) {\n\t\t        renderScheduler.microTask(function prepareUpdateOnFiberTask() {\n\t\t            prepareUpdateOnFiber(renderDispatch, fiber, true);\n\t\t        });\n\t\t    }\n\t\t    var invokeCallbackArray = callbacks.length\n\t\t        ? function invokeCallbackArray() {\n\t\t            return callbacks.forEach(function (cb) { return cb === null || cb === void 0 ? void 0 : cb(); });\n\t\t        }\n\t\t        : void 0;\n\t\t    return {\n\t\t        needUpdate: needUpdate,\n\t\t        nodes: processedNodes,\n\t\t        isSync: isSync,\n\t\t        isForce: isForce,\n\t\t        isImmediate: isImmediate,\n\t\t        isRetrigger: isRetrigger,\n\t\t        callback: invokeCallbackArray,\n\t\t    };\n\t\t};\n\t\tvar processFunctionComponentUpdateQueueLatest = function (renderDispatch, fiber, enableTaskPriority) {\n\t\t    var _a, _b;\n\t\t    if (include(fiber.state, STATE_TYPE.__unmount__))\n\t\t        return;\n\t\t    if (exclude(fiber.type, exports.NODE_TYPE.__function__)) {\n\t\t        throw new Error(\"[@my-react/react] current fiber is not a function component, look like a bug for @my-react\");\n\t\t    }\n\t\t    var renderScheduler = currentScheduler$c.current;\n\t\t    var allQueue = fiber.updateQueue;\n\t\t    var typedFiber = fiber;\n\t\t    var node = allQueue === null || allQueue === void 0 ? void 0 : allQueue.head;\n\t\t    var needUpdate = false;\n\t\t    var isSync = false;\n\t\t    var isForce = false;\n\t\t    var isImmediate = false;\n\t\t    var isRetrigger = false;\n\t\t    var processedNodes = [];\n\t\t    var callbacks = [];\n\t\t    if (enableTaskPriority && allQueue.some(function (l) { return l.isSync; })) {\n\t\t        var _loop_3 = function () {\n\t\t            var updater = node.value;\n\t\t            var nextNode = node.next;\n\t\t            if (updater.type === UpdateQueueType.hook && updater.isSync) {\n\t\t                if (getInstanceOwnerFiber(updater.trigger) !== fiber) {\n\t\t                    throw new Error(\"[@my-react/react] current update not valid, look like a bug for @my-react\");\n\t\t                }\n\t\t                allQueue.delete(node);\n\t\t                processedNodes.push(updater);\n\t\t                var trigger = updater.trigger, payLoad_4 = updater.payLoad, reducer_1 = updater.reducer;\n\t\t                var typedTrigger_1 = trigger;\n\t\t                var lastResult_1 = typedTrigger_1.result;\n\t\t                if (typedTrigger_1.type === HOOK_TYPE.useSyncExternalStore) {\n\t\t                    lastResult_1 = (_a = trigger.value) === null || _a === void 0 ? void 0 : _a.result;\n\t\t                }\n\t\t                var hasError_1 = false;\n\t\t                typedTrigger_1.result = safeCallWithCurrentFiber({\n\t\t                    fiber: fiber,\n\t\t                    fallback: function safeFallbackForState() {\n\t\t                        hasError_1 = true;\n\t\t                        return lastResult_1;\n\t\t                    },\n\t\t                    action: function safeGetNextState() {\n\t\t                        if (reducer_1 && typeof reducer_1 === \"function\") {\n\t\t                            return reducer_1(lastResult_1, payLoad_4);\n\t\t                        }\n\t\t                        else {\n\t\t                            return typedTrigger_1.reducer(lastResult_1, payLoad_4);\n\t\t                        }\n\t\t                    },\n\t\t                });\n\t\t                isSync = isSync || updater.isSync;\n\t\t                isForce = isForce || updater.isForce;\n\t\t                isImmediate = isImmediate || updater.isImmediate;\n\t\t                isRetrigger = isRetrigger || updater.isRetrigger;\n\t\t                updater.callback && callbacks.push(updater.callback);\n\t\t                if (!needUpdate && (isForce || hasError_1 || callbacks.length || !Object.is(lastResult_1, typedTrigger_1.result)))\n\t\t                    needUpdate = true;\n\t\t                if (enableDebugFiled$8.current) {\n\t\t                    var typedNode = updater;\n\t\t                    typedNode._debugRunTime = Date.now();\n\t\t                    typedNode._debugBeforeValue = lastResult_1;\n\t\t                    typedNode._debugAfterValue = typedTrigger_1.result;\n\t\t                    if (enableDebugUpdateQueue.current) {\n\t\t                        typedFiber._debugUpdateQueue = typedFiber._debugUpdateQueue || new ListTree();\n\t\t                        typedFiber._debugUpdateQueue.push(typedNode);\n\t\t                        typedTrigger_1._debugUpdateQueue = typedTrigger_1._debugUpdateQueue || new ListTree();\n\t\t                        typedTrigger_1._debugUpdateQueue.push(typedNode);\n\t\t                    }\n\t\t                }\n\t\t            }\n\t\t            else if (updater.isSync) {\n\t\t                allQueue.delete(node);\n\t\t                processedNodes.push(updater);\n\t\t                var payLoad = updater.payLoad;\n\t\t                isSync = isSync || updater.isSync;\n\t\t                isForce = isForce || updater.isForce;\n\t\t                isImmediate = isImmediate || updater.isImmediate;\n\t\t                isRetrigger = isRetrigger || updater.isRetrigger;\n\t\t                updater.callback && callbacks.push(updater.callback);\n\t\t                needUpdate = true;\n\t\t                if (enableDebugFiled$8.current) {\n\t\t                    var typedNode = updater;\n\t\t                    typedNode._debugRunTime = Date.now();\n\t\t                    typedNode._debugBeforeValue = undefined;\n\t\t                    typedNode._debugAfterValue = payLoad;\n\t\t                    if (enableDebugUpdateQueue.current) {\n\t\t                        typedFiber._debugUpdateQueue = typedFiber._debugUpdateQueue || new ListTree();\n\t\t                        typedFiber._debugUpdateQueue.push(typedNode);\n\t\t                    }\n\t\t                }\n\t\t            }\n\t\t            node = nextNode;\n\t\t        };\n\t\t        while (node) {\n\t\t            _loop_3();\n\t\t        }\n\t\t        if (allQueue.length) {\n\t\t            renderScheduler.microTask(function prepareUpdateOnFiberTask() {\n\t\t                prepareUpdateOnFiber(renderDispatch, fiber, true);\n\t\t            });\n\t\t        }\n\t\t        var invokeCallbackArray = callbacks.length\n\t\t            ? function invokeCallbackArray() {\n\t\t                return callbacks.forEach(function (cb) { return cb === null || cb === void 0 ? void 0 : cb(); });\n\t\t            }\n\t\t            : void 0;\n\t\t        return {\n\t\t            needUpdate: needUpdate,\n\t\t            nodes: processedNodes,\n\t\t            isSync: isSync,\n\t\t            isForce: isForce,\n\t\t            isImmediate: isImmediate,\n\t\t            isRetrigger: isRetrigger,\n\t\t            callback: invokeCallbackArray,\n\t\t        };\n\t\t    }\n\t\t    else {\n\t\t        var _loop_4 = function () {\n\t\t            var updater = node.value;\n\t\t            var nextNode = node.next;\n\t\t            if (updater.type === UpdateQueueType.hook) {\n\t\t                if (getInstanceOwnerFiber(updater.trigger) !== fiber) {\n\t\t                    throw new Error(\"[@my-react/react] current update not valid, look like a bug for @my-react\");\n\t\t                }\n\t\t                allQueue.delete(node);\n\t\t                processedNodes.push(updater);\n\t\t                var trigger = updater.trigger, payLoad_5 = updater.payLoad, reducer_2 = updater.reducer;\n\t\t                var typedTrigger_2 = trigger;\n\t\t                var lastResult_2 = typedTrigger_2.result;\n\t\t                if (typedTrigger_2.type === HOOK_TYPE.useSyncExternalStore) {\n\t\t                    lastResult_2 = (_b = trigger.value) === null || _b === void 0 ? void 0 : _b.result;\n\t\t                }\n\t\t                var hasError_2 = false;\n\t\t                typedTrigger_2.result = safeCallWithCurrentFiber({\n\t\t                    fiber: fiber,\n\t\t                    fallback: function safeFallbackForState() {\n\t\t                        hasError_2 = true;\n\t\t                        return lastResult_2;\n\t\t                    },\n\t\t                    action: function safeGetNextState() {\n\t\t                        if (reducer_2 && typeof reducer_2 === \"function\") {\n\t\t                            return reducer_2(lastResult_2, payLoad_5);\n\t\t                        }\n\t\t                        else {\n\t\t                            return typedTrigger_2.reducer(lastResult_2, payLoad_5);\n\t\t                        }\n\t\t                    },\n\t\t                });\n\t\t                isSync = isSync || updater.isSync;\n\t\t                isForce = isForce || updater.isForce;\n\t\t                isImmediate = isImmediate || updater.isImmediate;\n\t\t                isRetrigger = isRetrigger || updater.isRetrigger;\n\t\t                updater.callback && callbacks.push(updater.callback);\n\t\t                if (!needUpdate && (isForce || hasError_2 || callbacks.length || !Object.is(lastResult_2, typedTrigger_2.result)))\n\t\t                    needUpdate = true;\n\t\t                if (enableDebugFiled$8.current) {\n\t\t                    var typedNode = updater;\n\t\t                    typedNode._debugRunTime = Date.now();\n\t\t                    typedNode._debugBeforeValue = lastResult_2;\n\t\t                    typedNode._debugAfterValue = typedTrigger_2.result;\n\t\t                    if (enableDebugUpdateQueue.current) {\n\t\t                        typedFiber._debugUpdateQueue = typedFiber._debugUpdateQueue || new ListTree();\n\t\t                        typedFiber._debugUpdateQueue.push(typedNode);\n\t\t                        typedTrigger_2._debugUpdateQueue = typedTrigger_2._debugUpdateQueue || new ListTree();\n\t\t                        typedTrigger_2._debugUpdateQueue.push(typedNode);\n\t\t                    }\n\t\t                }\n\t\t            }\n\t\t            else {\n\t\t                allQueue.delete(node);\n\t\t                processedNodes.push(updater);\n\t\t                var payLoad = updater.payLoad;\n\t\t                isSync = isSync || updater.isSync;\n\t\t                isForce = isForce || updater.isForce;\n\t\t                isImmediate = isImmediate || updater.isImmediate;\n\t\t                isRetrigger = isRetrigger || updater.isRetrigger;\n\t\t                updater.callback && callbacks.push(updater.callback);\n\t\t                needUpdate = true;\n\t\t                if (enableDebugFiled$8.current) {\n\t\t                    var typedNode = updater;\n\t\t                    typedNode._debugRunTime = Date.now();\n\t\t                    typedNode._debugBeforeValue = undefined;\n\t\t                    typedNode._debugAfterValue = payLoad;\n\t\t                    if (enableDebugUpdateQueue.current) {\n\t\t                        typedFiber._debugUpdateQueue = typedFiber._debugUpdateQueue || new ListTree();\n\t\t                        typedFiber._debugUpdateQueue.push(typedNode);\n\t\t                    }\n\t\t                }\n\t\t            }\n\t\t            node = nextNode;\n\t\t        };\n\t\t        while (node) {\n\t\t            _loop_4();\n\t\t        }\n\t\t        var invokeCallbackArray = callbacks.length\n\t\t            ? function invokeCallbackArray() {\n\t\t                return callbacks.forEach(function (cb) { return cb === null || cb === void 0 ? void 0 : cb(); });\n\t\t            }\n\t\t            : void 0;\n\t\t        return {\n\t\t            needUpdate: needUpdate,\n\t\t            nodes: processedNodes,\n\t\t            isSync: isSync,\n\t\t            isForce: isForce,\n\t\t            isImmediate: isImmediate,\n\t\t            isRetrigger: isRetrigger,\n\t\t            callback: invokeCallbackArray,\n\t\t        };\n\t\t    }\n\t\t};\n\t\tvar processFunctionComponentUpdateQueueLegacy = function (renderDispatch, fiber) {\n\t\t    var _a;\n\t\t    if (include(fiber.state, STATE_TYPE.__unmount__))\n\t\t        return;\n\t\t    if (exclude(fiber.type, exports.NODE_TYPE.__function__)) {\n\t\t        throw new Error(\"[@my-react/react] current fiber is not a function component, look like a bug for @my-react\");\n\t\t    }\n\t\t    var renderScheduler = currentScheduler$c.current;\n\t\t    var allQueue = fiber.updateQueue;\n\t\t    var typedFiber = fiber;\n\t\t    var node = allQueue === null || allQueue === void 0 ? void 0 : allQueue.head;\n\t\t    var needUpdate = false;\n\t\t    var isSync = true;\n\t\t    var isForce = false;\n\t\t    var isImmediate = false;\n\t\t    var isRetrigger = false;\n\t\t    var processedNodes = [];\n\t\t    var callbacks = [];\n\t\t    if (node) {\n\t\t        var updater = node.value;\n\t\t        if (updater.type === UpdateQueueType.hook) {\n\t\t            if (getInstanceOwnerFiber(updater.trigger) !== fiber) {\n\t\t                throw new Error(\"[@my-react/react] current update not valid, look like a bug for @my-react\");\n\t\t            }\n\t\t            allQueue.delete(node);\n\t\t            processedNodes.push(updater);\n\t\t            var trigger = updater.trigger, payLoad_6 = updater.payLoad, reducer_3 = updater.reducer;\n\t\t            var typedTrigger_3 = trigger;\n\t\t            var lastResult_3 = typedTrigger_3.result;\n\t\t            if (typedTrigger_3.type === HOOK_TYPE.useSyncExternalStore) {\n\t\t                lastResult_3 = (_a = trigger.value) === null || _a === void 0 ? void 0 : _a.result;\n\t\t            }\n\t\t            var hasError_3 = false;\n\t\t            typedTrigger_3.result = safeCallWithCurrentFiber({\n\t\t                fiber: fiber,\n\t\t                fallback: function safeFallbackForState() {\n\t\t                    hasError_3 = true;\n\t\t                    return lastResult_3;\n\t\t                },\n\t\t                action: function safeGetNextState() {\n\t\t                    if (reducer_3 && typeof reducer_3 === \"function\") {\n\t\t                        return reducer_3(lastResult_3, payLoad_6);\n\t\t                    }\n\t\t                    else {\n\t\t                        return typedTrigger_3.reducer(lastResult_3, payLoad_6);\n\t\t                    }\n\t\t                },\n\t\t            });\n\t\t            isSync = isSync || updater.isSync;\n\t\t            isForce = isForce || updater.isForce;\n\t\t            isImmediate = isImmediate || updater.isImmediate;\n\t\t            isRetrigger = isRetrigger || updater.isRetrigger;\n\t\t            updater.callback && callbacks.push(updater.callback);\n\t\t            if (!needUpdate && (isForce || hasError_3 || callbacks.length || !Object.is(lastResult_3, typedTrigger_3.result)))\n\t\t                needUpdate = true;\n\t\t            if (enableDebugFiled$8.current) {\n\t\t                var typedNode = updater;\n\t\t                typedNode._debugRunTime = Date.now();\n\t\t                typedNode._debugBeforeValue = lastResult_3;\n\t\t                typedNode._debugAfterValue = typedTrigger_3.result;\n\t\t                if (enableDebugUpdateQueue.current) {\n\t\t                    typedFiber._debugUpdateQueue = typedFiber._debugUpdateQueue || new ListTree();\n\t\t                    typedFiber._debugUpdateQueue.push(typedNode);\n\t\t                    typedTrigger_3._debugUpdateQueue = typedTrigger_3._debugUpdateQueue || new ListTree();\n\t\t                    typedTrigger_3._debugUpdateQueue.push(typedNode);\n\t\t                }\n\t\t            }\n\t\t        }\n\t\t        else {\n\t\t            allQueue.delete(node);\n\t\t            processedNodes.push(updater);\n\t\t            var payLoad = updater.payLoad;\n\t\t            isSync = isSync || updater.isSync;\n\t\t            isForce = isForce || updater.isForce;\n\t\t            isImmediate = isImmediate || updater.isImmediate;\n\t\t            isRetrigger = isRetrigger || updater.isRetrigger;\n\t\t            updater.callback && callbacks.push(updater.callback);\n\t\t            needUpdate = true;\n\t\t            if (enableDebugFiled$8.current) {\n\t\t                var typedNode = updater;\n\t\t                typedNode._debugRunTime = Date.now();\n\t\t                typedNode._debugBeforeValue = undefined;\n\t\t                typedNode._debugAfterValue = payLoad;\n\t\t                if (enableDebugUpdateQueue.current) {\n\t\t                    typedFiber._debugUpdateQueue = typedFiber._debugUpdateQueue || new ListTree();\n\t\t                    typedFiber._debugUpdateQueue.push(typedNode);\n\t\t                }\n\t\t            }\n\t\t        }\n\t\t    }\n\t\t    if (allQueue.length) {\n\t\t        renderScheduler.microTask(function prepareUpdateOnFiberTask() {\n\t\t            prepareUpdateOnFiber(renderDispatch, fiber, true);\n\t\t        });\n\t\t    }\n\t\t    var invokeCallbackArray = callbacks.length\n\t\t        ? function invokeCallbackArray() {\n\t\t            return callbacks.forEach(function (cb) { return cb === null || cb === void 0 ? void 0 : cb(); });\n\t\t        }\n\t\t        : void 0;\n\t\t    return {\n\t\t        needUpdate: needUpdate,\n\t\t        nodes: processedNodes,\n\t\t        isSync: isSync,\n\t\t        isForce: isForce,\n\t\t        isImmediate: isImmediate,\n\t\t        isRetrigger: isRetrigger,\n\t\t        callback: invokeCallbackArray,\n\t\t    };\n\t\t};\n\t\tvar processNormalComponentUpdateLatest = function (renderDispatch, fiber) {\n\t\t    if (include(fiber.state, STATE_TYPE.__unmount__))\n\t\t        return;\n\t\t    var allQueue = fiber.updateQueue;\n\t\t    var typedFiber = fiber;\n\t\t    var node = allQueue === null || allQueue === void 0 ? void 0 : allQueue.head;\n\t\t    var needUpdate = true;\n\t\t    var isSync = false;\n\t\t    var isForce = false;\n\t\t    var isImmediate = false;\n\t\t    var isRetrigger = false;\n\t\t    var processedNodes = [];\n\t\t    var callbacks = [];\n\t\t    while (node) {\n\t\t        var updater = node.value;\n\t\t        var nextNode = node.next;\n\t\t        allQueue.delete(node);\n\t\t        processedNodes.push(updater);\n\t\t        var payLoad = updater.payLoad;\n\t\t        isSync = isSync || updater.isSync;\n\t\t        isForce = isForce || updater.isForce;\n\t\t        isImmediate = isImmediate || updater.isImmediate;\n\t\t        isRetrigger = isRetrigger || updater.isRetrigger;\n\t\t        updater.callback && callbacks.push(updater.callback);\n\t\t        if (enableDebugFiled$8.current) {\n\t\t            var typedNode = updater;\n\t\t            typedNode._debugRunTime = Date.now();\n\t\t            typedNode._debugBeforeValue = undefined;\n\t\t            typedNode._debugAfterValue = payLoad;\n\t\t            if (enableDebugUpdateQueue.current) {\n\t\t                typedFiber._debugUpdateQueue = typedFiber._debugUpdateQueue || new ListTree();\n\t\t                typedFiber._debugUpdateQueue.push(typedNode);\n\t\t            }\n\t\t        }\n\t\t        node = nextNode;\n\t\t    }\n\t\t    var invokeCallbackArray = callbacks.length\n\t\t        ? function invokeCallbackArray() {\n\t\t            return callbacks.forEach(function (cb) { return cb === null || cb === void 0 ? void 0 : cb(); });\n\t\t        }\n\t\t        : void 0;\n\t\t    return {\n\t\t        needUpdate: needUpdate,\n\t\t        nodes: processedNodes,\n\t\t        isSync: isSync,\n\t\t        isForce: isForce,\n\t\t        isImmediate: isImmediate,\n\t\t        isRetrigger: isRetrigger,\n\t\t        callback: invokeCallbackArray,\n\t\t    };\n\t\t};\n\t\tvar processNormalComponentUpdateLegacy = function (renderDispatch, fiber) {\n\t\t    if (include(fiber.state, STATE_TYPE.__unmount__))\n\t\t        return;\n\t\t    var allQueue = fiber.updateQueue;\n\t\t    var typedFiber = fiber;\n\t\t    var renderScheduler = currentScheduler$c.current;\n\t\t    var node = allQueue === null || allQueue === void 0 ? void 0 : allQueue.head;\n\t\t    var needUpdate = true;\n\t\t    var isSync = true;\n\t\t    var isForce = false;\n\t\t    var isImmediate = false;\n\t\t    var isRetrigger = false;\n\t\t    var processedNodes = [];\n\t\t    var callbacks = [];\n\t\t    if (node) {\n\t\t        var updater = node.value;\n\t\t        allQueue.delete(node);\n\t\t        processedNodes.push(updater);\n\t\t        var payLoad = updater.payLoad;\n\t\t        isSync = isSync || updater.isSync;\n\t\t        isForce = isForce || updater.isForce;\n\t\t        isImmediate = isImmediate || updater.isImmediate;\n\t\t        isRetrigger = isRetrigger || updater.isRetrigger;\n\t\t        updater.callback && callbacks.push(updater.callback);\n\t\t        if (enableDebugFiled$8.current) {\n\t\t            var typedNode = updater;\n\t\t            typedNode._debugRunTime = Date.now();\n\t\t            typedNode._debugBeforeValue = undefined;\n\t\t            typedNode._debugAfterValue = payLoad;\n\t\t            if (enableDebugUpdateQueue.current) {\n\t\t                typedFiber._debugUpdateQueue = typedFiber._debugUpdateQueue || new ListTree();\n\t\t                typedFiber._debugUpdateQueue.push(typedNode);\n\t\t            }\n\t\t        }\n\t\t    }\n\t\t    if (allQueue.length) {\n\t\t        renderScheduler.microTask(function prepareUpdateOnFiberTask() {\n\t\t            prepareUpdateOnFiber(renderDispatch, fiber, true);\n\t\t        });\n\t\t    }\n\t\t    var invokeCallbackArray = callbacks.length\n\t\t        ? function invokeCallbackArray() {\n\t\t            return callbacks.forEach(function (cb) { return cb === null || cb === void 0 ? void 0 : cb(); });\n\t\t        }\n\t\t        : void 0;\n\t\t    return {\n\t\t        needUpdate: needUpdate,\n\t\t        nodes: processedNodes,\n\t\t        isSync: isSync,\n\t\t        isForce: isForce,\n\t\t        isImmediate: isImmediate,\n\t\t        isRetrigger: isRetrigger,\n\t\t        callback: invokeCallbackArray,\n\t\t    };\n\t\t};\n\t\t/**\n\t\t * @deprecated\n\t\t */\n\t\tvar syncFiberStateToComponent = function (renderDispatch, fiber, callback) {\n\t\t    var typedInstance = fiber.instance;\n\t\t    var typedPendingState = fiber.pendingState;\n\t\t    typedInstance.state = Object.assign({}, typedInstance.state, typedPendingState);\n\t\t    callback && renderDispatch.pendingLayoutEffect(fiber, callback, { stickyToFoot: true });\n\t\t};\n\t\t/**\n\t\t * @deprecated\n\t\t */\n\t\tvar syncFlushComponentQueue = function (renderDispatch, fiber) {\n\t\t    var _a = processClassComponentUpdateQueueLatest(renderDispatch, fiber), needUpdate = _a.needUpdate, callback = _a.callback;\n\t\t    needUpdate && syncFiberStateToComponent(renderDispatch, fiber, callback);\n\t\t    syncComponentStateToFiber(fiber);\n\t\t};\n\n\t\tvar currentComponentFiber$4 = react.__my_react_internal__.currentComponentFiber, currentRunningFiber$1 = react.__my_react_internal__.currentRunningFiber;\n\t\tvar enableDebugFiled$7 = react.__my_react_shared__.enableDebugFiled;\n\t\tvar MAX_UPDATE_COUNT = 25;\n\t\tvar lastRenderComponentFiber = null;\n\t\tvar lastRenderComponentTimeStep = null;\n\t\tvar renderCount = 0;\n\t\tvar processState = function (renderDispatch, _params) {\n\t\t    if (enableDebugFiled$7.current) {\n\t\t        var typedUpdateQueue = _params;\n\t\t        typedUpdateQueue._debugCreateTime = Date.now();\n\t\t        typedUpdateQueue._debugType = UpdateQueueType[_params.type];\n\t\t    }\n\t\t    var ownerFiber = getInstanceOwnerFiber(_params.trigger);\n\t\t    if (!renderDispatch)\n\t\t        return;\n\t\t    _params.isRetrigger = currentRunningFiber$1.current === ownerFiber || !!_params.isRetrigger;\n\t\t    _params.isImmediate =\n\t\t        typeof _params.isImmediate === \"boolean\"\n\t\t            ? _params.isImmediate\n\t\t            : _params.isRetrigger || (renderDispatch.isAppMounted ? !!currentRunningFiber$1.current : false);\n\t\t    safeCallWithCurrentFiber({\n\t\t        fiber: ownerFiber,\n\t\t        action: function safeCallFiberStateListener() {\n\t\t            renderDispatch.callOnFiberState(ownerFiber, _params);\n\t\t        },\n\t\t    });\n\t\t    var isImmediate = _params.isImmediate;\n\t\t    _params.isRetrigger;\n\t\t    if (_params.type === UpdateQueueType.component) {\n\t\t        if (!ownerFiber || include(ownerFiber.state, STATE_TYPE.__unmount__))\n\t\t            return;\n\t\t        if (!exports.syncFlush && currentComponentFiber$4.current) {\n\t\t            var currentRFiber = currentRunningFiber$1.current;\n\t\t            var currentCFiber = currentComponentFiber$4.current;\n\t\t            var now = Date.now();\n\t\t            if (lastRenderComponentFiber === currentCFiber) {\n\t\t                if (lastRenderComponentTimeStep && now - lastRenderComponentTimeStep < 4) {\n\t\t                    renderCount++;\n\t\t                }\n\t\t                else {\n\t\t                    renderCount = 0;\n\t\t                }\n\t\t            }\n\t\t            else {\n\t\t                renderCount = 0;\n\t\t            }\n\t\t            if (renderCount > MAX_UPDATE_COUNT) {\n\t\t                renderCount = 0;\n\t\t                throw new Error(\"[@my-react/react] look like there are infinity update for current component \".concat(currentComponentFiber$4.current && getElementName(currentComponentFiber$4.current)));\n\t\t            }\n\t\t            else if (!isErrorBoundariesComponent(ownerFiber)) {\n\t\t                var triggeredElementName = getElementName(ownerFiber);\n\t\t                var currentElementName = getElementName(currentCFiber);\n\t\t                if (enableLogForCurrentFlowIsRunning.current) {\n\t\t                    onceWarnWithKeyAndFiber(currentRFiber, \"updateWhenCurrentFlowIsRunning-\".concat(triggeredElementName), \"[@my-react/react] trigger an update for \".concat(triggeredElementName, \" when current update flow is running, this is a unexpected behavior, please make sure current render function for \").concat(currentElementName, \" is a pure function\"));\n\t\t                }\n\t\t            }\n\t\t            lastRenderComponentFiber = currentCFiber;\n\t\t            lastRenderComponentTimeStep = now;\n\t\t        }\n\t\t        var trigger_1 = _params.trigger;\n\t\t        safeCallWithCurrentFiber({\n\t\t            fiber: ownerFiber,\n\t\t            action: function safeCallInstanceStateListener() {\n\t\t                renderDispatch.callOnInstanceState(trigger_1, ownerFiber, _params);\n\t\t            },\n\t\t        });\n\t\t        ownerFiber.updateQueue = ownerFiber.updateQueue || new ListTree();\n\t\t        ownerFiber.updateQueue.push(_params);\n\t\t        prepareUpdateOnFiber(renderDispatch, ownerFiber, isImmediate);\n\t\t    }\n\t\t    else if (_params.type === UpdateQueueType.hook) {\n\t\t        if (!ownerFiber || include(ownerFiber === null || ownerFiber === void 0 ? void 0 : ownerFiber.state, STATE_TYPE.__unmount__))\n\t\t            return;\n\t\t        if (!exports.syncFlush && currentComponentFiber$4.current) {\n\t\t            var currentRFiber = currentRunningFiber$1.current;\n\t\t            var currentCFiber = currentComponentFiber$4.current;\n\t\t            var now = Date.now();\n\t\t            if (lastRenderComponentFiber === currentCFiber) {\n\t\t                if (lastRenderComponentTimeStep && now - lastRenderComponentTimeStep < 4) {\n\t\t                    renderCount++;\n\t\t                }\n\t\t                else {\n\t\t                    renderCount = 0;\n\t\t                }\n\t\t            }\n\t\t            else {\n\t\t                renderCount = 0;\n\t\t            }\n\t\t            if (renderCount > MAX_UPDATE_COUNT) {\n\t\t                renderCount = 0;\n\t\t                throw new Error(\"[@my-react/react] look like there are infinity update for current component \".concat(currentComponentFiber$4.current && getElementName(currentComponentFiber$4.current)));\n\t\t            }\n\t\t            else if (!isErrorBoundariesComponent(ownerFiber)) {\n\t\t                var triggeredElementName = getElementName(ownerFiber);\n\t\t                var currentElementName = getElementName(currentCFiber);\n\t\t                if (enableLogForCurrentFlowIsRunning.current) {\n\t\t                    onceWarnWithKeyAndFiber(currentRFiber, \"updateWhenCurrentFlowIsRunning-\".concat(triggeredElementName), \"[@my-react/react] trigger an update for \".concat(triggeredElementName, \" when current update flow is running, this is a unexpected behavior, please make sure current render function for \").concat(currentElementName, \" is a pure function\"));\n\t\t                }\n\t\t            }\n\t\t            lastRenderComponentFiber = currentCFiber;\n\t\t            lastRenderComponentTimeStep = now;\n\t\t        }\n\t\t        var trigger_2 = _params.trigger;\n\t\t        safeCallWithCurrentFiber({\n\t\t            fiber: ownerFiber,\n\t\t            action: function safeCallHookStateListener() {\n\t\t                renderDispatch.callOnHookState(trigger_2, ownerFiber, _params);\n\t\t            },\n\t\t        });\n\t\t        ownerFiber.updateQueue = ownerFiber.updateQueue || new ListTree();\n\t\t        ownerFiber.updateQueue.push(_params);\n\t\t        prepareUpdateOnFiber(renderDispatch, ownerFiber, isImmediate);\n\t\t    }\n\t\t    else {\n\t\t        var ownerFiber_1 = _params.trigger;\n\t\t        if (!ownerFiber_1 || include(ownerFiber_1.state, STATE_TYPE.__unmount__))\n\t\t            return;\n\t\t        ownerFiber_1.updateQueue = ownerFiber_1.updateQueue || new ListTree();\n\t\t        ownerFiber_1.updateQueue.push(_params);\n\t\t        prepareUpdateOnFiber(renderDispatch, ownerFiber_1, isImmediate);\n\t\t    }\n\t\t};\n\n\t\tvar defaultGenerateUnmountMap = function (fiber, unmount, map) {\n\t\t    var list = map.get(fiber);\n\t\t    if (!list) {\n\t\t        list = new ListTree();\n\t\t        map.set(fiber, list);\n\t\t    }\n\t\t    list.push(unmount);\n\t\t};\n\t\tvar defaultDispatchUnmount = function (renderDispatch) {\n\t\t    if (renderDispatch.isAppUnmounted)\n\t\t        return;\n\t\t    var rootFiber = renderDispatch.rootFiber;\n\t\t    unmountFiber(renderDispatch, rootFiber);\n\t\t    clearContainer(renderDispatch);\n\t\t};\n\t\tvar defaultInvokeUnmountList = function (renderDispatch, fiber) {\n\t\t    if (include(fiber.patch, PATCH_TYPE.__unmount__)) {\n\t\t        var unmountMap = renderDispatch.runtimeMap.unmountMap;\n\t\t        var allUnmount = unmountMap.get(fiber);\n\t\t        unmountMap.delete(fiber);\n\t\t        if (allUnmount && allUnmount.length) {\n\t\t            allUnmount.listToFoot(function invokeUnmountFromCurrent(unmount) {\n\t\t                safeCallWithCurrentFiber({\n\t\t                    fiber: unmount,\n\t\t                    action: function safeCallUnmountFromCurrent() {\n\t\t                        unmountFiber(renderDispatch, unmount);\n\t\t                    },\n\t\t                });\n\t\t            });\n\t\t        }\n\t\t        fiber.patch = remove(fiber.patch, PATCH_TYPE.__unmount__);\n\t\t    }\n\t\t};\n\n\t\t// unmount current fiber\n\t\tvar unmountFiber = function (renderDispatch, fiber) {\n\t\t    if (include(fiber.state, STATE_TYPE.__unmount__))\n\t\t        return;\n\t\t    var list = generateFiberToListWithAction(fiber, function invokeUnmountPending(f) {\n\t\t        defaultInvokeUnmountList(renderDispatch, f);\n\t\t    });\n\t\t    list.listToFoot(function invokeFiberUnmountList(f) {\n\t\t        unmountFiberNode(renderDispatch, f);\n\t\t    });\n\t\t};\n\t\t// unmount current container with safe\n\t\tvar unmountContainer = function (renderDispatch, cb) {\n\t\t    renderDispatch.reconcileUnmount();\n\t\t    cb === null || cb === void 0 ? void 0 : cb();\n\t\t    currentTriggerFiber.current = null;\n\t\t};\n\t\tvar clearContainer = function (renderDispatch) {\n\t\t    var _a, _b, _c, _d;\n\t\t    renderDispatch.pendingCommitFiberPatch = PATCH_TYPE.__initial__;\n\t\t    (_a = renderDispatch.pendingUpdateFiberArray) === null || _a === void 0 ? void 0 : _a.clear();\n\t\t    (_b = renderDispatch.pendingSuspenseFiberArray) === null || _b === void 0 ? void 0 : _b.clear();\n\t\t    (_c = renderDispatch.pendingCommitFiberList) === null || _c === void 0 ? void 0 : _c.clear();\n\t\t    (_d = renderDispatch.pendingChangedFiberList) === null || _d === void 0 ? void 0 : _d.clear();\n\t\t    renderDispatch.resetUpdateFlowRuntimeFiber();\n\t\t    renderDispatch.isAppMounted = false;\n\t\t    renderDispatch.isAppUnmounted = true;\n\t\t};\n\n\t\tvar globalLoop$3 = react.__my_react_internal__.globalLoop, currentScheduler$b = react.__my_react_internal__.currentScheduler, currentError = react.__my_react_internal__.currentError;\n\t\tvar applyTriggerFiberCb = function (renderDispatch, fiber) {\n\t\t    var _a, _b;\n\t\t    var cbArray = renderDispatch.runtimeMap.triggerCallbackMap.get(fiber);\n\t\t    if (include(fiber.type, exports.NODE_TYPE.__class__)) {\n\t\t        (_a = cbArray === null || cbArray === void 0 ? void 0 : cbArray.listToFoot) === null || _a === void 0 ? void 0 : _a.call(cbArray, function (cb) {\n\t\t            renderDispatch.pendingLayoutEffect(fiber, cb, { stickyToFoot: true });\n\t\t        });\n\t\t    }\n\t\t    else {\n\t\t        (_b = cbArray === null || cbArray === void 0 ? void 0 : cbArray.listToFoot) === null || _b === void 0 ? void 0 : _b.call(cbArray, function (cb) {\n\t\t            renderDispatch.pendingEffect(fiber, cb, { stickyToFoot: true });\n\t\t        });\n\t\t    }\n\t\t    renderDispatch.runtimeMap.triggerCallbackMap.delete(fiber);\n\t\t};\n\t\t/**\n\t\t * only used for dev HMR\n\t\t * only invoke on the errorCatchFiber\n\t\t */\n\t\tvar triggerRevert = function (renderDispatch, fiber, cb) {\n\t\t    {\n\t\t        if (!isErrorBoundariesComponent(fiber))\n\t\t            return;\n\t\t        var instance = fiber.instance;\n\t\t        instance === null || instance === void 0 ? void 0 : instance.setState(fiber.memoizedState, function finishTriggerRevertOnFiber() {\n\t\t            renderDispatch.runtimeFiber.errorCatchFiber = null;\n\t\t            fiber.memoizedState = null;\n\t\t            cb === null || cb === void 0 ? void 0 : cb();\n\t\t        });\n\t\t    }\n\t\t};\n\t\tvar triggerUpdate = function (renderDispatch, fiber, state, cb) {\n\t\t    if (include(fiber.state, STATE_TYPE.__unmount__))\n\t\t        return;\n\t\t    var renderScheduler = currentScheduler$b.current;\n\t\t    if (!renderDispatch || !renderDispatch.enableUpdate)\n\t\t        return;\n\t\t    if (renderDispatch.isAppCrashed)\n\t\t        return;\n\t\t    if (renderDispatch.isAppUnmounted)\n\t\t        return;\n\t\t    // TODO\n\t\t    if (!renderDispatch.isAppMounted) {\n\t\t        devWarnWithFiber(fiber, \"[@my-react/react] pending, waiting for app mounted\");\n\t\t        renderScheduler.macroTask(function scheduleUpdateBeforeMount() {\n\t\t            triggerUpdate(renderDispatch, fiber, state, cb);\n\t\t        });\n\t\t        return;\n\t\t    }\n\t\t    if (typeof state === \"function\") {\n\t\t        cb = state;\n\t\t        state = STATE_TYPE.__triggerConcurrent__;\n\t\t    }\n\t\t    state = state || STATE_TYPE.__triggerSync__;\n\t\t    if (fiber.state === STATE_TYPE.__stable__) {\n\t\t        fiber.state = state;\n\t\t    }\n\t\t    else {\n\t\t        fiber.state = merge(fiber.state, state);\n\t\t    }\n\t\t    renderDispatch.pendingUpdateFiberArray.uniPush(fiber);\n\t\t    if (cb) {\n\t\t        var map = renderDispatch.runtimeMap.triggerCallbackMap;\n\t\t        var exist = map.get(fiber) || new ListTree();\n\t\t        exist.push(cb);\n\t\t        map.set(fiber, exist);\n\t\t    }\n\t\t    // if (globalLoop.current) {\n\t\t    //   const nextFiber = renderDispatch.runtimeFiber.nextWorkingFiber;\n\t\t    //   if (!nextFiber) return;\n\t\t    //   if (nextFiber.state !== STATE_TYPE.__stable__) {\n\t\t    //     nextFiber.state = merge(nextFiber.state, state);\n\t\t    //   }\n\t\t    //   return;\n\t\t    // }\n\t\t    if (globalLoop$3.current)\n\t\t        return;\n\t\t    globalLoop$3.current = true;\n\t\t    scheduleUpdate(renderDispatch);\n\t\t};\n\t\t// TODO: error flow\n\t\t// currently only work render flow\n\t\t// commit flow not work as expected\n\t\tvar triggerError = function (renderDispatch, fiber, error, cb) {\n\t\t    var _a;\n\t\t    var renderScheduler = currentScheduler$b.current;\n\t\t    var errorBoundariesFiber = renderDispatch.resolveErrorBoundaries(fiber);\n\t\t    if (errorBoundariesFiber) {\n\t\t        defaultDeleteChildEffect(renderDispatch, fiber);\n\t\t        var typedComponent = errorBoundariesFiber.elementType;\n\t\t        var typedInstance_1 = errorBoundariesFiber.instance;\n\t\t        var payloadState = (_a = typedComponent.getDerivedStateFromError) === null || _a === void 0 ? void 0 : _a.call(typedComponent, error);\n\t\t        if (!errorBoundariesFiber.memoizedState) {\n\t\t            errorBoundariesFiber.memoizedState = Object.assign({}, errorBoundariesFiber.pendingState);\n\t\t        }\n\t\t        if (renderDispatch.runtimeFiber.nextWorkingFiber) {\n\t\t            var updateQueue = {\n\t\t                type: UpdateQueueType.component,\n\t\t                trigger: typedInstance_1,\n\t\t                payLoad: payloadState,\n\t\t                isSync: true,\n\t\t                isForce: true,\n\t\t                isRetrigger: true,\n\t\t                isImmediate: true,\n\t\t                callback: function finishTriggerErrorOnFiber() {\n\t\t                    var _a;\n\t\t                    (_a = typedInstance_1.componentDidCatch) === null || _a === void 0 ? void 0 : _a.call(typedInstance_1, error, { componentStack: renderScheduler.getFiberTree(fiber) });\n\t\t                    renderDispatch.runtimeFiber.errorCatchFiber = errorBoundariesFiber;\n\t\t                    cb === null || cb === void 0 ? void 0 : cb();\n\t\t                    currentError.current = null;\n\t\t                },\n\t\t            };\n\t\t            errorBoundariesFiber.state = merge(errorBoundariesFiber.state, STATE_TYPE.__create__);\n\t\t            errorBoundariesFiber.state = merge(errorBoundariesFiber.state, STATE_TYPE.__triggerSyncForce__);\n\t\t            processState(renderDispatch, updateQueue);\n\t\t            syncFiberStateToComponent(renderDispatch, errorBoundariesFiber);\n\t\t        }\n\t\t        else {\n\t\t            var updateQueue = {\n\t\t                type: UpdateQueueType.component,\n\t\t                trigger: typedInstance_1,\n\t\t                payLoad: payloadState,\n\t\t                isSync: true,\n\t\t                isForce: true,\n\t\t                isRetrigger: false,\n\t\t                isImmediate: false,\n\t\t                callback: function finishTriggerErrorOnFiber() {\n\t\t                    var _a;\n\t\t                    (_a = typedInstance_1.componentDidCatch) === null || _a === void 0 ? void 0 : _a.call(typedInstance_1, error, { componentStack: renderScheduler.getFiberTree(fiber) });\n\t\t                    renderDispatch.runtimeFiber.errorCatchFiber = errorBoundariesFiber;\n\t\t                    cb === null || cb === void 0 ? void 0 : cb();\n\t\t                    currentError.current = null;\n\t\t                },\n\t\t            };\n\t\t            processState(renderDispatch, updateQueue);\n\t\t        }\n\t\t    }\n\t\t    else {\n\t\t        if (renderDispatch.isAppCrashed)\n\t\t            return;\n\t\t        renderDispatch.pendingUpdateFiberArray.clear();\n\t\t        renderDispatch.resetUpdateFlowRuntimeFiber();\n\t\t        renderDispatch.isAppCrashed = true;\n\t\t        globalLoop$3.current = false;\n\t\t        {\n\t\t            currentTriggerFiber.current = null;\n\t\t            devErrorWithFiber(fiber, \"[@my-react/react] a uncaught exception have been throw, current App will been unmount\");\n\t\t            unmountContainer(renderDispatch, cb);\n\t\t            throw error;\n\t\t        }\n\t\t    }\n\t\t};\n\n\t\tvar globalLoop$2 = react.__my_react_internal__.globalLoop, currentScheduler$a = react.__my_react_internal__.currentScheduler;\n\t\tvar scheduleUpdateFromRoot = function (renderDispatch) {\n\t\t    flushEffectCallback();\n\t\t    var allLive = renderDispatch.pendingUpdateFiberArray.getAll().filter(function (f) { return exclude(f.state, STATE_TYPE.__unmount__); });\n\t\t    renderDispatch.pendingUpdateFiberArray.clear();\n\t\t    if (allLive.length) {\n\t\t        renderDispatch.runtimeFiber.scheduledFiber = renderDispatch.rootFiber;\n\t\t        renderDispatch.runtimeFiber.nextWorkingFiber = renderDispatch.rootFiber;\n\t\t        currentTriggerFiber.current = allLive.length > 1 ? allLive : allLive[0];\n\t\t        allLive.forEach(function (fiber) { return applyTriggerFiberCb(renderDispatch, fiber); });\n\t\t        if (!renderDispatch.enableConcurrentMode || allLive.some(function (f) { return include(f.state, STATE_TYPE.__triggerSync__ | STATE_TYPE.__triggerSyncForce__); })) {\n\t\t            {\n\t\t                safeCall(function safeCallBeforeDispatchUpdate() {\n\t\t                    renderDispatch.callOnBeforeDispatchUpdate(renderDispatch, allLive);\n\t\t                });\n\t\t            }\n\t\t            updateSyncFromRoot(renderDispatch);\n\t\t        }\n\t\t        else {\n\t\t            renderDispatch.resetYield();\n\t\t            {\n\t\t                safeCall(function safeCallBeforeDispatchUpdate() {\n\t\t                    renderDispatch.callOnBeforeDispatchUpdate(renderDispatch, allLive);\n\t\t                });\n\t\t            }\n\t\t            updateConcurrentFromRoot(renderDispatch);\n\t\t        }\n\t\t    }\n\t\t    else {\n\t\t        currentTriggerFiber.current = null;\n\t\t        scheduleNext(renderDispatch);\n\t\t    }\n\t\t};\n\t\tvar scheduleOther = function (renderDispatch) {\n\t\t    var _a;\n\t\t    var renderScheduler = currentScheduler$a.current;\n\t\t    if (!renderScheduler.dispatchSet || ((_a = renderScheduler.dispatchSet) === null || _a === void 0 ? void 0 : _a.length) === 1)\n\t\t        return;\n\t\t    var allDispatch = renderScheduler.dispatchSet;\n\t\t    var hasPending = allDispatch\n\t\t        .getAll()\n\t\t        .find(function (d) { return d !== renderDispatch && d.isAppMounted && d.enableUpdate && !d.isAppCrashed && !d.isAppUnmounted && d.pendingUpdateFiberArray.length; });\n\t\t    if (hasPending) {\n\t\t        scheduleUpdate(hasPending);\n\t\t    }\n\t\t    else {\n\t\t        globalLoop$2.current = false;\n\t\t    }\n\t\t};\n\t\tvar scheduleNext = function (renderDispatch) {\n\t\t    var _a;\n\t\t    if (!renderDispatch.isAppUnmounted && !renderDispatch.isAppCrashed && renderDispatch.enableUpdate && renderDispatch.pendingUpdateFiberArray.length) {\n\t\t        scheduleUpdate(renderDispatch);\n\t\t        return;\n\t\t    }\n\t\t    var renderScheduler = currentScheduler$a.current;\n\t\t    if (!renderScheduler.dispatchSet || ((_a = renderScheduler.dispatchSet) === null || _a === void 0 ? void 0 : _a.length) === 1)\n\t\t        return;\n\t\t    var allDispatch = renderScheduler.dispatchSet;\n\t\t    var hasPending = allDispatch\n\t\t        .getAll()\n\t\t        .find(function (d) { return d !== renderDispatch && d.isAppMounted && d.enableUpdate && !d.isAppCrashed && !d.isAppUnmounted && d.pendingUpdateFiberArray.length; });\n\t\t    if (hasPending) {\n\t\t        scheduleUpdate(hasPending);\n\t\t    }\n\t\t    else {\n\t\t        globalLoop$2.current = false;\n\t\t    }\n\t\t};\n\t\tvar scheduleUpdate = function (renderDispatch) {\n\t\t    react.__my_react_internal__.recentlyCreatedOwnerStacks.current = 0;\n\t\t    if (renderDispatch.isAppUnmounted) {\n\t\t        scheduleOther(renderDispatch);\n\t\t        return;\n\t\t    }\n\t\t    scheduleUpdateFromRoot(renderDispatch);\n\t\t};\n\n\t\tvar globalLoop$1 = react.__my_react_internal__.globalLoop, currentScheduler$9 = react.__my_react_internal__.currentScheduler;\n\t\tvar enableScopeTreeLog$3 = react.__my_react_shared__.enableScopeTreeLog;\n\t\tfunction finishUpdateSyncFromRoot(renderDispatch) {\n\t\t    var commitList = renderDispatch.pendingCommitFiberList;\n\t\t    var changedList = renderDispatch.pendingChangedFiberList;\n\t\t    renderDispatch.resetUpdateFlowRuntimeFiber();\n\t\t    renderDispatch.pendingCommitFiberList = null;\n\t\t    renderDispatch.pendingChangedFiberList = null;\n\t\t    enableScopeTreeLog$3.current && setLogScope();\n\t\t    (commitList === null || commitList === void 0 ? void 0 : commitList.length) && renderDispatch.reconcileUpdate(commitList, true);\n\t\t    enableScopeTreeLog$3.current && resetLogScope();\n\t\t    safeCall(function safeCallAfterDispatchUpdate() {\n\t\t            renderDispatch.callOnAfterDispatchUpdate(renderDispatch);\n\t\t        });\n\t\t    (changedList === null || changedList === void 0 ? void 0 : changedList.length) &&\n\t\t        safeCall(function safeCallFiberHasChangeListener() {\n\t\t            renderDispatch.callOnFiberChange(changedList);\n\t\t        });\n\t\t}\n\t\tvar updateSyncFromRoot = function (renderDispatch) {\n\t\t    globalLoop$1.current = true;\n\t\t    var renderScheduler = currentScheduler$9.current;\n\t\t    enableScopeTreeLog$3.current && setLogScope();\n\t\t    updateLoopSyncFromRoot(renderDispatch);\n\t\t    processAsyncLoadListOnUpdate(renderDispatch);\n\t\t    enableScopeTreeLog$3.current && resetLogScope();\n\t\t    finishUpdateSyncFromRoot(renderDispatch);\n\t\t    renderScheduler.microTask(function callScheduleNext() {\n\t\t        globalLoop$1.current = false;\n\t\t        scheduleNext(renderDispatch);\n\t\t    });\n\t\t};\n\t\tfunction finishUpdateConcurrentFromRoot(renderDispatch) {\n\t\t    var commitList = renderDispatch.pendingCommitFiberList;\n\t\t    var changedList = renderDispatch.pendingChangedFiberList;\n\t\t    renderDispatch.resetUpdateFlowRuntimeFiber();\n\t\t    renderDispatch.pendingCommitFiberList = null;\n\t\t    renderDispatch.pendingChangedFiberList = null;\n\t\t    enableScopeTreeLog$3.current && setLogScope();\n\t\t    (commitList === null || commitList === void 0 ? void 0 : commitList.length) && renderDispatch.reconcileUpdate(commitList);\n\t\t    enableScopeTreeLog$3.current && setLogScope();\n\t\t    safeCall(function safeCallAfterDispatchUpdate() {\n\t\t            renderDispatch.callOnAfterDispatchUpdate(renderDispatch);\n\t\t        });\n\t\t    (changedList === null || changedList === void 0 ? void 0 : changedList.length) &&\n\t\t        safeCall(function safeCallFiberHasChangeListener() {\n\t\t            renderDispatch.callOnFiberChange(changedList);\n\t\t        });\n\t\t}\n\t\tfunction checkNextFiberIsSync(renderDispatch) {\n\t\t    return include(renderDispatch.runtimeFiber.nextWorkingFiber.state, STATE_TYPE.__triggerSync__ | STATE_TYPE.__triggerSyncForce__);\n\t\t    // include(renderDispatch.runtimeFiber.nextWorkingFiber.state, STATE_TYPE.__retrigger__)\n\t\t}\n\t\tfunction updateConcurrentNextFrame(renderDispatch) {\n\t\t    var renderScheduler = currentScheduler$9.current;\n\t\t    enableScopeTreeLog$3.current && setLogScope();\n\t\t    var hasSync = updateLoopConcurrentFromRoot(renderDispatch);\n\t\t    enableScopeTreeLog$3.current && resetLogScope();\n\t\t    if (renderDispatch.runtimeFiber.nextWorkingFiber) {\n\t\t        if (hasSync || checkNextFiberIsSync(renderDispatch)) {\n\t\t            updateSyncFromRoot(renderDispatch);\n\t\t        }\n\t\t        else {\n\t\t            renderScheduler.yieldTask(function resumeUpdateConcurrentFromRoot() {\n\t\t                if (hasSync || checkNextFiberIsSync(renderDispatch)) {\n\t\t                    updateSyncFromRoot(renderDispatch);\n\t\t                }\n\t\t                else {\n\t\t                    updateConcurrentNextFrame(renderDispatch);\n\t\t                }\n\t\t            });\n\t\t        }\n\t\t    }\n\t\t    else {\n\t\t        processAsyncLoadListOnUpdate(renderDispatch);\n\t\t        finishUpdateConcurrentFromRoot(renderDispatch);\n\t\t        renderScheduler.microTask(function callScheduleNext() {\n\t\t            globalLoop$1.current = false;\n\t\t            scheduleNext(renderDispatch);\n\t\t        });\n\t\t    }\n\t\t}\n\t\tvar updateConcurrentFromRoot = function (renderDispatch) {\n\t\t    globalLoop$1.current = true;\n\t\t    var renderScheduler = currentScheduler$9.current;\n\t\t    enableScopeTreeLog$3.current && setLogScope();\n\t\t    var hasSync = updateLoopConcurrentFromRoot(renderDispatch);\n\t\t    enableScopeTreeLog$3.current && resetLogScope();\n\t\t    if (renderDispatch.runtimeFiber.nextWorkingFiber) {\n\t\t        if (hasSync || checkNextFiberIsSync(renderDispatch)) {\n\t\t            updateSyncFromRoot(renderDispatch);\n\t\t        }\n\t\t        else {\n\t\t            renderScheduler.yieldTask(function resumeUpdateConcurrentFromRoot() {\n\t\t                if (hasSync || checkNextFiberIsSync(renderDispatch)) {\n\t\t                    updateSyncFromRoot(renderDispatch);\n\t\t                }\n\t\t                else {\n\t\t                    updateConcurrentNextFrame(renderDispatch);\n\t\t                }\n\t\t            });\n\t\t        }\n\t\t    }\n\t\t    else {\n\t\t        processAsyncLoadListOnUpdate(renderDispatch);\n\t\t        finishUpdateConcurrentFromRoot(renderDispatch);\n\t\t        renderScheduler.microTask(function callScheduleNext() {\n\t\t            globalLoop$1.current = false;\n\t\t            scheduleNext(renderDispatch);\n\t\t        });\n\t\t    }\n\t\t};\n\n\t\tvar checkHookValid = function (hookNode) {\n\t\t    if (hookNode.type === HOOK_TYPE.useMemo ||\n\t\t        hookNode.type === HOOK_TYPE.useEffect ||\n\t\t        hookNode.type === HOOK_TYPE.useCallback ||\n\t\t        hookNode.type === HOOK_TYPE.useLayoutEffect) {\n\t\t        if (typeof hookNode.value !== \"function\") {\n\t\t            throw new Error(\"[@my-react/react] \".concat(HOOK_TYPE[hookNode.type], \" initial error\"));\n\t\t        }\n\t\t    }\n\t\t    if (hookNode.type === HOOK_TYPE.useContext) {\n\t\t        if (typeof hookNode.value !== \"object\" || hookNode.value === null) {\n\t\t            throw new Error(\"[@my-react/react] \".concat(HOOK_TYPE[hookNode.type], \" initial error\"));\n\t\t        }\n\t\t    }\n\t\t    if (hookNode.type === HOOK_TYPE.useSyncExternalStore) {\n\t\t        var storeApi = hookNode.value;\n\t\t        if (typeof storeApi.subscribe !== \"function\" || typeof storeApi.getSnapshot !== \"function\") {\n\t\t            throw new Error(\"[@my-react/react] \".concat(HOOK_TYPE[hookNode.type], \" initial error\"));\n\t\t        }\n\t\t    }\n\t\t    if (hookNode.type === HOOK_TYPE.useOptimistic) {\n\t\t        var value = hookNode.value;\n\t\t        if (value.reducer && typeof value.reducer !== \"function\") {\n\t\t            throw new Error(\"[@my-react/react] \".concat(HOOK_TYPE[hookNode.type], \" initial error\"));\n\t\t        }\n\t\t    }\n\t\t    if (hookNode.type === HOOK_TYPE.useEffectEvent) {\n\t\t        if (typeof hookNode.value !== \"function\") {\n\t\t            throw new Error(\"[@my-react/react] \".concat(HOOK_TYPE[hookNode.type], \" initial error\"));\n\t\t        }\n\t\t    }\n\t\t};\n\n\t\tvar MyReactInternalInstance$4 = react.__my_react_internal__.MyReactInternalInstance, currentScheduler$8 = react.__my_react_internal__.currentScheduler;\n\t\tvar enableSyncFlush = react.__my_react_shared__.enableSyncFlush;\n\t\tvar defaultPayLoad = function (a) { return a; };\n\t\tvar MyReactHookNode = /** @class */ (function (_super) {\n\t\t    __extends(MyReactHookNode, _super);\n\t\t    function MyReactHookNode(type, value, reducer, deps) {\n\t\t        var _this = _super.call(this) || this;\n\t\t        _this.hasEffect = false;\n\t\t        _this.type = type;\n\t\t        _this.deps = deps;\n\t\t        _this.value = value;\n\t\t        _this.reducer = reducer;\n\t\t        return _this;\n\t\t    }\n\t\t    Object.defineProperty(MyReactHookNode.prototype, \"isMyReactHook\", {\n\t\t        get: function () {\n\t\t            return true;\n\t\t        },\n\t\t        enumerable: false,\n\t\t        configurable: true\n\t\t    });\n\t\t    MyReactHookNode.prototype._update = function (params) {\n\t\t        if (params === void 0) { params = {}; }\n\t\t        var updater = __assign({ type: UpdateQueueType.hook, trigger: this, payLoad: defaultPayLoad, isSync: false, isForce: false }, params);\n\t\t        var renderScheduler = currentScheduler$8.current;\n\t\t        renderScheduler === null || renderScheduler === void 0 ? void 0 : renderScheduler.dispatchState(updater);\n\t\t    };\n\t\t    return MyReactHookNode;\n\t\t}(MyReactInternalInstance$4));\n\t\tvar initHookInstance = function (hookNode) {\n\t\t    var field = getInstanceFieldByInstance(hookNode);\n\t\t    if (!field)\n\t\t        throw new Error(\"[@my-react/react] hook instance not found, look like a bug for @my-react\");\n\t\t    var typedField = field;\n\t\t    typedField.dispatch = function dispatchAction(action) {\n\t\t        hookNode._update({ payLoad: action, isForce: false, isSync: enableSyncFlush.current });\n\t\t    };\n\t\t};\n\n\t\tvar currentComponentFiber$3 = react.__my_react_internal__.currentComponentFiber;\n\t\tvar MyReactSignal = /** @class */ (function () {\n\t\t    function MyReactSignal(_rawValue, _renderDispatch) {\n\t\t        var _this = this;\n\t\t        this._renderDispatch = _renderDispatch;\n\t\t        this._depsSet = new Set();\n\t\t        this.getValue = function () {\n\t\t            if (currentComponentFiber$3.current) {\n\t\t                _this._depsSet.add(currentComponentFiber$3.current);\n\t\t            }\n\t\t            return _this._value;\n\t\t        };\n\t\t        this.setValue = function (newValue) {\n\t\t            if (!Object.is(_this._value, newValue)) {\n\t\t                var allDeps = new Set(_this._depsSet);\n\t\t                _this._depsSet.clear();\n\t\t                _this._value = newValue;\n\t\t                allDeps.forEach(function (f) { return exclude(f.state, STATE_TYPE.__unmount__) && (f.state = STATE_TYPE.__triggerConcurrent__); });\n\t\t                triggerUpdateOnFiber(_this._renderDispatch.rootFiber, STATE_TYPE.__triggerConcurrent__);\n\t\t            }\n\t\t        };\n\t\t        this._value = _rawValue;\n\t\t    }\n\t\t    return MyReactSignal;\n\t\t}());\n\n\t\tvar enableDebugLog$1 = react.__my_react_shared__.enableDebugLog, enableDebugFiled$6 = react.__my_react_shared__.enableDebugFiled;\n\t\tvar currentHookTreeNode$2 = react.__my_react_internal__.currentHookTreeNode, currentHookNodeIndex$2 = react.__my_react_internal__.currentHookNodeIndex;\n\t\tvar defaultReducer = function (state, action) {\n\t\t    return typeof action === \"function\" ? action(state) : action;\n\t\t};\n\t\tvar defaultOptimisticReducer = function (state) { return state; };\n\t\tvar createHookNode = function (renderDispatch, _a, fiber) {\n\t\t    var _b, _c;\n\t\t    var type = _a.type, value = _a.value, reducer = _a.reducer, deps = _a.deps;\n\t\t    var currentHook = (_b = currentHookTreeNode$2.current) === null || _b === void 0 ? void 0 : _b.value;\n\t\t    var currentHookIndex = currentHookNodeIndex$2.current;\n\t\t    var currentIsReCreate = include(fiber.state, STATE_TYPE.__recreate__);\n\t\t    if (currentHook) {\n\t\t        if (currentIsReCreate) {\n\t\t            if (currentHookIndex === 0) {\n\t\t                defaultDeleteChildEffect(renderDispatch, fiber);\n\t\t                defaultDeleteCurrentEffect(renderDispatch, fiber);\n\t\t                fiber.hookList.clear();\n\t\t            }\n\t\t        }\n\t\t        else {\n\t\t            throw new Error(\"[@my-react/react] should not have a hookList for current node, this is a bug for @my-react\");\n\t\t        }\n\t\t    }\n\t\t    var hookNode = new MyReactHookNode(type, value, reducer || defaultReducer, deps);\n\t\t    initInstance(hookNode);\n\t\t    initHookInstance(hookNode);\n\t\t    setOwnerForInstance(hookNode, fiber);\n\t\t    fiber.hookList.push(hookNode);\n\t\t    checkHookValid(hookNode);\n\t\t    if (hookNode.type === HOOK_TYPE.useMemo || hookNode.type === HOOK_TYPE.useState || hookNode.type === HOOK_TYPE.useReducer) {\n\t\t        hookNode.result = hookNode.value.call(null);\n\t\t        // hack code\n\t\t        var a = function () {\n\t\t        };\n\t\t        a.bind(null, fiber);\n\t\t    }\n\t\t    if (hookNode.type === HOOK_TYPE.useEffect ||\n\t\t        hookNode.type === HOOK_TYPE.useLayoutEffect ||\n\t\t        hookNode.type === HOOK_TYPE.useInsertionEffect ||\n\t\t        hookNode.type === HOOK_TYPE.useImperativeHandle) {\n\t\t        hookNode.result = hookNode.value;\n\t\t        hookNode.hasEffect = true;\n\t\t    }\n\t\t    if (hookNode.type === HOOK_TYPE.useRef ||\n\t\t        hookNode.type === HOOK_TYPE.useCallback ||\n\t\t        hookNode.type === HOOK_TYPE.useDeferredValue ||\n\t\t        hookNode.type === HOOK_TYPE.useEffectEvent) {\n\t\t        hookNode.result = hookNode.value;\n\t\t    }\n\t\t    // cache ref state from recreate\n\t\t    if (hookNode.type === HOOK_TYPE.useRef && currentHook && currentHook.type === HOOK_TYPE.useRef) {\n\t\t        hookNode.result = currentHook.result;\n\t\t    }\n\t\t    if (hookNode.type === HOOK_TYPE.useId) {\n\t\t        hookNode.result = \"\\u00AB-\".concat(currentHookIndex, \"-\").concat(renderDispatch.uniqueIdCount++, \"-\\u00BB\");\n\t\t        hookNode.cancel = function () { return renderDispatch.uniqueIdCount--; };\n\t\t    }\n\t\t    if (hookNode.type === HOOK_TYPE.useDebugValue) {\n\t\t        hookNode.result = hookNode.value;\n\t\t        if (enableDebugLog$1.current) {\n\t\t            console.warn.apply(console, __spreadArray([\"[debug]\"], hookNode.value, false));\n\t\t        }\n\t\t    }\n\t\t    if (hookNode.type === HOOK_TYPE.useContext) {\n\t\t        var providerFiber = renderDispatch.resolveContextFiber(fiber, hookNode.value);\n\t\t        var context = renderDispatch.resolveContextValue(providerFiber, hookNode.value);\n\t\t        setContextForInstance(hookNode, providerFiber);\n\t\t        hookNode.result = context;\n\t\t    }\n\t\t    if (hookNode.type === HOOK_TYPE.useSyncExternalStore) {\n\t\t        var storeApi_1 = hookNode.value;\n\t\t        var getNextResult = function () {\n\t\t            return safeCallWithCurrentFiber({\n\t\t                fiber: fiber,\n\t\t                action: function safeCallGetSnapshot() {\n\t\t                    return renderDispatch.isAppMounted\n\t\t                        ? storeApi_1.getSnapshot.call(null)\n\t\t                        : // SEE https://github.com/facebook/react/blob/main/packages/use-sync-external-store/src/useSyncExternalStoreShimClient.js#L33\n\t\t                            // : storeApi.getServerSnapshot\n\t\t                            // ? storeApi.getServerSnapshot?.call(null)\n\t\t                            // : storeApi.getSnapshot.call(null);\n\t\t                            storeApi_1.getSnapshot.call(null);\n\t\t                },\n\t\t            });\n\t\t        };\n\t\t        var nextResult = getNextResult();\n\t\t        if (!Object.is(nextResult, getNextResult())) {\n\t\t            throw new Error(\"[@my-react/react] syncExternalStore getSnapshot not stable!\");\n\t\t        }\n\t\t        storeApi_1.result = nextResult;\n\t\t        hookNode.result = nextResult;\n\t\t        var checkResultUpdate_1 = function checkResultUpdate() {\n\t\t            var prevResult = storeApi_1.result;\n\t\t            var nextResult = null;\n\t\t            var hasChange = true;\n\t\t            try {\n\t\t                nextResult = storeApi_1.getSnapshot.call(null);\n\t\t                hasChange = !Object.is(prevResult, nextResult);\n\t\t            }\n\t\t            catch (_a) {\n\t\t                hasChange = true;\n\t\t            }\n\t\t            if (hasChange) {\n\t\t                hookNode._update({ isForce: true, isSync: true, payLoad: function () { return nextResult; } });\n\t\t            }\n\t\t        };\n\t\t        renderDispatch.pendingLayoutEffect(fiber, function invokeLayoutEffectOnHook() {\n\t\t            checkResultUpdate_1();\n\t\t        });\n\t\t        renderDispatch.pendingEffect(fiber, function invokeEffectOnHook() {\n\t\t            hookNode.cancel && hookNode.cancel();\n\t\t            checkResultUpdate_1();\n\t\t            hookNode.cancel = storeApi_1.subscribe(checkResultUpdate_1);\n\t\t        });\n\t\t    }\n\t\t    // if (hookNode.type === HOOK_TYPE.useSyncExternalStore) {\n\t\t    //   const storeApi = hookNode.value;\n\t\t    //   const getNextResult = () =>\n\t\t    //     safeCallWithCurrentFiber({\n\t\t    //       fiber,\n\t\t    //       action: function safeCallGetSnapshot() {\n\t\t    //         return renderDispatch.isAppMounted\n\t\t    //           ? storeApi.getSnapshot.call(null)\n\t\t    //           : storeApi.getServerSnapshot\n\t\t    //             ? storeApi.getServerSnapshot?.call(null)\n\t\t    //             : storeApi.getSnapshot.call(null);\n\t\t    //       },\n\t\t    //     });\n\t\t    //   const nextResult = getNextResult();\n\t\t    //   if (!Object.is(nextResult, getNextResult())) {\n\t\t    //     throw new Error(`[@my-react/react] syncExternalStore getSnapshot not stable!`);\n\t\t    //   }\n\t\t    //   storeApi.result = nextResult;\n\t\t    //   hookNode.result = nextResult;\n\t\t    //   hookNode.hasEffect = true;\n\t\t    // }\n\t\t    if (hookNode.type === HOOK_TYPE.useSignal) {\n\t\t        hookNode.result = new MyReactSignal(hookNode.value.call(null), renderDispatch);\n\t\t    }\n\t\t    if (hookNode.type === HOOK_TYPE.useTransition) {\n\t\t        hookNode.result = {\n\t\t            value: false,\n\t\t            start: function startTransitionByHook(cb) {\n\t\t                var loadingCallback = function (cb) {\n\t\t                    react.startTransition(function () {\n\t\t                        hookNode._update({ isForce: true, isSync: true, callback: cb, payLoad: function (last) { return ({ value: true, start: last.start }); } });\n\t\t                    });\n\t\t                };\n\t\t                var loadedCallback = function () {\n\t\t                    react.startTransition(function () {\n\t\t                        hookNode._update({ isForce: true, isSync: true, payLoad: function (last) { return ({ value: false, start: last.start }); } });\n\t\t                    });\n\t\t                };\n\t\t                var taskCallback = function () {\n\t\t                    react.startTransition(function () {\n\t\t                        safeCallWithCurrentFiber({ fiber: fiber, action: cb });\n\t\t                        loadedCallback();\n\t\t                    });\n\t\t                };\n\t\t                loadingCallback(taskCallback);\n\t\t            },\n\t\t        };\n\t\t    }\n\t\t    if (hookNode.type === HOOK_TYPE.useOptimistic) {\n\t\t        hookNode.result = {\n\t\t            value: value.value,\n\t\t            start: function startOptimisticByHook(newValue) {\n\t\t                var mergeFunc = hookNode.value.reducer || defaultOptimisticReducer;\n\t\t                var nextValue = mergeFunc(newValue, hookNode.result.value.value);\n\t\t                var payloadRef = { current: function (last) { return ({ value: nextValue, start: last.start }); } };\n\t\t                hookNode._update({ isForce: true, isSync: true, payLoad: function (last) { return payloadRef.current(last); } });\n\t\t                hookNode.cancel = function () { return (payloadRef.current = function (last) { return last; }); };\n\t\t            },\n\t\t        };\n\t\t    }\n\t\t    var typedHook = hookNode;\n\t\t    if (enableDebugFiled$6.current) {\n\t\t        var typedFiber = fiber;\n\t\t        typedFiber._debugHookTypes = typedFiber._debugHookTypes || [];\n\t\t        typedFiber._debugHookTypes.push(HOOK_TYPE[hookNode.type]);\n\t\t        typedHook._debugType = HOOK_TYPE[hookNode.type];\n\t\t        typedHook._debugIndex = currentHookIndex;\n\t\t    }\n\t\t    currentHookTreeNode$2.current = (_c = currentHookTreeNode$2.current) === null || _c === void 0 ? void 0 : _c.next;\n\t\t    return hookNode;\n\t\t};\n\n\t\tvar effectHookNode = function (renderDispatch, fiber, hookNode, field) {\n\t\t    var effect = field.effect;\n\t\t    if (hookNode.hasEffect && effect === Effect_TYPE.__initial__) {\n\t\t        setEffectForInstance(hookNode, Effect_TYPE.__effect__);\n\t\t        if (hookNode.type === HOOK_TYPE.useEffect) {\n\t\t            renderDispatch.pendingEffect(fiber, function invokeEffectOnHook() {\n\t\t                hookNode.cancel && hookNode.cancel();\n\t\t                var ownerFiber = getInstanceOwnerFiber(hookNode);\n\t\t                if (ownerFiber && exclude(ownerFiber.state, STATE_TYPE.__unmount__))\n\t\t                    hookNode.cancel = hookNode.value();\n\t\t                hookNode.hasEffect = false;\n\t\t                setEffectForInstance(hookNode, Effect_TYPE.__initial__);\n\t\t            });\n\t\t        }\n\t\t        if (hookNode.type === HOOK_TYPE.useLayoutEffect) {\n\t\t            renderDispatch.pendingLayoutEffect(fiber, function invokeLayoutEffectOnHook() {\n\t\t                hookNode.cancel && hookNode.cancel();\n\t\t                hookNode.cancel = hookNode.value();\n\t\t                hookNode.hasEffect = false;\n\t\t                setEffectForInstance(hookNode, Effect_TYPE.__initial__);\n\t\t            });\n\t\t        }\n\t\t        if (hookNode.type === HOOK_TYPE.useInsertionEffect) {\n\t\t            renderDispatch.pendingInsertionEffect(fiber, function invokeInsertionEffectOnHook() {\n\t\t                hookNode.cancel && hookNode.cancel();\n\t\t                hookNode.cancel = hookNode.value();\n\t\t                hookNode.hasEffect = false;\n\t\t                setEffectForInstance(hookNode, Effect_TYPE.__initial__);\n\t\t            });\n\t\t        }\n\t\t        if (hookNode.type === HOOK_TYPE.useImperativeHandle) {\n\t\t            renderDispatch.pendingLayoutEffect(fiber, function invokeLayoutEffectOnHook() {\n\t\t                hookNode.cancel && hookNode.cancel();\n\t\t                // ref obj\n\t\t                if (hookNode.value && typeof hookNode.value === \"object\")\n\t\t                    hookNode.value.current = hookNode.reducer.call(null);\n\t\t                // ref function\n\t\t                if (hookNode.value && typeof hookNode.value === \"function\")\n\t\t                    hookNode.value(hookNode.reducer.call(null));\n\t\t                // TODO\n\t\t                // hookNode.cancel =\n\t\t                hookNode.hasEffect = false;\n\t\t                setEffectForInstance(hookNode, Effect_TYPE.__initial__);\n\t\t            });\n\t\t        }\n\t\t        if (hookNode.type === HOOK_TYPE.useSyncExternalStore) {\n\t\t            renderDispatch.pendingEffect(fiber, function invokeEffectOnHook() {\n\t\t                hookNode.cancel && hookNode.cancel();\n\t\t                var storeApi = hookNode.value;\n\t\t                hookNode.cancel = storeApi.subscribe(function triggerHookUpdate() {\n\t\t                    hookNode._update({ payLoad: function () { return storeApi.getSnapshot.call(null); } });\n\t\t                });\n\t\t                hookNode.hasEffect = false;\n\t\t                setEffectForInstance(hookNode, Effect_TYPE.__initial__);\n\t\t            });\n\t\t        }\n\t\t    }\n\t\t};\n\n\t\tvar enableDebugLog = react.__my_react_shared__.enableDebugLog;\n\t\tvar currentHookTreeNode$1 = react.__my_react_internal__.currentHookTreeNode, currentScheduler$7 = react.__my_react_internal__.currentScheduler;\n\t\tvar updateHookNode = function (renderDispatch, _a, fiber, isHMR) {\n\t\t    var _b, _c, _d;\n\t\t    var type = _a.type, value = _a.value, reducer = _a.reducer, deps = _a.deps;\n\t\t    var renderScheduler = currentScheduler$7.current;\n\t\t    var currentHook = (_b = currentHookTreeNode$1.current) === null || _b === void 0 ? void 0 : _b.value;\n\t\t    if (!currentHook) {\n\t\t        throw new Error(\"[@my-react/react] should have a hookList for current node, this is a bug for @my-react\");\n\t\t    }\n\t\t    if (type !== (currentHook === null || currentHook === void 0 ? void 0 : currentHook.type)) {\n\t\t        throw new Error(getHookTree(currentHookTreeNode$1.current.prev, {\n\t\t            lastRender: currentHook === null || currentHook === void 0 ? void 0 : currentHook.type,\n\t\t            nextRender: type,\n\t\t        }));\n\t\t    }\n\t\t    setOwnerForInstance(currentHook, fiber);\n\t\t    currentHookTreeNode$1.current = currentHookTreeNode$1.current.next;\n\t\t    if (currentHook.type === HOOK_TYPE.useMemo ||\n\t\t        currentHook.type === HOOK_TYPE.useEffect ||\n\t\t        currentHook.type === HOOK_TYPE.useCallback ||\n\t\t        currentHook.type === HOOK_TYPE.useLayoutEffect ||\n\t\t        currentHook.type === HOOK_TYPE.useInsertionEffect ||\n\t\t        currentHook.type === HOOK_TYPE.useImperativeHandle) {\n\t\t        if (deps && !currentHook.deps) {\n\t\t            throw new Error(\"[@my-react/react] deps state change\");\n\t\t        }\n\t\t        if (!deps && currentHook.deps) {\n\t\t            throw new Error(\"[@my-react/react] deps state change\");\n\t\t        }\n\t\t    }\n\t\t    if (currentHook.type === HOOK_TYPE.useEffect || currentHook.type === HOOK_TYPE.useLayoutEffect || currentHook.type === HOOK_TYPE.useInsertionEffect) {\n\t\t        if (isHMR || !deps || !isArrayEquals(currentHook.deps, deps)) {\n\t\t            currentHook.value = value;\n\t\t            currentHook.result = value;\n\t\t            currentHook.reducer = reducer || currentHook.reducer;\n\t\t            currentHook.deps = deps;\n\t\t            currentHook.hasEffect = true;\n\t\t        }\n\t\t        return currentHook;\n\t\t    }\n\t\t    if (currentHook.type === HOOK_TYPE.useImperativeHandle) {\n\t\t        var depsChanged = false;\n\t\t        // ref changed also need to trigger effect\n\t\t        if (isHMR || !deps || !isNormalEquals(currentHook.value, value) || ((depsChanged = !isArrayEquals(currentHook.deps, deps)), depsChanged)) {\n\t\t            currentHook.value = value;\n\t\t            currentHook.result = value;\n\t\t            currentHook.reducer = depsChanged ? reducer || currentHook.reducer : currentHook.reducer;\n\t\t            currentHook.deps = deps;\n\t\t            currentHook.hasEffect = true;\n\t\t        }\n\t\t        return currentHook;\n\t\t    }\n\t\t    if (currentHook.type === HOOK_TYPE.useSyncExternalStore) {\n\t\t        var storeApi_1 = currentHook.value;\n\t\t        var newStoreApi_1 = value;\n\t\t        var prevResult = storeApi_1.result;\n\t\t        var nextResult_1 = safeCallWithCurrentFiber({\n\t\t            fiber: fiber,\n\t\t            action: function safeCallGetSnapshot() {\n\t\t                return newStoreApi_1.getSnapshot.call(null);\n\t\t            },\n\t\t        });\n\t\t        if (!Object.is(nextResult_1, newStoreApi_1.getSnapshot.call(null))) {\n\t\t            throw new Error(\"[@my-react/react] syncExternalStore getSnapshot not stable!\");\n\t\t        }\n\t\t        currentHook.result = nextResult_1;\n\t\t        var checkResultUpdate_1 = function checkResultUpdate() {\n\t\t            var prevResult = storeApi_1.result;\n\t\t            var nextResult = null;\n\t\t            var hasChange = true;\n\t\t            try {\n\t\t                nextResult = storeApi_1.getSnapshot.call(null);\n\t\t                hasChange = !Object.is(prevResult, nextResult);\n\t\t            }\n\t\t            catch (_a) {\n\t\t                hasChange = true;\n\t\t            }\n\t\t            if (hasChange) {\n\t\t                currentHook._update({ isForce: true, isSync: true, payLoad: function () { return nextResult; } });\n\t\t            }\n\t\t        };\n\t\t        if (!Object.is(prevResult, nextResult_1) ||\n\t\t            !Object.is(storeApi_1.getSnapshot, newStoreApi_1.getSnapshot) ||\n\t\t            !Object.is(storeApi_1.subscribe, newStoreApi_1.subscribe)) {\n\t\t            renderDispatch.pendingLayoutEffect(fiber, function invokeLayoutEffectOnHook() {\n\t\t                storeApi_1.result = nextResult_1;\n\t\t                storeApi_1.getSnapshot = newStoreApi_1.getSnapshot;\n\t\t                checkResultUpdate_1();\n\t\t            });\n\t\t        }\n\t\t        if (isHMR || !Object.is(storeApi_1.subscribe, newStoreApi_1.subscribe)) {\n\t\t            renderDispatch.pendingEffect(fiber, function invokeEffectOnHook() {\n\t\t                currentHook.cancel && currentHook.cancel();\n\t\t                checkResultUpdate_1();\n\t\t                currentHook.cancel = storeApi_1.subscribe(checkResultUpdate_1);\n\t\t            });\n\t\t        }\n\t\t        return currentHook;\n\t\t    }\n\t\t    // if (currentHook.type === HOOK_TYPE.useSyncExternalStore) {\n\t\t    //   const storeApi = currentHook.value;\n\t\t    //   const newStoreApi = value;\n\t\t    //   const nextResult = safeCallWithCurrentFiber({\n\t\t    //     fiber,\n\t\t    //     action: function safeCallGetSnapshot() {\n\t\t    //       return newStoreApi.getSnapshot.call(null);\n\t\t    //     },\n\t\t    //   });\n\t\t    //   if (!Object.is(nextResult, newStoreApi.getSnapshot.call(null))) {\n\t\t    //     throw new Error(`[@my-react/react] syncExternalStore getSnapshot not stable!`);\n\t\t    //   }\n\t\t    //   currentHook.result = nextResult;\n\t\t    //   if (isHMR || !Object.is(storeApi.subscribe, newStoreApi.subscribe)) {\n\t\t    //     storeApi.subscribe = newStoreApi.subscribe;\n\t\t    //     currentHook.hasEffect = true;\n\t\t    //   }\n\t\t    //   storeApi.getSnapshot = newStoreApi.getSnapshot;\n\t\t    //   return currentHook;\n\t\t    // }\n\t\t    if (currentHook.type === HOOK_TYPE.useCallback) {\n\t\t        if (isHMR || !deps || !isArrayEquals(currentHook.deps, deps)) {\n\t\t            currentHook.value = value;\n\t\t            currentHook.result = value;\n\t\t            currentHook.deps = deps;\n\t\t        }\n\t\t        return currentHook;\n\t\t    }\n\t\t    if (currentHook.type === HOOK_TYPE.useMemo) {\n\t\t        if (isHMR || !deps || !isArrayEquals(currentHook.deps, deps)) {\n\t\t            currentHook.value = value;\n\t\t            currentHook.result = safeCallWithCurrentFiber({\n\t\t                fiber: fiber,\n\t\t                action: function safeCallMemoOnHook() {\n\t\t                    return value.call(null);\n\t\t                },\n\t\t            });\n\t\t            currentHook.deps = deps;\n\t\t        }\n\t\t        return currentHook;\n\t\t    }\n\t\t    if (currentHook.type === HOOK_TYPE.useContext) {\n\t\t        var contextFiber = getInstanceContextFiber(currentHook);\n\t\t        if (!contextFiber || include(contextFiber.state, STATE_TYPE.__unmount__) || !Object.is(currentHook.value, value)) {\n\t\t            currentHook.value = value;\n\t\t            var providerFiber = renderDispatch.resolveContextFiber(fiber, currentHook.value);\n\t\t            var context = renderDispatch.resolveContextValue(providerFiber, currentHook.value);\n\t\t            setContextForInstance(currentHook, providerFiber);\n\t\t            currentHook.result = context;\n\t\t        }\n\t\t        else {\n\t\t            var context = renderDispatch.resolveContextValue(contextFiber, currentHook.value);\n\t\t            currentHook.result = context;\n\t\t        }\n\t\t        return currentHook;\n\t\t    }\n\t\t    if (currentHook.type === HOOK_TYPE.useReducer) {\n\t\t        currentHook.value = value;\n\t\t        currentHook.reducer = reducer;\n\t\t        return currentHook;\n\t\t    }\n\t\t    if (currentHook.type === HOOK_TYPE.useDeferredValue) {\n\t\t        (_c = currentHook.cancel) === null || _c === void 0 ? void 0 : _c.call(currentHook);\n\t\t        currentHook.value = value;\n\t\t        if (!Object.is(currentHook.value, currentHook.result)) {\n\t\t            currentHook.cancel = renderScheduler.yieldTask(function triggerHookUpdate() {\n\t\t                currentHook._update({ isForce: true, payLoad: function () { return currentHook.value; } });\n\t\t                currentHook.cancel = null;\n\t\t            });\n\t\t        }\n\t\t    }\n\t\t    if (currentHook.type === HOOK_TYPE.useOptimistic) {\n\t\t        (_d = currentHook.cancel) === null || _d === void 0 ? void 0 : _d.call(currentHook);\n\t\t        currentHook.value = value;\n\t\t        if (!Object.is(currentHook.result.value, value.value)) {\n\t\t            currentHook.result.value = value.value;\n\t\t            // currentHook._update({ isForce: true, payLoad: (last) => ({ value: value.value, start: last.start }) });\n\t\t        }\n\t\t    }\n\t\t    if (currentHook.type === HOOK_TYPE.useEffectEvent) {\n\t\t        if (typeof value !== \"function\") {\n\t\t            throw new Error(\"[@my-react/react] useEffectEvent should be a function\");\n\t\t        }\n\t\t        currentHook.value = value;\n\t\t        currentHook.result = value;\n\t\t    }\n\t\t    if (currentHook.type === HOOK_TYPE.useDebugValue) {\n\t\t        if (!isArrayEquals(currentHook.value, value)) {\n\t\t            currentHook.value = value;\n\t\t            currentHook.result = value;\n\t\t            if (enableDebugLog.current) {\n\t\t                console.warn.apply(console, __spreadArray([\"[debug]\"], currentHook.value, false));\n\t\t            }\n\t\t        }\n\t\t    }\n\t\t    return currentHook;\n\t\t};\n\n\t\tvar hookListUnmount = function (renderDispatch, fiber) {\n\t\t    var _a, _b;\n\t\t    (_b = (_a = fiber.hookList) === null || _a === void 0 ? void 0 : _a.listToFoot) === null || _b === void 0 ? void 0 : _b.call(_a, function invokeHookUnmount(hookNode) {\n\t\t        safeCallWithCurrentFiber({\n\t\t            fiber: fiber,\n\t\t            action: function safeCallHookUnmountListener() {\n\t\t                renderDispatch.callOnHookUnmount(hookNode, fiber);\n\t\t            },\n\t\t        });\n\t\t        safeCallWithCurrentFiber({\n\t\t            fiber: fiber,\n\t\t            action: function safeCallHookNodeUnmount() {\n\t\t                hookNode.hasEffect = false;\n\t\t                hookNode.cancel && hookNode.cancel();\n\t\t                unmountInstance(hookNode);\n\t\t            },\n\t\t        });\n\t\t    });\n\t\t};\n\n\t\tvar enableDebugFiled$5 = react.__my_react_shared__.enableDebugFiled;\n\t\tvar clearFiberNode = function (renderDispatch, fiber) {\n\t\t    hookListUnmount(renderDispatch, fiber);\n\t\t    processClassComponentUnmount(renderDispatch, fiber);\n\t\t    defaultDeleteCurrentEffect(renderDispatch, fiber);\n\t\t    fiber.instance = null;\n\t\t    fiber.hookList = null;\n\t\t    fiber.updateQueue = null;\n\t\t    renderDispatch.commitUnsetRef(fiber);\n\t\t    if (enableDebugFiled$5.current) {\n\t\t        var typedFiber = fiber;\n\t\t        typedFiber._debugHookTypes = [];\n\t\t    }\n\t\t};\n\n\t\tvar currentScheduler$6 = react.__my_react_internal__.currentScheduler;\n\t\tvar hmr = function (fiber, nextType, forceRefresh) {\n\t\t    {\n\t\t        if (include(fiber.state, STATE_TYPE.__unmount__))\n\t\t            return;\n\t\t        var renderDispatch_1 = getCurrentDispatchFromFiber(fiber);\n\t\t        safeCallWithCurrentFiber({\n\t\t            fiber: fiber,\n\t\t            action: function safeCallHMR() {\n\t\t                var _a, _b;\n\t\t                // keep the type\n\t\t                var nodeType = fiber.type;\n\t\t                var element = react.createElement(nextType, __assign(__assign({}, fiber.pendingProps), { key: (_a = fiber.key) !== null && _a !== void 0 ? _a : undefined, ref: (_b = fiber.ref) !== null && _b !== void 0 ? _b : undefined }));\n\t\t                fiber._installElement(element);\n\t\t                fiber.type = nodeType;\n\t\t            },\n\t\t        });\n\t\t        setRefreshTypeMap(fiber);\n\t\t        if (forceRefresh) {\n\t\t            clearFiberNode(renderDispatch_1, fiber);\n\t\t            fiber.state = merge(STATE_TYPE.__create__, STATE_TYPE.__hmr__);\n\t\t        }\n\t\t        else {\n\t\t            fiber.state = merge(STATE_TYPE.__triggerSync__, STATE_TYPE.__hmr__);\n\t\t        }\n\t\t        safeCallWithCurrentFiber({\n\t\t            fiber: fiber,\n\t\t            action: function safeCallFiberHMRListener() {\n\t\t                renderDispatch_1.callOnFiberHMR(fiber, forceRefresh);\n\t\t            },\n\t\t        });\n\t\t        return fiber;\n\t\t    }\n\t\t};\n\t\tfunction hmrRevert(cb) {\n\t\t    if (include(this.state, STATE_TYPE.__unmount__))\n\t\t        return;\n\t\t    var renderDispatch = getCurrentDispatchFromFiber(this);\n\t\t    triggerRevert(renderDispatch, this, cb);\n\t\t}\n\t\tfunction hmrUpdate(state, cb) {\n\t\t    if (include(this.state, STATE_TYPE.__unmount__))\n\t\t        return;\n\t\t    var renderScheduler = currentScheduler$6.current;\n\t\t    var updater = {\n\t\t        type: UpdateQueueType.hmr,\n\t\t        trigger: this,\n\t\t        isSync: true,\n\t\t        isForce: false,\n\t\t        isImmediate: true,\n\t\t        isRetrigger: false,\n\t\t        callback: cb,\n\t\t    };\n\t\t    renderScheduler.dispatchState(updater);\n\t\t}\n\n\t\tvar checkIsMyReactFiberNode = function (fiber) {\n\t\t    return (fiber &&\n\t\t        typeof fiber === \"object\" &&\n\t\t        fiber.constructor &&\n\t\t        fiber.constructor.prototype &&\n\t\t        Object.prototype.hasOwnProperty.call(fiber.constructor.prototype, \"isMyReactFiberNode\") &&\n\t\t        fiber.constructor.prototype.isMyReactFiberNode);\n\t\t};\n\n\t\tvar currentScheduler$5 = react.__my_react_internal__.currentScheduler;\n\t\tvar processUpdateOnFiber = function (renderDispatch, fiber, _isImmediate, _isRetrigger) {\n\t\t    var renderScheduler = currentScheduler$5.current;\n\t\t    var flag = renderDispatch.enableConcurrentMode;\n\t\t    var updateState = null;\n\t\t    if (include(fiber.type, exports.NODE_TYPE.__class__)) {\n\t\t        updateState = flag ? processClassComponentUpdateQueueLatest(renderDispatch, fiber, flag) : processClassComponentUpdateQueueLegacy(renderDispatch, fiber);\n\t\t    }\n\t\t    else if (include(fiber.type, exports.NODE_TYPE.__function__)) {\n\t\t        updateState = flag\n\t\t            ? processFunctionComponentUpdateQueueLatest(renderDispatch, fiber, flag)\n\t\t            : processFunctionComponentUpdateQueueLegacy(renderDispatch, fiber);\n\t\t    }\n\t\t    else {\n\t\t        updateState = flag ? processNormalComponentUpdateLatest(renderDispatch, fiber) : processNormalComponentUpdateLegacy(renderDispatch, fiber);\n\t\t    }\n\t\t    if (updateState === null || updateState === void 0 ? void 0 : updateState.needUpdate) {\n\t\t        safeCallWithCurrentFiber({\n\t\t            fiber: fiber,\n\t\t            action: function safeCallFiberTriggerListener() {\n\t\t                renderDispatch.callOnFiberTrigger(fiber, updateState);\n\t\t            },\n\t\t        });\n\t\t        // TODO get from updateState ?\n\t\t        if (updateState.isRetrigger) {\n\t\t            fiber.state = remove(fiber.state, STATE_TYPE.__stable__);\n\t\t            fiber.state = merge(fiber.state, STATE_TYPE.__retrigger__);\n\t\t            if (updateState.callback) {\n\t\t                renderDispatch.pendingLayoutEffect(fiber, updateState.callback, { stickyToFoot: true });\n\t\t            }\n\t\t            renderDispatch.runtimeFiber.retriggerFiber = fiber;\n\t\t            // render flow is done, here should trigger a new render flow\n\t\t            if (!renderDispatch.runtimeFiber.nextWorkingFiber) {\n\t\t                renderDispatch.runtimeFiber.nextWorkingFiber = fiber;\n\t\t                mountLoopAllFromScheduler(renderDispatch);\n\t\t            }\n\t\t            return;\n\t\t        }\n\t\t        if (updateState.isSync) {\n\t\t            if (updateState.isImmediate) {\n\t\t                triggerUpdate(renderDispatch, fiber, updateState.isForce ? STATE_TYPE.__triggerSyncForce__ : STATE_TYPE.__triggerSync__, updateState.callback);\n\t\t            }\n\t\t            else {\n\t\t                renderScheduler.microTask(function triggerSyncUpdateOnFiber() {\n\t\t                    triggerUpdate(renderDispatch, fiber, updateState.isForce ? STATE_TYPE.__triggerSyncForce__ : STATE_TYPE.__triggerSync__, updateState.callback);\n\t\t                });\n\t\t            }\n\t\t        }\n\t\t        else {\n\t\t            if (updateState.isImmediate) {\n\t\t                triggerUpdate(renderDispatch, fiber, updateState.isForce ? STATE_TYPE.__triggerConcurrentForce__ : STATE_TYPE.__triggerConcurrent__, updateState.callback);\n\t\t            }\n\t\t            else {\n\t\t                renderScheduler.microTask(function triggerConcurrentUpdateOnFiber() {\n\t\t                    triggerUpdate(renderDispatch, fiber, updateState.isForce ? STATE_TYPE.__triggerConcurrentForce__ : STATE_TYPE.__triggerConcurrent__, updateState.callback);\n\t\t                });\n\t\t            }\n\t\t        }\n\t\t    }\n\t\t};\n\t\tvar prepareUpdateOnFiber = function (renderDispatch, fiber, isImmediate, isRetrigger) {\n\t\t    if (include(fiber.state, STATE_TYPE.__unmount__))\n\t\t        return;\n\t\t    var renderScheduler = currentScheduler$5.current;\n\t\t    if (isImmediate) {\n\t\t        processUpdateOnFiber(renderDispatch, fiber);\n\t\t    }\n\t\t    else {\n\t\t        renderScheduler.microTask(function asyncProcessUpdateOnFiber() {\n\t\t            processUpdateOnFiber(renderDispatch, fiber);\n\t\t        });\n\t\t    }\n\t\t};\n\t\tvar SyncState = merge(STATE_TYPE.__triggerSyncForce__, STATE_TYPE.__triggerSync__);\n\t\tvar ForceState = merge(STATE_TYPE.__triggerSyncForce__, STATE_TYPE.__triggerConcurrentForce__);\n\t\tvar triggerUpdateOnFiber = function (fiber, state, callback) {\n\t\t    if (include(fiber.state, STATE_TYPE.__unmount__))\n\t\t        return;\n\t\t    var renderScheduler = currentScheduler$5.current;\n\t\t    var updater = {\n\t\t        type: UpdateQueueType.trigger,\n\t\t        trigger: fiber,\n\t\t        isSync: include(state, SyncState),\n\t\t        isForce: include(state, ForceState),\n\t\t        callback: callback,\n\t\t    };\n\t\t    renderScheduler.dispatchState(updater);\n\t\t};\n\n\t\tvar emptyProps = {};\n\t\tvar MyReactFiberNode = /** @class */ (function () {\n\t\t    function MyReactFiberNode(element) {\n\t\t        this.state = STATE_TYPE.__initial__;\n\t\t        this.patch = PATCH_TYPE.__initial__;\n\t\t        this.type = exports.NODE_TYPE.__initial__;\n\t\t        this.child = null;\n\t\t        this.parent = null;\n\t\t        this.sibling = null;\n\t\t        this.pendingProps = emptyProps;\n\t\t        this.memoizedProps = emptyProps;\n\t\t        this.state = STATE_TYPE.__create__;\n\t\t        this._installElement(element);\n\t\t    }\n\t\t    MyReactFiberNode.prototype._installElement = function (element) {\n\t\t        var _a = getTypeFromElementNode(element), key = _a.key, ref = _a.ref, nodeType = _a.nodeType, elementType = _a.elementType, pendingProps = _a.pendingProps, pendingText = _a.pendingText;\n\t\t        this.ref = ref;\n\t\t        this.key = key;\n\t\t        this.type = nodeType;\n\t\t        this.elementType = elementType;\n\t\t        if (include(nodeType, exports.NODE_TYPE.__function__)) {\n\t\t            this.elementRawType = element === null || element === void 0 ? void 0 : element.type;\n\t\t        }\n\t\t        this.pendingProps = pendingProps;\n\t\t        if (typeof pendingText === \"string\") {\n\t\t            this.pendingText = pendingText;\n\t\t        }\n\t\t        {\n\t\t            var typeThis = this;\n\t\t            typeThis._debugElement = element;\n\t\t        }\n\t\t        return element;\n\t\t    };\n\t\t    MyReactFiberNode.prototype._addDependence = function (instance) {\n\t\t        this.dependence = this.dependence || new Set();\n\t\t        this.dependence.add(instance);\n\t\t    };\n\t\t    MyReactFiberNode.prototype._delDependence = function (instance) {\n\t\t        var _a;\n\t\t        (_a = this.dependence) === null || _a === void 0 ? void 0 : _a.delete(instance);\n\t\t    };\n\t\t    MyReactFiberNode.prototype._update = function (state) {\n\t\t        triggerUpdateOnFiber(this, state);\n\t\t    };\n\t\t    return MyReactFiberNode;\n\t\t}());\n\t\tObject.defineProperty(MyReactFiberNode.prototype, \"isMyReactFiberNode\", {\n\t\t    value: true,\n\t\t    configurable: true,\n\t\t});\n\t\tObject.defineProperty(MyReactFiberNode.prototype, \"return\", {\n\t\t    get: function () {\n\t\t        return this.parent;\n\t\t    },\n\t\t    configurable: true,\n\t\t});\n\t\tObject.defineProperty(MyReactFiberNode.prototype, \"stateNode\", {\n\t\t    get: function () {\n\t\t        return this.nativeNode || this.containerNode;\n\t\t    },\n\t\t    configurable: true,\n\t\t});\n\t\t{\n\t\t    Object.defineProperty(MyReactFiberNode.prototype, \"_debugLog\", {\n\t\t        get: function () {\n\t\t            var _a = getFiberTreeWithFiber(this), str = _a.str, arr = _a.arr;\n\t\t            console.log.apply(console, __spreadArray([str], arr, false));\n\t\t            return true;\n\t\t        },\n\t\t        configurable: true,\n\t\t    });\n\t\t    Object.defineProperty(MyReactFiberNode.prototype, \"__dev_hmr_revert__\", {\n\t\t        value: hmrRevert,\n\t\t        configurable: true,\n\t\t    });\n\t\t    Object.defineProperty(MyReactFiberNode.prototype, \"__dev_hmr_update__\", {\n\t\t        value: hmrUpdate,\n\t\t        configurable: true,\n\t\t    });\n\t\t}\n\n\t\tvar createFiberNode = function (renderDispatch, _a, element) {\n\t\t    var parent = _a.parent, _b = _a.type, type = _b === void 0 ? \"append\" : _b;\n\t\t    var newFiberNode = new MyReactFiberNode(element);\n\t\t    fiberToDispatchMap.set(newFiberNode, renderDispatch);\n\t\t    newFiberNode.parent = parent;\n\t\t    parent.child = parent.child || newFiberNode;\n\t\t    renderDispatch.pendingCreate(newFiberNode);\n\t\t    renderDispatch.pendingUpdate(newFiberNode);\n\t\t    if (type === \"position\") {\n\t\t        renderDispatch.pendingPosition(newFiberNode);\n\t\t    }\n\t\t    else {\n\t\t        renderDispatch.pendingAppend(newFiberNode);\n\t\t    }\n\t\t    renderDispatch.pendingRef(newFiberNode);\n\t\t    safeCallWithCurrentFiber({\n\t\t        fiber: newFiberNode,\n\t\t        action: function safeCallPatchToFiberInitial() {\n\t\t            var _a;\n\t\t            (_a = renderDispatch.patchToFiberInitial) === null || _a === void 0 ? void 0 : _a.call(renderDispatch, newFiberNode);\n\t\t        },\n\t\t    });\n\t\t    safeCallWithCurrentFiber({\n\t\t        fiber: newFiberNode,\n\t\t        action: function safeCallFiberInitialListener() {\n\t\t            renderDispatch.callOnFiberInitial(newFiberNode);\n\t\t        },\n\t\t    });\n\t\t    if (exclude(newFiberNode.patch, PATCH_TYPE.__update__)) {\n\t\t        newFiberNode.memoizedProps = newFiberNode.pendingProps;\n\t\t    }\n\t\t    return newFiberNode;\n\t\t};\n\n\t\tvar updateFiberNode = function (renderDispatch, _a, nextElement) {\n\t\t    var fiber = _a.fiber, parent = _a.parent, prevFiber = _a.prevFiber;\n\t\t    var prevElementType = fiber.elementType;\n\t\t    var prevProps = fiber.memoizedProps;\n\t\t    var prevRef = fiber.ref;\n\t\t    fiber.parent = parent;\n\t\t    fiber.sibling = null;\n\t\t    parent.child = parent.child || fiber;\n\t\t    nextElement = fiber._installElement(nextElement);\n\t\t    var nextElementType = fiber.elementType;\n\t\t    var nextProps = fiber.pendingProps;\n\t\t    var nextRef = fiber.ref;\n\t\t    if (prevElementType !== nextElementType || prevProps !== nextProps) {\n\t\t        if (include(fiber.type, exports.NODE_TYPE.__memo__)) {\n\t\t            var typedElement = nextElement;\n\t\t            var typedElementType = typedElement.type;\n\t\t            var compare = typedElementType.compare || isNormalEquals;\n\t\t            if (exclude(fiber.state, STATE_TYPE.__triggerSync__ | STATE_TYPE.__triggerConcurrent__ | STATE_TYPE.__triggerSyncForce__ | STATE_TYPE.__triggerConcurrentForce__) &&\n\t\t                compare(fiber.pendingProps, fiber.memoizedProps)) {\n\t\t                fiber.state = STATE_TYPE.__stable__;\n\t\t            }\n\t\t            else {\n\t\t                fiber.state = remove(fiber.state, STATE_TYPE.__stable__);\n\t\t                fiber.state = merge(fiber.state, STATE_TYPE.__inherit__);\n\t\t            }\n\t\t        }\n\t\t        else {\n\t\t            fiber.state = remove(fiber.state, STATE_TYPE.__stable__);\n\t\t            fiber.state = merge(fiber.state, STATE_TYPE.__inherit__);\n\t\t        }\n\t\t    }\n\t\t    if (fiber.state !== STATE_TYPE.__stable__) {\n\t\t        if (include(fiber.type, exports.NODE_TYPE.__plain__)) {\n\t\t            if (!isNormalEquals(fiber.pendingProps, fiber.memoizedProps, function (key) { return key === \"children\"; })) {\n\t\t                renderDispatch.pendingUpdate(fiber);\n\t\t            }\n\t\t        }\n\t\t        if (include(fiber.type, exports.NODE_TYPE.__text__)) {\n\t\t            renderDispatch.pendingUpdate(fiber);\n\t\t        }\n\t\t    }\n\t\t    if (prevRef !== nextRef) {\n\t\t        renderDispatch.pendingRef(fiber);\n\t\t    }\n\t\t    if (fiber !== prevFiber) {\n\t\t        renderDispatch.pendingPosition(fiber);\n\t\t    }\n\t\t    // if (exclude(fiber.patch, PATCH_TYPE.__update__)) {\n\t\t    //   fiber.memoizedProps = fiber.pendingProps;\n\t\t    // }\n\t\t    return fiber;\n\t\t};\n\n\t\t// no need to resolve map for this fiber, this code only used for fiberRoot init\n\t\tvar initialFiberNode = function (renderDispatch, fiber) {\n\t\t    fiberToDispatchMap.set(fiber, renderDispatch);\n\t\t    renderDispatch.pendingCreate(fiber);\n\t\t    renderDispatch.pendingUpdate(fiber);\n\t\t    renderDispatch.pendingAppend(fiber);\n\t\t    renderDispatch.pendingRef(fiber);\n\t\t    safeCallWithCurrentFiber({\n\t\t        fiber: fiber,\n\t\t        action: function safeCallPatchToFiberInitial() {\n\t\t            var _a;\n\t\t            (_a = renderDispatch.patchToFiberInitial) === null || _a === void 0 ? void 0 : _a.call(renderDispatch, fiber);\n\t\t        },\n\t\t    });\n\t\t    safeCallWithCurrentFiber({\n\t\t        fiber: fiber,\n\t\t        action: function safeCallFiberInitialListener() {\n\t\t            renderDispatch.callOnFiberInitial(fiber);\n\t\t        },\n\t\t    });\n\t\t    if (exclude(fiber.patch, PATCH_TYPE.__update__)) {\n\t\t        fiber.memoizedProps = fiber.pendingProps;\n\t\t    }\n\t\t    return fiber;\n\t\t};\n\n\t\tvar enableDebugFiled$4 = react.__my_react_shared__.enableDebugFiled;\n\t\tvar unmountFiberNode = function (renderDispatch, fiber) {\n\t\t    if (include(fiber.state, STATE_TYPE.__unmount__))\n\t\t        return;\n\t\t    hookListUnmount(renderDispatch, fiber);\n\t\t    processClassComponentUnmount(renderDispatch, fiber);\n\t\t    unmountInstance(fiber.instance);\n\t\t    safeCallWithCurrentFiber({\n\t\t        fiber: fiber,\n\t\t        action: function safeCallCommitUnsetRef() {\n\t\t            renderDispatch.commitUnsetRef(fiber);\n\t\t        },\n\t\t    });\n\t\t    safeCallWithCurrentFiber({\n\t\t        fiber: fiber,\n\t\t        action: function safeCallCommitClear() {\n\t\t            renderDispatch.commitClear(fiber);\n\t\t        },\n\t\t    });\n\t\t    safeCallWithCurrentFiber({\n\t\t        fiber: fiber,\n\t\t        action: function safeCallPatchToFiberUnmount() {\n\t\t            var _a;\n\t\t            (_a = renderDispatch.patchToFiberUnmount) === null || _a === void 0 ? void 0 : _a.call(renderDispatch, fiber);\n\t\t        },\n\t\t    });\n\t\t    safeCallWithCurrentFiber({\n\t\t        fiber: fiber,\n\t\t        action: function safeCallFiberUnmountListener() {\n\t\t            renderDispatch.callOnFiberUnmount(fiber);\n\t\t        },\n\t\t    });\n\t\t    renderDispatch.runtimeMap.insertionEffectMap.delete(fiber);\n\t\t    renderDispatch.runtimeMap.effectMap.delete(fiber);\n\t\t    renderDispatch.runtimeMap.layoutEffectMap.delete(fiber);\n\t\t    renderDispatch.runtimeMap.unmountMap.delete(fiber);\n\t\t    renderDispatch.runtimeMap.eventMap.delete(fiber);\n\t\t    renderDispatch.runtimeMap.triggerCallbackMap.delete(fiber);\n\t\t    if (Boolean(true) === false) {\n\t\t        // fiber.child = null;\n\t\t        // fiber.parent = null;\n\t\t        // fiber.sibling = null;\n\t\t        fiber.instance = null;\n\t\t        fiber.hookList = null;\n\t\t        fiber.dependence = null;\n\t\t        fiber.nativeNode = null;\n\t\t        fiber.updateQueue = null;\n\t\t    }\n\t\t    fiber.patch = PATCH_TYPE.__initial__;\n\t\t    fiber.state = STATE_TYPE.__unmount__;\n\t\t    if (enableDebugFiled$4.current) {\n\t\t        var typedFiber = fiber;\n\t\t        typedFiber._debugIsMount = false;\n\t\t        delete typedFiber._debugStrict;\n\t\t        delete typedFiber._debugEventMap;\n\t\t        delete typedFiber._debugUpdateQueue;\n\t\t    }\n\t\t};\n\n\t\tvar enableDebugFiled$3 = react.__my_react_shared__.enableDebugFiled;\n\t\tvar getIsSameTypeNode = function (newChild, draftFiber) {\n\t\t    if (!draftFiber)\n\t\t        return false;\n\t\t    var result = checkIsSameType(draftFiber, newChild);\n\t\t    return result;\n\t\t};\n\t\tvar getExistingChildren = function (parentFiber) {\n\t\t    var existingChildrenMap = new Map();\n\t\t    var existingChildrenArray = [];\n\t\t    var child = parentFiber.child;\n\t\t    var index = 0;\n\t\t    while (child) {\n\t\t        var key = typeof child.key === \"string\" ? child.key : index;\n\t\t        var existingChild = existingChildrenMap.get(key) || new ListTree();\n\t\t        existingChild.push(child);\n\t\t        existingChildrenMap.set(key, existingChild);\n\t\t        existingChildrenArray.push(child);\n\t\t        child = child.sibling;\n\t\t        index++;\n\t\t    }\n\t\t    return { existingChildrenMap: existingChildrenMap, existingChildrenArray: existingChildrenArray };\n\t\t};\n\t\tvar dynamicFragmentProps = { wrap: true };\n\t\tvar createFragmentWithInitial = function (renderDispatch, newChild, parentFiber) {\n\t\t    // TODO make there are not a element\n\t\t    var newElement = react.createElement(Fragment, dynamicFragmentProps, newChild);\n\t\t    var newFiber = createFiberNode(renderDispatch, { parent: parentFiber }, newElement);\n\t\t    return newFiber;\n\t\t};\n\t\tvar createFragmentWithUpdate = function (renderDispatch, newChild, parentFiber) {\n\t\t    var newElement = react.createElement(Fragment, dynamicFragmentProps, newChild);\n\t\t    var newFiber = createFiberNode(renderDispatch, { parent: parentFiber, type: \"position\" }, newElement);\n\t\t    return newFiber;\n\t\t};\n\t\tvar deleteIfNeed = function (renderDispatch, parentFiber, existingChildren) {\n\t\t    if (existingChildren.size) {\n\t\t        existingChildren.forEach(function forEachInvokePendingUnmountList(list) {\n\t\t            list.listToFoot(function invokePendingUnmountList(f) {\n\t\t                renderDispatch.pendingUnmount(parentFiber, f);\n\t\t            });\n\t\t        });\n\t\t        renderDispatch.generateChangedList(parentFiber, true);\n\t\t    }\n\t\t};\n\t\tvar getNewFiberWithUpdate = function (renderDispatch, newChild, parentFiber, existingChildren, prevFiberChild, index) {\n\t\t    if (Array.isArray(newChild)) {\n\t\t        var draftList_1 = existingChildren.get(index);\n\t\t        // TODO try to get the same type node?\n\t\t        var draftFiber_1 = draftList_1 === null || draftList_1 === void 0 ? void 0 : draftList_1.shift();\n\t\t        if (draftList_1 && !draftList_1.length) {\n\t\t            existingChildren.delete(index);\n\t\t        }\n\t\t        // same type\n\t\t        if (include(draftFiber_1 === null || draftFiber_1 === void 0 ? void 0 : draftFiber_1.type, exports.NODE_TYPE.__fragment__)) {\n\t\t            var newElement = react.createElement(Fragment, dynamicFragmentProps, newChild);\n\t\t            draftFiber_1 !== prevFiberChild && renderDispatch.generateChangedList(parentFiber);\n\t\t            return updateFiberNode(renderDispatch, { fiber: draftFiber_1, parent: parentFiber, prevFiber: prevFiberChild }, newElement);\n\t\t        }\n\t\t        else {\n\t\t            draftFiber_1 && renderDispatch.generateChangedList(parentFiber);\n\t\t            draftFiber_1 && renderDispatch.pendingUnmount(parentFiber, draftFiber_1);\n\t\t            return createFragmentWithUpdate(renderDispatch, newChild, parentFiber);\n\t\t        }\n\t\t    }\n\t\t    var keyToGet = react.isValidElement(newChild) && typeof newChild.key === \"string\" ? newChild.key : index;\n\t\t    var draftList = existingChildren.get(keyToGet);\n\t\t    var draftFiber = draftList === null || draftList === void 0 ? void 0 : draftList.shift();\n\t\t    if (draftList && !draftList.length) {\n\t\t        existingChildren.delete(keyToGet);\n\t\t    }\n\t\t    var isSameType = getIsSameTypeNode(newChild, draftFiber);\n\t\t    if (isSameType) {\n\t\t        draftFiber !== prevFiberChild && renderDispatch.generateChangedList(parentFiber);\n\t\t        return updateFiberNode(renderDispatch, { fiber: draftFiber, parent: parentFiber, prevFiber: prevFiberChild }, newChild);\n\t\t    }\n\t\t    else {\n\t\t        draftFiber && renderDispatch.pendingUnmount(parentFiber, draftFiber);\n\t\t        draftFiber && renderDispatch.generateChangedList(parentFiber);\n\t\t        return createFiberNode(renderDispatch, { parent: parentFiber, type: \"position\" }, newChild);\n\t\t    }\n\t\t};\n\t\tvar getNewFiberWithInitial = function (renderDispatch, newChild, parentFiber) {\n\t\t    // wrapper array child item as a Fragment fiber node, so all of the children will be a fiber node\n\t\t    // and could be add to the child list\n\t\t    if (Array.isArray(newChild))\n\t\t        return createFragmentWithInitial(renderDispatch, newChild, parentFiber);\n\t\t    return createFiberNode(renderDispatch, { parent: parentFiber }, newChild);\n\t\t};\n\t\tvar transformChildrenFiber = function (renderDispatch, parentFiber, children) {\n\t\t    var isUpdate = exclude(parentFiber.state, STATE_TYPE.__create__);\n\t\t    var isHMR = include(parentFiber.state, STATE_TYPE.__hmr__);\n\t\t    var isRetrigger = include(parentFiber.state, STATE_TYPE.__retrigger__);\n\t\t    var isSuspense = include(parentFiber.state, STATE_TYPE.__suspense__);\n\t\t    // if current is retrigger update, skip update children\n\t\t    if (isRetrigger)\n\t\t        return;\n\t\t    // if current is suspense, skip update children\n\t\t    if (isSuspense)\n\t\t        return;\n\t\t    if (isUpdate || isHMR) {\n\t\t        var _a = getExistingChildren(parentFiber), existingChildrenMap = _a.existingChildrenMap, existingChildrenArray = _a.existingChildrenArray;\n\t\t        parentFiber.child = null;\n\t\t        var typedParentFiber = parentFiber;\n\t\t        if (enableDebugFiled$3.current) {\n\t\t            typedParentFiber._debugRenderChildrenCurrent && (typedParentFiber._debugRenderChildrenPrevious = typedParentFiber._debugRenderChildrenCurrent);\n\t\t            typedParentFiber._debugRenderChildrenCurrent = [];\n\t\t        }\n\t\t        if (Array.isArray(children)) {\n\t\t            var newChildren = children;\n\t\t            var index = 0;\n\t\t            var lastFiber = null;\n\t\t            while (index < newChildren.length) {\n\t\t                var newChild = newChildren[index];\n\t\t                var newFiber = getNewFiberWithUpdate(renderDispatch, newChild, parentFiber, existingChildrenMap, existingChildrenArray[index] || null, index);\n\t\t                lastFiber && (lastFiber.sibling = newFiber);\n\t\t                lastFiber = newFiber;\n\t\t                if (enableDebugFiled$3.current)\n\t\t                    typedParentFiber._debugRenderChildrenCurrent.push(newChild);\n\t\t                index++;\n\t\t            }\n\t\t        }\n\t\t        else {\n\t\t            getNewFiberWithUpdate(renderDispatch, children, parentFiber, existingChildrenMap, existingChildrenArray[0], 0);\n\t\t            if (enableDebugFiled$3.current)\n\t\t                typedParentFiber._debugRenderChildrenCurrent.push(children);\n\t\t        }\n\t\t        deleteIfNeed(renderDispatch, parentFiber, existingChildrenMap);\n\t\t    }\n\t\t    else {\n\t\t        renderDispatch.generateChangedList(parentFiber);\n\t\t        var existingChildrenMap = getExistingChildren(parentFiber).existingChildrenMap;\n\t\t        deleteIfNeed(renderDispatch, parentFiber, existingChildrenMap);\n\t\t        var typedParentFiber = parentFiber;\n\t\t        if (enableDebugFiled$3.current) {\n\t\t            typedParentFiber._debugRenderChildrenCurrent && (typedParentFiber._debugRenderChildrenPrevious = typedParentFiber._debugRenderChildrenCurrent);\n\t\t            typedParentFiber._debugRenderChildrenCurrent = [];\n\t\t        }\n\t\t        parentFiber.child = null;\n\t\t        if (Array.isArray(children)) {\n\t\t            var newChildren = children;\n\t\t            var lastFiber = null;\n\t\t            var index = 0;\n\t\t            while (index < newChildren.length) {\n\t\t                var newChild = newChildren[index];\n\t\t                var newFiber = getNewFiberWithInitial(renderDispatch, newChild, parentFiber);\n\t\t                lastFiber && (lastFiber.sibling = newFiber);\n\t\t                lastFiber = newFiber;\n\t\t                if (enableDebugFiled$3.current)\n\t\t                    typedParentFiber._debugRenderChildrenCurrent.push(newChild);\n\t\t                index++;\n\t\t            }\n\t\t        }\n\t\t        else {\n\t\t            getNewFiberWithInitial(renderDispatch, children, parentFiber);\n\t\t            if (enableDebugFiled$3.current)\n\t\t                typedParentFiber._debugRenderChildrenCurrent.push(children);\n\t\t        }\n\t\t    }\n\t\t};\n\n\t\t// TODO\n\t\tvar processActivity = function (fiber) {\n\t\t    var props = fiber.pendingProps;\n\t\t    if (props.mode === \"visible\")\n\t\t        return props.children;\n\t\t    return null;\n\t\t};\n\n\t\tvar currentComponentFiber$2 = react.__my_react_internal__.currentComponentFiber, MyReactInternalInstance$3 = react.__my_react_internal__.MyReactInternalInstance;\n\t\tvar processProvider = function (renderDispatch, fiber) {\n\t\t    if (renderDispatch.isAppMounted) {\n\t\t        var prevProps = fiber.memoizedProps.value;\n\t\t        var nextProps = fiber.pendingProps.value;\n\t\t        if (!isNormalEquals(prevProps, nextProps)) {\n\t\t            prepareUpdateAllDependence(renderDispatch, fiber, prevProps, nextProps);\n\t\t        }\n\t\t    }\n\t\t};\n\t\tvar processConsumer = function (renderDispatch, fiber) {\n\t\t    var typedElementType = fiber.elementType;\n\t\t    var isUpdate = !!fiber.instance;\n\t\t    fiber.instance = fiber.instance || new MyReactInternalInstance$3();\n\t\t    !isUpdate && initInstance(fiber.instance);\n\t\t    !isUpdate && setOwnerForInstance(fiber.instance, fiber);\n\t\t    var Context = typedElementType.Context;\n\t\t    currentComponentFiber$2.current = fiber;\n\t\t    var contextFiber = getInstanceContextFiber(fiber.instance);\n\t\t    var finalContext = null;\n\t\t    if (!contextFiber || include(contextFiber.state, STATE_TYPE.__unmount__)) {\n\t\t        var providerFiber = renderDispatch.resolveContextFiber(fiber, Context);\n\t\t        var context = renderDispatch.resolveContextValue(providerFiber, Context);\n\t\t        finalContext = context;\n\t\t        setContextForInstance(fiber.instance, providerFiber);\n\t\t    }\n\t\t    else {\n\t\t        var context = renderDispatch.resolveContextValue(contextFiber, Context);\n\t\t        finalContext = context;\n\t\t    }\n\t\t    var typedChildren = fiber.pendingProps.children;\n\t\t    var children = safeCallWithCurrentFiber({\n\t\t        fiber: fiber,\n\t\t        action: function safeCallConsumerChildren() {\n\t\t            return typedChildren(finalContext);\n\t\t        },\n\t\t    });\n\t\t    currentComponentFiber$2.current = null;\n\t\t    return children;\n\t\t};\n\n\t\tvar currentHookTreeNode = react.__my_react_internal__.currentHookTreeNode, currentHookNodeIndex$1 = react.__my_react_internal__.currentHookNodeIndex, currentScheduler$4 = react.__my_react_internal__.currentScheduler;\n\t\tvar triggerState = STATE_TYPE.__triggerSync__ |\n\t\t    STATE_TYPE.__triggerSyncForce__ |\n\t\t    STATE_TYPE.__triggerConcurrent__ |\n\t\t    STATE_TYPE.__triggerConcurrentForce__ |\n\t\t    STATE_TYPE.__retrigger__;\n\t\tvar processFunction = function (fiber) {\n\t\t    var _a;\n\t\t    currentHookTreeNode.current = (_a = fiber.hookList) === null || _a === void 0 ? void 0 : _a.head;\n\t\t    currentHookNodeIndex$1.current = 0;\n\t\t    var typedElementType = fiber.elementType;\n\t\t    var children = null;\n\t\t    if (include(fiber.type, exports.NODE_TYPE.__forwardRef__)) {\n\t\t        var typedElementTypeWithRef_1 = typedElementType;\n\t\t        children = safeCallWithCurrentFiber({\n\t\t            fiber: fiber,\n\t\t            action: function safeCallForwardRefFunctionalComponent() {\n\t\t                var _a, _b, _c, _d;\n\t\t                var re = undefined;\n\t\t                try {\n\t\t                    re = typedElementTypeWithRef_1(fiber.pendingProps, fiber.ref);\n\t\t                }\n\t\t                catch (e) {\n\t\t                    if (isPromise(e)) {\n\t\t                        var currentIsTrigger = include(fiber.state, triggerState);\n\t\t                        if (currentIsTrigger) {\n\t\t                            re = (_b = (_a = currentScheduler$4.current) === null || _a === void 0 ? void 0 : _a.dispatchSuspensePromise) === null || _b === void 0 ? void 0 : _b.call(_a, { fiber: fiber, promise: e });\n\t\t                        }\n\t\t                        else {\n\t\t                            re = (_d = (_c = currentScheduler$4.current) === null || _c === void 0 ? void 0 : _c.dispatchPromise) === null || _d === void 0 ? void 0 : _d.call(_c, { fiber: fiber, promise: e });\n\t\t                        }\n\t\t                    }\n\t\t                    else {\n\t\t                        throw e;\n\t\t                    }\n\t\t                }\n\t\t                return re;\n\t\t            },\n\t\t        });\n\t\t    }\n\t\t    else {\n\t\t        children = safeCallWithCurrentFiber({\n\t\t            fiber: fiber,\n\t\t            action: function safeCallFunctionalComponent() {\n\t\t                var _a, _b, _c, _d;\n\t\t                var re = undefined;\n\t\t                try {\n\t\t                    re = typedElementType(fiber.pendingProps);\n\t\t                }\n\t\t                catch (e) {\n\t\t                    if (isPromise(e)) {\n\t\t                        var currentIsTrigger = include(fiber.state, triggerState);\n\t\t                        if (currentIsTrigger) {\n\t\t                            re = (_b = (_a = currentScheduler$4.current) === null || _a === void 0 ? void 0 : _a.dispatchSuspensePromise) === null || _b === void 0 ? void 0 : _b.call(_a, { fiber: fiber, promise: e });\n\t\t                        }\n\t\t                        else {\n\t\t                            re = (_d = (_c = currentScheduler$4.current) === null || _c === void 0 ? void 0 : _c.dispatchPromise) === null || _d === void 0 ? void 0 : _d.call(_c, { fiber: fiber, promise: e });\n\t\t                        }\n\t\t                    }\n\t\t                    else {\n\t\t                        throw e;\n\t\t                    }\n\t\t                }\n\t\t                return re;\n\t\t            },\n\t\t        });\n\t\t    }\n\t\t    currentHookNodeIndex$1.current = 0;\n\t\t    currentHookTreeNode.current = null;\n\t\t    return children;\n\t\t};\n\n\t\tvar WrapperByLazyScope = function (children) { return react.createElement(ScopeLazy, null, children); };\n\t\tvar WrapperBySuspenseScope = function (children) {\n\t\t    return react.createElement(ScopeSuspense, null, react.createElement(Comment, { mode: \"s\" }), children, react.createElement(Comment, { mode: \"e\" }));\n\t\t};\n\t\tvar isCommentElement = function (fiber) { return include(fiber.type, exports.NODE_TYPE.__comment__); };\n\t\tvar isCommentStartElement = function (fiber) {\n\t\t    if (isCommentElement(fiber)) {\n\t\t        return fiber.pendingProps[\"mode\"] === \"s\";\n\t\t    }\n\t\t    return false;\n\t\t};\n\t\tvar isCommentEndElement = function (fiber) {\n\t\t    if (isCommentElement(fiber)) {\n\t\t        return fiber.pendingProps[\"mode\"] === \"e\";\n\t\t    }\n\t\t    return false;\n\t\t};\n\n\t\tvar enableSuspenseRoot$1 = react.__my_react_shared__.enableSuspenseRoot;\n\t\tvar currentScheduler$3 = react.__my_react_internal__.currentScheduler;\n\t\tvar loadLazy = function (renderDispatch, typedElementType) { return __awaiter(void 0, void 0, void 0, function () {\n\t\t    var loadedPromise, loaded, render, e_1;\n\t\t    return __generator(this, function (_a) {\n\t\t        switch (_a.label) {\n\t\t            case 0:\n\t\t                if (typedElementType._loaded)\n\t\t                    return [2 /*return*/];\n\t\t                _a.label = 1;\n\t\t            case 1:\n\t\t                _a.trys.push([1, 3, 4, 5]);\n\t\t                typedElementType._loading = true;\n\t\t                loadedPromise = typedElementType.loader();\n\t\t                if (!isPromise(loadedPromise)) {\n\t\t                    console.warn(\"[@my-react/react] lazy() must return a promise, but got\", loadedPromise);\n\t\t                }\n\t\t                return [4 /*yield*/, Promise.resolve(loadedPromise)];\n\t\t            case 2:\n\t\t                loaded = _a.sent();\n\t\t                render = typeof loaded === \"object\" && (typeof (loaded === null || loaded === void 0 ? void 0 : loaded.default) === \"function\" || typeof (loaded === null || loaded === void 0 ? void 0 : loaded.default) === \"object\") ? loaded.default : loaded;\n\t\t                typedElementType.render = render;\n\t\t                return [3 /*break*/, 5];\n\t\t            case 3:\n\t\t                e_1 = _a.sent();\n\t\t                typedElementType._error = e_1;\n\t\t                return [3 /*break*/, 5];\n\t\t            case 4:\n\t\t                typedElementType._loaded = true;\n\t\t                typedElementType._loading = false;\n\t\t                return [7 /*endfinally*/];\n\t\t            case 5: return [2 /*return*/];\n\t\t        }\n\t\t    });\n\t\t}); };\n\t\tvar processLazy = function (renderDispatch, fiber) {\n\t\t    var _a, _b;\n\t\t    var typedElementType = fiber.elementType;\n\t\t    if (typedElementType._error) {\n\t\t        (_b = (_a = currentScheduler$3.current).dispatchError) === null || _b === void 0 ? void 0 : _b.call(_a, { fiber: fiber, error: typedElementType._error });\n\t\t        return null;\n\t\t    }\n\t\t    if (typedElementType._loaded === true) {\n\t\t        var render = typedElementType.render;\n\t\t        return WrapperByLazyScope(react.createElement(render, fiber.pendingProps));\n\t\t    }\n\t\t    typedElementType._list = typedElementType._list || new Set();\n\t\t    typedElementType._list.add(fiber);\n\t\t    var suspenseFiber = renderDispatch.resolveSuspenseFiber(fiber);\n\t\t    if (suspenseFiber) {\n\t\t        var suspenseField = getInstanceFieldByInstance(suspenseFiber.instance);\n\t\t        suspenseField.asyncLoadList.uniPush(typedElementType);\n\t\t        renderDispatch.pendingSuspenseFiberArray.uniPush(suspenseFiber);\n\t\t        return null;\n\t\t    }\n\t\t    else {\n\t\t        // TODO update flow\n\t\t        if (enableSuspenseRoot$1.current && !renderDispatch.isAppMounted) {\n\t\t            var suspenseField = getInstanceFieldByInstance(renderDispatch);\n\t\t            suspenseField.asyncLoadList.uniPush(typedElementType);\n\t\t            return null;\n\t\t        }\n\t\t        devWarnWithFiber(fiber, \"[@my-react/react] lazy() must be used inside a Suspense component, otherwise it will not work as expected\");\n\t\t        if (typedElementType._loading)\n\t\t            return null;\n\t\t        typedElementType._loading = true;\n\t\t        var renderScheduler_1 = currentScheduler$3.current;\n\t\t        renderDispatch.processLazy(typedElementType).then(function () {\n\t\t            fiber.state = STATE_TYPE.__recreate__;\n\t\t            typedElementType._list.delete(fiber);\n\t\t            var updater = {\n\t\t                type: UpdateQueueType.lazy,\n\t\t                trigger: fiber,\n\t\t                isSync: true,\n\t\t                isForce: true,\n\t\t                payLoad: typedElementType,\n\t\t            };\n\t\t            renderScheduler_1.dispatchState(updater);\n\t\t        });\n\t\t        return null;\n\t\t    }\n\t\t};\n\n\t\tvar initSuspenseInstance = function (instance) {\n\t\t    var field = getInstanceFieldByInstance(instance);\n\t\t    if (!field)\n\t\t        throw new Error(\"[@my-react/react] can not get field for instance, this is a bug for @my-react\");\n\t\t    var typedField = field;\n\t\t    typedField.isHidden = false;\n\t\t    typedField.asyncLoadList = new UniqueArray();\n\t\t};\n\n\t\tvar MyReactInternalInstance$2 = react.__my_react_internal__.MyReactInternalInstance;\n\t\tvar processSuspense = function (fiber) {\n\t\t    var isUpdate = !!fiber.instance;\n\t\t    fiber.instance = fiber.instance || new MyReactInternalInstance$2();\n\t\t    !isUpdate && initInstance(fiber.instance);\n\t\t    !isUpdate && initVisibleInstance(fiber.instance);\n\t\t    !isUpdate && initSuspenseInstance(fiber.instance);\n\t\t    !isUpdate && setOwnerForInstance(fiber.instance, fiber);\n\t\t    var instanceField = getInstanceFieldByInstance(fiber.instance);\n\t\t    var children = WrapperBySuspenseScope(instanceField.isHidden ? fiber.pendingProps.fallback : fiber.pendingProps.children);\n\t\t    return children;\n\t\t};\n\n\t\tvar MyReactInternalInstanceClass$1 = react.__my_react_internal__.MyReactInternalInstance, instanceToInitialFieldMap = react.__my_react_internal__.instanceToInitialFieldMap;\n\t\t// support private instance field\n\t\tvar instanceMap = instanceToInitialFieldMap;\n\t\tvar initInstance = function (instance) {\n\t\t    var exist = instanceMap.get(instance);\n\t\t    if (exist)\n\t\t        return exist;\n\t\t    var field = {\n\t\t        _owner: null,\n\t\t        _context: null,\n\t\t        _subscribe: null,\n\t\t        effect: Effect_TYPE.__initial__,\n\t\t    };\n\t\t    instanceMap.set(instance, field);\n\t\t    return field;\n\t\t};\n\t\tvar initVisibleInstance = function (instance) {\n\t\t    var field = getInstanceFieldByInstance(instance);\n\t\t    if (!field)\n\t\t        throw new Error(\"[@my-react/react] can not get field for instance, this is a bug for @my-react\");\n\t\t    var typedField = field;\n\t\t    typedField.isHidden = false;\n\t\t};\n\t\tvar setOwnerForInstance = function (instance, fiber, instanceField) {\n\t\t    var field = instanceField || instanceMap.get(instance);\n\t\t    instance._reactInternals = fiber;\n\t\t    // unmount instance\n\t\t    if (!field)\n\t\t        return;\n\t\t    field._owner = fiber;\n\t\t};\n\t\tvar setContextForInstance = function (instance, fiber, instanceField) {\n\t\t    var _a, _b;\n\t\t    var field = instanceField || instanceMap.get(instance);\n\t\t    // unmount instance\n\t\t    if (!field)\n\t\t        return;\n\t\t    (_a = field._context) === null || _a === void 0 ? void 0 : _a._delDependence(instance);\n\t\t    field._context = fiber;\n\t\t    (_b = field._context) === null || _b === void 0 ? void 0 : _b._addDependence(instance);\n\t\t};\n\t\tvar setSubscribeForInstance = function (instance, fiber, instanceField) {\n\t\t    var field = instanceField || instanceMap.get(instance);\n\t\t    // unmount instance\n\t\t    if (!field)\n\t\t        return;\n\t\t    if (!field._subscribe) {\n\t\t        field._subscribe = new Set();\n\t\t    }\n\t\t    if (fiber) {\n\t\t        field._subscribe.add(fiber);\n\t\t        fiber._addDependence(instance);\n\t\t    }\n\t\t};\n\t\tvar setEffectForInstance = function (instance, effect, instanceField) {\n\t\t    var field = instanceField || instanceMap.get(instance);\n\t\t    // unmount instance\n\t\t    if (!field)\n\t\t        return;\n\t\t    field.effect = effect;\n\t\t};\n\t\tvar unmountInstance = function (instance) {\n\t\t    var _a, _b, _c;\n\t\t    if (!instance || !instance.isMyReactInstance)\n\t\t        return;\n\t\t    var field = instanceMap.get(instance);\n\t\t    if (!field)\n\t\t        return;\n\t\t    (_a = field._context) === null || _a === void 0 ? void 0 : _a._delDependence(instance);\n\t\t    field.effect = Effect_TYPE.__unmount__;\n\t\t    field._owner = null;\n\t\t    field._context = null;\n\t\t    (_c = (_b = field._subscribe) === null || _b === void 0 ? void 0 : _b.forEach) === null || _c === void 0 ? void 0 : _c.call(_b, function (fiber) {\n\t\t        var _a;\n\t\t        (_a = fiber === null || fiber === void 0 ? void 0 : fiber._delDependence) === null || _a === void 0 ? void 0 : _a.call(fiber, instance);\n\t\t    });\n\t\t    instanceMap.delete(instance);\n\t\t};\n\t\tvar getInstanceFieldByInstance = function (instance) {\n\t\t    var field = instanceMap.get(instance);\n\t\t    if (!field)\n\t\t        throw new Error(\"[@my-react/react] instance not found, look like a bug for @my-react\");\n\t\t    return field;\n\t\t};\n\t\tvar getInstanceOwnerFiber = function (instance) {\n\t\t    var typedInstance = instance;\n\t\t    if (typedInstance.isMyReactInstance) {\n\t\t        var field = instanceMap.get(typedInstance);\n\t\t        return field === null || field === void 0 ? void 0 : field._owner;\n\t\t    }\n\t\t    else {\n\t\t        if (checkIsMyReactFiberNode(instance)) {\n\t\t            return instance;\n\t\t        }\n\t\t        throw new Error(\"instance is not a MyReactInternalInstance or MyReactFiberNode\");\n\t\t    }\n\t\t};\n\t\tvar getInstanceContextFiber = function (instance) {\n\t\t    var field = instanceMap.get(instance);\n\t\t    return field === null || field === void 0 ? void 0 : field._context;\n\t\t};\n\t\tvar getInstanceEffectState = function (instance) {\n\t\t    var field = instanceMap.get(instance);\n\t\t    return field === null || field === void 0 ? void 0 : field.effect;\n\t\t};\n\t\t{\n\t\t    Object.defineProperty(MyReactInternalInstanceClass$1.prototype, \"_debugField\", {\n\t\t        get: function () {\n\t\t            return instanceMap.get(this);\n\t\t        },\n\t\t        configurable: true,\n\t\t    });\n\t\t}\n\n\t\tvar currentComponentFiber$1 = react.__my_react_internal__.currentComponentFiber, MyReactInternalInstance$1 = react.__my_react_internal__.MyReactInternalInstance;\n\t\tvar enablePerformanceLog = react.__my_react_shared__.enablePerformanceLog, enableDebugFiled$2 = react.__my_react_shared__.enableDebugFiled;\n\t\tvar nextWorkCommon = function (renderDispatch, fiber, children) {\n\t\t    if (isPromise(children)) {\n\t\t        console.error(\"[@my-react/react] render function should not return a promise, please check your code\");\n\t\t    }\n\t\t    if (exclude(fiber.patch, PATCH_TYPE.__update__)) {\n\t\t        fiber.memoizedProps = fiber.pendingProps;\n\t\t    }\n\t\t    safeCallWithCurrentFiber({\n\t\t        fiber: fiber,\n\t\t        action: function safeCallTransformChildrenFiber() {\n\t\t            transformChildrenFiber(renderDispatch, fiber, children);\n\t\t        },\n\t\t    });\n\t\t};\n\t\tvar nextWorkNormal = function (renderDispatch, fiber) {\n\t\t    if (\"children\" in fiber.pendingProps ||\n\t\t        \"children\" in fiber.memoizedProps ||\n\t\t        \"dangerouslySetInnerHTML\" in fiber.pendingProps ||\n\t\t        \"dangerouslySetInnerHTML\" in fiber.memoizedProps) {\n\t\t        var children = fiber.pendingProps.children;\n\t\t        nextWorkCommon(renderDispatch, fiber, children);\n\t\t    }\n\t\t};\n\t\tvar nextWorkClassComponent = function (renderDispatch, fiber) {\n\t\t    if (!fiber.instance) {\n\t\t        var children = processClassComponentMount(renderDispatch, fiber);\n\t\t        nextWorkCommon(renderDispatch, fiber, children);\n\t\t    }\n\t\t    else {\n\t\t        var field = getClassInstanceFieldByInstance(fiber.instance);\n\t\t        if (!field.isMounted)\n\t\t            return;\n\t\t        var _a = processClassComponentUpdate(renderDispatch, fiber), updated = _a.updated, children = _a.children;\n\t\t        if (updated)\n\t\t            nextWorkCommon(renderDispatch, fiber, children);\n\t\t    }\n\t\t};\n\t\tvar nextWorkFunctionComponent = function (renderDispatch, fiber) {\n\t\t    var children = processFunction(fiber);\n\t\t    nextWorkCommon(renderDispatch, fiber, children);\n\t\t};\n\t\tvar nextWorkComponent = function (renderDispatch, fiber) {\n\t\t    if (include(fiber.type, exports.NODE_TYPE.__function__)) {\n\t\t        currentComponentFiber$1.current = fiber;\n\t\t        nextWorkFunctionComponent(renderDispatch, fiber);\n\t\t        currentComponentFiber$1.current = null;\n\t\t    }\n\t\t    else {\n\t\t        currentComponentFiber$1.current = fiber;\n\t\t        nextWorkClassComponent(renderDispatch, fiber);\n\t\t        currentComponentFiber$1.current = null;\n\t\t    }\n\t\t};\n\t\tvar nextWorkLazy = function (renderDispatch, fiber) {\n\t\t    var children = processLazy(renderDispatch, fiber);\n\t\t    nextWorkCommon(renderDispatch, fiber, children);\n\t\t};\n\t\tvar nextWorkSuspense = function (renderDispatch, fiber) {\n\t\t    var children = processSuspense(fiber);\n\t\t    nextWorkCommon(renderDispatch, fiber, children);\n\t\t};\n\t\tvar nextWorkProvider = function (renderDispatch, fiber) {\n\t\t    processProvider(renderDispatch, fiber);\n\t\t    nextWorkNormal(renderDispatch, fiber);\n\t\t};\n\t\tvar nextWorkConsumer = function (renderDispatch, fiber) {\n\t\t    var children = processConsumer(renderDispatch, fiber);\n\t\t    nextWorkCommon(renderDispatch, fiber, children);\n\t\t};\n\t\tvar nextWorkActivity = function (renderDispatch, fiber) {\n\t\t    var children = processActivity(fiber);\n\t\t    nextWorkCommon(renderDispatch, fiber, children);\n\t\t};\n\t\tvar nextWorkRoot = function (renderDispatch, fiber) {\n\t\t    var isUpdate = !!fiber.instance;\n\t\t    fiber.instance = fiber.instance || new MyReactInternalInstance$1();\n\t\t    !isUpdate && initInstance(fiber.instance);\n\t\t    !isUpdate && initVisibleInstance(fiber.instance);\n\t\t    !isUpdate && setOwnerForInstance(fiber.instance, fiber);\n\t\t    var instanceField = getInstanceFieldByInstance(fiber.instance);\n\t\t    if (instanceField.isHidden) {\n\t\t        nextWorkCommon(renderDispatch, fiber, null);\n\t\t    }\n\t\t    else {\n\t\t        nextWorkNormal(renderDispatch, fiber);\n\t\t    }\n\t\t};\n\t\tvar runtimeNextWork = function (renderDispatch, fiber) {\n\t\t    renderDispatch.dispatchFiber(fiber);\n\t\t};\n\t\tvar runtimeNextWorkDev = function (renderDispatch, fiber) {\n\t\t    safeCallWithCurrentFiber({\n\t\t        fiber: fiber,\n\t\t        action: function safeCallFiberRunListener() {\n\t\t            renderDispatch.callOnBeforeFiberRun(fiber);\n\t\t        },\n\t\t    });\n\t\t    setRefreshTypeMap(fiber);\n\t\t    var typedFiber = fiber;\n\t\t    var start = Date.now();\n\t\t    runtimeNextWork(renderDispatch, fiber);\n\t\t    var end = Date.now();\n\t\t    var renderTime = end - start;\n\t\t    var hasPerformanceWarn = renderTime > renderDispatch.performanceLogTimeLimit;\n\t\t    if (enablePerformanceLog.current && hasPerformanceWarn) {\n\t\t        onceWarnWithKeyAndFiber(fiber, \"performance\", \"[@my-react/react] render current component take a lot of time, there have a performance warning\");\n\t\t    }\n\t\t    if (hasPerformanceWarn) {\n\t\t        safeCallWithCurrentFiber({\n\t\t            fiber: fiber,\n\t\t            action: function safeCallPerformanceWarnListener() {\n\t\t                renderDispatch.callOnPerformanceWarn(fiber, renderTime);\n\t\t            },\n\t\t        });\n\t\t    }\n\t\t    var timeNow = end;\n\t\t    if (enableDebugFiled$2.current) {\n\t\t        if (typedFiber.state === STATE_TYPE.__create__) {\n\t\t            typedFiber._debugRenderState = {\n\t\t                mountTimeStep: timeNow,\n\t\t                timeForRender: renderTime,\n\t\t                maxTimeForRender: renderTime,\n\t\t            };\n\t\t            typedFiber._debugIsMount = true;\n\t\t        }\n\t\t        else {\n\t\t            var prevRenderState = Object.assign({}, typedFiber._debugRenderState);\n\t\t            var prevRenderTime = prevRenderState.updateTimeStep || prevRenderState.mountTimeStep;\n\t\t            typedFiber._debugRenderState = {\n\t\t                renderCount: (prevRenderState.renderCount || 0) + 1,\n\t\t                mountTimeStep: prevRenderState.mountTimeStep,\n\t\t                updateTimeStep: timeNow,\n\t\t                trigger: currentTriggerFiber.current,\n\t\t                timeForRender: renderTime,\n\t\t                timeForUpdate: timeNow - prevRenderTime,\n\t\t                maxTimeForRender: Math.max(prevRenderState.maxTimeForRender, renderTime),\n\t\t            };\n\t\t        }\n\t\t    }\n\t\t    safeCallWithCurrentFiber({\n\t\t        fiber: fiber,\n\t\t        action: function safeCallFiberRunListener() {\n\t\t            renderDispatch.callOnAfterFiberRun(fiber);\n\t\t        },\n\t\t    });\n\t\t};\n\n\t\tvar enableDebugFiled$1 = react.__my_react_shared__.enableDebugFiled;\n\t\tvar currentRunningFiber = react.__my_react_internal__.currentRunningFiber, MyReactInternalInstance = react.__my_react_internal__.MyReactInternalInstance;\n\t\tvar defaultGetContextValue = function (fiber, ContextObject) {\n\t\t    var _a;\n\t\t    if (fiber) {\n\t\t        return fiber.pendingProps[\"value\"];\n\t\t    }\n\t\t    else {\n\t\t        return (_a = ContextObject === null || ContextObject === void 0 ? void 0 : ContextObject.Provider) === null || _a === void 0 ? void 0 : _a[\"value\"];\n\t\t    }\n\t\t};\n\t\tvar defaultGetContextFiber = function (fiber, ContextObject) {\n\t\t    if ((fiber === null || fiber === void 0 ? void 0 : fiber.parent) && ContextObject) {\n\t\t        var parent_1 = fiber.parent;\n\t\t        while (parent_1) {\n\t\t            if (include(parent_1.type, exports.NODE_TYPE.__provider__)) {\n\t\t                var typedElementType = parent_1.elementType;\n\t\t                var contextObj = typedElementType[\"Context\"];\n\t\t                if (contextObj === ContextObject) {\n\t\t                    return parent_1;\n\t\t                }\n\t\t            }\n\t\t            if (include(parent_1.type, exports.NODE_TYPE.__context__)) {\n\t\t                var typedElementType = parent_1.elementType;\n\t\t                var contextObj = typedElementType;\n\t\t                if (contextObj === ContextObject) {\n\t\t                    return parent_1;\n\t\t                }\n\t\t            }\n\t\t            parent_1 = parent_1.parent;\n\t\t        }\n\t\t    }\n\t\t    else {\n\t\t        return null;\n\t\t    }\n\t\t};\n\t\tvar defaultReadContext = function (Context) {\n\t\t    var fiber = currentRunningFiber.current;\n\t\t    if (!Context) {\n\t\t        throw new Error(\"the Context what you read is not exist\");\n\t\t    }\n\t\t    if (!fiber) {\n\t\t        throw new Error('current environment is not support \"readContext\"');\n\t\t    }\n\t\t    var isUpdate = !!fiber.instance;\n\t\t    fiber.instance = fiber.instance || new MyReactInternalInstance();\n\t\t    !isUpdate && initInstance(fiber.instance);\n\t\t    !isUpdate && setOwnerForInstance(fiber.instance, fiber);\n\t\t    var contextFiber = defaultGetContextFiber(fiber, Context);\n\t\t    setSubscribeForInstance(fiber.instance, contextFiber);\n\t\t    return defaultGetContextValue(contextFiber, Context);\n\t\t};\n\t\tvar prepareUpdateAllDependence = function (renderDispatch, fiber, beforeValue, afterValue) {\n\t\t    var consumerList = new Set((fiber === null || fiber === void 0 ? void 0 : fiber.dependence) || []);\n\t\t    consumerList.forEach(function prepareUpdateSingleConsumer(i) {\n\t\t        var owner = getInstanceOwnerFiber(i);\n\t\t        if (owner && exclude(owner.state, STATE_TYPE.__unmount__)) {\n\t\t            var typedFiber_1 = owner;\n\t\t            typedFiber_1.state = STATE_TYPE.__triggerSyncForce__;\n\t\t        }\n\t\t    });\n\t\t    var typedFiber = fiber;\n\t\t    var processedNodes = [];\n\t\t    var updater = {\n\t\t        type: UpdateQueueType.context,\n\t\t        trigger: fiber,\n\t\t        payLoad: afterValue,\n\t\t        isSync: true,\n\t\t        isForce: true,\n\t\t        isImmediate: true,\n\t\t        isRetrigger: true,\n\t\t    };\n\t\t    if (enableDebugFiled$1.current) {\n\t\t        var now = Date.now();\n\t\t        updater._debugBeforeValue = beforeValue;\n\t\t        updater._debugAfterValue = afterValue;\n\t\t        updater._debugCreateTime = now;\n\t\t        updater._debugRunTime = now;\n\t\t        updater._debugType = UpdateQueueType[UpdateQueueType.context];\n\t\t        if (enableDebugUpdateQueue.current) {\n\t\t            typedFiber._debugUpdateQueue = typedFiber._debugUpdateQueue || new ListTree();\n\t\t            typedFiber._debugUpdateQueue.push(updater);\n\t\t        }\n\t\t    }\n\t\t    processedNodes.push(updater);\n\t\t    var updateState = {\n\t\t        needUpdate: true,\n\t\t        nodes: processedNodes,\n\t\t        isSync: true,\n\t\t        isForce: true,\n\t\t        isImmediate: true,\n\t\t        isRetrigger: true,\n\t\t    };\n\t\t    safeCallWithCurrentFiber({\n\t\t        fiber: fiber,\n\t\t        action: function safeCallFiberTriggerListener() {\n\t\t            renderDispatch.callOnFiberTrigger(fiber, updateState);\n\t\t        },\n\t\t    });\n\t\t};\n\n\t\tvar currentScheduler$2 = react.__my_react_internal__.currentScheduler;\n\t\tvar enableScopeTreeLog$2 = react.__my_react_shared__.enableScopeTreeLog;\n\t\t// TODO improve\n\t\tvar defaultDispatchMountLatest = function (_dispatch, _fiber) {\n\t\t    beforeSyncUpdate();\n\t\t    var _list = generateFiberToListWithAction(_fiber, function invokeUnmountPendingList(_fiber) {\n\t\t        defaultInvokeUnmountList(_dispatch, _fiber);\n\t\t    });\n\t\t    _list.listToFoot(function invokeInsertionEffectList(_fiber) {\n\t\t        insertionEffect(_dispatch, _fiber);\n\t\t    });\n\t\t    afterSyncUpdate();\n\t\t    _list.listToFoot(function invokeCreateAndUpdateList(_fiber) {\n\t\t        safeCallWithCurrentFiber({\n\t\t            fiber: _fiber,\n\t\t            action: function safeCallCreateAndUpdate() {\n\t\t                _dispatch.commitCreate(_fiber);\n\t\t                _dispatch.commitUpdate(_fiber);\n\t\t            },\n\t\t        });\n\t\t    });\n\t\t    _list.listToFoot(function invokeAppendList(_fiber) {\n\t\t        safeCallWithCurrentFiber({\n\t\t            fiber: _fiber,\n\t\t            action: function safeCallAppendList() {\n\t\t                _dispatch.commitAppend(_fiber);\n\t\t            },\n\t\t        });\n\t\t    });\n\t\t    _list.listToFoot(function invokeSetRefList(_fiber) {\n\t\t        safeCallWithCurrentFiber({\n\t\t            fiber: _fiber,\n\t\t            action: function safeCallSetRefList() {\n\t\t                _dispatch.commitSetRef(_fiber);\n\t\t            },\n\t\t        });\n\t\t    });\n\t\t    beforeSyncUpdate();\n\t\t    _list.listToFoot(function invokeLayoutEffectList(_fiber) {\n\t\t        layoutEffect(_dispatch, _fiber);\n\t\t    });\n\t\t    afterSyncUpdate();\n\t\t    function invokeEffectListTask() {\n\t\t        enableScopeTreeLog$2.current && setLogScope();\n\t\t        _list.listToFoot(function invokeEffectList(_fiber) {\n\t\t            effect(_dispatch, _fiber);\n\t\t        });\n\t\t        enableScopeTreeLog$2.current && resetLogScope();\n\t\t    }\n\t\t    addEffectCallback(invokeEffectListTask);\n\t\t    var renderScheduler = currentScheduler$2.current;\n\t\t    if (_dispatch.enableConcurrentMode) {\n\t\t        renderScheduler.macroTask(function flushEffect() {\n\t\t            flushEffectCallback();\n\t\t        });\n\t\t    }\n\t\t    else {\n\t\t        renderScheduler.microTask(function flushEffect() {\n\t\t            flushEffectCallback();\n\t\t        });\n\t\t    }\n\t\t};\n\t\tvar defaultDispatchMount = defaultDispatchMountLatest;\n\n\t\tvar defaultResolveScope = function (fiber) {\n\t\t    var parent = fiber.parent;\n\t\t    while (parent) {\n\t\t        if (include(parent.type, exports.NODE_TYPE.__scope__) || include(parent.type, exports.NODE_TYPE.__scopeSuspense__)) {\n\t\t            return parent;\n\t\t        }\n\t\t        parent = parent.parent;\n\t\t    }\n\t\t    return null;\n\t\t};\n\n\t\tvar enableDebugFiled = react.__my_react_shared__.enableDebugFiled;\n\t\tvar defaultGenerateStrict = function (fiber) {\n\t\t    {\n\t\t        var parent_1 = fiber.parent;\n\t\t        var isStrict = false;\n\t\t        var typedParent = parent_1;\n\t\t        if (parent_1) {\n\t\t            if (include(parent_1.type, exports.NODE_TYPE.__strict__)) {\n\t\t                isStrict = true;\n\t\t            }\n\t\t            if (typedParent._debugStrict) {\n\t\t                isStrict = true;\n\t\t            }\n\t\t        }\n\t\t        if (enableDebugFiled.current) {\n\t\t            var typedFiber = fiber;\n\t\t            typedFiber._debugStrict = isStrict;\n\t\t        }\n\t\t        return isStrict;\n\t\t    }\n\t\t};\n\n\t\tvar currentScheduler$1 = react.__my_react_internal__.currentScheduler;\n\t\tvar enableScopeTreeLog$1 = react.__my_react_shared__.enableScopeTreeLog;\n\t\tvar defaultDispatchUpdate = function (_dispatch, _list, sync) {\n\t\t    // TODO maybe need call `insertionEffect` in another function\n\t\t    beforeSyncUpdate();\n\t\t    _list.listToFoot(function invokeUnmountPendingAndInsertionEffectList(_fiber) {\n\t\t        if (exclude(_fiber.state, STATE_TYPE.__unmount__) && !_dispatch.isAppUnmounted) {\n\t\t            defaultInvokeUnmountList(_dispatch, _fiber);\n\t\t        }\n\t\t    });\n\t\t    _list.listToFoot(function invokeUnmountPendingAndInsertionEffectList(_fiber) {\n\t\t        if (exclude(_fiber.state, STATE_TYPE.__unmount__) && !_dispatch.isAppUnmounted) {\n\t\t            insertionEffect(_dispatch, _fiber);\n\t\t        }\n\t\t    });\n\t\t    afterSyncUpdate();\n\t\t    _list.listToFoot(function invokeCreateAndUpdateList(_fiber) {\n\t\t        if (exclude(_fiber.state, STATE_TYPE.__unmount__) && !_dispatch.isAppUnmounted) {\n\t\t            safeCallWithCurrentFiber({\n\t\t                fiber: _fiber,\n\t\t                action: function safeCallCreateAndUpdate() {\n\t\t                    _dispatch.commitCreate(_fiber);\n\t\t                    _dispatch.commitUpdate(_fiber);\n\t\t                },\n\t\t            });\n\t\t        }\n\t\t    });\n\t\t    _list.listToHead(function invokePositionList(_fiber) {\n\t\t        if (exclude(_fiber.state, STATE_TYPE.__unmount__) && !_dispatch.isAppUnmounted) {\n\t\t            safeCallWithCurrentFiber({\n\t\t                fiber: _fiber,\n\t\t                action: function safeCallPosition() {\n\t\t                    _dispatch.commitPosition(_fiber);\n\t\t                },\n\t\t            });\n\t\t        }\n\t\t    });\n\t\t    _list.listToFoot(function invokeAppendList(_fiber) {\n\t\t        if (exclude(_fiber.state, STATE_TYPE.__unmount__) && !_dispatch.isAppUnmounted) {\n\t\t            safeCallWithCurrentFiber({\n\t\t                fiber: _fiber,\n\t\t                action: function safeCallAppendList() {\n\t\t                    _dispatch.commitAppend(_fiber);\n\t\t                },\n\t\t            });\n\t\t        }\n\t\t    });\n\t\t    _list.listToFoot(function invokeSetRefList(_fiber) {\n\t\t        if (exclude(_fiber.state, STATE_TYPE.__unmount__) && !_dispatch.isAppUnmounted) {\n\t\t            safeCallWithCurrentFiber({\n\t\t                fiber: _fiber,\n\t\t                action: function safeCallSetRefList() {\n\t\t                    _dispatch.commitSetRef(_fiber);\n\t\t                },\n\t\t            });\n\t\t        }\n\t\t    });\n\t\t    beforeSyncUpdate();\n\t\t    _list.listToFoot(function invokeLayoutEffectList(_fiber) {\n\t\t        if (exclude(_fiber.state, STATE_TYPE.__unmount__) && !_dispatch.isAppUnmounted) {\n\t\t            layoutEffect(_dispatch, _fiber);\n\t\t        }\n\t\t    });\n\t\t    afterSyncUpdate();\n\t\t    function invokeEffectListTask() {\n\t\t        enableScopeTreeLog$1.current && setLogScope();\n\t\t        _list.listToFoot(function invokeEffectList(_fiber) {\n\t\t            if (exclude(_fiber.state, STATE_TYPE.__unmount__) && !_dispatch.isAppUnmounted) {\n\t\t                effect(_dispatch, _fiber);\n\t\t            }\n\t\t        });\n\t\t        enableScopeTreeLog$1.current && resetLogScope();\n\t\t    }\n\t\t    addEffectCallback(invokeEffectListTask);\n\t\t    var renderScheduler = currentScheduler$1.current;\n\t\t    if (_dispatch.enableConcurrentMode && !sync) {\n\t\t        renderScheduler.macroTask(function flushEffect() {\n\t\t            flushEffectCallback();\n\t\t        });\n\t\t    }\n\t\t    else {\n\t\t        renderScheduler.microTask(function flushEffect() {\n\t\t            flushEffectCallback();\n\t\t        });\n\t\t    }\n\t\t};\n\n\t\tvar currentComponentFiber = react.__my_react_internal__.currentComponentFiber, currentHookNodeIndex = react.__my_react_internal__.currentHookNodeIndex;\n\t\tvar resolveHookValue = function (hookNode, field) {\n\t\t    if (hookNode) {\n\t\t        switch (hookNode.type) {\n\t\t            case HOOK_TYPE.useState:\n\t\t            case HOOK_TYPE.useReducer:\n\t\t                return [hookNode.result, field.dispatch];\n\t\t            case HOOK_TYPE.useId:\n\t\t            case HOOK_TYPE.useRef:\n\t\t            case HOOK_TYPE.useMemo:\n\t\t            case HOOK_TYPE.useContext:\n\t\t            case HOOK_TYPE.useCallback:\n\t\t            case HOOK_TYPE.useDeferredValue:\n\t\t            case HOOK_TYPE.useSyncExternalStore:\n\t\t            case HOOK_TYPE.useEffectEvent:\n\t\t                return hookNode.result;\n\t\t            case HOOK_TYPE.useOptimistic:\n\t\t            case HOOK_TYPE.useTransition:\n\t\t                return [hookNode.result.value, hookNode.result.start];\n\t\t            case HOOK_TYPE.useSignal:\n\t\t                return [hookNode.result.getValue, hookNode.result.setValue];\n\t\t        }\n\t\t    }\n\t\t};\n\t\tvar processHook = function (renderDispatch, _a) {\n\t\t    var type = _a.type, reducer = _a.reducer, value = _a.value, deps = _a.deps;\n\t\t    var fiber = currentComponentFiber.current;\n\t\t    if (!fiber)\n\t\t        throw new Error(\"[@my-react/react] can not use hook outside of component\");\n\t\t    if (!renderDispatch)\n\t\t        throw new Error(\"[@my-react/react] internal error, can not get 'renderDispatch' for current render\");\n\t\t    fiber.hookList = fiber.hookList || new ListTree();\n\t\t    var currentHook = null;\n\t\t    // initial\n\t\t    if (include(fiber.state, STATE_TYPE.__create__ | STATE_TYPE.__recreate__)) {\n\t\t        currentHook = createHookNode(renderDispatch, { type: type, reducer: reducer, value: value, deps: deps }, fiber);\n\t\t        safeCall(function safeCallHookInitialListener() {\n\t\t            renderDispatch.callOnHookInitial(currentHook, fiber);\n\t\t        });\n\t\t    }\n\t\t    else {\n\t\t        // update\n\t\t        currentHook = updateHookNode(renderDispatch, { type: type, reducer: reducer, value: value, deps: deps }, fiber, Boolean(include(fiber.state, STATE_TYPE.__hmr__)));\n\t\t        safeCall(function safeCallHookUpdateListener() {\n\t\t            renderDispatch.callOnHookUpdate(currentHook, fiber);\n\t\t        });\n\t\t    }\n\t\t    currentHookNodeIndex.current++;\n\t\t    var field = getInstanceFieldByInstance(currentHook);\n\t\t    effectHookNode(renderDispatch, fiber, currentHook, field);\n\t\t    return resolveHookValue(currentHook, field);\n\t\t};\n\n\t\tvar enableSuspenseRoot = react.__my_react_shared__.enableSuspenseRoot;\n\t\tvar currentScheduler = react.__my_react_internal__.currentScheduler;\n\t\tvar loadPromise = function (renderDispatch, promise) { return __awaiter(void 0, void 0, void 0, function () {\n\t\t    var value, reason_1;\n\t\t    return __generator(this, function (_a) {\n\t\t        switch (_a.label) {\n\t\t            case 0:\n\t\t                if (promise.status === \"fulfilled\" || promise.status === \"rejected\")\n\t\t                    return [2 /*return*/];\n\t\t                _a.label = 1;\n\t\t            case 1:\n\t\t                _a.trys.push([1, 3, , 4]);\n\t\t                promise.status = \"pending\";\n\t\t                return [4 /*yield*/, Promise.resolve(promise)];\n\t\t            case 2:\n\t\t                value = _a.sent();\n\t\t                promise.status = \"fulfilled\";\n\t\t                promise._value = value;\n\t\t                return [3 /*break*/, 4];\n\t\t            case 3:\n\t\t                reason_1 = _a.sent();\n\t\t                promise.status = \"rejected\";\n\t\t                promise._reason = reason_1;\n\t\t                return [3 /*break*/, 4];\n\t\t            case 4: return [2 /*return*/];\n\t\t        }\n\t\t    });\n\t\t}); };\n\t\tvar processPromise = function (renderDispatch, fiber, promise) {\n\t\t    var _a, _b;\n\t\t    defaultDeleteCurrentEffect(renderDispatch, fiber);\n\t\t    if (promise.status === \"rejected\") {\n\t\t        (_b = (_a = currentScheduler.current).dispatchError) === null || _b === void 0 ? void 0 : _b.call(_a, { fiber: fiber, error: promise._reason });\n\t\t        return null;\n\t\t    }\n\t\t    if (promise.status === \"fulfilled\") {\n\t\t        {\n\t\t            console.warn(\"[@my-react/react] throw a promise what has already fulfilled, this is not a valid usage\");\n\t\t        }\n\t\t    }\n\t\t    promise._list = promise._list || new Set();\n\t\t    promise._list.add(fiber);\n\t\t    var suspenseFiber = renderDispatch.resolveSuspenseFiber(fiber);\n\t\t    if (suspenseFiber) {\n\t\t        var suspenseField = getInstanceFieldByInstance(suspenseFiber.instance);\n\t\t        suspenseField.asyncLoadList.uniPush(promise);\n\t\t        renderDispatch.pendingSuspenseFiberArray.uniPush(suspenseFiber);\n\t\t        return null;\n\t\t    }\n\t\t    else {\n\t\t        // TODO update flow\n\t\t        if (enableSuspenseRoot.current && !renderDispatch.isAppMounted) {\n\t\t            var suspenseField = getInstanceFieldByInstance(renderDispatch);\n\t\t            suspenseField.asyncLoadList.uniPush(promise);\n\t\t            return null;\n\t\t        }\n\t\t        devWarnWithFiber(fiber, \"[@my-react/react] promise must be used inside a Suspense component, otherwise it will not work as expected\");\n\t\t        if (promise._loading)\n\t\t            return null;\n\t\t        promise._loading = true;\n\t\t        promise.status = \"pending\";\n\t\t        var renderScheduler_1 = currentScheduler.current;\n\t\t        renderDispatch\n\t\t            .processPromise(promise)\n\t\t            .then(function () {\n\t\t            fiber.state = STATE_TYPE.__recreate__;\n\t\t            promise._list.delete(fiber);\n\t\t            promise._loading = false;\n\t\t            var updater = {\n\t\t                type: UpdateQueueType.promise,\n\t\t                trigger: fiber,\n\t\t                isSync: true,\n\t\t                isForce: true,\n\t\t                payLoad: promise,\n\t\t            };\n\t\t            renderScheduler_1.dispatchState(updater);\n\t\t        })\n\t\t            .catch(function (e) { return renderScheduler_1.dispatchError({ fiber: fiber, error: e }); });\n\t\t        return null;\n\t\t    }\n\t\t};\n\t\tvar processSuspensePromise = function (renderDispatch, fiber, promise) {\n\t\t    var _a, _b;\n\t\t    defaultDeleteCurrentEffect(renderDispatch, fiber);\n\t\t    fiber.state = STATE_TYPE.__suspense__;\n\t\t    if (promise.status === \"rejected\") {\n\t\t        (_b = (_a = currentScheduler.current).dispatchError) === null || _b === void 0 ? void 0 : _b.call(_a, { fiber: fiber, error: promise._reason });\n\t\t        return null;\n\t\t    }\n\t\t    if (promise.status === \"fulfilled\") {\n\t\t        {\n\t\t            console.warn(\"[@my-react/react] throw a promise what has already fulfilled, this is not a valid usage\");\n\t\t        }\n\t\t    }\n\t\t    promise._list = promise._list || new Set();\n\t\t    promise._list.add(fiber);\n\t\t    if (promise._loading)\n\t\t        return null;\n\t\t    promise._loading = true;\n\t\t    promise.status = \"pending\";\n\t\t    var renderScheduler = currentScheduler.current;\n\t\t    renderDispatch\n\t\t        .processPromise(promise)\n\t\t        .then(function () {\n\t\t        fiber.state = STATE_TYPE.__recreate__;\n\t\t        promise._list.delete(fiber);\n\t\t        promise._loading = false;\n\t\t        var updater = {\n\t\t            type: UpdateQueueType.promise,\n\t\t            trigger: fiber,\n\t\t            isSync: true,\n\t\t            isForce: true,\n\t\t            payLoad: promise,\n\t\t        };\n\t\t        renderScheduler.dispatchState(updater);\n\t\t    })\n\t\t        .catch(function (e) { return renderScheduler.dispatchError({ fiber: fiber, error: e }); });\n\t\t    return null;\n\t\t};\n\n\t\tvar Dispatcher = react.__my_react_internal__.Dispatcher, MyReactInternalInstanceClass = react.__my_react_internal__.MyReactInternalInstance, dispatchToListenerMap = react.__my_react_internal__.dispatchToListenerMap;\n\t\tvar getInitialListeners = function () {\n\t\t    return {\n\t\t            fiberInitial: new Set(),\n\t\t            fiberUpdate: new Set(),\n\t\t            fiberHasChange: new Set(),\n\t\t            fiberUnmount: new Set(),\n\t\t            fiberHMR: new Set(),\n\t\t            beforeFiberRun: new Set(),\n\t\t            afterFiberRun: new Set(),\n\t\t            afterFiberDone: new Set(),\n\t\t            beforeDispatchRender: new Set(),\n\t\t            afterDispatchRender: new Set(),\n\t\t            beforeDispatchUpdate: new Set(),\n\t\t            afterDispatchUpdate: new Set(),\n\t\t            fiberWarn: new Set(),\n\t\t            fiberError: new Set(),\n\t\t            fiberState: new Set(),\n\t\t            fiberTrigger: new Set(),\n\t\t            performanceWarn: new Set(),\n\t\t            instanceInitial: new Set(),\n\t\t            instanceUpdate: new Set(),\n\t\t            instanceState: new Set(),\n\t\t            instanceUnmount: new Set(),\n\t\t            hookInitial: new Set(),\n\t\t            hookUpdate: new Set(),\n\t\t            hookState: new Set(),\n\t\t            hookUnmount: new Set(),\n\t\t            beforeCommitMount: new Set(),\n\t\t            afterCommitMount: new Set(),\n\t\t            beforeCommitUpdate: new Set(),\n\t\t            afterCommitUpdate: new Set(),\n\t\t            beforeCommitUnmount: new Set(),\n\t\t            afterCommitUnmount: new Set(),\n\t\t        }\n\t\t        ;\n\t\t};\n\t\tvar getInitialMap = function () { return ({\n\t\t    effectMap: new MyWeakMap(),\n\t\t    layoutEffectMap: new MyWeakMap(),\n\t\t    insertionEffectMap: new MyWeakMap(),\n\t\t    unmountMap: new MyWeakMap(),\n\t\t    eventMap: new MyWeakMap(),\n\t\t    triggerCallbackMap: new MyWeakMap(),\n\t\t}); };\n\t\tvar getInitialFiber = function () { return ({\n\t\t    scheduledFiber: null,\n\t\t    errorCatchFiber: null,\n\t\t    nextWorkingFiber: null,\n\t\t    retriggerFiber: null,\n\t\t}); };\n\t\tvar initialRef = {\n\t\t    typeForRef: exports.NODE_TYPE.__plain__ | exports.NODE_TYPE.__class__,\n\t\t    typeForCreate: exports.NODE_TYPE.__text__ | exports.NODE_TYPE.__plain__ | exports.NODE_TYPE.__portal__ | exports.NODE_TYPE.__comment__,\n\t\t    typeForUpdate: exports.NODE_TYPE.__text__ | exports.NODE_TYPE.__plain__ | exports.NODE_TYPE.__comment__,\n\t\t    typeForAppend: exports.NODE_TYPE.__text__ | exports.NODE_TYPE.__plain__ | exports.NODE_TYPE.__comment__,\n\t\t    typeForNativeNode: exports.NODE_TYPE.__text__ | exports.NODE_TYPE.__plain__ | exports.NODE_TYPE.__portal__ | exports.NODE_TYPE.__comment__,\n\t\t};\n\t\tvar listenerMap = dispatchToListenerMap;\n\t\tvar RenderDispatchEvent = /** @class */ (function (_super) {\n\t\t    __extends(RenderDispatchEvent, _super);\n\t\t    function RenderDispatchEvent() {\n\t\t        var _this = _super.call(this) || this;\n\t\t        _this.dispatcher = Dispatcher;\n\t\t        _this.runtimeRef = initialRef;\n\t\t        _this.runtimeMap = getInitialMap();\n\t\t        _this.runtimeFiber = getInitialFiber();\n\t\t        listenerMap.set(_this, getInitialListeners());\n\t\t        initInstance(_this);\n\t\t        initVisibleInstance(_this);\n\t\t        initSuspenseInstance(_this);\n\t\t        Object.defineProperty(_this, \"dispatcher\", {\n\t\t            value: Dispatcher,\n\t\t            writable: false,\n\t\t            enumerable: false,\n\t\t            configurable: false,\n\t\t        });\n\t\t        return _this;\n\t\t    }\n\t\t    RenderDispatchEvent.prototype.getFiberTree = function (_fiber) {\n\t\t        throw new Error(\"Method not implemented.\");\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.readPromise = function (_params) {\n\t\t        throw new Error(\"Method not implemented.\");\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.readContext = function (_params) {\n\t\t        throw new Error(\"Method not implemented.\");\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.dispatchHook = function (_params) {\n\t\t        throw new Error(\"Method not implemented.\");\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.dispatchState = function (_params) {\n\t\t        throw new Error(\"Method not implemented.\");\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.dispatchError = function (_params) {\n\t\t        throw new Error(\"Method not implemented.\");\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.dispatchPromise = function (_params) {\n\t\t        throw new Error(\"Method not implemented.\");\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.dispatchSuspensePromise = function (_params) {\n\t\t        throw new Error(\"Method not implemented.\");\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.trigger = function (_fiber, _state, cb) {\n\t\t        return triggerUpdateOnFiber(_fiber, _state, cb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.generateCommitList = function (_fiber) { };\n\t\t    RenderDispatchEvent.prototype.pendingCreate = function (_fiber) { };\n\t\t    RenderDispatchEvent.prototype.pendingUpdate = function (_fiber) { };\n\t\t    RenderDispatchEvent.prototype.pendingAppend = function (_fiber) { };\n\t\t    RenderDispatchEvent.prototype.pendingPosition = function (_fiber) { };\n\t\t    RenderDispatchEvent.prototype.pendingRef = function (_fiber) { };\n\t\t    RenderDispatchEvent.prototype.pendingUnmount = function (_fiber, _pendingUnmount) { };\n\t\t    RenderDispatchEvent.prototype.pendingEffect = function (_fiber, _effect, _option) { };\n\t\t    RenderDispatchEvent.prototype.pendingLayoutEffect = function (_fiber, _layoutEffect, _option) { };\n\t\t    RenderDispatchEvent.prototype.pendingInsertionEffect = function (_fiber, _insertionEffect, _option) { };\n\t\t    RenderDispatchEvent.prototype.dispatchFiber = function (_fiber) { };\n\t\t    RenderDispatchEvent.prototype.processLazy = function (_elementType) {\n\t\t        return Promise.resolve();\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.processPromise = function (_promise) {\n\t\t        return Promise.resolve();\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.commitCreate = function (_fiber) { };\n\t\t    RenderDispatchEvent.prototype.commitUpdate = function (_fiber) { };\n\t\t    RenderDispatchEvent.prototype.commitAppend = function (_fiber) { };\n\t\t    RenderDispatchEvent.prototype.commitPosition = function (_fiber) { };\n\t\t    RenderDispatchEvent.prototype.commitSetRef = function (_fiber) { };\n\t\t    RenderDispatchEvent.prototype.commitUnsetRef = function (_fiber) { };\n\t\t    RenderDispatchEvent.prototype.commitClear = function (_fiber) { };\n\t\t    RenderDispatchEvent.prototype.resolveStrict = function (_fiber) {\n\t\t        return false;\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.resolveScope = function (_fiber) {\n\t\t        return null;\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.resolveSuspenseValue = function (_fiber) {\n\t\t        return null;\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.resolveSuspenseFiber = function (_fiber) {\n\t\t        return null;\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.resolveErrorBoundaries = function (_fiber) {\n\t\t        return null;\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.resolveContextFiber = function (_fiber, _contextObject) {\n\t\t        return null;\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.resolveContextValue = function (_fiber, _contextObject) {\n\t\t        return null;\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.reconcileCommit = function (_fiber) { };\n\t\t    RenderDispatchEvent.prototype.reconcileUpdate = function (_list) { };\n\t\t    RenderDispatchEvent.prototype.reconcileUnmount = function () { };\n\t\t    RenderDispatchEvent.prototype.shouldYield = function () {\n\t\t        return false;\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.resetYield = function () {\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onFiberInitial = function (cb) {\n\t\t        var set = listenerMap.get(this).fiberInitial;\n\t\t        set.add(cb);\n\t\t        return function () { return set.delete(cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceFiberInitial = function (cb) {\n\t\t        var set = listenerMap.get(this).fiberInitial;\n\t\t        var onceCb = function (_fiber) {\n\t\t            cb(_fiber);\n\t\t            set.delete(onceCb);\n\t\t        };\n\t\t        set.add(onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnFiberInitial = function (_fiber) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).fiberInitial;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(_fiber); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onFiberUpdate = function (cb) {\n\t\t        var set = listenerMap.get(this).fiberUpdate;\n\t\t        set.add(cb);\n\t\t        return function () { return set.delete(cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceFiberUpdate = function (cb) {\n\t\t        var set = listenerMap.get(this).fiberUpdate;\n\t\t        var onceCb = function (_fiber) {\n\t\t            cb(_fiber);\n\t\t            set.delete(onceCb);\n\t\t        };\n\t\t        set.add(onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnFiberUpdate = function (_fiber) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).fiberUpdate;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(_fiber); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onFiberChange = function (cb) {\n\t\t        var set = listenerMap.get(this).fiberHasChange;\n\t\t        set.add(cb);\n\t\t        return function () { return set.delete(cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceFiberChange = function (cb) {\n\t\t        var set = listenerMap.get(this).fiberHasChange;\n\t\t        var onceCb = function (_list) {\n\t\t            cb(_list);\n\t\t            set.delete(onceCb);\n\t\t        };\n\t\t        set.add(onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnFiberChange = function (_list) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).fiberHasChange;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(_list); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onFiberUnmount = function (cb) {\n\t\t        var set = listenerMap.get(this).fiberUnmount;\n\t\t        set.add(cb);\n\t\t        return function () { return set.delete(cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceFiberUnmount = function (cb) {\n\t\t        var set = listenerMap.get(this).fiberUnmount;\n\t\t        var onceCb = function (_fiber) {\n\t\t            cb(_fiber);\n\t\t            set.delete(onceCb);\n\t\t        };\n\t\t        set.add(onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnFiberUnmount = function (_fiber) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).fiberUnmount;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(_fiber); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onFiberState = function (cb) {\n\t\t        var set = listenerMap.get(this).fiberState;\n\t\t        set.add(cb);\n\t\t        return function () { return set.delete(cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceFiberState = function (cb) {\n\t\t        var set = listenerMap.get(this).fiberState;\n\t\t        var onceCb = function (_fiber, _updater) {\n\t\t            cb(_fiber, _updater);\n\t\t            set.delete(onceCb);\n\t\t        };\n\t\t        set.add(onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnFiberState = function (_fiber, _updater) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).fiberState;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(_fiber, _updater); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onFiberTrigger = function (cb) {\n\t\t        var set = listenerMap.get(this).fiberTrigger;\n\t\t        set.add(cb);\n\t\t        return function () { return set.delete(cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceFiberTrigger = function (cb) {\n\t\t        var set = listenerMap.get(this).fiberTrigger;\n\t\t        var onceCb = function (_fiber, _state) {\n\t\t            cb(_fiber, _state);\n\t\t            set.delete(onceCb);\n\t\t        };\n\t\t        set.add(onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnFiberTrigger = function (_fiber, _state) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).fiberTrigger;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(_fiber, _state); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onFiberHMR = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).fiberHMR;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, cb);\n\t\t        return function () { var _a; return (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceFiberHMR = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).fiberHMR;\n\t\t        var onceCb = function (_fiber, _forceRefresh) {\n\t\t            var _a;\n\t\t            cb(_fiber, _forceRefresh);\n\t\t            (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t        };\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnFiberHMR = function (_fiber, _forceRefresh) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).fiberHMR;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(_fiber, _forceRefresh); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onFiberWarn = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).fiberWarn;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, cb);\n\t\t        return function () { var _a; return (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceFiberWarn = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).fiberWarn;\n\t\t        var onceCb = function (_fiber) {\n\t\t            var _a;\n\t\t            cb(_fiber);\n\t\t            (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t        };\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnFiberWarn = function (_fiber) {\n\t\t        var _a;\n\t\t        var args = [];\n\t\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t\t            args[_i - 1] = arguments[_i];\n\t\t        }\n\t\t        var set = listenerMap.get(this).fiberWarn;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb.apply(void 0, __spreadArray([_fiber], args, false)); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onFiberError = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).fiberError;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, cb);\n\t\t        return function () { var _a; return (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceFiberError = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).fiberError;\n\t\t        var onceCb = function (_fiber) {\n\t\t            var _a;\n\t\t            cb(_fiber);\n\t\t            (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t        };\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnFiberError = function (_fiber) {\n\t\t        var _a;\n\t\t        var args = [];\n\t\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t\t            args[_i - 1] = arguments[_i];\n\t\t        }\n\t\t        var set = listenerMap.get(this).fiberError;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb.apply(void 0, __spreadArray([_fiber], args, false)); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onPerformanceWarn = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).performanceWarn;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, cb);\n\t\t        return function () { var _a; return (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.oncePerformanceWarn = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).performanceWarn;\n\t\t        var onceCb = function (_fiber, _renderTime) {\n\t\t            var _a;\n\t\t            cb(_fiber, _renderTime);\n\t\t            (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t        };\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnPerformanceWarn = function (_fiber, _renderTime) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).performanceWarn;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(_fiber, _renderTime); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onBeforeFiberRun = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).beforeFiberRun;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, cb);\n\t\t        return function () { var _a; return (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceBeforeFiberRun = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).beforeFiberRun;\n\t\t        var onceCb = function (_fiber) {\n\t\t            var _a;\n\t\t            cb(_fiber);\n\t\t            (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t        };\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnBeforeFiberRun = function (_fiber) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).beforeFiberRun;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(_fiber); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onAfterFiberRun = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).afterFiberRun;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, cb);\n\t\t        return function () { var _a; return (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceAfterFiberRun = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).afterFiberRun;\n\t\t        var onceCb = function (_fiber) {\n\t\t            var _a;\n\t\t            cb(_fiber);\n\t\t            (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t        };\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnAfterFiberRun = function (_fiber) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).afterFiberRun;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(_fiber); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onAfterFiberDone = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).afterFiberDone;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, cb);\n\t\t        return function () { var _a; return (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceAfterFiberDone = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).afterFiberDone;\n\t\t        var onceCb = function (_fiber) {\n\t\t            var _a;\n\t\t            cb(_fiber);\n\t\t            (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t        };\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnAfterFiberDone = function (_fiber) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).afterFiberDone;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(_fiber); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onBeforeDispatchRender = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).beforeDispatchRender;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, cb);\n\t\t        return function () { var _a; return (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceBeforeDispatchRender = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).beforeDispatchRender;\n\t\t        var onceCb = function (renderDispatch, fiber) {\n\t\t            var _a;\n\t\t            cb(renderDispatch, fiber);\n\t\t            (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t        };\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnBeforeDispatchRender = function (renderDispatch, fiber) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).beforeDispatchRender;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(renderDispatch, fiber); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onAfterDispatchRender = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).afterDispatchRender;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, cb);\n\t\t        return function () { var _a; return (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceAfterDispatchRender = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).afterDispatchRender;\n\t\t        var onceCb = function (renderDispatch) {\n\t\t            var _a;\n\t\t            cb(renderDispatch);\n\t\t            (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t        };\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnAfterDispatchRender = function (renderDispatch) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).afterDispatchRender;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(renderDispatch); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onBeforeDispatchUpdate = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).beforeDispatchUpdate;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, cb);\n\t\t        return function () { var _a; return (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceBeforeDispatchUpdate = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).beforeDispatchUpdate;\n\t\t        var onceCb = function (renderDispatch, list) {\n\t\t            var _a;\n\t\t            cb(renderDispatch, list);\n\t\t            (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t        };\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnBeforeDispatchUpdate = function (renderDispatch, list) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).beforeDispatchUpdate;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(renderDispatch, list); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onAfterDispatchUpdate = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).afterDispatchUpdate;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, cb);\n\t\t        return function () { var _a; return (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceAfterDispatchUpdate = function (cb) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).afterDispatchUpdate;\n\t\t        var onceCb = function (renderDispatch) {\n\t\t            var _a;\n\t\t            cb(renderDispatch);\n\t\t            (_a = set === null || set === void 0 ? void 0 : set.delete) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t        };\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.add) === null || _a === void 0 ? void 0 : _a.call(set, onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnAfterDispatchUpdate = function (renderDispatch) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).afterDispatchUpdate;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(renderDispatch); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onInstanceInitial = function (cb) {\n\t\t        var set = listenerMap.get(this).instanceInitial;\n\t\t        set.add(cb);\n\t\t        return function () { return set.delete(cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceInstanceInitial = function (cb) {\n\t\t        var set = listenerMap.get(this).instanceInitial;\n\t\t        var onceCb = function (_instance, _fiber) {\n\t\t            cb(_instance, _fiber);\n\t\t            set.delete(onceCb);\n\t\t        };\n\t\t        set.add(onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnInstanceInitial = function (_instance, _fiber) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).instanceInitial;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(_instance, _fiber); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onInstanceUpdate = function (cb) {\n\t\t        var set = listenerMap.get(this).instanceUpdate;\n\t\t        set.add(cb);\n\t\t        return function () { return set.delete(cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceInstanceUpdate = function (cb) {\n\t\t        var set = listenerMap.get(this).instanceUpdate;\n\t\t        var onceCb = function (_instance, _fiber) {\n\t\t            cb(_instance, _fiber);\n\t\t            set.delete(onceCb);\n\t\t        };\n\t\t        set.add(onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnInstanceUpdate = function (_instance, _fiber) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).instanceUpdate;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(_instance, _fiber); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onInstanceState = function (cb) {\n\t\t        var set = listenerMap.get(this).instanceState;\n\t\t        set.add(cb);\n\t\t        return function () { return set.delete(cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceInstanceState = function (cb) {\n\t\t        var set = listenerMap.get(this).instanceState;\n\t\t        var onceCb = function (_instance, _fiber, _updater) {\n\t\t            cb(_instance, _fiber, _updater);\n\t\t            set.delete(onceCb);\n\t\t        };\n\t\t        set.add(onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnInstanceState = function (_instance, _fiber, _updater) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).instanceState;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(_instance, _fiber, _updater); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onInstanceUnmount = function (cb) {\n\t\t        var set = listenerMap.get(this).instanceUnmount;\n\t\t        set.add(cb);\n\t\t        return function () { return set.delete(cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceInstanceUnmount = function (cb) {\n\t\t        var set = listenerMap.get(this).instanceUnmount;\n\t\t        var onceCb = function (_instance, _fiber) {\n\t\t            cb(_instance, _fiber);\n\t\t            set.delete(onceCb);\n\t\t        };\n\t\t        set.add(onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnInstanceUnmount = function (_instance, _fiber) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).instanceUnmount;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(_instance, _fiber); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onHookInitial = function (cb) {\n\t\t        var set = listenerMap.get(this).hookInitial;\n\t\t        set.add(cb);\n\t\t        return function () { return set.delete(cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceHookInitial = function (cb) {\n\t\t        var set = listenerMap.get(this).hookInitial;\n\t\t        var onceCb = function (_hook, _fiber) {\n\t\t            cb(_hook, _fiber);\n\t\t            set.delete(onceCb);\n\t\t        };\n\t\t        set.add(onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnHookInitial = function (_hook, _fiber) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).hookInitial;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(_hook, _fiber); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onHookUpdate = function (cb) {\n\t\t        var set = listenerMap.get(this).hookUpdate;\n\t\t        set.add(cb);\n\t\t        return function () { return set.delete(cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceHookUpdate = function (cb) {\n\t\t        var set = listenerMap.get(this).hookUpdate;\n\t\t        var onceCb = function (_hook, _fiber) {\n\t\t            cb(_hook, _fiber);\n\t\t            set.delete(onceCb);\n\t\t        };\n\t\t        set.add(onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnHookUpdate = function (_hook, _fiber) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).hookUpdate;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(_hook, _fiber); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onHookUnmount = function (cb) {\n\t\t        var set = listenerMap.get(this).hookUnmount;\n\t\t        set.add(cb);\n\t\t        return function () { return set.delete(cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceHookUnmount = function (cb) {\n\t\t        var set = listenerMap.get(this).hookUnmount;\n\t\t        var onceCb = function (_hook, _fiber) {\n\t\t            cb(_hook, _fiber);\n\t\t            set.delete(onceCb);\n\t\t        };\n\t\t        set.add(onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnHookUnmount = function (_hook, _fiber) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).hookUnmount;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(_hook, _fiber); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onHookState = function (cb) {\n\t\t        var set = listenerMap.get(this).hookState;\n\t\t        set.add(cb);\n\t\t        return function () { return set.delete(cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceHookTrigger = function (cb) {\n\t\t        var set = listenerMap.get(this).hookState;\n\t\t        var onceCb = function (_hook, _fiber, _updater) {\n\t\t            cb(_hook, _fiber, _updater);\n\t\t            set.delete(onceCb);\n\t\t        };\n\t\t        set.add(onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnHookState = function (_hook, _fiber, _updater) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).hookState;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(_hook, _fiber, _updater); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onBeforeCommitMount = function (cb) {\n\t\t        var set = listenerMap.get(this).beforeCommitMount;\n\t\t        set.add(cb);\n\t\t        return function () { return set.delete(cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceBeforeCommitMount = function (cb) {\n\t\t        var set = listenerMap.get(this).beforeCommitMount;\n\t\t        var onceCb = function (renderDispatch) {\n\t\t            cb(renderDispatch);\n\t\t            set.delete(onceCb);\n\t\t        };\n\t\t        set.add(onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnBeforeCommitMount = function (renderDispatch) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).beforeCommitMount;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(renderDispatch); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onAfterCommitMount = function (cb) {\n\t\t        var set = listenerMap.get(this).afterCommitMount;\n\t\t        set.add(cb);\n\t\t        return function () { return set.delete(cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceAfterCommitMount = function (cb) {\n\t\t        var set = listenerMap.get(this).afterCommitMount;\n\t\t        var onceCb = function (renderDispatch) {\n\t\t            cb(renderDispatch);\n\t\t            set.delete(onceCb);\n\t\t        };\n\t\t        set.add(onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnAfterCommitMount = function (renderDispatch) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).afterCommitMount;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(renderDispatch); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onBeforeCommitUpdate = function (cb) {\n\t\t        var set = listenerMap.get(this).beforeCommitUpdate;\n\t\t        set.add(cb);\n\t\t        return function () { return set.delete(cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceBeforeCommitUpdate = function (cb) {\n\t\t        var set = listenerMap.get(this).beforeCommitUpdate;\n\t\t        var onceCb = function (renderDispatch) {\n\t\t            cb(renderDispatch);\n\t\t            set.delete(onceCb);\n\t\t        };\n\t\t        set.add(onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnBeforeCommitUpdate = function (renderDispatch) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).beforeCommitUpdate;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(renderDispatch); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onAfterCommitUpdate = function (cb) {\n\t\t        var set = listenerMap.get(this).afterCommitUpdate;\n\t\t        set.add(cb);\n\t\t        return function () { return set.delete(cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceAfterCommitUpdate = function (cb) {\n\t\t        var set = listenerMap.get(this).afterCommitUpdate;\n\t\t        var onceCb = function (renderDispatch) {\n\t\t            cb(renderDispatch);\n\t\t            set.delete(onceCb);\n\t\t        };\n\t\t        set.add(onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnAfterCommitUpdate = function (renderDispatch) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).afterCommitUpdate;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(renderDispatch); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onBeforeCommitUnmount = function (cb) {\n\t\t        var set = listenerMap.get(this).beforeCommitUnmount;\n\t\t        set.add(cb);\n\t\t        return function () { return set.delete(cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceBeforeCommitUnmount = function (cb) {\n\t\t        var set = listenerMap.get(this).beforeCommitUnmount;\n\t\t        var onceCb = function (renderDispatch) {\n\t\t            cb(renderDispatch);\n\t\t            set.delete(onceCb);\n\t\t        };\n\t\t        set.add(onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnBeforeCommitUnmount = function (renderDispatch) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).beforeCommitUnmount;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(renderDispatch); });\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onAfterCommitUnmount = function (cb) {\n\t\t        var set = listenerMap.get(this).afterCommitUnmount;\n\t\t        set.add(cb);\n\t\t        return function () { return set.delete(cb); };\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.onceAfterCommitUnmount = function (cb) {\n\t\t        var set = listenerMap.get(this).afterCommitUnmount;\n\t\t        var onceCb = function (renderDispatch) {\n\t\t            cb(renderDispatch);\n\t\t            set.delete(onceCb);\n\t\t        };\n\t\t        set.add(onceCb);\n\t\t    };\n\t\t    RenderDispatchEvent.prototype.callOnAfterCommitUnmount = function (renderDispatch) {\n\t\t        var _a;\n\t\t        var set = listenerMap.get(this).afterCommitUnmount;\n\t\t        (_a = set === null || set === void 0 ? void 0 : set.forEach) === null || _a === void 0 ? void 0 : _a.call(set, function (cb) { return cb(renderDispatch); });\n\t\t    };\n\t\t    return RenderDispatchEvent;\n\t\t}(MyReactInternalInstanceClass));\n\n\t\tvar defaultDispatchFiber = function (renderDispatch, fiber) {\n\t\t    if (include(fiber.type, exports.NODE_TYPE.__root__)) {\n\t\t        // TODO\n\t\t        nextWorkRoot(renderDispatch, fiber);\n\t\t    }\n\t\t    else if (include(fiber.type, exports.NODE_TYPE.__class__ | exports.NODE_TYPE.__function__)) {\n\t\t        nextWorkComponent(renderDispatch, fiber);\n\t\t    }\n\t\t    else if (include(fiber.type, exports.NODE_TYPE.__lazy__)) {\n\t\t        nextWorkLazy(renderDispatch, fiber);\n\t\t    }\n\t\t    else if (include(fiber.type, exports.NODE_TYPE.__suspense__)) {\n\t\t        nextWorkSuspense(renderDispatch, fiber);\n\t\t    }\n\t\t    else if (include(fiber.type, exports.NODE_TYPE.__consumer__)) {\n\t\t        nextWorkConsumer(renderDispatch, fiber);\n\t\t    }\n\t\t    else if (include(fiber.type, exports.NODE_TYPE.__provider__ | exports.NODE_TYPE.__context__)) {\n\t\t        nextWorkProvider(renderDispatch, fiber);\n\t\t    }\n\t\t    else if (include(fiber.type, exports.NODE_TYPE.__activity__)) {\n\t\t        nextWorkActivity(renderDispatch, fiber);\n\t\t    }\n\t\t    else {\n\t\t        nextWorkNormal(renderDispatch, fiber);\n\t\t    }\n\t\t};\n\n\t\tvar CustomRenderDispatch = /** @class */ (function (_super) {\n\t\t    __extends(CustomRenderDispatch, _super);\n\t\t    function CustomRenderDispatch(rootNode, rootFiber, rootElement) {\n\t\t        var _this = _super.call(this) || this;\n\t\t        _this.rootNode = rootNode;\n\t\t        _this.rootFiber = rootFiber;\n\t\t        _this.isAppMounted = false;\n\t\t        _this.isAppCrashed = false;\n\t\t        _this.isAppUnmounted = false;\n\t\t        _this.version = \"0.3.21\";\n\t\t        _this.id = Math.random().toString(16).slice(2);\n\t\t        _this.mode = \"development\" ;\n\t\t        _this.renderMode = \"render\";\n\t\t        _this.pendingCommitFiberList = null;\n\t\t        _this.pendingCommitFiberPatch = PATCH_TYPE.__initial__;\n\t\t        _this.pendingChangedFiberList = null;\n\t\t        _this.pendingUpdateFiberArray = new UniqueArray();\n\t\t        _this.pendingSuspenseFiberArray = new UniqueArray();\n\t\t        _this.uniqueIdCount = 0;\n\t\t        _this.rootElement = rootElement;\n\t\t        var typedFiber = rootFiber;\n\t\t        typedFiber.renderDispatch = _this;\n\t\t        return _this;\n\t\t    }\n\t\t    CustomRenderDispatch.prototype.generateCommitList = function (_fiber) {\n\t\t        if (!_fiber)\n\t\t            return;\n\t\t        this.pendingCommitFiberPatch = merge(this.pendingCommitFiberPatch, _fiber.patch);\n\t\t        if (_fiber.patch !== PATCH_TYPE.__initial__) {\n\t\t            this.pendingCommitFiberList = this.pendingCommitFiberList || new ListTree();\n\t\t            this.pendingCommitFiberList.push(_fiber);\n\t\t        }\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.generateChangedList = function (_fiber, withCheck) {\n\t\t        if (!_fiber)\n\t\t            return;\n\t\t        if (!this.isAppMounted)\n\t\t            return;\n\t\t        this.pendingChangedFiberList = this.pendingChangedFiberList || new ListTree();\n\t\t        if (withCheck && this.pendingChangedFiberList.hasValue(_fiber)) {\n\t\t            return;\n\t\t        }\n\t\t        this.pendingChangedFiberList.push(_fiber);\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.pendingCreate = function (_fiber) {\n\t\t        if (include(_fiber.type, this.runtimeRef.typeForCreate)) {\n\t\t            _fiber.patch = merge(_fiber.patch, PATCH_TYPE.__create__);\n\t\t        }\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.pendingUpdate = function (_fiber) {\n\t\t        if (include(_fiber.type, this.runtimeRef.typeForUpdate)) {\n\t\t            _fiber.patch = merge(_fiber.patch, PATCH_TYPE.__update__);\n\t\t        }\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.pendingAppend = function (_fiber) {\n\t\t        if (include(_fiber.type, this.runtimeRef.typeForAppend)) {\n\t\t            _fiber.patch = merge(_fiber.patch, PATCH_TYPE.__append__);\n\t\t        }\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.pendingPosition = function (_fiber) {\n\t\t        _fiber.patch = merge(_fiber.patch, PATCH_TYPE.__position__);\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.pendingRef = function (_fiber) {\n\t\t        if (_fiber.ref) {\n\t\t            if (include(_fiber.type, this.runtimeRef.typeForRef)) {\n\t\t                _fiber.patch = merge(_fiber.patch, PATCH_TYPE.__ref__);\n\t\t            }\n\t\t            else if (exclude(_fiber.type, exports.NODE_TYPE.__forwardRef__)) {\n\t\t                onceWarnWithKeyAndFiber(_fiber, \"ref\", \"[@my-react/react] set ref for current element will be ignored\");\n\t\t            }\n\t\t        }\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.pendingUnmount = function (_fiber, _pendingUnmount) {\n\t\t        _fiber.patch = merge(_fiber.patch, PATCH_TYPE.__unmount__);\n\t\t        defaultGenerateUnmountMap(_fiber, _pendingUnmount, this.runtimeMap.unmountMap);\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.pendingEffect = function (_fiber, _effect, option) {\n\t\t        _fiber.patch = merge(_fiber.patch, PATCH_TYPE.__effect__);\n\t\t        defaultGenerateEffectMap(_fiber, _effect, this.runtimeMap.effectMap, option);\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.pendingLayoutEffect = function (_fiber, _layoutEffect, option) {\n\t\t        _fiber.patch = merge(_fiber.patch, PATCH_TYPE.__layoutEffect__);\n\t\t        defaultGenerateEffectMap(_fiber, _layoutEffect, this.runtimeMap.layoutEffectMap, option);\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.pendingInsertionEffect = function (_fiber, _insertionEffect, option) {\n\t\t        _fiber.patch = merge(_fiber.patch, PATCH_TYPE.__insertionEffect__);\n\t\t        defaultGenerateEffectMap(_fiber, _insertionEffect, this.runtimeMap.insertionEffectMap, option);\n\t\t    };\n\t\t    /**\n\t\t     * @deprecated\n\t\t     */\n\t\t    CustomRenderDispatch.prototype.patchToFiberInitial = function (_fiber) {\n\t\t    };\n\t\t    /**\n\t\t     * @deprecated\n\t\t     */\n\t\t    CustomRenderDispatch.prototype.patchToFiberUpdate = function (_fiber) {\n\t\t    };\n\t\t    /**\n\t\t     * @deprecated\n\t\t     */\n\t\t    CustomRenderDispatch.prototype.patchToFiberUnmount = function (_fiber) {\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.dispatchFiber = function (_fiber) {\n\t\t        defaultDispatchFiber(this, _fiber);\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.processLazy = function (_elementType) {\n\t\t        return loadLazy(this, _elementType);\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.processPromise = function (_promise) {\n\t\t        return loadPromise(this, _promise);\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.commitCreate = function (_fiber) {\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.commitUpdate = function (_fiber) {\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.commitAppend = function (_fiber) {\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.commitPosition = function (_fiber) {\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.commitSetRef = function (_fiber) {\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.commitUnsetRef = function (_fiber) {\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.commitClear = function (_fiber) {\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.resolveStrict = function (_fiber) {\n\t\t        return defaultGenerateStrict(_fiber);\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.resolveScope = function (_fiber) {\n\t\t        return defaultResolveScope(_fiber);\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.resolveSuspenseValue = function (_fiber) {\n\t\t        return defaultResolveSuspenseValue(_fiber);\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.resolveSuspenseFiber = function (_fiber) {\n\t\t        return defaultResolveSuspenseFiber(_fiber);\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.resolveErrorBoundaries = function (_fiber) {\n\t\t        return defaultResolveErrorBoundaries(_fiber);\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.resolveContextFiber = function (_fiber, _contextObject) {\n\t\t        return defaultGetContextFiber(_fiber, _contextObject);\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.resolveContextValue = function (_fiber, _contextObject) {\n\t\t        return defaultGetContextValue(_fiber, _contextObject);\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.reconcileCommit = function (_fiber) {\n\t\t        var instance = this;\n\t\t        safeCall(function safeCallBeforeCommit() {\n\t\t            var _a;\n\t\t            (_a = instance.beforeCommit) === null || _a === void 0 ? void 0 : _a.call(instance);\n\t\t        });\n\t\t        safeCall(function safeCallBeforeCommitListener() {\n\t\t            instance.callOnBeforeCommitMount(instance);\n\t\t        });\n\t\t        defaultDispatchMount(this, _fiber);\n\t\t        safeCall(function safeCallAfterCommitListener() {\n\t\t            instance.callOnAfterCommitMount(instance);\n\t\t        });\n\t\t        safeCall(function safeCallAfterCommit() {\n\t\t            var _a;\n\t\t            (_a = instance.afterCommit) === null || _a === void 0 ? void 0 : _a.call(instance);\n\t\t        });\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.reconcileUpdate = function (_list, sync) {\n\t\t        var instance = this;\n\t\t        safeCall(function safeCallBeforeUpdate() {\n\t\t            var _a;\n\t\t            (_a = instance.beforeUpdate) === null || _a === void 0 ? void 0 : _a.call(instance);\n\t\t        });\n\t\t        safeCall(function safeCallBeforeUpdateListener() {\n\t\t            instance.callOnBeforeCommitUpdate(instance);\n\t\t        });\n\t\t        defaultDispatchUpdate(this, _list, sync);\n\t\t        safeCall(function safeCallAfterUpdateListener() {\n\t\t            instance.callOnAfterCommitUpdate(instance);\n\t\t        });\n\t\t        safeCall(function safeCallAfterUpdate() {\n\t\t            var _a;\n\t\t            (_a = instance.afterUpdate) === null || _a === void 0 ? void 0 : _a.call(instance);\n\t\t        });\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.reconcileUnmount = function () {\n\t\t        var instance = this;\n\t\t        safeCall(function safeCallBeforeUnmount() {\n\t\t            var _a;\n\t\t            (_a = instance.beforeUnmount) === null || _a === void 0 ? void 0 : _a.call(instance);\n\t\t        });\n\t\t        safeCall(function safeCallBeforeUnmountListener() {\n\t\t            instance.callOnBeforeCommitUnmount(instance);\n\t\t        });\n\t\t        defaultDispatchUnmount(this);\n\t\t        safeCall(function safeCallAfterUnmountListener() {\n\t\t            instance.callOnAfterCommitUnmount(instance);\n\t\t        });\n\t\t        safeCall(function safeCallAfterUnmount() {\n\t\t            var _a;\n\t\t            (_a = instance.afterUnmount) === null || _a === void 0 ? void 0 : _a.call(instance);\n\t\t        });\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.shouldYield = function () {\n\t\t        return false;\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.resetYield = function () {\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.resetUpdateFlowRuntimeFiber = function () {\n\t\t        this.runtimeFiber.scheduledFiber = null;\n\t\t        this.runtimeFiber.nextWorkingFiber = null;\n\t\t        this.runtimeFiber.retriggerFiber = null;\n\t\t        this.pendingCommitFiberPatch = PATCH_TYPE.__initial__;\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.getFiberTree = function (_fiber) {\n\t\t        return getFiberTree$1(_fiber);\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.readPromise = function (_params) {\n\t\t        return defaultReadPromise(_params);\n\t\t    };\n\t\t    CustomRenderDispatch.prototype.readContext = function (_params) {\n\t\t        return defaultReadContext(_params);\n\t\t    };\n\t\t    return CustomRenderDispatch;\n\t\t}(RenderDispatchEvent));\n\n\t\tvar globalLoop = react.__my_react_internal__.globalLoop;\n\t\tvar enableScopeTreeLog = react.__my_react_shared__.enableScopeTreeLog;\n\t\tfunction finishMountSync(renderDispatch, fiber) {\n\t\t    enableScopeTreeLog.current && setLogScope();\n\t\t    renderDispatch.reconcileCommit(fiber);\n\t\t    var changedList = renderDispatch.pendingChangedFiberList;\n\t\t    renderDispatch.resetUpdateFlowRuntimeFiber();\n\t\t    renderDispatch.pendingCommitFiberList = null;\n\t\t    renderDispatch.pendingChangedFiberList = null;\n\t\t    enableScopeTreeLog.current && resetLogScope();\n\t\t    (changedList === null || changedList === void 0 ? void 0 : changedList.length) &&\n\t\t        safeCallWithCurrentFiber({\n\t\t            fiber: fiber,\n\t\t            action: function safeCallFiberHasChangeListener() {\n\t\t                renderDispatch.callOnFiberChange(changedList);\n\t\t            },\n\t\t        });\n\t\t}\n\t\tvar mountSync = function (renderDispatch, fiber) {\n\t\t    safeCall(function safeCallBeforeDispatchRender() {\n\t\t            renderDispatch.callOnBeforeDispatchRender(renderDispatch, fiber);\n\t\t        });\n\t\t    globalLoop.current = true;\n\t\t    enableScopeTreeLog.current && setLogScope();\n\t\t    mountLoopAll(renderDispatch, fiber);\n\t\t    processAsyncLoadListOnSyncMount(renderDispatch);\n\t\t    enableScopeTreeLog.current && resetLogScope();\n\t\t    finishMountSync(renderDispatch, fiber);\n\t\t    safeCall(function safeCallAfterDispatchRender() {\n\t\t            renderDispatch.callOnAfterDispatchRender(renderDispatch);\n\t\t        });\n\t\t    globalLoop.current = false;\n\t\t};\n\t\tfunction finishMountAsync(renderDispatch, fiber) {\n\t\t    enableScopeTreeLog.current && setLogScope();\n\t\t    renderDispatch.reconcileCommit(fiber);\n\t\t    var changedList = renderDispatch.pendingChangedFiberList;\n\t\t    renderDispatch.resetUpdateFlowRuntimeFiber();\n\t\t    renderDispatch.pendingCommitFiberList = null;\n\t\t    renderDispatch.pendingChangedFiberList = null;\n\t\t    enableScopeTreeLog.current && resetLogScope();\n\t\t    (changedList === null || changedList === void 0 ? void 0 : changedList.length) &&\n\t\t        safeCallWithCurrentFiber({\n\t\t            fiber: fiber,\n\t\t            action: function safeCallFiberHasChangeListener() {\n\t\t                renderDispatch.callOnFiberChange(changedList);\n\t\t            },\n\t\t        });\n\t\t}\n\t\tvar mountAsync = function (renderDispatch, fiber) { return __awaiter(void 0, void 0, void 0, function () {\n\t\t    return __generator(this, function (_a) {\n\t\t        switch (_a.label) {\n\t\t            case 0:\n\t\t                safeCall(function safeCallBeforeDispatchRender() {\n\t\t                        renderDispatch.callOnBeforeDispatchRender(renderDispatch, fiber);\n\t\t                    });\n\t\t                globalLoop.current = true;\n\t\t                enableScopeTreeLog.current && setLogScope();\n\t\t                mountLoopAll(renderDispatch, fiber);\n\t\t                return [4 /*yield*/, processAsyncLoadListOnAsyncMount(renderDispatch)];\n\t\t            case 1:\n\t\t                _a.sent();\n\t\t                enableScopeTreeLog.current && resetLogScope();\n\t\t                finishMountAsync(renderDispatch, fiber);\n\t\t                safeCall(function safeCallAfterDispatchRender() {\n\t\t                        renderDispatch.callOnAfterDispatchRender(renderDispatch);\n\t\t                    });\n\t\t                globalLoop.current = false;\n\t\t                return [2 /*return*/];\n\t\t        }\n\t\t    });\n\t\t}); };\n\n\t\tvar version = \"0.3.21\";\n\n\t\texports.CustomRenderDispatch = CustomRenderDispatch;\n\t\texports.MyReactFiberNode = MyReactFiberNode;\n\t\texports.MyReactHookNode = MyReactHookNode;\n\t\texports.MyWeakMap = MyWeakMap;\n\t\texports.RenderDispatchEvent = RenderDispatchEvent;\n\t\texports.WrapperByLazyScope = WrapperByLazyScope;\n\t\texports.WrapperBySuspenseScope = WrapperBySuspenseScope;\n\t\texports.addEffectCallback = addEffectCallback;\n\t\texports.afterSyncFlush = afterSyncFlush;\n\t\texports.afterSyncUpdate = afterSyncUpdate;\n\t\texports.applyTriggerFiberCb = applyTriggerFiberCb;\n\t\texports.beforeSyncFlush = beforeSyncFlush;\n\t\texports.beforeSyncUpdate = beforeSyncUpdate;\n\t\texports.callWithFiber = callWithFiber;\n\t\texports.checkIsMyReactFiberNode = checkIsMyReactFiberNode;\n\t\texports.checkIsSameType = checkIsSameType;\n\t\texports.clearContainer = clearContainer;\n\t\texports.clearFiberNode = clearFiberNode;\n\t\texports.createFiberNode = createFiberNode;\n\t\texports.createHookNode = createHookNode;\n\t\texports.currentRefreshHandler = currentRefreshHandler;\n\t\texports.currentTriggerFiber = currentTriggerFiber;\n\t\texports.debugWithNode = debugWithNode;\n\t\texports.defaultDeleteChildEffect = defaultDeleteChildEffect;\n\t\texports.defaultDeleteCurrentEffect = defaultDeleteCurrentEffect;\n\t\texports.defaultDispatchMount = defaultDispatchMount;\n\t\texports.defaultDispatchMountLatest = defaultDispatchMountLatest;\n\t\texports.defaultDispatchUnmount = defaultDispatchUnmount;\n\t\texports.defaultDispatchUpdate = defaultDispatchUpdate;\n\t\texports.defaultGenerateEffectMap = defaultGenerateEffectMap;\n\t\texports.defaultGenerateStrict = defaultGenerateStrict;\n\t\texports.defaultGenerateUnmountMap = defaultGenerateUnmountMap;\n\t\texports.defaultGetContextFiber = defaultGetContextFiber;\n\t\texports.defaultGetContextValue = defaultGetContextValue;\n\t\texports.defaultInvokeEffect = defaultInvokeEffect;\n\t\texports.defaultInvokeInsertionEffect = defaultInvokeInsertionEffect;\n\t\texports.defaultInvokeLayoutEffect = defaultInvokeLayoutEffect;\n\t\texports.defaultInvokeUnmountList = defaultInvokeUnmountList;\n\t\texports.defaultReadContext = defaultReadContext;\n\t\texports.defaultReadPromise = defaultReadPromise;\n\t\texports.defaultResolveAliveSuspenseFiber = defaultResolveAliveSuspenseFiber;\n\t\texports.defaultResolveErrorBoundaries = defaultResolveErrorBoundaries;\n\t\texports.defaultResolveScope = defaultResolveScope;\n\t\texports.defaultResolveSuspenseFiber = defaultResolveSuspenseFiber;\n\t\texports.defaultResolveSuspenseValue = defaultResolveSuspenseValue;\n\t\texports.devError = devError;\n\t\texports.devErrorWithFiber = devErrorWithFiber;\n\t\texports.devWarn = devWarn;\n\t\texports.devWarnWithFiber = devWarnWithFiber;\n\t\texports.effect = effect;\n\t\texports.effectHookNode = effectHookNode;\n\t\texports.emptyProps = emptyProps;\n\t\texports.enableDebugUpdateQueue = enableDebugUpdateQueue;\n\t\texports.enableFiberForLog = enableFiberForLog;\n\t\texports.enableLogForCurrentFlowIsRunning = enableLogForCurrentFlowIsRunning;\n\t\texports.enableValidMyReactElement = enableValidMyReactElement;\n\t\texports.fiberToDispatchMap = fiberToDispatchMap;\n\t\texports.flushEffectCallback = flushEffectCallback;\n\t\texports.generateFiberToListWithAction = generateFiberToListWithAction;\n\t\texports.generateFiberToMountList = generateFiberToMountList;\n\t\texports.generateFiberToUnmountList = generateFiberToUnmountList;\n\t\texports.getClassInstanceFieldByInstance = getClassInstanceFieldByInstance;\n\t\texports.getCurrentDispatchFromFiber = getCurrentDispatchFromFiber;\n\t\texports.getCurrentDispatchFromType = getCurrentDispatchFromType;\n\t\texports.getCurrentFibersFromType = getCurrentFibersFromType;\n\t\texports.getCurrentTypeFromRefresh = getCurrentTypeFromRefresh;\n\t\texports.getCurrentTypeFromRefreshOnly = getCurrentTypeFromRefreshOnly;\n\t\texports.getElementFromRefreshIfExist = getElementFromRefreshIfExist;\n\t\texports.getElementName = getElementName;\n\t\texports.getElementTypeFromType = getElementTypeFromType;\n\t\texports.getFiberTree = getFiberTree$1;\n\t\texports.getFiberTreeWithFiber = getFiberTreeWithFiber;\n\t\texports.getHookTree = getHookTree;\n\t\texports.getInstanceContextFiber = getInstanceContextFiber;\n\t\texports.getInstanceEffectState = getInstanceEffectState;\n\t\texports.getInstanceFieldByInstance = getInstanceFieldByInstance;\n\t\texports.getInstanceOwnerFiber = getInstanceOwnerFiber;\n\t\texports.getPlainFiberName = getPlainFiberName;\n\t\texports.getStackTree = getStackTree;\n\t\texports.getTypeFromElement = getTypeFromElement;\n\t\texports.getTypeFromElementNode = getTypeFromElementNode;\n\t\texports.hmr = hmr;\n\t\texports.hmrRevert = hmrRevert;\n\t\texports.hmrUpdate = hmrUpdate;\n\t\texports.hookListUnmount = hookListUnmount;\n\t\texports.initClassInstance = initClassInstance;\n\t\texports.initHMR = initHMR;\n\t\texports.initHookInstance = initHookInstance;\n\t\texports.initInstance = initInstance;\n\t\texports.initScheduler = initScheduler;\n\t\texports.initSuspenseInstance = initSuspenseInstance;\n\t\texports.initVisibleInstance = initVisibleInstance;\n\t\texports.initialFiberNode = initialFiberNode;\n\t\texports.insertionEffect = insertionEffect;\n\t\texports.isCommentElement = isCommentElement;\n\t\texports.isCommentEndElement = isCommentEndElement;\n\t\texports.isCommentStartElement = isCommentStartElement;\n\t\texports.isErrorBoundariesComponent = isErrorBoundariesComponent;\n\t\texports.isErrorBoundariesInstance = isErrorBoundariesInstance;\n\t\texports.layoutEffect = layoutEffect;\n\t\texports.loadLazy = loadLazy;\n\t\texports.loadPromise = loadPromise;\n\t\texports.mountAsync = mountAsync;\n\t\texports.mountClassInstance = mountClassInstance;\n\t\texports.mountLoopAll = mountLoopAll;\n\t\texports.mountLoopAllFromScheduler = mountLoopAllFromScheduler;\n\t\texports.mountSync = mountSync;\n\t\texports.mountToNextFiberFromRoot = mountToNextFiberFromRoot;\n\t\texports.nextWorkActivity = nextWorkActivity;\n\t\texports.nextWorkClassComponent = nextWorkClassComponent;\n\t\texports.nextWorkCommon = nextWorkCommon;\n\t\texports.nextWorkComponent = nextWorkComponent;\n\t\texports.nextWorkConsumer = nextWorkConsumer;\n\t\texports.nextWorkFunctionComponent = nextWorkFunctionComponent;\n\t\texports.nextWorkLazy = nextWorkLazy;\n\t\texports.nextWorkNormal = nextWorkNormal;\n\t\texports.nextWorkProvider = nextWorkProvider;\n\t\texports.nextWorkRoot = nextWorkRoot;\n\t\texports.nextWorkSuspense = nextWorkSuspense;\n\t\texports.onceErrorWithKeyAndFiber = onceErrorWithKeyAndFiber;\n\t\texports.onceWarnWithKeyAndFiber = onceWarnWithKeyAndFiber;\n\t\texports.originalError = originalError;\n\t\texports.originalWarn = originalWarn;\n\t\texports.performToNextFiberFromRoot = performToNextFiberFromRoot;\n\t\texports.prepareUpdateAllDependence = prepareUpdateAllDependence;\n\t\texports.prepareUpdateOnFiber = prepareUpdateOnFiber;\n\t\texports.processAsyncLoadListOnAsyncMount = processAsyncLoadListOnAsyncMount;\n\t\texports.processAsyncLoadListOnSyncMount = processAsyncLoadListOnSyncMount;\n\t\texports.processAsyncLoadListOnUpdate = processAsyncLoadListOnUpdate;\n\t\texports.processClassComponentActive = processClassComponentActive;\n\t\texports.processClassComponentMount = processClassComponentMount;\n\t\texports.processClassComponentUnmount = processClassComponentUnmount;\n\t\texports.processClassComponentUpdate = processClassComponentUpdate;\n\t\texports.processClassComponentUpdateQueueLatest = processClassComponentUpdateQueueLatest;\n\t\texports.processClassComponentUpdateQueueLegacy = processClassComponentUpdateQueueLegacy;\n\t\texports.processConsumer = processConsumer;\n\t\texports.processFunction = processFunction;\n\t\texports.processFunctionComponentUpdateQueueLatest = processFunctionComponentUpdateQueueLatest;\n\t\texports.processFunctionComponentUpdateQueueLegacy = processFunctionComponentUpdateQueueLegacy;\n\t\texports.processHook = processHook;\n\t\texports.processLazy = processLazy;\n\t\texports.processNormalComponentUpdateLatest = processNormalComponentUpdateLatest;\n\t\texports.processNormalComponentUpdateLegacy = processNormalComponentUpdateLegacy;\n\t\texports.processPromise = processPromise;\n\t\texports.processProvider = processProvider;\n\t\texports.processState = processState;\n\t\texports.processSuspense = processSuspense;\n\t\texports.processSuspensePromise = processSuspensePromise;\n\t\texports.resetLogScope = resetLogScope;\n\t\texports.runtimeNextWork = runtimeNextWork;\n\t\texports.runtimeNextWorkDev = runtimeNextWorkDev;\n\t\texports.safeCall = safeCall;\n\t\texports.safeCallWithCurrentFiber = safeCallWithCurrentFiber;\n\t\texports.safeCallWithSync = safeCallWithSync;\n\t\texports.scheduleNext = scheduleNext;\n\t\texports.scheduleUpdate = scheduleUpdate;\n\t\texports.setContextForInstance = setContextForInstance;\n\t\texports.setEffectForInstance = setEffectForInstance;\n\t\texports.setLogScope = setLogScope;\n\t\texports.setOwnerForInstance = setOwnerForInstance;\n\t\texports.setRefreshHandler = setRefreshHandler;\n\t\texports.setRefreshTypeMap = setRefreshTypeMap;\n\t\texports.setSubscribeForInstance = setSubscribeForInstance;\n\t\texports.syncComponentStateToFiber = syncComponentStateToFiber;\n\t\texports.syncFiberStateToComponent = syncFiberStateToComponent;\n\t\texports.syncFlushComponentQueue = syncFlushComponentQueue;\n\t\texports.transformChildrenFiber = transformChildrenFiber;\n\t\texports.triggerError = triggerError;\n\t\texports.triggerFiberUpdateListener = triggerFiberUpdateListener;\n\t\texports.triggerRevert = triggerRevert;\n\t\texports.triggerUpdate = triggerUpdate;\n\t\texports.triggerUpdateOnFiber = triggerUpdateOnFiber;\n\t\texports.typeToFibersMap = typeToFibersMap;\n\t\texports.unmountContainer = unmountContainer;\n\t\texports.unmountFiber = unmountFiber;\n\t\texports.unmountFiberNode = unmountFiberNode;\n\t\texports.unmountInstance = unmountInstance;\n\t\texports.updateConcurrentFromRoot = updateConcurrentFromRoot;\n\t\texports.updateFiberNode = updateFiberNode;\n\t\texports.updateHookNode = updateHookNode;\n\t\texports.updateLoopConcurrentFromRoot = updateLoopConcurrentFromRoot;\n\t\texports.updateLoopSyncFromRoot = updateLoopSyncFromRoot;\n\t\texports.updateSyncFromRoot = updateSyncFromRoot;\n\t\texports.version = version; \n\t} (index_development));\n\treturn index_development;\n}\n\nvar hasRequiredMyreactReconciler;\n\nfunction requireMyreactReconciler () {\n\tif (hasRequiredMyreactReconciler) return myreactReconciler.exports;\n\thasRequiredMyreactReconciler = 1;\n\n\tif (process.env.NODE_ENV === \"production\") {\n\t  myreactReconciler.exports = requireIndex_production();\n\t} else {\n\t  myreactReconciler.exports = requireIndex_development();\n\t}\n\treturn myreactReconciler.exports;\n}\n\nvar myreactReconcilerExports = requireMyreactReconciler();\n\nvar remove$1 = function (src, rest) {\n    if (src & rest) {\n        return src ^ rest;\n    }\n    else {\n        return src;\n    }\n};\nvar include = function (src, rest) {\n    return !!(src & rest);\n};\nvar exclude = function (src, rest) {\n    return !(src & rest);\n};\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\nvar Portal$1 = Symbol.for(\"react.portal\");\n\nvar HOOK_TYPE;\n(function (HOOK_TYPE) {\n    HOOK_TYPE[HOOK_TYPE[\"useId\"] = 0] = \"useId\";\n    HOOK_TYPE[HOOK_TYPE[\"useRef\"] = 1] = \"useRef\";\n    HOOK_TYPE[HOOK_TYPE[\"useMemo\"] = 2] = \"useMemo\";\n    HOOK_TYPE[HOOK_TYPE[\"useState\"] = 3] = \"useState\";\n    HOOK_TYPE[HOOK_TYPE[\"useSignal\"] = 4] = \"useSignal\";\n    HOOK_TYPE[HOOK_TYPE[\"useEffect\"] = 5] = \"useEffect\";\n    HOOK_TYPE[HOOK_TYPE[\"useContext\"] = 6] = \"useContext\";\n    HOOK_TYPE[HOOK_TYPE[\"useReducer\"] = 7] = \"useReducer\";\n    HOOK_TYPE[HOOK_TYPE[\"useCallback\"] = 8] = \"useCallback\";\n    HOOK_TYPE[HOOK_TYPE[\"useTransition\"] = 9] = \"useTransition\";\n    HOOK_TYPE[HOOK_TYPE[\"useDebugValue\"] = 10] = \"useDebugValue\";\n    HOOK_TYPE[HOOK_TYPE[\"useLayoutEffect\"] = 11] = \"useLayoutEffect\";\n    HOOK_TYPE[HOOK_TYPE[\"useDeferredValue\"] = 12] = \"useDeferredValue\";\n    HOOK_TYPE[HOOK_TYPE[\"useInsertionEffect\"] = 13] = \"useInsertionEffect\";\n    HOOK_TYPE[HOOK_TYPE[\"useImperativeHandle\"] = 14] = \"useImperativeHandle\";\n    HOOK_TYPE[HOOK_TYPE[\"useSyncExternalStore\"] = 15] = \"useSyncExternalStore\";\n    HOOK_TYPE[HOOK_TYPE[\"useOptimistic\"] = 16] = \"useOptimistic\";\n    HOOK_TYPE[HOOK_TYPE[\"useEffectEvent\"] = 17] = \"useEffectEvent\";\n})(HOOK_TYPE || (HOOK_TYPE = {}));\n\nvar UpdateQueueType;\n(function (UpdateQueueType) {\n    UpdateQueueType[UpdateQueueType[\"component\"] = 1] = \"component\";\n    UpdateQueueType[UpdateQueueType[\"hook\"] = 2] = \"hook\";\n    UpdateQueueType[UpdateQueueType[\"context\"] = 3] = \"context\";\n    UpdateQueueType[UpdateQueueType[\"hmr\"] = 4] = \"hmr\";\n    UpdateQueueType[UpdateQueueType[\"trigger\"] = 5] = \"trigger\";\n    UpdateQueueType[UpdateQueueType[\"suspense\"] = 6] = \"suspense\";\n    UpdateQueueType[UpdateQueueType[\"lazy\"] = 7] = \"lazy\";\n    UpdateQueueType[UpdateQueueType[\"promise\"] = 8] = \"promise\";\n})(UpdateQueueType || (UpdateQueueType = {}));\n\nvar STATE_TYPE;\n(function (STATE_TYPE) {\n    STATE_TYPE[STATE_TYPE[\"__initial__\"] = 0] = \"__initial__\";\n    STATE_TYPE[STATE_TYPE[\"__create__\"] = 1] = \"__create__\";\n    STATE_TYPE[STATE_TYPE[\"__stable__\"] = 2] = \"__stable__\";\n    STATE_TYPE[STATE_TYPE[\"__inherit__\"] = 4] = \"__inherit__\";\n    STATE_TYPE[STATE_TYPE[\"__triggerConcurrent__\"] = 8] = \"__triggerConcurrent__\";\n    STATE_TYPE[STATE_TYPE[\"__triggerConcurrentForce__\"] = 16] = \"__triggerConcurrentForce__\";\n    STATE_TYPE[STATE_TYPE[\"__triggerSync__\"] = 32] = \"__triggerSync__\";\n    STATE_TYPE[STATE_TYPE[\"__triggerSyncForce__\"] = 64] = \"__triggerSyncForce__\";\n    STATE_TYPE[STATE_TYPE[\"__unmount__\"] = 128] = \"__unmount__\";\n    STATE_TYPE[STATE_TYPE[\"__hmr__\"] = 256] = \"__hmr__\";\n    STATE_TYPE[STATE_TYPE[\"__retrigger__\"] = 512] = \"__retrigger__\";\n    STATE_TYPE[STATE_TYPE[\"__reschedule__\"] = 1024] = \"__reschedule__\";\n    STATE_TYPE[STATE_TYPE[\"__recreate__\"] = 2048] = \"__recreate__\";\n    STATE_TYPE[STATE_TYPE[\"__suspense__\"] = 4096] = \"__suspense__\";\n})(STATE_TYPE || (STATE_TYPE = {}));\n\nvar PATCH_TYPE;\n(function (PATCH_TYPE) {\n    PATCH_TYPE[PATCH_TYPE[\"__initial__\"] = 0] = \"__initial__\";\n    PATCH_TYPE[PATCH_TYPE[\"__create__\"] = 1] = \"__create__\";\n    PATCH_TYPE[PATCH_TYPE[\"__update__\"] = 2] = \"__update__\";\n    PATCH_TYPE[PATCH_TYPE[\"__append__\"] = 4] = \"__append__\";\n    PATCH_TYPE[PATCH_TYPE[\"__position__\"] = 8] = \"__position__\";\n    PATCH_TYPE[PATCH_TYPE[\"__effect__\"] = 16] = \"__effect__\";\n    PATCH_TYPE[PATCH_TYPE[\"__layoutEffect__\"] = 32] = \"__layoutEffect__\";\n    PATCH_TYPE[PATCH_TYPE[\"__insertionEffect__\"] = 64] = \"__insertionEffect__\";\n    PATCH_TYPE[PATCH_TYPE[\"__unmount__\"] = 128] = \"__unmount__\";\n    PATCH_TYPE[PATCH_TYPE[\"__ref__\"] = 256] = \"__ref__\";\n})(PATCH_TYPE || (PATCH_TYPE = {}));\n\nvar Effect_TYPE;\n(function (Effect_TYPE) {\n    Effect_TYPE[Effect_TYPE[\"__initial__\"] = 0] = \"__initial__\";\n    Effect_TYPE[Effect_TYPE[\"__effect__\"] = 1] = \"__effect__\";\n    Effect_TYPE[Effect_TYPE[\"__unmount__\"] = 2] = \"__unmount__\";\n})(Effect_TYPE || (Effect_TYPE = {}));\n\nvar ListTreeNode = /** @class */ (function () {\n    function ListTreeNode(value) {\n        this.prev = null;\n        this.next = null;\n        this.value = value;\n    }\n    return ListTreeNode;\n}());\nvar ListTree = /** @class */ (function () {\n    function ListTree() {\n        this.length = 0;\n        var _stickyHead = null;\n        Object.defineProperty(this, \"stickyHead\", {\n            get: function () {\n                return _stickyHead;\n            },\n            set: function (v) {\n                _stickyHead = v;\n            },\n        });\n        var _stickyFoot = null;\n        Object.defineProperty(this, \"stickyFoot\", {\n            get: function () {\n                return _stickyFoot;\n            },\n            set: function (v) {\n                _stickyFoot = v;\n            },\n        });\n        var _head = null;\n        Object.defineProperty(this, \"head\", {\n            get: function () {\n                return _head;\n            },\n            set: function (v) {\n                _head = v;\n            },\n        });\n        var _foot = null;\n        Object.defineProperty(this, \"foot\", {\n            get: function () {\n                return _foot;\n            },\n            set: function (v) {\n                _foot = v;\n            },\n        });\n    }\n    ListTree.prototype.push = function (node) {\n        var listNode = new ListTreeNode(node);\n        this.length++;\n        if (!this.foot) {\n            this.head = listNode;\n            this.foot = listNode;\n        }\n        else {\n            this.foot.next = listNode;\n            listNode.prev = this.foot;\n            this.foot = listNode;\n        }\n    };\n    ListTree.prototype.pushToLast = function (node) {\n        if (this.stickyFoot) {\n            var node_1 = this.stickyFoot;\n            this.push(node_1.value);\n            this.stickyFoot = null;\n        }\n        else {\n            this.length++;\n        }\n        var listNode = new ListTreeNode(node);\n        this.stickyFoot = listNode;\n    };\n    ListTree.prototype.pushToHead = function (node) {\n        if (this.stickyHead) {\n            var node_2 = this.stickyHead;\n            this.unshift(node_2.value);\n            this.stickyHead = null;\n        }\n        else {\n            this.length++;\n        }\n        var listNode = new ListTreeNode(node);\n        this.stickyHead = listNode;\n    };\n    ListTree.prototype.pop = function () {\n        var foot = this.stickyFoot || this.foot || this.stickyHead;\n        if (foot) {\n            this.delete(foot);\n            return foot.value;\n        }\n        else {\n            return null;\n        }\n    };\n    ListTree.prototype.unshift = function (node) {\n        var listNode = new ListTreeNode(node);\n        this.length++;\n        if (!this.head) {\n            this.head = listNode;\n            this.foot = listNode;\n        }\n        else {\n            this.head.prev = listNode;\n            listNode.next = this.head;\n            this.head = listNode;\n        }\n    };\n    ListTree.prototype.unshiftToHead = function (node) {\n        if (this.stickyHead) {\n            var node_3 = this.stickyHead;\n            this.unshift(node_3.value);\n            this.stickyHead = null;\n        }\n        else {\n            this.length++;\n        }\n        var listNode = new ListTreeNode(node);\n        this.stickyHead = listNode;\n    };\n    ListTree.prototype.unshiftToFoot = function (node) {\n        if (this.stickyFoot) {\n            var node_4 = this.stickyFoot;\n            this.push(node_4.value);\n            this.stickyFoot = null;\n        }\n        else {\n            this.length++;\n        }\n        var listNode = new ListTreeNode(node);\n        this.stickyFoot = listNode;\n    };\n    ListTree.prototype.shift = function () {\n        var head = this.stickyHead || this.head || this.stickyFoot;\n        if (head) {\n            this.delete(head);\n            return head.value;\n        }\n        else {\n            return null;\n        }\n    };\n    ListTree.prototype.pickHead = function () {\n        var _a, _b;\n        return ((_a = this.stickyHead) === null || _a === void 0 ? void 0 : _a.value) || ((_b = this.head) === null || _b === void 0 ? void 0 : _b.value);\n    };\n    ListTree.prototype.pickFoot = function () {\n        var _a, _b;\n        return ((_a = this.stickyFoot) === null || _a === void 0 ? void 0 : _a.value) || ((_b = this.foot) === null || _b === void 0 ? void 0 : _b.value);\n    };\n    ListTree.prototype.listToFoot = function (action) {\n        if (this.stickyHead) {\n            action(this.stickyHead.value);\n        }\n        var node = this.head;\n        while (node) {\n            action(node.value);\n            node = node.next;\n        }\n        if (this.stickyFoot) {\n            action(this.stickyFoot.value);\n        }\n    };\n    ListTree.prototype.listToHead = function (action) {\n        if (this.stickyFoot) {\n            action(this.stickyFoot.value);\n        }\n        var node = this.foot;\n        while (node) {\n            action(node.value);\n            node = node.prev;\n        }\n        if (this.stickyHead) {\n            action(this.stickyHead.value);\n        }\n    };\n    ListTree.prototype.toArray = function () {\n        var re = [];\n        this.listToFoot(function (v) { return re.push(v); });\n        return re;\n    };\n    ListTree.prototype.delete = function (node) {\n        if (this.stickyHead === node) {\n            this.stickyHead = null;\n            this.length--;\n        }\n        else if (this.stickyFoot === node) {\n            this.stickyFoot = null;\n            this.length--;\n        }\n        else if (this.head === node) {\n            var next = node.next;\n            node.next = null;\n            if (next) {\n                this.head = next;\n                next.prev = null;\n            }\n            else {\n                this.head = null;\n                this.foot = null;\n            }\n            this.length--;\n        }\n        else if (this.foot === node) {\n            var prev = node.prev;\n            node.prev = null;\n            if (prev) {\n                this.foot = prev;\n                prev.next = null;\n            }\n            else {\n                this.head = null;\n                this.foot = null;\n            }\n            this.length--;\n        }\n        else if (this.hasNode(node)) {\n            var prev = node.prev;\n            var next = node.next;\n            node.prev = null;\n            node.next = null;\n            prev.next = next;\n            next.prev = prev;\n            this.length--;\n        }\n    };\n    ListTree.prototype.size = function () {\n        return this.length;\n    };\n    ListTree.prototype.hasNode = function (node) {\n        if (this.stickyHead && Object.is(this.stickyHead, node))\n            return true;\n        if (this.stickyFoot && Object.is(this.stickyFoot, node))\n            return true;\n        var listNode = this.head;\n        while (listNode) {\n            if (Object.is(listNode, node))\n                return true;\n            listNode = listNode.next;\n        }\n        return false;\n    };\n    ListTree.prototype.hasValue = function (node) {\n        if (this.stickyHead && Object.is(this.stickyHead.value, node))\n            return true;\n        if (this.stickyFoot && Object.is(this.stickyFoot.value, node))\n            return true;\n        var listNode = this.head;\n        while (listNode) {\n            if (Object.is(listNode.value, node))\n                return true;\n            listNode = listNode.next;\n        }\n        return false;\n    };\n    ListTree.prototype.some = function (iterator) {\n        var re = false;\n        this.listToFoot(function (node) {\n            re = re || iterator(node);\n        });\n        return re;\n    };\n    ListTree.prototype.every = function (iterator) {\n        var re = true;\n        this.listToFoot(function (node) {\n            re = re && iterator(node);\n        });\n        return re;\n    };\n    ListTree.prototype.concat = function (list) {\n        var newList = new ListTree();\n        this.listToFoot(function (node) { return newList.push(node); });\n        list.listToFoot(function (node) { return newList.push(node); });\n        return newList;\n    };\n    ListTree.prototype.clone = function () {\n        var newList = new ListTree();\n        this.listToFoot(function (v) { return newList.push(v); });\n        return newList;\n    };\n    ListTree.prototype.clear = function () {\n        this.length = 0;\n        this.head = null;\n        this.foot = null;\n        this.stickyHead = null;\n        this.stickyFoot = null;\n    };\n    return ListTree;\n}());\nif (process.env.NODE_ENV === \"development\") {\n    Object.defineProperty(ListTree.prototype, \"_debugToArray\", {\n        get: function () {\n            return this.toArray();\n        },\n    });\n}\n\nvar DISPATCH_FIELD = \"__@my-react/dispatch__\";\nvar DEV_TOOL_FIELD = \"__@my-react/react-devtool-inject__\";\nvar addGlobalDispatch = function (dispatch) {\n    if (typeof globalThis !== \"undefined\") {\n        if (Array.isArray(globalThis[DISPATCH_FIELD])) {\n            globalThis[DISPATCH_FIELD] = globalThis[DISPATCH_FIELD].filter(function (i) { return i !== dispatch; });\n            globalThis[DISPATCH_FIELD].push(dispatch);\n        }\n        else {\n            globalThis[DISPATCH_FIELD] = [dispatch];\n        }\n    }\n};\nvar autoSetDevTools = function (dispatch) {\n    addGlobalDispatch(dispatch);\n    if (typeof globalThis !== \"undefined\" && globalThis[DEV_TOOL_FIELD]) {\n        try {\n            var typedRuntimeField = globalThis[DEV_TOOL_FIELD];\n            typedRuntimeField === null || typedRuntimeField === void 0 ? void 0 : typedRuntimeField(dispatch);\n        }\n        catch (_a) {\n        }\n    }\n};\nvar delGlobalDispatch = function (dispatch) {\n    if (typeof globalThis !== \"undefined\") {\n        if (Array.isArray(globalThis[DISPATCH_FIELD])) {\n            globalThis[DISPATCH_FIELD] = globalThis[DISPATCH_FIELD].filter(function (i) { return i !== dispatch; });\n        }\n    }\n};\n\n/**\n * @internal\n */\nvar setRef = function (_fiber, config) {\n    if (include(_fiber.patch, PATCH_TYPE.__ref__)) {\n        var cleanUp = function () {\n            // const refPrevious = _fiber.refPrevious;\n            // safeCallWithCurrentFiber({\n            //   fiber: _fiber,\n            //   action: function safeCallRefPrevious() {\n            //     if (typeof refPrevious === \"object\" && refPrevious !== null) {\n            //       refPrevious.current = null;\n            //     } else if (typeof refPrevious === \"function\") {\n            //       refPrevious?.(null);\n            //     }\n            //   },\n            // });\n            // _fiber.refPrevious = undefined;\n            var refCleanup = _fiber.refCleanup;\n            myreactReconcilerExports.safeCallWithCurrentFiber({\n                fiber: _fiber,\n                action: function safeCallRefCleanup() {\n                    if (typeof refCleanup === \"function\") {\n                        refCleanup();\n                    }\n                },\n            });\n            _fiber.refCleanup = undefined;\n        };\n        if (include(_fiber.type, myreactReconcilerExports.NODE_TYPE.__plain__)) {\n            if (_fiber.nativeNode) {\n                cleanUp();\n                var ref_1 = _fiber.ref;\n                myreactReconcilerExports.safeCallWithCurrentFiber({\n                    fiber: _fiber,\n                    action: function safeCallSetRef() {\n                        var _a, _b;\n                        if (typeof ref_1 === \"object\" && ref_1 !== null) {\n                            ref_1.current = (_a = config === null || config === void 0 ? void 0 : config.getPublicInstance) === null || _a === void 0 ? void 0 : _a.call(config, _fiber.nativeNode);\n                        }\n                        else if (typeof ref_1 === \"function\") {\n                            var refCleanUp = ref_1((_b = config === null || config === void 0 ? void 0 : config.getPublicInstance) === null || _b === void 0 ? void 0 : _b.call(config, _fiber.nativeNode));\n                            if (typeof refCleanUp === \"function\") {\n                                _fiber.refCleanup = refCleanUp;\n                            }\n                        }\n                    },\n                });\n            }\n            else {\n                throw new Error(\"[@my-react/react] plain element do not have a native node\");\n            }\n        }\n        else if (include(_fiber.type, myreactReconcilerExports.NODE_TYPE.__class__)) {\n            if (_fiber.instance) {\n                cleanUp();\n                var ref_2 = _fiber.ref;\n                myreactReconcilerExports.safeCallWithCurrentFiber({\n                    fiber: _fiber,\n                    action: function safeCallSetRef() {\n                        var _a, _b;\n                        if (typeof ref_2 === \"object\" && ref_2 !== null) {\n                            ref_2.current = (_a = config === null || config === void 0 ? void 0 : config.getPublicInstance) === null || _a === void 0 ? void 0 : _a.call(config, _fiber.instance);\n                        }\n                        else if (typeof ref_2 === \"function\") {\n                            var refCleanUp = ref_2((_b = config === null || config === void 0 ? void 0 : config.getPublicInstance) === null || _b === void 0 ? void 0 : _b.call(config, _fiber.instance));\n                            if (typeof refCleanUp === \"function\") {\n                                _fiber.refCleanup = refCleanUp;\n                            }\n                        }\n                    },\n                });\n            }\n            else {\n                throw new Error(\"[@my-react/react-dom] class component do not have a instance\");\n            }\n        }\n        else {\n            console.error(\"can not set ref for current element\");\n        }\n        _fiber.patch = remove$1(_fiber.patch, PATCH_TYPE.__ref__);\n    }\n};\n/**\n * @internal\n */\nvar unsetRef = function (_fiber) {\n    if (include(_fiber.state, STATE_TYPE.__unmount__))\n        return;\n    if (_fiber.ref && include(_fiber.type, myreactReconcilerExports.NODE_TYPE.__plain__ | myreactReconcilerExports.NODE_TYPE.__class__)) {\n        var ref_3 = _fiber.ref;\n        if (typeof ref_3 === \"object\" && ref_3 !== null) {\n            ref_3.current = null;\n        }\n        else if (typeof ref_3 === \"function\") {\n            myreactReconcilerExports.safeCallWithCurrentFiber({\n                fiber: _fiber,\n                action: function safeCallClearRef() {\n                    if (_fiber.refCleanup) {\n                        _fiber.refCleanup();\n                    }\n                    else {\n                        ref_3(null);\n                    }\n                },\n            });\n        }\n    }\n};\n\nvar create = function (_dispatch, _fiber, _config) {\n    var _a, _b;\n    if (!include(_fiber.patch, PATCH_TYPE.__create__))\n        return;\n    var type = _fiber.elementType;\n    var props = _fiber.pendingProps;\n    // const rootContainerInstance = config.getPublicInstance(rootNode);\n    var rootContainerInstance = _dispatch.rootNode;\n    var hostContext = _dispatch.runtimeDom.hostContextMap.get(_fiber.parent || _fiber);\n    // TODO\n    if (include(_fiber.type, myreactReconcilerExports.NODE_TYPE.__text__)) {\n        var parent_1 = _fiber.parent;\n        var shouldNotCreate = (_config === null || _config === void 0 ? void 0 : _config.shouldSetTextContent(parent_1.elementType, parent_1.pendingProps)) || false;\n        if (!shouldNotCreate) {\n            _fiber.nativeNode = _config.createTextInstance(type, rootContainerInstance, hostContext, _fiber);\n        }\n    }\n    else if (include(_fiber.type, myreactReconcilerExports.NODE_TYPE.__plain__)) {\n        _fiber.nativeNode = _config.createInstance(type, props, rootContainerInstance, hostContext, _fiber);\n    }\n    else if (include(_fiber.type, myreactReconcilerExports.NODE_TYPE.__portal__)) {\n        var fiberContainer = _fiber;\n        var containerNode = _fiber.pendingProps[\"container\"];\n        (_a = _config.preparePortalMount) === null || _a === void 0 ? void 0 : _a.call(_config, containerNode);\n        fiberContainer.containerNode = containerNode;\n        if (process.env.NODE_ENV === \"development\")\n            (_b = containerNode.setAttribute) === null || _b === void 0 ? void 0 : _b.call(containerNode, \"portal\", \"@my-react\");\n    }\n    else {\n        throw new Error(\"current type node not supported\");\n    }\n    _fiber.memoizedProps = _fiber.pendingProps;\n    _fiber.patch = remove$1(_fiber.patch, PATCH_TYPE.__update__);\n    _fiber.patch = remove$1(_fiber.patch, PATCH_TYPE.__create__);\n};\n\nvar initialMap = function (dispatch, fiber, config) {\n    var parentFiberWithNode = null;\n    var parentFiberHostContext = null;\n    var hostContext = null;\n    if (fiber.parent) {\n        var mayFiberContainer = fiber.parent;\n        if (mayFiberContainer.containerNode) {\n            parentFiberWithNode = fiber.parent;\n        }\n        else if (include(fiber.parent.type, dispatch.runtimeRef.typeForNativeNode)) {\n            parentFiberWithNode = fiber.parent;\n        }\n        else {\n            parentFiberWithNode = dispatch.runtimeDom.elementMap.get(fiber.parent) || dispatch.rootFiber;\n        }\n        parentFiberHostContext = dispatch.runtimeDom.hostContextMap.get(parentFiberWithNode);\n        if (checkFiberWithNativeNode(dispatch, fiber)) {\n            hostContext = config.getChildHostContext(parentFiberHostContext, fiber.elementType, dispatch.rootNode, fiber);\n        }\n        else {\n            hostContext = parentFiberHostContext;\n        }\n    }\n    else {\n        hostContext = config.getRootHostContext(dispatch.rootNode);\n    }\n    if (parentFiberWithNode) {\n        dispatch.runtimeDom.elementMap.set(fiber, parentFiberWithNode);\n    }\n    dispatch.runtimeDom.hostContextMap.set(fiber, hostContext);\n};\nvar unmountMap = function (dispatch, fiber) {\n    dispatch.runtimeDom.hostContextMap.delete(fiber);\n    dispatch.runtimeDom.elementMap.delete(fiber);\n};\nvar getFiberWithNativeNode = function (fiber, transform) {\n    while (fiber) {\n        var maybeContainer = fiber;\n        if (fiber.nativeNode && exclude(fiber.state, STATE_TYPE.__unmount__))\n            return fiber;\n        if (maybeContainer.containerNode && exclude(maybeContainer.state, STATE_TYPE.__unmount__))\n            return fiber;\n        fiber = transform(fiber);\n    }\n    return null;\n};\nvar getValidParentFiberWithNode = function (_dispatch, _fiber) {\n    var parentFiberWithNode = _dispatch.runtimeDom.elementMap.get(_fiber);\n    if (!parentFiberWithNode || include(parentFiberWithNode.state, STATE_TYPE.__unmount__)) {\n        parentFiberWithNode = getFiberWithNativeNode(_fiber.parent, function (f) { return f.parent; });\n        _dispatch.runtimeDom.elementMap.set(_fiber, parentFiberWithNode);\n    }\n    return parentFiberWithNode;\n};\nvar findFiberWithNodeFromFiber = function (fiber) {\n    if (!fiber || include(fiber.state, STATE_TYPE.__unmount__))\n        return null;\n    if (include(fiber.type, myreactReconcilerExports.NODE_TYPE.__portal__))\n        return null;\n    if (fiber.nativeNode)\n        return fiber;\n    var child = fiber.child;\n    while (child) {\n        var childWithDom = findFiberWithNodeFromFiber(child);\n        if (childWithDom)\n            return childWithDom;\n        child = child.sibling;\n    }\n    return null;\n};\nvar getInsertBeforeNodeFromSibling = function (fiber) {\n    if (!fiber)\n        return null;\n    return findFiberWithNodeFromFiber(fiber) || getInsertBeforeNodeFromSibling(fiber === null || fiber === void 0 ? void 0 : fiber.sibling);\n};\nvar getInsertBeforeNodeFromSiblingAndParent = function (fiber, parentFiber) {\n    if (!fiber)\n        return null;\n    if (fiber === parentFiber)\n        return null;\n    var beforeDom = getInsertBeforeNodeFromSibling(fiber.sibling);\n    if (beforeDom)\n        return beforeDom;\n    return getInsertBeforeNodeFromSiblingAndParent(fiber.parent, parentFiber);\n};\nvar checkFiberWithNativeNode = function (dispatch, fiber) {\n    var _a;\n    var maybeContainer = fiber;\n    var maybeRoot = fiber;\n    if (include(fiber.state, STATE_TYPE.__unmount__))\n        return false;\n    if (maybeContainer.containerNode)\n        return true;\n    if ((_a = maybeRoot.renderDispatch) === null || _a === void 0 ? void 0 : _a.rootNode)\n        return true;\n    if (include(fiber.type, dispatch.runtimeRef.typeForNativeNode)) {\n        return true;\n    }\n    return false;\n};\n\nvar append$1 = function (_dispatch, _fiber, _config) {\n    var _a, _b, _c, _d, _e, _f;\n    if (!include(_fiber.patch, PATCH_TYPE.__append__))\n        return;\n    var isRender = !_dispatch.isAppMounted;\n    var parentFiberWithNode = getValidParentFiberWithNode(_dispatch, _fiber);\n    var mayFiberContainer = parentFiberWithNode;\n    if (!_fiber.nativeNode) {\n        if (include(_fiber.type, myreactReconcilerExports.NODE_TYPE.__text__)) {\n            _fiber.patch = remove$1(_fiber.patch, PATCH_TYPE.__append__);\n            return;\n        }\n        throw new Error(\"append error, current render node not have a native node\");\n    }\n    // const parentNode = config.getPublicInstance(parentFiberWithNode?.nativeNode || mayFiberContainer?.containerNode);\n    var parentNode = (parentFiberWithNode === null || parentFiberWithNode === void 0 ? void 0 : parentFiberWithNode.nativeNode) || (mayFiberContainer === null || mayFiberContainer === void 0 ? void 0 : mayFiberContainer.containerNode);\n    // const rootNode = config.getPublicInstance(this.rootNode);\n    var rootNode = _dispatch.rootNode;\n    var isContainer = !parentNode || (parentNode && parentNode === (mayFiberContainer === null || mayFiberContainer === void 0 ? void 0 : mayFiberContainer.containerNode));\n    // const currentNode = config.getPublicInstance(_fiber.nativeNode);\n    var currentNode = _fiber.nativeNode;\n    if (isRender) {\n        if (isContainer) {\n            if (_config.appendChildToContainer) {\n                (_a = _config.appendChildToContainer) === null || _a === void 0 ? void 0 : _a.call(_config, rootNode, currentNode, _fiber);\n            }\n            else {\n                (_b = _config.appendInitialChild) === null || _b === void 0 ? void 0 : _b.call(_config, rootNode, currentNode, _fiber);\n            }\n        }\n        else {\n            (_c = _config.appendInitialChild) === null || _c === void 0 ? void 0 : _c.call(_config, parentNode, currentNode, _fiber);\n        }\n    }\n    else {\n        if (isContainer) {\n            if (_config.appendChildToContainer) {\n                (_d = _config.appendChildToContainer) === null || _d === void 0 ? void 0 : _d.call(_config, rootNode, currentNode, _fiber);\n            }\n            else {\n                (_e = _config.appendChild) === null || _e === void 0 ? void 0 : _e.call(_config, rootNode, currentNode, _fiber);\n            }\n        }\n        else {\n            (_f = _config.appendChild) === null || _f === void 0 ? void 0 : _f.call(_config, parentNode, currentNode, _fiber);\n        }\n    }\n    _fiber.patch = remove$1(_fiber.patch, PATCH_TYPE.__append__);\n};\n\nvar update$1 = function (_dispatch, _fiber, _config) {\n    var _a;\n    if (!include(_fiber.patch, PATCH_TYPE.__update__))\n        return;\n    // const node = config.getPublicInstance(_fiber.nativeNode);\n    var node = _fiber.nativeNode;\n    var type = _fiber.elementType;\n    var oldProps = _fiber.memoizedProps;\n    var newProps = _fiber.pendingProps;\n    // const rootContainerInstance = config.getPublicInstance(rootNode);\n    var rootContainerInstance = _dispatch.rootNode;\n    var hostContext = _dispatch.runtimeDom.hostContextMap.get(_fiber.parent || _fiber);\n    if (include(_fiber.type, myreactReconcilerExports.NODE_TYPE.__text__)) {\n        var parent_1 = _fiber.parent;\n        var shouldNotCreate = (_config === null || _config === void 0 ? void 0 : _config.shouldSetTextContent(parent_1.elementType, parent_1.pendingProps)) || false;\n        if (!shouldNotCreate) {\n            (_a = _config.commitTextUpdate) === null || _a === void 0 ? void 0 : _a.call(_config, node, _fiber.memoizedText, _fiber.pendingText);\n        }\n    }\n    else if (include(_fiber.type, myreactReconcilerExports.NODE_TYPE.__plain__)) {\n        if (typeof _config.prepareUpdate === \"function\") {\n            var updatePayload = _config.prepareUpdate(node, type, oldProps, newProps, rootContainerInstance, hostContext, _fiber);\n            if (updatePayload) {\n                _config.commitUpdate(node, updatePayload, type, oldProps, newProps, _fiber);\n            }\n        }\n        else {\n            _config.commitUpdate(node, type, oldProps, newProps, _fiber);\n        }\n    }\n    _fiber.memoizedProps = _fiber.pendingProps;\n    _fiber.patch = remove$1(_fiber.patch, PATCH_TYPE.__update__);\n};\n\nvar remove = function (_dispatch, _fiber, _config) {\n    var _a, _b;\n    if (include(_fiber.state, STATE_TYPE.__unmount__))\n        return;\n    if (!_fiber.nativeNode)\n        return;\n    var parentFiberWithNode = getValidParentFiberWithNode(_dispatch, _fiber);\n    var maybeContainer = parentFiberWithNode;\n    // const parentNode = config.getPublicInstance(parentFiberWithNode?.nativeNode || mayFiberContainer?.containerNode);\n    var parentNode = (parentFiberWithNode === null || parentFiberWithNode === void 0 ? void 0 : parentFiberWithNode.nativeNode) || (maybeContainer === null || maybeContainer === void 0 ? void 0 : maybeContainer.containerNode);\n    // const rootNode = config.getPublicInstance(this.rootNode);\n    var rootNode = _dispatch.rootNode;\n    // const currentNode = config.getPublicInstance(_fiber.nativeNode);\n    var currentNode = _fiber.nativeNode;\n    var isContainer = !parentNode || (parentNode && parentNode === (maybeContainer === null || maybeContainer === void 0 ? void 0 : maybeContainer.containerNode));\n    if (isContainer) {\n        (_a = _config.removeChildFromContainer) === null || _a === void 0 ? void 0 : _a.call(_config, rootNode, currentNode, _fiber);\n    }\n    else {\n        (_b = _config.removeChild) === null || _b === void 0 ? void 0 : _b.call(_config, parentNode, currentNode, _fiber);\n    }\n};\n\nvar append = function (dispatch, config, fiber, parentFiberWithNode) {\n    var _a, _b, _c;\n    if (!fiber)\n        throw new Error(\"position error, look like a bug for @my-react\");\n    fiber.patch = remove$1(fiber.patch, PATCH_TYPE.__append__);\n    fiber.patch = remove$1(fiber.patch, PATCH_TYPE.__position__);\n    if (include(fiber.type, myreactReconcilerExports.NODE_TYPE.__portal__))\n        return;\n    if (include(fiber.type, myreactReconcilerExports.NODE_TYPE.__plain__ | myreactReconcilerExports.NODE_TYPE.__text__)) {\n        var maybeContainer = parentFiberWithNode;\n        var maybeFiber = parentFiberWithNode;\n        // const parentNode = config?.getPublicInstance?.(maybeFiber?.nativeNode || maybeContainer?.containerNode);\n        var parentNode = (maybeFiber === null || maybeFiber === void 0 ? void 0 : maybeFiber.nativeNode) || (maybeContainer === null || maybeContainer === void 0 ? void 0 : maybeContainer.containerNode);\n        // const rootNode = config?.getPublicInstance?.(dispatch.rootNode);\n        var rootNode = dispatch.rootNode;\n        // const childNode = config?.getPublicInstance?.(fiber.nativeNode);\n        var childNode = fiber.nativeNode;\n        var isContainer = !parentNode || (parentNode && parentNode === (maybeContainer === null || maybeContainer === void 0 ? void 0 : maybeContainer.containerNode));\n        if (isContainer) {\n            if (config.appendChildToContainer) {\n                (_a = config.appendChildToContainer) === null || _a === void 0 ? void 0 : _a.call(config, rootNode, childNode, fiber);\n            }\n            else {\n                (_b = config.appendChild) === null || _b === void 0 ? void 0 : _b.call(config, rootNode, childNode, fiber);\n            }\n        }\n        else {\n            (_c = config.appendChild) === null || _c === void 0 ? void 0 : _c.call(config, parentNode, childNode, fiber);\n        }\n        return;\n    }\n    var child = fiber.child;\n    while (child) {\n        append(dispatch, config, child, parentFiberWithNode);\n        child = child.sibling;\n    }\n};\nvar insertBefore$1 = function (dispatch, config, fiber, beforeFiberWithNode, parentFiberWithNode) {\n    var _a, _b, _c;\n    if (!fiber)\n        throw new Error(\"position error, look like a bug for @my-react\");\n    fiber.patch = remove$1(fiber.patch, PATCH_TYPE.__append__);\n    fiber.patch = remove$1(fiber.patch, PATCH_TYPE.__position__);\n    if (include(fiber.type, myreactReconcilerExports.NODE_TYPE.__portal__))\n        return;\n    if (include(fiber.type, myreactReconcilerExports.NODE_TYPE.__plain__ | myreactReconcilerExports.NODE_TYPE.__text__)) {\n        var maybeContainer = parentFiberWithNode;\n        var maybeFiber = parentFiberWithNode;\n        // const parentNode = config?.getPublicInstance?.(maybeFiber?.nativeNode || maybeContainer?.containerNode);\n        var parentNode = (maybeFiber === null || maybeFiber === void 0 ? void 0 : maybeFiber.nativeNode) || (maybeContainer === null || maybeContainer === void 0 ? void 0 : maybeContainer.containerNode);\n        // const rootNode = config?.getPublicInstance?.(dispatch.rootNode);\n        var rootNode = dispatch.rootNode;\n        // the before dom will not have containerNode\n        // const beforeNode = config?.getPublicInstance?.(beforeFiberWithNode.nativeNode);\n        var beforeNode = beforeFiberWithNode.nativeNode;\n        if (process.env.NODE_ENV === \"development\" && !beforeNode) {\n            console.error(\"not have a before node, look like a bug for @my-react\");\n        }\n        // const childNode = config?.getPublicInstance?.(fiber.nativeNode);\n        var childNode = fiber.nativeNode;\n        var isContainer = !parentNode || (parentNode && parentNode === (maybeContainer === null || maybeContainer === void 0 ? void 0 : maybeContainer.containerNode));\n        if (isContainer) {\n            if (config.insertInContainerBefore) {\n                (_a = config.insertInContainerBefore) === null || _a === void 0 ? void 0 : _a.call(config, rootNode, childNode, beforeNode, fiber);\n            }\n            else {\n                (_b = config.insertBefore) === null || _b === void 0 ? void 0 : _b.call(config, rootNode, childNode, beforeNode, fiber);\n            }\n        }\n        else {\n            (_c = config.insertBefore) === null || _c === void 0 ? void 0 : _c.call(config, parentNode, childNode, beforeNode, fiber);\n        }\n        return;\n    }\n    var child = fiber.child;\n    while (child) {\n        insertBefore$1(dispatch, config, child, beforeFiberWithNode, parentFiberWithNode);\n        child = child.sibling;\n    }\n};\nvar position = function (_dispatch, _fiber, _config) {\n    if (!include(_fiber.patch, PATCH_TYPE.__position__))\n        return;\n    var rootFiber = _dispatch.rootFiber;\n    var parentFiberWithNode = getValidParentFiberWithNode(_dispatch, _fiber);\n    var beforeFiberWithNode = getInsertBeforeNodeFromSiblingAndParent(_fiber, parentFiberWithNode || rootFiber);\n    if (beforeFiberWithNode && exclude(beforeFiberWithNode.patch, PATCH_TYPE.__append__ | PATCH_TYPE.__position__)) {\n        insertBefore$1(_dispatch, _config, _fiber, beforeFiberWithNode, parentFiberWithNode);\n    }\n    else {\n        append(_dispatch, _config, _fiber, parentFiberWithNode);\n    }\n    _fiber.patch = remove$1(_fiber.patch, PATCH_TYPE.__position__);\n};\n\nvar createPortal$1 = function (_element, _container) {\n    var portal = createElement(Portal$1, { container: _container }, _element);\n    return portal;\n};\nvar nextWorkPortal = function (renderDispatch, fiber) {\n    var typedFiber = fiber;\n    myreactReconcilerExports.nextWorkNormal(renderDispatch, fiber);\n    if (typedFiber.containerNode !== fiber.pendingProps[\"container\"]) {\n        renderDispatch.pendingCreate(fiber);\n        var child = fiber.child;\n        while (child) {\n            renderDispatch.pendingAppend(child);\n            child = child.sibling;\n        }\n    }\n};\n\nvar ReconcilerDispatchFiber = function (renderDispatch, fiber) {\n    if (include(fiber.type, myreactReconcilerExports.NODE_TYPE.__root__)) {\n        // TODO\n        myreactReconcilerExports.nextWorkRoot(renderDispatch, fiber);\n    }\n    else if (include(fiber.type, myreactReconcilerExports.NODE_TYPE.__class__ | myreactReconcilerExports.NODE_TYPE.__function__)) {\n        myreactReconcilerExports.nextWorkComponent(renderDispatch, fiber);\n    }\n    else if (include(fiber.type, myreactReconcilerExports.NODE_TYPE.__portal__)) {\n        nextWorkPortal(renderDispatch, fiber);\n    }\n    else if (include(fiber.type, myreactReconcilerExports.NODE_TYPE.__lazy__)) {\n        myreactReconcilerExports.nextWorkLazy(renderDispatch, fiber);\n    }\n    else if (include(fiber.type, myreactReconcilerExports.NODE_TYPE.__suspense__)) {\n        myreactReconcilerExports.nextWorkSuspense(renderDispatch, fiber);\n    }\n    else if (include(fiber.type, myreactReconcilerExports.NODE_TYPE.__consumer__)) {\n        myreactReconcilerExports.nextWorkConsumer(renderDispatch, fiber);\n    }\n    else if (include(fiber.type, myreactReconcilerExports.NODE_TYPE.__provider__ | myreactReconcilerExports.NODE_TYPE.__context__)) {\n        myreactReconcilerExports.nextWorkProvider(renderDispatch, fiber);\n    }\n    else if (include(fiber.type, myreactReconcilerExports.NODE_TYPE.__activity__)) {\n        myreactReconcilerExports.nextWorkActivity(renderDispatch, fiber);\n    }\n    else {\n        myreactReconcilerExports.nextWorkNormal(renderDispatch, fiber);\n    }\n};\n\nvar currentScheduler$2 = __my_react_internal__.currentScheduler;\nvar enableScopeTreeLog$3 = __my_react_shared__.enableScopeTreeLog;\nvar ReconcilerDispatchMount = function (_dispatch, _fiber, config) {\n    var pendingCommitFiberArray = [];\n    myreactReconcilerExports.beforeSyncUpdate();\n    var _list = myreactReconcilerExports.generateFiberToListWithAction(_fiber, function invokeUnmountPendingList(_fiber) {\n        myreactReconcilerExports.defaultInvokeUnmountList(_dispatch, _fiber);\n    });\n    _list.listToFoot(function invokeInsertionEffectList(_fiber) {\n        myreactReconcilerExports.insertionEffect(_dispatch, _fiber);\n    });\n    myreactReconcilerExports.afterSyncUpdate();\n    _list.listToFoot(function invokeCreateAndUpdateList(_fiber) {\n        myreactReconcilerExports.safeCallWithCurrentFiber({\n            fiber: _fiber,\n            action: function safeCallCreateAndUpdate() {\n                _dispatch.commitCreate(_fiber);\n                _dispatch.commitUpdate(_fiber);\n            },\n        });\n    });\n    _list.listToFoot(function invokeAppendList(_fiber) {\n        myreactReconcilerExports.safeCallWithCurrentFiber({\n            fiber: _fiber,\n            action: function safeCallAppendList() {\n                _dispatch.commitAppend(_fiber);\n            },\n        });\n    });\n    _list.listToFoot(function invokeSetRefList(_fiber) {\n        myreactReconcilerExports.safeCallWithCurrentFiber({\n            fiber: _fiber,\n            action: function safeCallSetRefList() {\n                _dispatch.commitSetRef(_fiber);\n            },\n        });\n    });\n    _list.listToFoot(function invokeFinalizeInitialChildren(_fiber) {\n        if (_fiber.nativeNode) {\n            var node = config.getPublicInstance(_fiber.nativeNode);\n            var type = _fiber.elementType;\n            var props = _fiber.pendingProps;\n            var rootContainerInstance = config.getPublicInstance(_dispatch.rootNode);\n            var hostContext = _dispatch.runtimeDom.hostContextMap.get(_fiber.parent || _fiber);\n            if (config.finalizeInitialChildren(node, type, props, rootContainerInstance, hostContext)) {\n                pendingCommitFiberArray.push(_fiber);\n            }\n        }\n    });\n    pendingCommitFiberArray.forEach(function invokeCommitMount(_fiber) {\n        var _a;\n        var node = config.getPublicInstance(_fiber.nativeNode);\n        var type = _fiber.elementType;\n        var props = _fiber.pendingProps;\n        (_a = config.commitMount) === null || _a === void 0 ? void 0 : _a.call(config, node, type, props, _fiber);\n    });\n    myreactReconcilerExports.beforeSyncUpdate();\n    _list.listToFoot(function invokeLayoutEffectList(_fiber) {\n        myreactReconcilerExports.layoutEffect(_dispatch, _fiber);\n    });\n    myreactReconcilerExports.afterSyncUpdate();\n    function invokeEffectListTask() {\n        process.env.NODE_ENV === \"development\" && enableScopeTreeLog$3.current && myreactReconcilerExports.setLogScope();\n        _list.listToFoot(function invokeEffectList(_fiber) {\n            myreactReconcilerExports.effect(_dispatch, _fiber);\n        });\n        process.env.NODE_ENV === \"development\" && enableScopeTreeLog$3.current && myreactReconcilerExports.resetLogScope();\n    }\n    myreactReconcilerExports.addEffectCallback(invokeEffectListTask);\n    var renderScheduler = currentScheduler$2.current;\n    renderScheduler.macroTask(function flushEffect() {\n        myreactReconcilerExports.flushEffectCallback();\n    });\n};\n\nvar currentScheduler$1 = __my_react_internal__.currentScheduler;\nvar enableScopeTreeLog$2 = __my_react_shared__.enableScopeTreeLog;\nvar ReconcilerDispatchUpdate = function (_dispatch, _list, config, sync) {\n    myreactReconcilerExports.beforeSyncUpdate();\n    _list.listToFoot(function invokeUnmountPendingAndInsertionEffectList(_fiber) {\n        if (exclude(_fiber.state, STATE_TYPE.__unmount__) && !_dispatch.isAppUnmounted) {\n            myreactReconcilerExports.defaultInvokeUnmountList(_dispatch, _fiber);\n        }\n    });\n    _list.listToFoot(function invokeUnmountPendingAndInsertionEffectList(_fiber) {\n        if (exclude(_fiber.state, STATE_TYPE.__unmount__) && !_dispatch.isAppUnmounted) {\n            myreactReconcilerExports.insertionEffect(_dispatch, _fiber);\n        }\n    });\n    myreactReconcilerExports.afterSyncUpdate();\n    var pendingFinalizeInitialChildrenFiberSet = new Set();\n    var pendingCommitFiberArray = [];\n    _list.listToFoot(function invokeCreateAndUpdateList(_fiber) {\n        if (exclude(_fiber.state, STATE_TYPE.__unmount__) && !_dispatch.isAppUnmounted) {\n            var beforeHasNode = _fiber.nativeNode;\n            myreactReconcilerExports.safeCallWithCurrentFiber({\n                fiber: _fiber,\n                action: function safeCallCreateAndUpdate() {\n                    _dispatch.commitCreate(_fiber);\n                    _dispatch.commitUpdate(_fiber);\n                },\n            });\n            var afterHasNode = _fiber.nativeNode;\n            if (!beforeHasNode && afterHasNode) {\n                pendingFinalizeInitialChildrenFiberSet.add(_fiber);\n            }\n        }\n    });\n    _list.listToHead(function invokePositionList(_fiber) {\n        if (exclude(_fiber.state, STATE_TYPE.__unmount__) && !_dispatch.isAppUnmounted) {\n            myreactReconcilerExports.safeCallWithCurrentFiber({\n                fiber: _fiber,\n                action: function safeCallPosition() {\n                    _dispatch.commitPosition(_fiber);\n                    var parentFiber = getValidParentFiberWithNode(_dispatch, _fiber);\n                    parentFiber && pendingFinalizeInitialChildrenFiberSet.add(parentFiber);\n                },\n            });\n        }\n    });\n    _list.listToFoot(function invokeAppendList(_fiber) {\n        if (exclude(_fiber.state, STATE_TYPE.__unmount__) && !_dispatch.isAppUnmounted) {\n            myreactReconcilerExports.safeCallWithCurrentFiber({\n                fiber: _fiber,\n                action: function safeCallAppendList() {\n                    _dispatch.commitAppend(_fiber);\n                    var parentFiber = getValidParentFiberWithNode(_dispatch, _fiber);\n                    parentFiber && pendingFinalizeInitialChildrenFiberSet.add(parentFiber);\n                },\n            });\n        }\n    });\n    _list.listToFoot(function invokeSetRefList(_fiber) {\n        if (exclude(_fiber.state, STATE_TYPE.__unmount__) && !_dispatch.isAppUnmounted) {\n            myreactReconcilerExports.safeCallWithCurrentFiber({\n                fiber: _fiber,\n                action: function safeCallSetRefList() {\n                    _dispatch.commitSetRef(_fiber);\n                },\n            });\n        }\n    });\n    pendingFinalizeInitialChildrenFiberSet.forEach(function invokeFinalizeInitialChildren(_fiber) {\n        if (_fiber.nativeNode) {\n            var node = config.getPublicInstance(_fiber.nativeNode);\n            var type = _fiber.elementType;\n            var props = _fiber.pendingProps;\n            var rootContainerInstance = config.getPublicInstance(_dispatch.rootNode);\n            var hostContext = _dispatch.runtimeDom.hostContextMap.get(_fiber.parent || _fiber);\n            if (config.finalizeInitialChildren(node, type, props, rootContainerInstance, hostContext)) {\n                pendingCommitFiberArray.push(_fiber);\n            }\n        }\n    });\n    pendingCommitFiberArray.forEach(function invokeCommitMount(_fiber) {\n        var _a;\n        var node = config.getPublicInstance(_fiber.nativeNode);\n        var type = _fiber.elementType;\n        var props = _fiber.pendingProps;\n        (_a = config.commitMount) === null || _a === void 0 ? void 0 : _a.call(config, node, type, props, _fiber);\n    });\n    myreactReconcilerExports.beforeSyncUpdate();\n    _list.listToFoot(function invokeLayoutEffectList(_fiber) {\n        if (exclude(_fiber.state, STATE_TYPE.__unmount__) && !_dispatch.isAppUnmounted) {\n            myreactReconcilerExports.layoutEffect(_dispatch, _fiber);\n        }\n    });\n    myreactReconcilerExports.afterSyncUpdate();\n    function invokeEffectListTask() {\n        process.env.NODE_ENV === \"development\" && enableScopeTreeLog$2.current && myreactReconcilerExports.setLogScope();\n        _list.listToFoot(function invokeEffectList(_fiber) {\n            if (exclude(_fiber.state, STATE_TYPE.__unmount__) && !_dispatch.isAppUnmounted) {\n                myreactReconcilerExports.effect(_dispatch, _fiber);\n            }\n        });\n        process.env.NODE_ENV === \"development\" && enableScopeTreeLog$2.current && myreactReconcilerExports.resetLogScope();\n    }\n    myreactReconcilerExports.addEffectCallback(invokeEffectListTask);\n    var renderScheduler = currentScheduler$1.current;\n    if (_dispatch.enableConcurrentMode && !sync) {\n        renderScheduler.macroTask(function flushEffect() {\n            myreactReconcilerExports.flushEffectCallback();\n        });\n    }\n    else {\n        renderScheduler.microTask(function flushEffect() {\n            myreactReconcilerExports.flushEffectCallback();\n        });\n    }\n};\n\nvar currentComponentFiber = __my_react_internal__.currentComponentFiber;\nvar initialRef = {\n    typeForRef: myreactReconcilerExports.NODE_TYPE.__plain__ | myreactReconcilerExports.NODE_TYPE.__class__,\n    typeForCreate: myreactReconcilerExports.NODE_TYPE.__text__ | myreactReconcilerExports.NODE_TYPE.__plain__ | myreactReconcilerExports.NODE_TYPE.__portal__,\n    typeForUpdate: myreactReconcilerExports.NODE_TYPE.__text__ | myreactReconcilerExports.NODE_TYPE.__plain__,\n    typeForAppend: myreactReconcilerExports.NODE_TYPE.__text__ | myreactReconcilerExports.NODE_TYPE.__plain__,\n    typeForNativeNode: myreactReconcilerExports.NODE_TYPE.__text__ | myreactReconcilerExports.NODE_TYPE.__plain__ | myreactReconcilerExports.NODE_TYPE.__portal__,\n};\nvar createDispatch = function (rootNode, rootFiber, rootElement, config, flag) {\n    var ReconcilerDispatch = /** @class */ (function (_super) {\n        __extends(ReconcilerDispatch, _super);\n        function ReconcilerDispatch() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.enableUpdate = true;\n            _this.enableAsyncLoad = true;\n            _this.runtimeDom = {\n                hostContextMap: new WeakMap(),\n                elementMap: new WeakMap(),\n            };\n            _this.runtimeRef = initialRef;\n            return _this;\n        }\n        ReconcilerDispatch.prototype.dispatchFiber = function (_fiber) {\n            ReconcilerDispatchFiber(this, _fiber);\n        };\n        ReconcilerDispatch.prototype.commitCreate = function (_fiber) {\n            create(this, _fiber, config);\n        };\n        ReconcilerDispatch.prototype.commitUpdate = function (_fiber) {\n            update$1(this, _fiber, config);\n        };\n        ReconcilerDispatch.prototype.commitAppend = function (_fiber) {\n            append$1(this, _fiber, config);\n        };\n        ReconcilerDispatch.prototype.commitPosition = function (_fiber) {\n            position(this, _fiber, config);\n        };\n        ReconcilerDispatch.prototype.commitSetRef = function (_fiber) {\n            setRef(_fiber, config);\n        };\n        ReconcilerDispatch.prototype.commitUnsetRef = function (_fiber) {\n            unsetRef(_fiber);\n        };\n        ReconcilerDispatch.prototype.commitClear = function (_fiber) {\n            remove(this, _fiber, config);\n        };\n        ReconcilerDispatch.prototype.reconcileCommit = function (_fiber) {\n            var _a, _b;\n            (_a = config.prepareForCommit) === null || _a === void 0 ? void 0 : _a.call(config, rootNode);\n            var instance = this;\n            myreactReconcilerExports.safeCall(function safeCallBeforeCommit() {\n                var _a;\n                (_a = instance.beforeCommit) === null || _a === void 0 ? void 0 : _a.call(instance);\n            });\n            myreactReconcilerExports.safeCall(function safeCallBeforeCommitListener() {\n                instance.callOnBeforeCommitMount(instance);\n            });\n            ReconcilerDispatchMount(this, _fiber, config);\n            myreactReconcilerExports.safeCall(function safeCallAfterCommitListener() {\n                instance.callOnAfterCommitMount(instance);\n            });\n            myreactReconcilerExports.safeCall(function safeCallAfterCommit() {\n                var _a;\n                (_a = instance.afterCommit) === null || _a === void 0 ? void 0 : _a.call(instance);\n            });\n            (_b = config.resetAfterCommit) === null || _b === void 0 ? void 0 : _b.call(config, rootNode);\n        };\n        ReconcilerDispatch.prototype.reconcileUpdate = function (_list, sync) {\n            var _a, _b;\n            (_a = config.prepareForCommit) === null || _a === void 0 ? void 0 : _a.call(config, rootNode);\n            var instance = this;\n            myreactReconcilerExports.safeCall(function safeCallBeforeUpdate() {\n                var _a;\n                (_a = instance.beforeUpdate) === null || _a === void 0 ? void 0 : _a.call(instance);\n            });\n            myreactReconcilerExports.safeCall(function safeCallBeforeUpdateListener() {\n                instance.callOnBeforeCommitUpdate(instance);\n            });\n            ReconcilerDispatchUpdate(this, _list, config, sync);\n            myreactReconcilerExports.safeCall(function safeCallAfterUpdateListener() {\n                instance.callOnAfterCommitUpdate(instance);\n            });\n            myreactReconcilerExports.safeCall(function safeCallAfterUpdate() {\n                var _a;\n                (_a = instance.afterUpdate) === null || _a === void 0 ? void 0 : _a.call(instance);\n            });\n            (_b = config.resetAfterCommit) === null || _b === void 0 ? void 0 : _b.call(config, rootNode);\n        };\n        ReconcilerDispatch.prototype.patchToFiberInitial = function (_fiber) {\n            initialMap(this, _fiber, config);\n        };\n        ReconcilerDispatch.prototype.patchToFiberUnmount = function (_fiber) {\n            unmountMap(this, _fiber);\n        };\n        ReconcilerDispatch.prototype.dispatchState = function (_params) {\n            return myreactReconcilerExports.processState(this, _params);\n        };\n        ReconcilerDispatch.prototype.dispatchHook = function (_params) {\n            return myreactReconcilerExports.processHook(this, _params);\n        };\n        ReconcilerDispatch.prototype.dispatchPromise = function (_params) {\n            return myreactReconcilerExports.processPromise(this, _params.fiber, _params.promise);\n        };\n        ReconcilerDispatch.prototype.dispatchSuspensePromise = function (_params) {\n            return myreactReconcilerExports.processSuspensePromise(this, _params.fiber, _params.promise);\n        };\n        ReconcilerDispatch.prototype.dispatchError = function (_params) {\n            if (process.env.NODE_ENV === \"development\") {\n                myreactReconcilerExports.devErrorWithFiber(_params.fiber, _params.error);\n            }\n            myreactReconcilerExports.triggerError(this, _params.fiber, _params.error);\n            return void 0;\n        };\n        return ReconcilerDispatch;\n    }(myreactReconcilerExports.CustomRenderDispatch));\n    if (process.env.NODE_ENV === \"development\") {\n        Object.defineProperty(ReconcilerDispatch.prototype, \"__dev_hmr_runtime__\", {\n            value: {\n                hmr: myreactReconcilerExports.hmr,\n                typeToFibersMap: myreactReconcilerExports.typeToFibersMap,\n                setRefreshHandler: myreactReconcilerExports.setRefreshHandler,\n                currentComponentFiber: currentComponentFiber,\n                getCurrentFibersFromType: myreactReconcilerExports.getCurrentFibersFromType,\n                getCurrentDispatchFromType: myreactReconcilerExports.getCurrentDispatchFromType,\n                getCurrentDispatchFromFiber: myreactReconcilerExports.getCurrentDispatchFromFiber,\n            },\n        });\n        Object.defineProperty(ReconcilerDispatch.prototype, \"__dev_hmr_remount__\", {\n            value: function hmrRemount(cb) {\n                console.log(\"not implement yet\");\n                cb === null || cb === void 0 ? void 0 : cb();\n            },\n        });\n    }\n    var dispatch = new ReconcilerDispatch(rootNode, rootFiber, rootElement);\n    dispatch.enableConcurrentMode = flag !== 0;\n    dispatch.renderMode = flag !== 0 ? \"concurrent\" : \"legacy\";\n    return dispatch;\n};\n\nvar DEV_REFRESH_FIELD = \"__@my-react/react-refresh-inject__\";\nvar autoSetDevHMR = function (dispatch) {\n    if (process.env.NODE_ENV === \"development\") {\n        if (typeof globalThis !== \"undefined\" && globalThis[DEV_REFRESH_FIELD]) {\n            try {\n                var typedRuntimeField = globalThis[DEV_REFRESH_FIELD];\n                typedRuntimeField === null || typedRuntimeField === void 0 ? void 0 : typedRuntimeField(dispatch);\n            }\n            catch (_a) {\n            }\n        }\n    }\n};\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable @typescript-eslint/ban-ts-comment */\nfunction loadRemoteScript(url, options) {\n    if (options === void 0) { options = {}; }\n    return __awaiter(this, void 0, void 0, function () {\n        var _a, timeout, _b, context, _c, useEval, controller_1, timeoutId, response, code, error_1, errorMsg;\n        return __generator(this, function (_d) {\n            switch (_d.label) {\n                case 0:\n                    _a = options.timeout, timeout = _a === void 0 ? 10000 : _a, _b = options.context, context = _b === void 0 ? {} : _b, _c = options.useEval, useEval = _c === void 0 ? false : _c;\n                    _d.label = 1;\n                case 1:\n                    _d.trys.push([1, 5, , 6]);\n                    controller_1 = new AbortController();\n                    timeoutId = setTimeout(function () { return controller_1.abort(); }, timeout);\n                    return [4 /*yield*/, fetch(url, {\n                            signal: controller_1.signal,\n                        })];\n                case 2:\n                    response = _d.sent();\n                    if (!response.ok) {\n                        throw new Error(\"HTTP \".concat(response.status, \": \").concat(response.statusText));\n                    }\n                    return [4 /*yield*/, response.text()];\n                case 3:\n                    code = _d.sent();\n                    clearTimeout(timeoutId);\n                    // \n                    return [4 /*yield*/, executeScript(code, url, { context: context, useEval: useEval })];\n                case 4:\n                    // \n                    _d.sent();\n                    return [3 /*break*/, 6];\n                case 5:\n                    error_1 = _d.sent();\n                    if ((error_1 === null || error_1 === void 0 ? void 0 : error_1.name) === \"AbortError\") {\n                        throw new Error(\"\\u52A0\\u8F7D\\u8FDC\\u7A0B\\u811A\\u672C\\u8D85\\u65F6 (\".concat(timeout, \"ms)\"));\n                    }\n                    errorMsg = (error_1 === null || error_1 === void 0 ? void 0 : error_1.message) || String(error_1);\n                    throw new Error(\"\\u52A0\\u8F7D\\u8FDC\\u7A0B\\u811A\\u672C\\u5931\\u8D25: \".concat(errorMsg));\n                case 6: return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction executeScript(code, url, options) {\n    return __awaiter(this, void 0, void 0, function () {\n        var _a, context, _b, useEval, env, _c;\n        return __generator(this, function (_d) {\n            switch (_d.label) {\n                case 0:\n                    _a = options.context, context = _a === void 0 ? {} : _a, _b = options.useEval, useEval = _b === void 0 ? false : _b;\n                    env = detectEnvironment();\n                    _c = env;\n                    switch (_c) {\n                        case \"bun\": return [3 /*break*/, 1];\n                        case \"node\": return [3 /*break*/, 3];\n                        case \"browser\": return [3 /*break*/, 5];\n                    }\n                    return [3 /*break*/, 7];\n                case 1: return [4 /*yield*/, executeInBun(code, url, context)];\n                case 2:\n                    _d.sent();\n                    return [3 /*break*/, 8];\n                case 3: return [4 /*yield*/, executeInNode(code, url, context)];\n                case 4:\n                    _d.sent();\n                    return [3 /*break*/, 8];\n                case 5: return [4 /*yield*/, executeInBrowser(code, url, context, useEval)];\n                case 6:\n                    _d.sent();\n                    return [3 /*break*/, 8];\n                case 7: throw new Error(\" JavaScript \");\n                case 8: return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction detectEnvironment() {\n    //  Bun\n    // @ts-ignore\n    if (typeof Bun !== \"undefined\" && typeof Bun === \"object\") {\n        return \"bun\";\n    }\n    //  Node.js\n    if (typeof process !== \"undefined\" && process.versions && process.versions.node) {\n        return \"node\";\n    }\n    // \n    if (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\n        return \"browser\";\n    }\n    // \n    return \"browser\";\n}\n//  Base64 \nfunction safeBase64Encode(str) {\n    // Node.js \n    if (typeof Buffer !== \"undefined\") {\n        return Buffer.from(str, \"utf-8\").toString(\"base64\");\n    }\n    // \n    if (typeof btoa !== \"undefined\") {\n        //  Unicode \n        var utf8Bytes_1 = new TextEncoder().encode(str);\n        var binary = \"\";\n        for (var i = 0; i < utf8Bytes_1.length; i++) {\n            binary += String.fromCharCode(utf8Bytes_1[i]);\n        }\n        return btoa(binary);\n    }\n    //  Base64 \n    var base64Chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    var utf8Bytes = new TextEncoder().encode(str);\n    var result = \"\";\n    for (var i = 0; i < utf8Bytes.length; i += 3) {\n        var a = utf8Bytes[i];\n        var b = i + 1 < utf8Bytes.length ? utf8Bytes[i + 1] : 0;\n        var c = i + 2 < utf8Bytes.length ? utf8Bytes[i + 2] : 0;\n        var bitmap = (a << 16) | (b << 8) | c;\n        result += base64Chars[(bitmap >> 18) & 63];\n        result += base64Chars[(bitmap >> 12) & 63];\n        result += i + 1 < utf8Bytes.length ? base64Chars[(bitmap >> 6) & 63] : \"=\";\n        result += i + 2 < utf8Bytes.length ? base64Chars[bitmap & 63] : \"=\";\n    }\n    return result;\n}\n// Bun \nfunction executeInBun(code, url, context) {\n    return __awaiter(this, void 0, void 0, function () {\n        var base64Code, dataUrl;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _a.trys.push([0, 2, , 4]);\n                    base64Code = safeBase64Encode(code);\n                    dataUrl = \"data:application/javascript;base64,\".concat(base64Code);\n                    return [4 /*yield*/, import(/* @vite-ignore */ dataUrl)];\n                case 1:\n                    _a.sent();\n                    return [2 /*return*/];\n                case 2:\n                    _a.sent();\n                    // 2:  VM \n                    return [4 /*yield*/, executeWithVM(code, url, context)];\n                case 3:\n                    // 2:  VM \n                    _a.sent();\n                    return [3 /*break*/, 4];\n                case 4: return [2 /*return*/];\n            }\n        });\n    });\n}\n// Node.js \nfunction executeInNode(code, url, context) {\n    return __awaiter(this, void 0, void 0, function () {\n        var error_3, base64Code, dataUrl, importError_1, errorMsg, importErrorMsg;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _a.trys.push([0, 2, , 7]);\n                    // 1:  VM \n                    return [4 /*yield*/, executeWithVM(code, url, context)];\n                case 1:\n                    // 1:  VM \n                    _a.sent();\n                    return [3 /*break*/, 7];\n                case 2:\n                    error_3 = _a.sent();\n                    _a.label = 3;\n                case 3:\n                    _a.trys.push([3, 5, , 6]);\n                    base64Code = safeBase64Encode(code);\n                    dataUrl = \"data:application/javascript;base64,\".concat(base64Code);\n                    return [4 /*yield*/, import(/* @vite-ignore */ dataUrl)];\n                case 4:\n                    _a.sent();\n                    return [3 /*break*/, 6];\n                case 5:\n                    importError_1 = _a.sent();\n                    errorMsg = (error_3 === null || error_3 === void 0 ? void 0 : error_3.message) || String(error_3);\n                    importErrorMsg = (importError_1 === null || importError_1 === void 0 ? void 0 : importError_1.message) || String(importError_1);\n                    throw new Error(\"Node.js \\u6267\\u884C\\u5931\\u8D25: \".concat(errorMsg, \", \").concat(importErrorMsg));\n                case 6: return [3 /*break*/, 7];\n                case 7: return [2 /*return*/];\n            }\n        });\n    });\n}\n// \nfunction executeInBrowser(code, url, context, useEval) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    // \n                    if (!useEval && isPotentiallyUnsafe(code)) {\n                        throw new Error(\" useEval: true\");\n                    }\n                    _a.label = 1;\n                case 1:\n                    _a.trys.push([1, 3, , 4]);\n                    // 1:  script  ()\n                    return [4 /*yield*/, executeWithScriptTag(code)];\n                case 2:\n                    // 1:  script  ()\n                    _a.sent();\n                    return [3 /*break*/, 4];\n                case 3:\n                    _a.sent();\n                    // 2:  eval ()\n                    if (useEval) {\n                        executeWithEval(code, context);\n                    }\n                    else {\n                        throw new Error(\" useEval  CSP \");\n                    }\n                    return [3 /*break*/, 4];\n                case 4: return [2 /*return*/];\n            }\n        });\n    });\n}\n//  VM  (Node.js/Bun)\nfunction executeWithVM(code, url, context) {\n    return __awaiter(this, void 0, void 0, function () {\n        var vm, sandbox, vmContext, script, error_5, errorMsg;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _a.trys.push([0, 2, , 3]);\n                    return [4 /*yield*/, import('vm')];\n                case 1:\n                    vm = _a.sent();\n                    sandbox = __assign(__assign(__assign({ \n                        // \n                        console: console, setTimeout: setTimeout, setInterval: setInterval, clearTimeout: clearTimeout, clearInterval: clearInterval, URL: URL, URLSearchParams: URLSearchParams, \n                        // \n                        Object: Object, Array: Array, String: String, Number: Number, Boolean: Boolean, Symbol: Symbol, Date: Date, RegExp: RegExp, Error: Error, TypeError: TypeError, RangeError: RangeError, SyntaxError: SyntaxError, Map: Map, Set: Set, WeakMap: WeakMap, WeakSet: WeakSet, Promise: Promise, JSON: JSON, Math: Math }, (typeof global !== \"undefined\" ? { global: global } : {})), (typeof process !== \"undefined\" ? { process: process } : {})), context);\n                    vmContext = vm.createContext(sandbox);\n                    script = new vm.Script(code, {\n                        filename: url,\n                        lineOffset: 0,\n                        columnOffset: 0,\n                    });\n                    script.runInContext(vmContext);\n                    return [3 /*break*/, 3];\n                case 2:\n                    error_5 = _a.sent();\n                    errorMsg = (error_5 === null || error_5 === void 0 ? void 0 : error_5.message) || String(error_5);\n                    throw new Error(\"VM \\u6267\\u884C\\u5931\\u8D25: \".concat(errorMsg));\n                case 3: return [2 /*return*/];\n            }\n        });\n    });\n}\n//  script \nfunction executeWithScriptTag(code, url) {\n    // \n    if (typeof document === \"undefined\") {\n        throw new Error(\"document \");\n    }\n    return new Promise(function (resolve, reject) {\n        //  script \n        var script = document.createElement(\"script\");\n        //  Blob URL  CSP \n        var blob = new Blob([code], { type: \"application/javascript\" });\n        var blobUrl = URL.createObjectURL(blob);\n        script.src = blobUrl;\n        // \n        var cleanup = function () {\n            URL.revokeObjectURL(blobUrl);\n            //  DOM  script \n            if (script.parentNode) {\n                script.parentNode.removeChild(script);\n            }\n        };\n        // \n        script.onerror = function () {\n            cleanup();\n            reject(new Error(\"Script \"));\n        };\n        script.onload = function () {\n            cleanup();\n            resolve();\n        };\n        //  DOM\n        document.head.appendChild(script);\n    });\n}\n//  eval \nfunction executeWithEval(code, context) {\n    // \n    var contextKeys = Object.keys(context);\n    var contextValues = Object.values(context);\n    try {\n        //  Function  eval \n        var func = new (Function.bind.apply(Function, __spreadArray(__spreadArray([void 0], contextKeys, false), [\"\\n      \\\"use strict\\\";\\n      \".concat(code, \"\\n    \")], false)))();\n        func.apply(void 0, contextValues);\n    }\n    catch (error) {\n        //  eval\n        try {\n            var indirectEval = eval;\n            indirectEval(code);\n        }\n        catch (evalError) {\n            var errorMsg = (evalError === null || evalError === void 0 ? void 0 : evalError.message) || String(evalError);\n            throw new Error(\"Eval \\u6267\\u884C\\u5931\\u8D25: \".concat(errorMsg));\n        }\n    }\n}\n// \nfunction isPotentiallyUnsafe(code) {\n    var unsafePatterns = [\n        // Cookie \n        /document\\.cookie/i,\n        /localStorage/i,\n        /sessionStorage/i,\n        /indexedDB/i,\n        // \n        /\\beval\\s*\\(/i,\n        /Function\\s*\\(/i,\n        /setTimeout\\s*\\(\\s*[\"'`]/i, // setTimeout with string\n        /setInterval\\s*\\(\\s*[\"'`]/i, // setInterval with string\n        //  DOM \n        /script\\.src/i,\n        /\\.innerHTML/i,\n        /\\.outerHTML/i,\n        /document\\.write/i,\n        /document\\.writeln/i,\n        // \n        /\\[[\"'`]eval[\"'`]\\]/i,\n        /\\[[\"'`]cookie[\"'`]\\]/i,\n        /\\[[\"'`]localStorage[\"'`]\\]/i,\n        // import() \n        /import\\s*\\(/i,\n        //  DOM API\n        /\\.insertAdjacentHTML/i,\n        /createContextualFragment/i,\n    ];\n    return unsafePatterns.some(function (pattern) { return pattern.test(code); });\n}\n//  require \nfunction createSafeRequire() {\n    if (typeof require !== \"undefined\") {\n        return require;\n    }\n    //  require\n    return function (id) {\n        throw new Error(\"require('\".concat(id, \"') \\u5728\\u6D4F\\u89C8\\u5668\\u73AF\\u5883\\u4E2D\\u4E0D\\u53EF\\u7528\"));\n    };\n}\n// \nfunction loadRemoteModule(url, options) {\n    if (options === void 0) { options = {}; }\n    return __awaiter(this, void 0, void 0, function () {\n        var _a, context, moduleExports, moduleContext;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    _a = options.context, context = _a === void 0 ? {} : _a;\n                    moduleExports = {};\n                    moduleContext = __assign({ exports: moduleExports, module: { exports: moduleExports }, require: createSafeRequire() }, context);\n                    return [4 /*yield*/, loadRemoteScript(url, __assign(__assign({}, options), { context: moduleContext }))];\n                case 1:\n                    _b.sent();\n                    return [2 /*return*/, moduleContext.module.exports];\n            }\n        });\n    });\n}\n\nvar enableDebugFiled$1 = __my_react_shared__.enableDebugFiled, enableScopeTreeLog$1 = __my_react_shared__.enableScopeTreeLog;\n/**\n * @internal\n */\nvar prepareScheduler = function () {\n    enableDebugFiled$1.current = true;\n    enableScopeTreeLog$1.current = true;\n    myreactReconcilerExports.enableFiberForLog.current = true;\n    myreactReconcilerExports.enableValidMyReactElement.current = false;\n    myreactReconcilerExports.initScheduler();\n};\n\nvar enableDebugFiled = __my_react_shared__.enableDebugFiled, enableScopeTreeLog = __my_react_shared__.enableScopeTreeLog;\nvar currentScheduler = __my_react_internal__.currentScheduler;\n// react-reconciler compat implementation\nvar Reconciler = function (_config) {\n    var rendererPackageName = \"@my-react\";\n    var ReconcilerSet = new Set();\n    var createContainer = function (_container, flag) {\n        prepareScheduler();\n        if (flag === 0) {\n            // legacy mode\n            _container.__flag__ = 0;\n        }\n        else {\n            // concurrent mode\n            _container.__flag__ = 1;\n        }\n        enableDebugFiled.current = process.env.NODE_ENV === \"development\";\n        enableScopeTreeLog.current = false;\n        myreactReconcilerExports.enableFiberForLog.current = false;\n        return _container;\n    };\n    var updateContainer = function (_element, _container, _ignore, _cb) {\n        var renderDispatch = _container.__container__;\n        var renderScheduler = currentScheduler.current;\n        if (renderDispatch instanceof myreactReconcilerExports.CustomRenderDispatch) {\n            var _fiber_1 = _container.__fiber__;\n            if (renderDispatch.isAppCrashed || include(_fiber_1.state, STATE_TYPE.__unmount__)) {\n                // is there are not a valid render tree, try do the pure rerender\n                _container.__fiber__ = null;\n                _container.__container__ = null;\n                updateContainer(_element, _container, _config, _cb);\n                return;\n            }\n            if (myreactReconcilerExports.checkIsSameType(_fiber_1, _element)) {\n                _fiber_1._installElement(_element);\n                myreactReconcilerExports.triggerUpdateOnFiber(_fiber_1, STATE_TYPE.__triggerSync__, _cb);\n                return;\n            }\n            myreactReconcilerExports.unmountContainer(renderDispatch);\n            ReconcilerSet.delete(renderDispatch);\n            renderScheduler.dispatchSet.uniDelete(renderDispatch);\n            delGlobalDispatch(renderDispatch);\n        }\n        var _fiber = new myreactReconcilerExports.MyReactFiberNode(_element);\n        var _renderDispatch = createDispatch(_container, _fiber, _element, _config, _container.__flag__);\n        _cb && _renderDispatch.pendingEffect(_fiber, _cb);\n        ReconcilerSet.add(_renderDispatch);\n        renderScheduler.dispatchSet.uniPush(_renderDispatch);\n        _renderDispatch.renderPackage = rendererPackageName;\n        _container.__fiber__ = _fiber;\n        _container.__container__ = _renderDispatch;\n        autoSetDevTools(_renderDispatch);\n        autoSetDevHMR(_renderDispatch);\n        myreactReconcilerExports.initialFiberNode(_renderDispatch, _fiber);\n        myreactReconcilerExports.mountSync(_renderDispatch, _fiber);\n        _renderDispatch.isAppMounted = true;\n    };\n    var injectIntoDevTools = function (_config) { return __awaiter(void 0, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    rendererPackageName = _config.rendererPackageName || rendererPackageName;\n                    ReconcilerSet.forEach(function (renderDispatch) { return (renderDispatch.renderPackage = rendererPackageName); });\n                    if (globalThis[\"__MY_REACT_DEVTOOL_INTERNAL__\"])\n                        return [2 /*return*/];\n                    // load core runtime\n                    // await loadScript(\"https://mrwangjusttodo.github.io/myreact-devtools/bundle/hook.js\");\n                    return [4 /*yield*/, loadRemoteModule(\"https://mrwangjusttodo.github.io/myreact-devtools/bundle/hook.js\", { context: { globalThis: globalThis } })];\n                case 1:\n                    // load core runtime\n                    // await loadScript(\"https://mrwangjusttodo.github.io/myreact-devtools/bundle/hook.js\");\n                    _a.sent();\n                    return [2 /*return*/];\n            }\n        });\n    }); };\n    var injectIntoDevToolsWithSocketIO = function (url, _config) { return __awaiter(void 0, void 0, void 0, function () {\n        var init;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0: \n                // load core runtime\n                return [4 /*yield*/, injectIntoDevTools(_config || {})];\n                case 1:\n                    // load core runtime\n                    _b.sent();\n                    init = globalThis[\"__MY_REACT_DEVTOOL_NODE__\"];\n                    _b.label = 2;\n                case 2:\n                    _b.trys.push([2, 4, , 5]);\n                    return [4 /*yield*/, init(url)];\n                case 3:\n                    _b.sent();\n                    return [3 /*break*/, 5];\n                case 4:\n                    _b.sent();\n                    return [3 /*break*/, 5];\n                case 5: return [2 /*return*/];\n            }\n        });\n    }); };\n    var getPublicRootInstance = function (_container) {\n        return _container.__container__;\n    };\n    return {\n        createPortal: createPortal$1,\n        createContainer: createContainer,\n        updateContainer: updateContainer,\n        injectIntoDevTools: injectIntoDevTools,\n        getPublicRootInstance: getPublicRootInstance,\n        injectIntoDevToolsWithSocketIO: injectIntoDevToolsWithSocketIO,\n        flushSync: myreactReconcilerExports.safeCallWithSync,\n        flushSyncWork: myreactReconcilerExports.safeCallWithSync,\n        batchedUpdates: myreactReconcilerExports.safeCallWithSync,\n    };\n};\nvar createReconciler$1 = Reconciler;\n\n/* eslint-disable @typescript-eslint/ban-ts-comment */\n/* eslint-disable @typescript-eslint/no-empty-object-type */\n/* eslint-disable @typescript-eslint/no-unsafe-function-type */\n/* eslint-disable max-lines */\n/* eslint-disable @typescript-eslint/no-non-null-asserted-optional-chain */\n// type Fiber = Omit<Reconciler.Fiber, \"alternate\"> & { refCleanup: null | (() => void); alternate: Fiber | null };\nfunction createReconciler(config) {\n    const reconciler = createReconciler$1(config);\n    reconciler.injectIntoDevTools({\n        bundleType: typeof process !== \"undefined\" && process.env.NODE_ENV !== \"production\" ? 1 : 0,\n        rendererPackageName: \"@react-three/fiber\",\n        version: React.version,\n    });\n    return reconciler;\n}\nconst NoEventPriority = 0;\nconst catalogue = {};\nconst PREFIX_REGEX = /^three(?=[A-Z])/;\nconst toPascalCase = (type) => `${type[0].toUpperCase()}${type.slice(1)}`;\nlet i = 0;\nconst isConstructor = (object) => typeof object === \"function\";\nfunction extend(objects) {\n    if (isConstructor(objects)) {\n        const Component = `${i++}`;\n        catalogue[Component] = objects;\n        return Component;\n    }\n    else {\n        Object.assign(catalogue, objects);\n    }\n}\nfunction validateInstance(type, props) {\n    // Get target from catalogue\n    const name = toPascalCase(type);\n    const target = catalogue[name];\n    // Validate element target\n    if (type !== \"primitive\" && !target)\n        throw new Error(`R3F: ${name} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);\n    // Validate primitives\n    if (type === \"primitive\" && !props.object)\n        throw new Error(`R3F: Primitives without 'object' are invalid!`);\n    // Throw if an object or literal was passed for args\n    if (props.args !== undefined && !Array.isArray(props.args))\n        throw new Error(\"R3F: The args prop must be an array!\");\n}\nfunction createInstance(type, props, root) {\n    // Remove three* prefix from elements if native element not present\n    type = toPascalCase(type) in catalogue ? type : type.replace(PREFIX_REGEX, \"\");\n    validateInstance(type, props);\n    // Regenerate the R3F instance for primitives to simulate a new object\n    if (type === \"primitive\" && props.object?.__r3f)\n        delete props.object.__r3f;\n    return prepare(props.object, root, type, props);\n}\nfunction hideInstance(instance) {\n    if (!instance.isHidden) {\n        if (instance.props.attach && instance.parent?.object) {\n            detach(instance.parent, instance);\n        }\n        else if (isObject3D(instance.object)) {\n            instance.object.visible = false;\n        }\n        instance.isHidden = true;\n        invalidateInstance(instance);\n    }\n}\nfunction unhideInstance(instance) {\n    if (instance.isHidden) {\n        if (instance.props.attach && instance.parent?.object) {\n            attach(instance.parent, instance);\n        }\n        else if (isObject3D(instance.object) && instance.props.visible !== false) {\n            instance.object.visible = true;\n        }\n        instance.isHidden = false;\n        invalidateInstance(instance);\n    }\n}\n// https://github.com/facebook/react/issues/20271\n// This will make sure events and attach are only handled once when trees are complete\nfunction handleContainerEffects(parent, child, beforeChild) {\n    // Bail if tree isn't mounted or parent is not a container.\n    // This ensures that the tree is finalized and React won't discard results to Suspense\n    const state = child.root.getState();\n    if (!parent.parent && parent.object !== state.scene)\n        return;\n    // Create & link object on first run\n    if (!child.object) {\n        // Get target from catalogue\n        const target = catalogue[toPascalCase(child.type)];\n        // Create object\n        child.object = child.props.object ?? new target(...(child.props.args ?? []));\n        child.object.__r3f = child;\n    }\n    // Set initial props\n    applyProps(child.object, child.props);\n    // Append instance\n    if (child.props.attach) {\n        attach(parent, child);\n    }\n    else if (isObject3D(child.object) && isObject3D(parent.object)) {\n        const childIndex = parent.object.children.indexOf(beforeChild?.object);\n        if (beforeChild && childIndex !== -1) {\n            // If the child is already in the parent's children array, move it to the new position\n            // Otherwise, just insert it at the target position\n            const existingIndex = parent.object.children.indexOf(child.object);\n            if (existingIndex !== -1) {\n                parent.object.children.splice(existingIndex, 1);\n                const adjustedIndex = existingIndex < childIndex ? childIndex - 1 : childIndex;\n                parent.object.children.splice(adjustedIndex, 0, child.object);\n            }\n            else {\n                child.object.parent = parent.object;\n                parent.object.children.splice(childIndex, 0, child.object);\n                child.object.dispatchEvent({ type: \"added\" });\n                // @ts-ignore\n                parent.object.dispatchEvent({ type: \"childadded\", child: child.object });\n            }\n        }\n        else {\n            parent.object.add(child.object);\n        }\n    }\n    // Link subtree\n    for (const childInstance of child.children)\n        handleContainerEffects(child, childInstance);\n    // Tree was updated, request a frame\n    invalidateInstance(child);\n}\nfunction appendChild(parent, child) {\n    if (!child)\n        return;\n    // Link instances\n    child.parent = parent;\n    parent.children.push(child);\n    // Attach tree once complete\n    handleContainerEffects(parent, child);\n}\nfunction insertBefore(parent, child, beforeChild) {\n    if (!child || !beforeChild)\n        return;\n    // Link instances\n    child.parent = parent;\n    const childIndex = parent.children.indexOf(beforeChild);\n    if (childIndex !== -1)\n        parent.children.splice(childIndex, 0, child);\n    else\n        parent.children.push(child);\n    // Attach tree once complete\n    handleContainerEffects(parent, child, beforeChild);\n}\nfunction disposeOnIdle(object) {\n    if (typeof object.dispose === \"function\") {\n        const handleDispose = () => {\n            try {\n                object.dispose();\n            }\n            catch {\n                // no-op\n            }\n        };\n        // In a testing environment, cleanup immediately\n        // if (typeof IS_REACT_ACT_ENVIRONMENT !== \"undefined\") handleDispose();\n        // Otherwise, using a real GPU so schedule cleanup to prevent stalls\n        // else scheduleCallback(idlePriority, handleDispose);\n        handleDispose();\n    }\n}\nfunction removeChild(parent, child, dispose) {\n    if (!child)\n        return;\n    // Unlink instances\n    child.parent = null;\n    const childIndex = parent.children.indexOf(child);\n    if (childIndex !== -1)\n        parent.children.splice(childIndex, 1);\n    // Eagerly tear down tree\n    if (child.props.attach) {\n        detach(parent, child);\n    }\n    else if (isObject3D(child.object) && isObject3D(parent.object)) {\n        parent.object.remove(child.object);\n        removeInteractivity(findInitialRoot(child), child.object);\n    }\n    // Allow objects to bail out of unmount disposal with dispose={null}\n    const shouldDispose = child.props.dispose !== null && dispose !== false;\n    // Recursively remove instance children\n    for (let i = child.children.length - 1; i >= 0; i--) {\n        const node = child.children[i];\n        removeChild(child, node, shouldDispose);\n    }\n    child.children.length = 0;\n    // Unlink instance object\n    delete child.object.__r3f;\n    // Dispose object whenever the reconciler feels like it.\n    // Never dispose of primitives because their state may be kept outside of React!\n    // In order for an object to be able to dispose it\n    //   - has a dispose method\n    //   - cannot be a <primitive object={...} />\n    //   - cannot be a THREE.Scene, because three has broken its own API\n    if (shouldDispose && child.type !== \"primitive\" && child.object.type !== \"Scene\") {\n        disposeOnIdle(child.object);\n    }\n    // Tree was updated, request a frame for top-level instance\n    if (dispose === undefined)\n        invalidateInstance(child);\n}\nfunction setFiberRef(fiber, publicInstance) {\n    for (const _fiber of [fiber, fiber.alternate]) {\n        if (_fiber !== null) {\n            if (typeof _fiber?.ref === \"function\") {\n                _fiber.refCleanup?.();\n                const cleanup = _fiber.ref(publicInstance);\n                if (typeof cleanup === \"function\")\n                    _fiber.refCleanup = cleanup;\n            }\n            else if (_fiber?.ref) {\n                _fiber.ref.current = publicInstance;\n            }\n        }\n    }\n}\nconst reconstructed = [];\nfunction swapInstances() {\n    // Detach instance\n    for (const [instance] of reconstructed) {\n        const parent = instance.parent;\n        if (parent) {\n            if (instance.props.attach) {\n                detach(parent, instance);\n            }\n            else if (isObject3D(instance.object) && isObject3D(parent.object)) {\n                parent.object.remove(instance.object);\n            }\n            for (const child of instance.children) {\n                if (child.props.attach) {\n                    detach(instance, child);\n                }\n                else if (isObject3D(child.object) && isObject3D(instance.object)) {\n                    instance.object.remove(child.object);\n                }\n            }\n        }\n        // If the old instance is hidden, we need to unhide it.\n        // React assumes it can discard instances since they're pure for DOM.\n        // This isn't true for us since our lifetimes are impure and longliving.\n        // So, we manually check if an instance was hidden and unhide it.\n        if (instance.isHidden)\n            unhideInstance(instance);\n        // Dispose of old object if able\n        if (instance.object.__r3f)\n            delete instance.object.__r3f;\n        if (instance.type !== \"primitive\")\n            disposeOnIdle(instance.object);\n    }\n    // Update instance\n    for (const [instance, props, fiber] of reconstructed) {\n        instance.props = props;\n        const parent = instance.parent;\n        if (parent) {\n            // Get target from catalogue\n            const target = catalogue[toPascalCase(instance.type)];\n            // Create object\n            instance.object = instance.props.object ?? new target(...(instance.props.args ?? []));\n            instance.object.__r3f = instance;\n            setFiberRef(fiber, instance.object);\n            // Set initial props\n            applyProps(instance.object, instance.props);\n            if (instance.props.attach) {\n                attach(parent, instance);\n            }\n            else if (isObject3D(instance.object) && isObject3D(parent.object)) {\n                parent.object.add(instance.object);\n            }\n            for (const child of instance.children) {\n                if (child.props.attach) {\n                    attach(instance, child);\n                }\n                else if (isObject3D(child.object) && isObject3D(instance.object)) {\n                    instance.object.add(child.object);\n                }\n            }\n            // Tree was updated, request a frame\n            invalidateInstance(instance);\n        }\n    }\n    reconstructed.length = 0;\n}\n// Don't handle text instances, make it no-op\nconst handleTextInstance = () => { };\nconst NO_CONTEXT = {};\nlet currentUpdatePriority = NoEventPriority;\n// https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberFlags.js\nconst NoFlags = 0;\nconst Update = 4;\nconst reconciler = /* @__PURE__ */ createReconciler({\n    isPrimaryRenderer: false,\n    warnsIfNotActing: false,\n    supportsMutation: true,\n    supportsPersistence: false,\n    supportsHydration: false,\n    createInstance,\n    removeChild,\n    appendChild,\n    appendInitialChild: appendChild,\n    insertBefore,\n    appendChildToContainer(container, child) {\n        const scene = container.getState().scene.__r3f;\n        if (!child || !scene)\n            return;\n        appendChild(scene, child);\n    },\n    removeChildFromContainer(container, child) {\n        const scene = container.getState().scene.__r3f;\n        if (!child || !scene)\n            return;\n        removeChild(scene, child);\n    },\n    insertInContainerBefore(container, child, beforeChild) {\n        const scene = container.getState().scene.__r3f;\n        if (!child || !beforeChild || !scene)\n            return;\n        insertBefore(scene, child, beforeChild);\n    },\n    // @ts-ignore\n    getRootHostContext: () => NO_CONTEXT,\n    // @ts-ignore\n    getChildHostContext: () => NO_CONTEXT,\n    commitUpdate(instance, type, oldProps, newProps, fiber) {\n        validateInstance(type, newProps);\n        let reconstruct = false;\n        // Reconstruct primitives if object prop changes\n        if (instance.type === \"primitive\" && oldProps.object !== newProps.object)\n            reconstruct = true;\n        // Reconstruct instance if args were added or removed\n        else if (newProps.args?.length !== oldProps.args?.length)\n            reconstruct = true;\n        // Reconstruct instance if args were changed\n        else if (newProps.args?.some((value, index) => value !== oldProps.args?.[index]))\n            reconstruct = true;\n        // Reconstruct when args or <primitive object={...} have changes\n        if (reconstruct) {\n            reconstructed.push([instance, { ...newProps }, fiber]);\n        }\n        else {\n            // Create a diff-set, flag if there are any changes\n            const changedProps = diffProps(instance, newProps);\n            if (Object.keys(changedProps).length) {\n                Object.assign(instance.props, changedProps);\n                applyProps(instance.object, changedProps);\n            }\n        }\n        // Flush reconstructed siblings when we hit the last updated child in a sequence\n        // @ts-ignore\n        const isTailSibling = fiber.sibling === null || (fiber.flags & Update) === NoFlags;\n        if (isTailSibling)\n            swapInstances();\n    },\n    finalizeInitialChildren: () => false,\n    commitMount() { },\n    // @ts-ignore\n    getPublicInstance: (instance) => instance?.object,\n    prepareForCommit: () => null,\n    preparePortalMount: (container) => prepare(container.getState().scene, container, \"\", {}),\n    resetAfterCommit: () => { },\n    shouldSetTextContent: () => false,\n    clearContainer: () => false,\n    hideInstance,\n    unhideInstance,\n    createTextInstance: handleTextInstance,\n    hideTextInstance: handleTextInstance,\n    unhideTextInstance: handleTextInstance,\n    scheduleTimeout: (typeof setTimeout === \"function\" ? setTimeout : undefined),\n    cancelTimeout: (typeof clearTimeout === \"function\" ? clearTimeout : undefined),\n    noTimeout: -1,\n    getInstanceFromNode: () => null,\n    beforeActiveInstanceBlur() { },\n    afterActiveInstanceBlur() { },\n    detachDeletedInstance() { },\n    prepareScopeUpdate() { },\n    getInstanceFromScope: () => null,\n    shouldAttemptEagerTransition: () => false,\n    trackSchedulerEvent: () => { },\n    resolveEventType: () => null,\n    resolveEventTimeStamp: () => -1.1,\n    requestPostPaintCallback() { },\n    maySuspendCommit: () => false,\n    preloadInstance: () => true, // true indicates already loaded\n    startSuspendingCommit() { },\n    suspendInstance() { },\n    waitForCommitToBeReady: () => null,\n    NotPendingTransition: null,\n    // @ts-ignore\n    HostTransitionContext: /* @__PURE__ */ React.createContext(null),\n    setCurrentUpdatePriority(newPriority) {\n        currentUpdatePriority = newPriority;\n    },\n    getCurrentUpdatePriority() {\n        return currentUpdatePriority;\n    },\n    resolveUpdatePriority() {\n        if (currentUpdatePriority !== NoEventPriority)\n            return currentUpdatePriority;\n        switch (typeof window !== \"undefined\" && window.event?.type) {\n            case \"click\":\n            case \"contextmenu\":\n            case \"dblclick\":\n            case \"pointercancel\":\n            case \"pointerdown\":\n            case \"pointerup\":\n                // return DiscreteEventPriority;\n                return 1;\n            case \"pointermove\":\n            case \"pointerout\":\n            case \"pointerover\":\n            case \"pointerenter\":\n            case \"pointerleave\":\n            case \"wheel\":\n                return 1;\n            // return ContinuousEventPriority;\n            default:\n                // return DefaultEventPriority;\n                return 1;\n        }\n    },\n    resetFormInstance() { },\n});\n\nconst _roots = new Map();\nconst shallowLoose = { objects: \"shallow\", strict: false };\nfunction computeInitialSize(canvas, size) {\n    if (!size && typeof HTMLCanvasElement !== \"undefined\" && canvas instanceof HTMLCanvasElement && canvas.parentElement) {\n        const { width, height, top, left } = canvas.parentElement.getBoundingClientRect();\n        return { width, height, top, left };\n    }\n    else if (!size && typeof OffscreenCanvas !== \"undefined\" && canvas instanceof OffscreenCanvas) {\n        return {\n            width: canvas.width,\n            height: canvas.height,\n            top: 0,\n            left: 0,\n        };\n    }\n    return { width: 0, height: 0, top: 0, left: 0, ...size };\n}\nfunction createRoot(canvas) {\n    // Check against mistaken use of createRoot\n    const prevRoot = _roots.get(canvas);\n    const prevFiber = prevRoot?.fiber;\n    const prevStore = prevRoot?.store;\n    if (prevRoot)\n        console.warn(\"R3F.createRoot should only be called once!\");\n    // Report when an error was detected in a previous render\n    // https://github.com/pmndrs/react-three-fiber/pull/2261\n    const logRecoverableError = typeof reportError === \"function\"\n        ? // In modern browsers, reportError will dispatch an error event,\n            // emulating an uncaught JavaScript error.\n            reportError\n        : // In older browsers and test environments, fallback to console.error.\n            console.error;\n    // Create store\n    const store = prevStore || createStore(invalidate, advance);\n    // Create renderer\n    const fiber = prevFiber ||\n        reconciler.createContainer(store, // container\n        // ConcurrentRoot, // tag\n        1, null, // hydration callbacks\n        false, // isStrictMode\n        null, // concurrentUpdatesByDefaultOverride\n        \"\", // identifierPrefix\n        logRecoverableError, // onUncaughtError\n        null, logRecoverableError, // onCaughtError\n        logRecoverableError, // onRecoverableError\n        null // transitionCallbacks\n        );\n    // Map it\n    if (!prevRoot)\n        _roots.set(canvas, { fiber, store });\n    // Locals\n    let onCreated;\n    let lastCamera;\n    let configured = false;\n    let pending = null;\n    return {\n        async configure(props = {}) {\n            let resolve;\n            pending = new Promise((_resolve) => (resolve = _resolve));\n            const { gl: glConfig, size: propsSize, scene: sceneOptions, events, onCreated: onCreatedCallback, shadows = false, linear = false, flat = false, legacy = false, orthographic = false, frameloop = \"always\", dpr = [1, 2], performance, raycaster: raycastOptions, camera: cameraOptions, onPointerMissed, } = props;\n            const state = store.getState();\n            // Set up renderer (one time only!)\n            let gl = state.gl;\n            if (!state.gl) {\n                const defaultProps = {\n                    canvas: canvas,\n                    powerPreference: \"high-performance\",\n                    antialias: true,\n                    alpha: true,\n                };\n                const customRenderer = (typeof glConfig === \"function\" ? await glConfig(defaultProps) : glConfig);\n                if (isRenderer(customRenderer)) {\n                    gl = customRenderer;\n                }\n                else {\n                    gl = new THREE.WebGLRenderer({\n                        ...defaultProps,\n                        ...glConfig,\n                    });\n                }\n                state.set({ gl });\n            }\n            // Set up raycaster (one time only!)\n            let raycaster = state.raycaster;\n            if (!raycaster)\n                state.set({ raycaster: (raycaster = new THREE.Raycaster()) });\n            // Set raycaster options\n            const { params, ...options } = raycastOptions || {};\n            if (!is.equ(options, raycaster, shallowLoose))\n                applyProps(raycaster, { ...options });\n            if (!is.equ(params, raycaster.params, shallowLoose))\n                applyProps(raycaster, { params: { ...raycaster.params, ...params } });\n            // Create default camera, don't overwrite any user-set state\n            if (!state.camera || (state.camera === lastCamera && !is.equ(lastCamera, cameraOptions, shallowLoose))) {\n                lastCamera = cameraOptions;\n                const isCamera = cameraOptions?.isCamera;\n                const camera = isCamera\n                    ? cameraOptions\n                    : orthographic\n                        ? new THREE.OrthographicCamera(0, 0, 0, 0, 0.1, 1000)\n                        : new THREE.PerspectiveCamera(75, 0, 0.1, 1000);\n                if (!isCamera) {\n                    camera.position.z = 5;\n                    if (cameraOptions) {\n                        applyProps(camera, cameraOptions);\n                        // Preserve user-defined frustum if possible\n                        // https://github.com/pmndrs/react-three-fiber/issues/3160\n                        if (!camera.manual) {\n                            if (\"aspect\" in cameraOptions || \"left\" in cameraOptions || \"right\" in cameraOptions || \"bottom\" in cameraOptions || \"top\" in cameraOptions) {\n                                camera.manual = true;\n                                camera.updateProjectionMatrix();\n                            }\n                        }\n                    }\n                    // Always look at center by default\n                    if (!state.camera && !cameraOptions?.rotation)\n                        camera.lookAt(0, 0, 0);\n                }\n                state.set({ camera });\n                // Configure raycaster\n                // https://github.com/pmndrs/react-xr/issues/300\n                raycaster.camera = camera;\n            }\n            // Set up scene (one time only!)\n            if (!state.scene) {\n                let scene;\n                if (sceneOptions?.isScene) {\n                    scene = sceneOptions;\n                    prepare(scene, store, \"\", {});\n                }\n                else {\n                    scene = new THREE.Scene();\n                    prepare(scene, store, \"\", {});\n                    if (sceneOptions)\n                        applyProps(scene, sceneOptions);\n                }\n                state.set({ scene });\n            }\n            // Store events internally\n            if (events && !state.events.handlers)\n                state.set({ events: events(store) });\n            // Check size, allow it to take on container bounds initially\n            const size = computeInitialSize(canvas, propsSize);\n            if (!is.equ(size, state.size, shallowLoose)) {\n                state.setSize(size.width, size.height, size.top, size.left);\n            }\n            // Check pixelratio\n            if (dpr && state.viewport.dpr !== calculateDpr(dpr))\n                state.setDpr(dpr);\n            // Check frameloop\n            if (state.frameloop !== frameloop)\n                state.setFrameloop(frameloop);\n            // Check pointer missed\n            if (!state.onPointerMissed)\n                state.set({ onPointerMissed });\n            // Check performance\n            if (performance && !is.equ(performance, state.performance, shallowLoose))\n                state.set((state) => ({ performance: { ...state.performance, ...performance } }));\n            // Set up XR (one time only!)\n            if (!state.xr) {\n                // Handle frame behavior in WebXR\n                const handleXRFrame = (timestamp, frame) => {\n                    const state = store.getState();\n                    if (state.frameloop === \"never\")\n                        return;\n                    advance(timestamp, true, state, frame);\n                };\n                // Toggle render switching on session\n                const handleSessionChange = () => {\n                    const state = store.getState();\n                    state.gl.xr.enabled = state.gl.xr.isPresenting;\n                    state.gl.xr.setAnimationLoop(state.gl.xr.isPresenting ? handleXRFrame : null);\n                    if (!state.gl.xr.isPresenting)\n                        invalidate(state);\n                };\n                // WebXR session manager\n                const xr = {\n                    connect() {\n                        const gl = store.getState().gl;\n                        gl.xr.addEventListener(\"sessionstart\", handleSessionChange);\n                        gl.xr.addEventListener(\"sessionend\", handleSessionChange);\n                    },\n                    disconnect() {\n                        const gl = store.getState().gl;\n                        gl.xr.removeEventListener(\"sessionstart\", handleSessionChange);\n                        gl.xr.removeEventListener(\"sessionend\", handleSessionChange);\n                    },\n                };\n                // Subscribe to WebXR session events\n                if (typeof gl.xr?.addEventListener === \"function\")\n                    xr.connect();\n                state.set({ xr });\n            }\n            // Set shadowmap\n            if (gl.shadowMap) {\n                const oldEnabled = gl.shadowMap.enabled;\n                const oldType = gl.shadowMap.type;\n                gl.shadowMap.enabled = !!shadows;\n                if (is.boo(shadows)) {\n                    gl.shadowMap.type = THREE.PCFSoftShadowMap;\n                }\n                else if (is.str(shadows)) {\n                    const types = {\n                        basic: THREE.BasicShadowMap,\n                        percentage: THREE.PCFShadowMap,\n                        soft: THREE.PCFSoftShadowMap,\n                        variance: THREE.VSMShadowMap,\n                    };\n                    gl.shadowMap.type = types[shadows] ?? THREE.PCFSoftShadowMap;\n                }\n                else if (is.obj(shadows)) {\n                    Object.assign(gl.shadowMap, shadows);\n                }\n                if (oldEnabled !== gl.shadowMap.enabled || oldType !== gl.shadowMap.type)\n                    gl.shadowMap.needsUpdate = true;\n            }\n            THREE.ColorManagement.enabled = !legacy;\n            // Set color space and tonemapping preferences\n            if (!configured) {\n                gl.outputColorSpace = linear ? THREE.LinearSRGBColorSpace : THREE.SRGBColorSpace;\n                gl.toneMapping = flat ? THREE.NoToneMapping : THREE.ACESFilmicToneMapping;\n            }\n            // Update color management state\n            if (state.legacy !== legacy)\n                state.set(() => ({ legacy }));\n            if (state.linear !== linear)\n                state.set(() => ({ linear }));\n            if (state.flat !== flat)\n                state.set(() => ({ flat }));\n            // Set gl props\n            if (glConfig && !is.fun(glConfig) && !isRenderer(glConfig) && !is.equ(glConfig, gl, shallowLoose))\n                applyProps(gl, glConfig);\n            // Set locals\n            onCreated = onCreatedCallback;\n            configured = true;\n            resolve();\n            return this;\n        },\n        render(children) {\n            // The root has to be configured before it can be rendered\n            if (!configured && !pending)\n                this.configure();\n            pending.then(() => {\n                reconciler.updateContainer(jsx(Provider, { store: store, children: children, onCreated: onCreated, rootElement: canvas }), fiber, null, () => undefined);\n            });\n            return store;\n        },\n        unmount() {\n            unmountComponentAtNode(canvas);\n        },\n    };\n}\nfunction Provider({ store, children, onCreated, rootElement }) {\n    useIsomorphicLayoutEffect(() => {\n        const state = store.getState();\n        // Flag the canvas active, rendering will now begin\n        state.set((state) => ({ internal: { ...state.internal, active: true } }));\n        // Notify that init is completed, the scene graph exists, but nothing has yet rendered\n        if (onCreated)\n            onCreated(state);\n        // Connect events to the targets parent, this is done to ensure events are registered on\n        // a shared target, and not on the canvas itself\n        if (!store.getState().events.connected)\n            state.events.connect?.(rootElement);\n    }, []);\n    return jsx(context.Provider, { value: store, children: children });\n}\nfunction unmountComponentAtNode(canvas, callback) {\n    const root = _roots.get(canvas);\n    const fiber = root?.fiber;\n    if (fiber) {\n        const state = root?.store.getState();\n        if (state)\n            state.internal.active = false;\n        reconciler.updateContainer(null, fiber, null, () => {\n            if (state) {\n                setTimeout(() => {\n                    try {\n                        state.events.disconnect?.();\n                        state.gl?.renderLists?.dispose?.();\n                        state.gl?.forceContextLoss?.();\n                        if (state.gl?.xr)\n                            state.xr.disconnect();\n                        dispose(state.scene);\n                        _roots.delete(canvas);\n                        if (callback)\n                            callback(canvas);\n                    }\n                    catch (e) {\n                        console.log(e);\n                        /* ... */\n                    }\n                }, 500);\n            }\n        });\n    }\n}\nfunction createPortal(children, container, state) {\n    return jsx(Portal, { children: children, container: container, state: state });\n}\nfunction Portal({ state = {}, children, container }) {\n    /** This has to be a component because it would not be able to call useThree/useStore otherwise since\n     *  if this is our environment, then we are not in r3f's renderer but in react-dom, it would trigger\n     *  the \"R3F hooks can only be used within the Canvas component!\" warning:\n     *  <Canvas>\n     *    {createPortal(...)} */\n    const { events, size, ...rest } = state;\n    const previousRoot = useStore();\n    const [raycaster] = React.useState(() => new THREE.Raycaster());\n    const [pointer] = React.useState(() => new THREE.Vector2());\n    const inject = useMutableCallback((rootState, injectState) => {\n        let viewport = undefined;\n        if (injectState.camera && size) {\n            const camera = injectState.camera;\n            // Calculate the override viewport, if present\n            viewport = rootState.viewport.getCurrentViewport(camera, new THREE.Vector3(), size);\n            // Update the portal camera, if it differs from the previous layer\n            if (camera !== rootState.camera)\n                updateCamera(camera, size);\n        }\n        return {\n            // The intersect consists of the previous root state\n            ...rootState,\n            ...injectState,\n            // Portals have their own scene, which forms the root, a raycaster and a pointer\n            scene: container,\n            raycaster,\n            pointer,\n            mouse: pointer,\n            // Their previous root is the layer before it\n            previousRoot,\n            // Events, size and viewport can be overridden by the inject layer\n            events: { ...rootState.events, ...injectState.events, ...events },\n            size: { ...rootState.size, ...size },\n            viewport: { ...rootState.viewport, ...viewport },\n            // Layers are allowed to override events\n            setEvents: (events) => injectState.set((state) => ({ ...state, events: { ...state.events, ...events } })),\n        };\n    });\n    const usePortalStore = React.useMemo(() => {\n        // Create a mirrored store, based on the previous root with a few overrides ...\n        const store = createWithEqualityFn((set, get) => ({ ...rest, set, get }));\n        // Subscribe to previous root-state and copy changes over to the mirrored portal-state\n        const onMutate = (prev) => store.setState((state) => inject.current(prev, state));\n        onMutate(previousRoot.getState());\n        previousRoot.subscribe(onMutate);\n        return store;\n    }, [previousRoot, container]);\n    return jsx(Fragment, { children: reconciler.createPortal(jsx(context.Provider, { value: usePortalStore, children: children }), usePortalStore, null) });\n}\n\nfunction createSubs(callback, subs) {\n    const sub = { callback };\n    subs.add(sub);\n    return () => void subs.delete(sub);\n}\nconst globalEffects = new Set();\nconst globalAfterEffects = new Set();\nconst globalTailEffects = new Set();\n/**\n * Adds a global render callback which is called each frame.\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addEffect\n */\nconst addEffect = (callback) => createSubs(callback, globalEffects);\n/**\n * Adds a global after-render callback which is called each frame.\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addAfterEffect\n */\nconst addAfterEffect = (callback) => createSubs(callback, globalAfterEffects);\n/**\n * Adds a global callback which is called when rendering stops.\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addTail\n */\nconst addTail = (callback) => createSubs(callback, globalTailEffects);\nfunction run(effects, timestamp) {\n    if (!effects.size)\n        return;\n    for (const { callback } of effects.values()) {\n        callback(timestamp);\n    }\n}\nfunction flushGlobalEffects(type, timestamp) {\n    switch (type) {\n        case \"before\":\n            return run(globalEffects, timestamp);\n        case \"after\":\n            return run(globalAfterEffects, timestamp);\n        case \"tail\":\n            return run(globalTailEffects, timestamp);\n    }\n}\nlet subscribers;\nlet subscription;\nfunction update(timestamp, state, frame) {\n    // Run local effects\n    let delta = state.clock.getDelta();\n    // In frameloop='never' mode, clock times are updated using the provided timestamp\n    if (state.frameloop === \"never\" && typeof timestamp === \"number\") {\n        delta = timestamp - state.clock.elapsedTime;\n        state.clock.oldTime = state.clock.elapsedTime;\n        state.clock.elapsedTime = timestamp;\n    }\n    // Call subscribers (useFrame)\n    subscribers = state.internal.subscribers;\n    for (let i = 0; i < subscribers.length; i++) {\n        subscription = subscribers[i];\n        subscription.ref.current?.(subscription.store.getState(), delta, frame);\n    }\n    // Render content\n    if (!state.internal.priority && state.gl.render)\n        state.gl.render(state.scene, state.camera);\n    // Decrease frame count\n    state.internal.frames = Math.max(0, state.internal.frames - 1);\n    return state.frameloop === \"always\" ? 1 : state.internal.frames;\n}\nlet running = false;\nlet useFrameInProgress = false;\nlet repeat;\nlet frame;\nlet state;\nfunction loop(timestamp) {\n    frame = requestAnimationFrame(loop);\n    running = true;\n    repeat = 0;\n    // Run effects\n    flushGlobalEffects(\"before\", timestamp);\n    // Render all roots\n    useFrameInProgress = true;\n    for (const root of _roots.values()) {\n        state = root.store.getState();\n        // If the frameloop is invalidated, do not run another frame\n        if (state.internal.active && (state.frameloop === \"always\" || state.internal.frames > 0) && !state.gl.xr?.isPresenting) {\n            repeat += update(timestamp, state);\n        }\n    }\n    useFrameInProgress = false;\n    // Run after-effects\n    flushGlobalEffects(\"after\", timestamp);\n    // Stop the loop if nothing invalidates it\n    if (repeat === 0) {\n        // Tail call effects, they are called when rendering stops\n        flushGlobalEffects(\"tail\", timestamp);\n        // Flag end of operation\n        running = false;\n        return cancelAnimationFrame(frame);\n    }\n}\n/**\n * Invalidates the view, requesting a frame to be rendered. Will globally invalidate unless passed a root's state.\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#invalidate\n */\nfunction invalidate(state, frames = 1) {\n    if (!state)\n        return _roots.forEach((root) => invalidate(root.store.getState(), frames));\n    if (state.gl.xr?.isPresenting || !state.internal.active || state.frameloop === \"never\")\n        return;\n    if (frames > 1) {\n        // legacy support for people using frames parameters\n        // Increase frames, do not go higher than 60\n        state.internal.frames = Math.min(60, state.internal.frames + frames);\n    }\n    else {\n        if (useFrameInProgress) {\n            //called from within a useFrame, it means the user wants an additional frame\n            state.internal.frames = 2;\n        }\n        else {\n            //the user need a new frame, no need to increment further than 1\n            state.internal.frames = 1;\n        }\n    }\n    // If the render-loop isn't active, start it\n    if (!running) {\n        running = true;\n        requestAnimationFrame(loop);\n    }\n}\n/**\n * Advances the frameloop and runs render effects, useful for when manually rendering via `frameloop=\"never\"`.\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#advance\n */\nfunction advance(timestamp, runGlobalEffects = true, state, frame) {\n    if (runGlobalEffects)\n        flushGlobalEffects(\"before\", timestamp);\n    if (!state)\n        for (const root of _roots.values())\n            update(timestamp, root.store.getState());\n    else\n        update(timestamp, state, frame);\n    if (runGlobalEffects)\n        flushGlobalEffects(\"after\", timestamp);\n}\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\nconst DOM_EVENTS = {\n    onClick: [\"click\", false],\n    onContextMenu: [\"contextmenu\", false],\n    onDoubleClick: [\"dblclick\", false],\n    onWheel: [\"wheel\", true],\n    onPointerDown: [\"pointerdown\", true],\n    onPointerUp: [\"pointerup\", true],\n    onPointerLeave: [\"pointerleave\", true],\n    onPointerMove: [\"pointermove\", true],\n    onPointerCancel: [\"pointercancel\", true],\n    onLostPointerCapture: [\"lostpointercapture\", true],\n};\n/** Default R3F event manager for web */\nfunction createPointerEvents(store) {\n    const { handlePointer } = createEvents(store);\n    return {\n        priority: 1,\n        enabled: true,\n        compute(event, state, previous) {\n            // https://github.com/pmndrs/react-three-fiber/pull/782\n            // Events trigger outside of canvas when moved, use offsetX/Y by default and allow overrides\n            state.pointer.set((event.offsetX / state.size.width) * 2 - 1, -(event.offsetY / state.size.height) * 2 + 1);\n            state.raycaster.setFromCamera(state.pointer, state.camera);\n        },\n        connected: undefined,\n        handlers: Object.keys(DOM_EVENTS).reduce((acc, key) => ({ ...acc, [key]: handlePointer(key) }), {}),\n        update: () => {\n            const { events, internal } = store.getState();\n            if (internal.lastEvent?.current && events.handlers)\n                events.handlers.onPointerMove(internal.lastEvent.current);\n        },\n        connect: (target) => {\n            const { set, events } = store.getState();\n            events.disconnect?.();\n            set((state) => ({ events: { ...state.events, connected: target } }));\n            if (events.handlers) {\n                for (const name in events.handlers) {\n                    const event = events.handlers[name];\n                    const [eventName, passive] = DOM_EVENTS[name];\n                    target.addEventListener(eventName, event, { passive });\n                }\n            }\n        },\n        disconnect: () => {\n            const { set, events } = store.getState();\n            if (events.connected) {\n                if (events.handlers) {\n                    for (const name in events.handlers) {\n                        const event = events.handlers[name];\n                        const [eventName] = DOM_EVENTS[name];\n                        events.connected.removeEventListener(eventName, event);\n                    }\n                }\n                set((state) => ({ events: { ...state.events, connected: undefined } }));\n            }\n        },\n    };\n}\n\nfunction CanvasImpl({ ref, children, fallback, resize, style, gl, events = createPointerEvents, eventSource, eventPrefix, shadows, linear, flat, legacy, orthographic, frameloop, dpr, performance, raycaster, camera, scene, onPointerMissed, onCreated, forwardRef, ...props }) {\n    // Create a known catalogue of Threejs-native elements\n    // This will include the entire THREE namespace by default, users can extend\n    // their own elements by using the createRoot API instead\n    React.useMemo(() => extend(THREE), []);\n    const Bridge = useBridge();\n    const [containerRef, containerRect] = useMeasure({ scroll: true, debounce: { scroll: 50, resize: 0 }, ...resize });\n    const canvasRef = React.useRef(null);\n    const divRef = React.useRef(null);\n    React.useImperativeHandle(forwardRef, () => canvasRef.current);\n    const handlePointerMissed = useMutableCallback(onPointerMissed);\n    const [block, setBlock] = React.useState(false);\n    const [error, setError] = React.useState(false);\n    // Suspend this component if block is a promise (2nd run)\n    if (block)\n        throw block;\n    // Throw exception outwards if anything within canvas throws\n    if (error)\n        throw error;\n    const root = React.useRef(null);\n    useIsomorphicLayoutEffect(() => {\n        const canvas = canvasRef.current;\n        if (containerRect.width > 0 && containerRect.height > 0 && canvas) {\n            if (!root.current)\n                root.current = createRoot(canvas);\n            async function run() {\n                await root.current.configure({\n                    gl,\n                    scene,\n                    events,\n                    shadows,\n                    linear,\n                    flat,\n                    legacy,\n                    orthographic,\n                    frameloop,\n                    dpr,\n                    performance,\n                    raycaster,\n                    camera,\n                    size: containerRect,\n                    // Pass mutable reference to onPointerMissed so it's free to update\n                    onPointerMissed: (...args) => handlePointerMissed.current?.(...args),\n                    onCreated: (state) => {\n                        // Connect to event source\n                        state.events.connect?.(eventSource ? (isRef(eventSource) ? eventSource.current : eventSource) : divRef.current);\n                        // Set up compute function\n                        if (eventPrefix) {\n                            state.setEvents({\n                                compute: (event, state) => {\n                                    const x = event[(eventPrefix + \"X\")];\n                                    const y = event[(eventPrefix + \"Y\")];\n                                    state.pointer.set((x / state.size.width) * 2 - 1, -(y / state.size.height) * 2 + 1);\n                                    state.raycaster.setFromCamera(state.pointer, state.camera);\n                                },\n                            });\n                        }\n                        // Call onCreated callback\n                        onCreated?.(state);\n                    },\n                });\n                root.current.render(jsx(Bridge, { children: jsx(ErrorBoundary, { set: setError, children: jsx(React.Suspense, { fallback: jsx(Block, { set: setBlock }), children: children ?? null }) }) }));\n            }\n            run();\n        }\n    });\n    React.useEffect(() => {\n        const canvas = canvasRef.current;\n        if (canvas)\n            return () => unmountComponentAtNode(canvas);\n    }, []);\n    // When the event source is not this div, we need to set pointer-events to none\n    // Or else the canvas will block events from reaching the event source\n    const pointerEvents = eventSource ? \"none\" : \"auto\";\n    return (jsx(\"div\", { ref: divRef, style: {\n            position: \"relative\",\n            width: \"100%\",\n            height: \"100%\",\n            overflow: \"hidden\",\n            pointerEvents,\n            ...style,\n        }, ...props, children: jsx(\"div\", { ref: containerRef, style: { width: \"100%\", height: \"100%\" }, children: jsx(\"canvas\", { ref: canvasRef, style: { display: \"block\" }, children: fallback }) }) }));\n}\n/**\n * A DOM canvas which accepts threejs elements as children.\n * @see https://docs.pmnd.rs/react-three-fiber/api/canvas\n */\nconst Canvas = React.forwardRef(function Canvas(props, ref) {\n    return (jsx(FiberProvider, { children: jsx(CanvasImpl, { ...props, forwardRef: ref }) }));\n});\n\nexport { Canvas, FiberProvider, threeTypes as ReactThreeFiber, _roots, addAfterEffect, addEffect, addTail, advance, applyProps, buildGraph, context, createEvents, createPortal, createRoot, dispose, createPointerEvents as events, extend, flushGlobalEffects, getRootState, invalidate, reconciler, traverseFiber, unmountComponentAtNode, useContainer, useContextBridge, useContextMap, useFiber, useFrame, useGraph, useInstanceHandle, useLoader, useNearestChild, useNearestParent, useStore, useThree };\n"],"names":["webpackEmptyAsyncContext","req","Promise","resolve","then","e","Error","code","keys","id","module","exports","HOOK_TYPE$1","UpdateQueueType$1","STATE_TYPE$1","PATCH_TYPE$1","Effect_TYPE$1","SuppressedError","HOOK_TYPE","UpdateQueueType","STATE_TYPE","PATCH_TYPE","Effect_TYPE","ListTreeNode$1","value","this","prev","next","traverseFiber","fiber","ascending","selector","child","return","match","sibling","ListTree","length","_stickyHead","Object","defineProperty","get","set","v","_stickyFoot","_head","_foot","prototype","push","node","listNode","foot","head","pushToLast","stickyFoot","node_1","pushToHead","stickyHead","node_2","unshift","pop","delete","unshiftToHead","node_3","unshiftToFoot","node_4","shift","pickHead","_a","_b","pickFoot","listToFoot","action","listToHead","toArray","re","hasNode","size","is","hasValue","some","iterator","every","concat","list","newList","clone","clear","window","document","createElement","navigator","product","FiberContext","FiberProvider","_reactInternals","render","jsx","Provider","children","props","useFiber","root","maybeFiber","alternate","hookList","hook","typedHook","type","useId","result","REACT_CONTEXT_TYPE","Symbol","for","REACT_PROVIDER_TYPE","findInitialRoot","instance","getState","previousRoot","isOrthographicCamera","def","isColorRepresentation","isColor","useIsomorphicLayoutEffect","useMutableCallback","fn","ref","current","Block","ErrorBoundary","state","error","static","componentDidCatch","err","calculateDpr","dpr","target","devicePixelRatio","Array","isArray","Math","min","max","getRootState","obj","__r3f","a","arr","fun","str","num","boo","und","nul","equ","b","arrays","objects","strict","isObj","isArr","i","REACT_INTERNAL_PROPS","getInstanceProps","queue","key","includes","prepare","object","parent","eventCount","handlers","isHidden","parts","split","part","undefined","slice","indexOf","join","INDEX_REGEX","attach","test","index","replace","previousAttach","detach","previous","RESERVED_PROPS","MEMOIZED_PROTOTYPES","Map","getMemoizedPrototype","ctor","constructor","console","log","colorMaps","EVENT_REGEX","applyProps","rootState","prevHandlers","prop","mask","copy","fromArray","setScalar","linear","isTexture","format","colorSpace","internal","isObject3D","interaction","splice","raycast","isBufferGeometry","isMaterial","invalidateInstance","onUpdate","frames","invalidate","updateCamera","camera","manual","left","width","right","top","height","bottom","aspect","updateProjectionMatrix","makeId","event","eventObject","uuid","instanceId","releaseInternalPointerCapture","capturedMap","captures","pointerId","captureData","releasePointerCapture","isRenderer","context","useStore","store","useFrame","callback","renderPriority","subscribe","memoizedLoaders","WeakMap","loadingFn","extensions","onProgress","Proto","input","loader","all","map","res","reject","load","data","scene","assign","nodes","materials","meshes","traverse","name","material","isMesh","buildGraph","message","useLoader","results","equal","preload","extendStatics","d","setPrototypeOf","__proto__","p","hasOwnProperty","call","__assign","t","s","n","arguments","apply","__awaiter","thisArg","_arguments","P","generator","fulfilled","step","rejected","done","__generator","body","f","y","_","label","sent","trys","ops","g","create","Iterator","verb","op","TypeError","__spreadArray","to","from","pack","ar","l","hasRequiredIndex_production","hasRequiredMyreactReconciler","myreactReconciler","index_production","myreactReconcilerExports","react","merge","src","rest","remove","include","exclude","TYPEKEY","Memo","ForwardRef","Portal","Fragment","Context","Consumer","Lazy","Suspense","Strict","Root","Scope","ScopeLazy","ScopeSuspense","Comment","Activity","Profiler","isFunction","isPromise","val","catch","UniqueArray","Set","uniPop","uniPush","has","add","uniShift","uniUnshift","uniDelete","filter","getAll","isNormalEquals","isSkipKey","hasSkipKeyFunction","srcKeys","targetKeys","_i","srcKeys_1","srcKeys_2","isArrayEquals","ListTreeNode","__extends","String","__","NODE_TYPE","MyWeakMap","currentRefreshHandler","createRef","currentTriggerFiber","fiberToDispatchMap","__my_react_internal__","enableFiberForLog","enableDebugUpdateQueue","enableValidMyReactElement","enableLogForCurrentFlowIsRunning","enableSyncFlush$1","__my_react_shared__","enableSyncFlush","syncFlush","beforeSyncFlush","afterSyncFlush","stack","beforeSyncUpdate","afterSyncUpdate","currentRunningFiber$5","currentRunningFiber","currentScheduler$h","currentScheduler","currentScopeFiber$1","currentScopeFiber","currentError$1","currentError","currentCallingFiber$1","currentCallingFiber","safeCall","args","renderScheduler","dispatchError","safeCallWithCurrentFiber","fallback","currentScheduler$g","currentRunningFiber$4","enableOptimizeTreeLog","warnMap","errorMap","fiberWarn","renderDispatch","getCurrentDispatchFromFiber","callOnFiberWarn","fiberError","callOnFiberError","originalWarn","warn","originalError","warnFiber","errorFiber","devWarn","startWithPlain","renderFiber","treeLog","getFiberTree","devWarnWithFiber","devError","shouldIncludeLog","__class__","__function__","getPlainFiberName","__provider__","name_2","typedElementType","elementType","displayName","__context__","name_3","__consumer__","name_4","__lazy__","typedRender","name_5","__portal__","__null__","__empty__","__scope__","__scopeLazy__","__scopeSuspense__","__strict__","__profiler__","__suspense__","__comment__","__root__","__fragment__","__text__","name_6","getElementName","tag","__memo__","__forwardRef__","pendingProps","getFiberTagName","getFiberNodeName","getFiberNodeNameWithFiber","getFiberTree$1","preString","padEnd","temp","getHookTree","treeHookNode","errorType","pre","toString","repeat","lastRender","nextRender","onceWarnWithKeyAndFiber","tree","enableHMRForDev","emptyProps$1","getElementTypeFromType","getTypeFromElementNode","element","nodeType","__initial__","isValidElement","getTypeFromElement","finalElement","pendingText","_e","_f","_g","isMyReactComponent","__activity__","__plain__","typeToFibersMap","setRefreshTypeMap","exist","getCurrentFibersFromType","dispatch","typedFiberRoot","currentComponentFiber","currentRunningFiber$3","currentScheduler$f","dispatchHook","params","__unmount__","dispatchState","_params","trigger","dispatchPromise","dispatchSuspensePromise","readContext","readPromise","checkIsSameType","MyReactFiberNode","existElementType","incomingElementType","typedExistElement","typedIncomingElement","updateTypeEnum","generateFiberToMountList","listTree","getNext","generateFiberToUnmountList","generateFiberToListWithAction","defaultGenerateEffectMap","effect","option","stickyToHead","stickyToFoot","defaultInvokeEffect","patch","__effect__","effectMap","runtimeMap","allEffect","defaultInvokeLayoutEffect","__layoutEffect__","layoutEffectMap","allLayoutEffect","defaultInvokeInsertionEffect","__insertionEffect__","insertionEffectMap","allInsertionEffect","defaultDeleteCurrentEffect","defaultDeleteChildEffect","effectCallbackList","addEffectCallback","cb","flushEffectCallback","layoutEffect","insertionEffect","defaultReadPromise","_promise","status","_value","_reason","defaultResolveSuspenseValue","defaultResolveSuspenseFiber","defaultResolveAliveSuspenseFiber","currentRunningFiber$2","mountToNextFiberFromRoot","isAppCrashed","__create__","__inherit__","__triggerSync__","__triggerSyncForce__","__triggerConcurrent__","__triggerConcurrentForce__","__retrigger__","__reschedule__","__recreate__","runtimeNextWork","__stable__","nextFiber","runtimeFiber","scheduledFiber","generateCommitList","performToNextFiberFromRoot","triggerFiberUpdateListener","enableSuspenseRoot$3","enableSuspenseRoot","currentScheduler$e","mountLoopAllFromScheduler","nextWorkingFiber","retriggerFiber","currentFiber","mountLoopAll","processAsyncLoadListOnAsyncMount","_loop_1","suspenseField_1","suspenseField","pendingSuspenseFiberArray","getInstanceFieldByInstance","asyncLoadList","item","processPromise","processLazy","_list","forEach","processAsyncLoadListOnSyncMount","allPendingSuspenseFiberArray","enableAsyncLoad","allField_1","field","allPendingLoadArray","_loading","_loaded","_error","aliveNode","rootFiber","updater","suspense","isSync","isForce","payLoad","suspenseField_2","allFiber","enableSuspenseRoot$2","currentScheduler$d","patchToFiberUpdate","callOnFiberUpdate","updateLoopSyncFromRoot","updateLoopConcurrentFromRoot","hasSync","shouldYield","processAsyncLoadListOnUpdate","isErrorBoundariesInstance","Component","getDerivedStateFromError","isErrorBoundariesComponent","typedComponent","typedInstance","defaultResolveErrorBoundaries","initClassInstance","isMounted","mountClassInstance","getClassInstanceFieldByInstance","enableLegacyLifeCycle","getInstanceOwnerFiber","configurable","processComponentStateFromProps","pendingState","getDerivedStateFromProps","payloadState","newState","processComponentFiberOnUpdate","callOnInstanceUpdate","setOwnerForInstance","processComponentRenderOnMountAndUpdate","processComponentDidMountOnMount","getInstanceEffectState","setEffectForInstance","pendingLayoutEffect","componentDidMount","processComponentContextOnUpdate","contextType","contextFiber","getInstanceContextFiber","providerFiber","resolveContextFiber","resolveContextValue","setContextForInstance","processClassComponentMount","callOnInstanceInitial","initInstance","processComponentInstanceOnMount","hasLegacyLifeFunction","UNSAFE_componentWillMount","componentWillMount","processComponentWillMountOnMount","syncFlushComponentQueue","syncComponentStateToFiber","processClassComponentUpdate","UNSAFE_componentWillReceiveProps","nextProps_1","componentWillReceiveProps","nextProps_2","processComponentWillReceiveProps","baseState","baseProps","nextState","nextProps","nextContext","shouldUpdate","Boolean","shouldComponentUpdate","processComponentShouldUpdateOnUpdate","UNSAFE_componentWillUpdate","componentWillUpdate","processComponentWillUpdate","snapshot","getSnapshotBeforeUpdate","processComponentGetSnapshotOnUpdate","componentDidUpdate","processComponentDidUpdateOnUpdate","updated","classComponentUpdateImpl","processClassComponentUnmount","classField","callOnInstanceUnmount","componentWillUnmount","enableDebugFiled","currentScheduler$c","processClassComponentUpdateQueueLatest","enableTaskPriority","allQueue","updateQueue","needUpdate","isImmediate","isRetrigger","callbacks","processedNodes","nextNode","component","payLoad_1","microTask","prepareUpdateOnFiber","invokeCallbackArray","_loop_2","payLoad_2","processClassComponentUpdateQueueLegacy","payLoad_3","processFunctionComponentUpdateQueueLatest","_loop_3","payLoad_4","reducer_1","reducer","typedTrigger_1","lastResult_1","useSyncExternalStore","hasError_1","_loop_4","payLoad_5","reducer_2","typedTrigger_2","lastResult_2","hasError_2","processFunctionComponentUpdateQueueLegacy","payLoad_6","reducer_3","typedTrigger_3","lastResult_3","hasError_3","processNormalComponentUpdateLatest","processNormalComponentUpdateLegacy","syncFiberStateToComponent","typedPendingState","currentRunningFiber$1","processState","ownerFiber","isAppMounted","callOnFiberState","trigger_1","callOnInstanceState","trigger_2","callOnHookState","ownerFiber_1","defaultGenerateUnmountMap","unmount","defaultDispatchUnmount","isAppUnmounted","unmountFiber","clearContainer","defaultInvokeUnmountList","unmountMap","allUnmount","unmountFiberNode","_c","_d","pendingCommitFiberPatch","pendingUpdateFiberArray","pendingCommitFiberList","pendingChangedFiberList","resetUpdateFlowRuntimeFiber","globalLoop$3","globalLoop","currentScheduler$b","applyTriggerFiberCb","cbArray","triggerCallbackMap","pendingEffect","triggerRevert","triggerUpdate","enableUpdate","scheduleUpdate","macroTask","globalLoop$2","currentScheduler$a","scheduleNext","dispatchSet","hasPending","find","recentlyCreatedOwnerStacks","scheduleOther","allLive","enableConcurrentMode","updateSyncFromRoot","resetYield","updateConcurrentFromRoot","scheduleUpdateFromRoot","globalLoop$1","currentScheduler$9","enableScopeTreeLog","commitList","changedList","reconcileUpdate","callOnFiberChange","finishUpdateSyncFromRoot","finishUpdateConcurrentFromRoot","checkNextFiberIsSync","updateConcurrentNextFrame","yieldTask","MyReactInternalInstance$4","MyReactInternalInstance","currentScheduler$8","defaultPayLoad","MyReactHookNode","_super","deps","_this","hasEffect","enumerable","_update","initHookInstance","hookNode","currentComponentFiber$3","MyReactSignal","_rawValue","_renderDispatch","_depsSet","getValue","setValue","newValue","allDeps","triggerUpdateOnFiber","enableDebugLog$1","enableDebugLog","currentHookTreeNode$2","currentHookTreeNode","currentHookNodeIndex$2","currentHookNodeIndex","defaultReducer","defaultOptimisticReducer","createHookNode","currentHook","currentHookIndex","currentIsReCreate","useMemo","useState","useReducer","bind","useEffect","useLayoutEffect","useInsertionEffect","useImperativeHandle","useRef","useCallback","useDeferredValue","useEffectEvent","uniqueIdCount","cancel","useDebugValue","useContext","storeApi_1","getNextResult","getSnapshot","nextResult","checkResultUpdate_1","prevResult","hasChange","useSignal","useTransition","start","startTransition","last","loadingCallback","useOptimistic","nextValue","payloadRef","effectHookNode","pendingInsertionEffect","storeApi","currentHookTreeNode$1","currentScheduler$7","updateHookNode","isHMR","depsChanged","newStoreApi_1","nextResult_1","hookListUnmount","callOnHookUnmount","unmountInstance","currentScheduler$6","checkIsMyReactFiberNode","isMyReactFiberNode","currentScheduler$5","processUpdateOnFiber","_isImmediate","_isRetrigger","updateState","flag","callOnFiberTrigger","SyncState","ForceState","emptyProps","memoizedProps","_installElement","elementRawType","_addDependence","dependence","_delDependence","nativeNode","containerNode","createFiberNode","newFiberNode","pendingCreate","pendingUpdate","pendingPosition","pendingAppend","pendingRef","patchToFiberInitial","callOnFiberInitial","__update__","updateFiberNode","nextElement","prevFiber","prevElementType","prevProps","prevRef","nextElementType","nextRef","compare","commitUnsetRef","commitClear","patchToFiberUnmount","callOnFiberUnmount","eventMap","getExistingChildren","parentFiber","existingChildrenMap","existingChildrenArray","existingChild","dynamicFragmentProps","wrap","deleteIfNeed","existingChildren","pendingUnmount","generateChangedList","getNewFiberWithUpdate","newChild","prevFiberChild","draftList_1","draftFiber_1","newElement","createFragmentWithUpdate","keyToGet","draftList","draftFiber","isSameType","getIsSameTypeNode","getNewFiberWithInitial","createFragmentWithInitial","transformChildrenFiber","isUpdate","__hmr__","isSuspense","newChildren","lastFiber","newFiber","currentComponentFiber$2","MyReactInternalInstance$3","processProvider","prepareUpdateAllDependence","processConsumer","finalContext","typedChildren","currentHookNodeIndex$1","currentScheduler$4","triggerState","processFunction","typedElementTypeWithRef_1","promise","WrapperByLazyScope","WrapperBySuspenseScope","mode","isCommentElement","enableSuspenseRoot$1","currentScheduler$3","loadLazy","loadedPromise","loaded","e_1","default","suspenseFiber","resolveSuspenseFiber","renderScheduler_1","lazy","initSuspenseInstance","typedField","MyReactInternalInstance$2","processSuspense","initVisibleInstance","instanceField","instanceMap","instanceToInitialFieldMap","_owner","_context","_subscribe","setSubscribeForInstance","isMyReactInstance","currentComponentFiber$1","MyReactInternalInstance$1","enablePerformanceLog","nextWorkCommon","nextWorkNormal","nextWorkClassComponent","nextWorkFunctionComponent","nextWorkComponent","nextWorkLazy","nextWorkSuspense","nextWorkProvider","nextWorkConsumer","nextWorkActivity","processActivity","nextWorkRoot","dispatchFiber","defaultGetContextValue","ContextObject","defaultGetContextFiber","parent_1","defaultReadContext","beforeValue","afterValue","owner","currentScheduler$2","defaultDispatchMountLatest","_dispatch","_fiber","commitCreate","commitUpdate","commitAppend","commitSetRef","defaultDispatchMount","defaultResolveScope","currentScheduler$1","defaultDispatchUpdate","sync","commitPosition","loadPromise","reason_1","Dispatcher","MyReactInternalInstanceClass","dispatchToListenerMap","initialRef","typeForRef","typeForCreate","typeForUpdate","typeForAppend","typeForNativeNode","listenerMap","RenderDispatchEvent","dispatcher","runtimeRef","errorCatchFiber","fiberInitial","fiberUpdate","fiberHasChange","fiberUnmount","fiberState","fiberTrigger","instanceInitial","instanceUpdate","instanceState","instanceUnmount","hookInitial","hookUpdate","hookState","hookUnmount","beforeCommitMount","afterCommitMount","beforeCommitUpdate","afterCommitUpdate","beforeCommitUnmount","afterCommitUnmount","writable","_state","_pendingUnmount","_effect","_option","_layoutEffect","_insertionEffect","_elementType","resolveStrict","resolveScope","resolveSuspenseValue","resolveErrorBoundaries","_contextObject","reconcileCommit","reconcileUnmount","onFiberInitial","onceFiberInitial","onceCb","onFiberUpdate","onceFiberUpdate","onFiberChange","onceFiberChange","onFiberUnmount","onceFiberUnmount","onFiberState","onceFiberState","_updater","onFiberTrigger","onceFiberTrigger","onFiberHMR","fiberHMR","onceFiberHMR","_forceRefresh","callOnFiberHMR","onFiberWarn","onceFiberWarn","onFiberError","onceFiberError","onPerformanceWarn","performanceWarn","oncePerformanceWarn","_renderTime","callOnPerformanceWarn","onBeforeFiberRun","beforeFiberRun","onceBeforeFiberRun","callOnBeforeFiberRun","onAfterFiberRun","afterFiberRun","onceAfterFiberRun","callOnAfterFiberRun","onAfterFiberDone","afterFiberDone","onceAfterFiberDone","callOnAfterFiberDone","onBeforeDispatchRender","beforeDispatchRender","onceBeforeDispatchRender","callOnBeforeDispatchRender","onAfterDispatchRender","afterDispatchRender","onceAfterDispatchRender","callOnAfterDispatchRender","onBeforeDispatchUpdate","beforeDispatchUpdate","onceBeforeDispatchUpdate","callOnBeforeDispatchUpdate","onAfterDispatchUpdate","afterDispatchUpdate","onceAfterDispatchUpdate","callOnAfterDispatchUpdate","onInstanceInitial","onceInstanceInitial","_instance","onInstanceUpdate","onceInstanceUpdate","onInstanceState","onceInstanceState","onInstanceUnmount","onceInstanceUnmount","onHookInitial","onceHookInitial","_hook","callOnHookInitial","onHookUpdate","onceHookUpdate","callOnHookUpdate","onHookUnmount","onceHookUnmount","onHookState","onceHookTrigger","onBeforeCommitMount","onceBeforeCommitMount","callOnBeforeCommitMount","onAfterCommitMount","onceAfterCommitMount","callOnAfterCommitMount","onBeforeCommitUpdate","onceBeforeCommitUpdate","callOnBeforeCommitUpdate","onAfterCommitUpdate","onceAfterCommitUpdate","callOnAfterCommitUpdate","onBeforeCommitUnmount","onceBeforeCommitUnmount","callOnBeforeCommitUnmount","onAfterCommitUnmount","onceAfterCommitUnmount","callOnAfterCommitUnmount","CustomRenderDispatch","rootNode","rootElement","version","random","renderMode","withCheck","__append__","__position__","__ref__","beforeCommit","afterCommit","beforeUpdate","afterUpdate","beforeUnmount","afterUnmount","callWithFiber","clearFiberNode","debugWithNode","mayFiberContainer","__fiber__","__props__","defaultGenerateStrict","devErrorWithFiber","getCurrentDispatchFromType","fibers","getCurrentTypeFromRefresh","getCurrentTypeFromRefreshOnly","getElementFromRefreshIfExist","getFiberTreeWithFiber","isMount","_debugIsMount","isPlain","getStackTree","hmr","nextType","forceRefresh","hmrRevert","hmrUpdate","initHMR","env","initScheduler","scheduler","initialFiberNode","isCommentEndElement","isCommentStartElement","mountAsync","finishMountAsync","mountSync","finishMountSync","onceErrorWithKeyAndFiber","processClassComponentActive","processComponentPropsAndContextOnActive","processHook","resolveHookValue","processSuspensePromise","resetLogScope","runtimeNextWorkDev","typedFiber","Date","now","end","renderTime","hasPerformanceWarn","performanceLogTimeLimit","timeNow","_debugRenderState","mountTimeStep","timeForRender","maxTimeForRender","prevRenderState","prevRenderTime","updateTimeStep","renderCount","timeForUpdate","safeCallWithSync","setLogScope","setRefreshHandler","handler","triggerError","errorBoundariesFiber","typedInstance_1","memoizedState","componentStack","unmountContainer","remove$1","Portal$1","DISPATCH_FIELD","DEV_TOOL_FIELD","getValidParentFiberWithNode","parentFiberWithNode","runtimeDom","elementMap","maybeContainer","getFiberWithNativeNode","findFiberWithNodeFromFiber","childWithDom","getInsertBeforeNodeFromSibling","getInsertBeforeNodeFromSiblingAndParent","append","config","parentNode","childNode","appendChildToContainer","appendChild","insertBefore$1","beforeFiberWithNode","beforeNode","insertInContainerBefore","insertBefore","createPortal$1","_element","_container","container","createDispatch","ReconcilerDispatch","hostContextMap","nextWorkPortal","_config","rootContainerInstance","hostContext","shouldSetTextContent","createTextInstance","createInstance","fiberContainer","preparePortalMount","oldProps","newProps","commitTextUpdate","memoizedText","prepareUpdate","updatePayload","update$1","isRender","isContainer","currentNode","appendInitialChild","append$1","position","cleanUp","refCleanup","ref_1","getPublicInstance","refCleanUp","ref_2","setRef","ref_3","unsetRef","removeChildFromContainer","removeChild","prepareForCommit","pendingCommitFiberArray","finalizeInitialChildren","commitMount","ReconcilerDispatchMount","resetAfterCommit","pendingFinalizeInitialChildrenFiberSet","beforeHasNode","afterHasNode","ReconcilerDispatchUpdate","parentFiberHostContext","maybeRoot","checkFiberWithNativeNode","getChildHostContext","getRootHostContext","initialMap","loadRemoteScript","url","options","timeout","useEval","controller_1","timeoutId","response","error_1","errorMsg","AbortController","setTimeout","abort","fetch","signal","ok","statusText","text","clearTimeout","executeScript","Bun","process","versions","executeInBun","executeInNode","executeInBrowser","safeBase64Encode","Buffer","btoa","utf8Bytes_1","TextEncoder","encode","binary","fromCharCode","base64Chars","utf8Bytes","bitmap","base64Code","dataUrl","executeWithVM","error_3","importError_1","importErrorMsg","pattern","isPotentiallyUnsafe","executeWithScriptTag","contextKeys","contextValues","values","Function","indirectEval","eval","evalError","executeWithEval","vm","sandbox","vmContext","error_5","setInterval","clearInterval","URL","URLSearchParams","Number","RegExp","RangeError","SyntaxError","WeakSet","JSON","global","createContext","Script","filename","lineOffset","columnOffset","runInContext","script","blob","Blob","blobUrl","createObjectURL","cleanup","revokeObjectURL","onerror","onload","loadRemoteModule","moduleExports","moduleContext","require","enableDebugFiled$1","enableScopeTreeLog$1","createReconciler$1","rendererPackageName","ReconcilerSet","updateContainer","_ignore","_cb","__container__","_fiber_1","globalThis","__flag__","renderPackage","addGlobalDispatch","typedRuntimeField","autoSetDevTools","injectIntoDevTools","createPortal","createContainer","getPublicRootInstance","injectIntoDevToolsWithSocketIO","init","flushSync","flushSyncWork","batchedUpdates","createReconciler","reconciler","bundleType","catalogue","PREFIX_REGEX","toPascalCase","toUpperCase","isConstructor","extend","validateInstance","unhideInstance","visible","handleContainerEffects","beforeChild","childIndex","existingIndex","adjustedIndex","dispatchEvent","childInstance","disposeOnIdle","dispose","handleDispose","o","initialHits","hovered","removeInteractivity","shouldDispose","setFiberRef","publicInstance","reconstructed","handleTextInstance","NO_CONTEXT","currentUpdatePriority","isPrimaryRenderer","warnsIfNotActing","supportsMutation","supportsPersistence","supportsHydration","reconstruct","changedProps","other","startsWith","diffProps","flags","swapInstances","hideInstance","hideTextInstance","unhideTextInstance","scheduleTimeout","cancelTimeout","noTimeout","getInstanceFromNode","beforeActiveInstanceBlur","afterActiveInstanceBlur","detachDeletedInstance","prepareScopeUpdate","getInstanceFromScope","shouldAttemptEagerTransition","trackSchedulerEvent","resolveEventType","resolveEventTimeStamp","requestPostPaintCallback","maySuspendCommit","preloadInstance","startSuspendingCommit","suspendInstance","waitForCommitToBeReady","NotPendingTransition","HostTransitionContext","setCurrentUpdatePriority","newPriority","getCurrentUpdatePriority","resolveUpdatePriority","resetFormInstance","_roots","shallowLoose","onCreated","active","events","connected","connect","unmountComponentAtNode","canvas","disconnect","gl","renderLists","forceContextLoss","xr","raycaster","pointer","inject","injectState","viewport","getCurrentViewport","mouse","setEvents","usePortalStore","onMutate","setState","globalEffects","globalAfterEffects","globalTailEffects","run","effects","timestamp","flushGlobalEffects","subscribers","subscription","update","frame","delta","clock","getDelta","frameloop","elapsedTime","oldTime","priority","running","useFrameInProgress","loop","requestAnimationFrame","isPresenting","cancelAnimationFrame","advance","runGlobalEffects","DOM_EVENTS","onClick","onContextMenu","onDoubleClick","onWheel","onPointerDown","onPointerUp","onPointerLeave","onPointerMove","onPointerCancel","onLostPointerCapture","createPointerEvents","handlePointer","filterPointerEvents","cancelPointer","intersections","hoveredObj","hit","onPointerOut","pointerMissed","onPointerMissed","lastEvent","isPointerMove","isClickEvent","hits","duplicates","eventsObjects","compute","flatMap","enabled","intersectObject","sort","aState","bState","distance","intersection","intersect","dx","offsetX","initialClick","dy","offsetY","round","sqrt","calculateDistance","localState","stopped","traverseAncestors","parentState","unprojectedPoint","x","unproject","hasPointerCapture","setPointerCapture","extractEventProps","property","raycastEvent","ray","stopPropagation","capturesForPointer","currentTarget","nativeEvent","handleIntersects","onPointerOver","onPointerEnter","hoveredItem","createEvents","setFromCamera","reduce","acc","eventName","passive","addEventListener","removeEventListener","CanvasImpl","resize","style","eventSource","eventPrefix","shadows","flat","legacy","orthographic","performance","forwardRef","Bridge","ContextBridge","contextMap","$$typeof","contextProvider","useContextMap","Prev","Tar","useContextBridge","useBridge","containerRef","containerRect","scroll","debounce","canvasRef","divRef","handlePointerMissed","block","setBlock","setError","async","configure","prevRoot","prevStore","logRecoverableError","reportError","rootStore","defaultTarget","tempTarget","isVector3","getWorldPosition","distanceTo","zoom","factor","fov","PI","h","tan","w","performanceTimeout","setPerformanceCurrent","controls","regress","initialDpr","setSize","setDpr","resolved","setFrameloop","stop","oldSize","oldDpr","oldCamera","setPixelRatio","updateStyle","HTMLCanvasElement","domElement","createStore","lastCamera","configured","pending","_resolve","glConfig","propsSize","sceneOptions","onCreatedCallback","raycastOptions","cameraOptions","defaultProps","powerPreference","antialias","alpha","customRenderer","isCamera","z","rotation","lookAt","isScene","parentElement","getBoundingClientRect","OffscreenCanvas","computeInitialSize","handleXRFrame","handleSessionChange","setAnimationLoop","shadowMap","oldEnabled","oldType","types","basic","percentage","soft","variance","needsUpdate","outputColorSpace","toneMapping","createRoot","pointerEvents","overflow","display","Canvas"],"sourceRoot":""}