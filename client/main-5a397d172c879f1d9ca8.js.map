{"version":3,"file":"main-5a397d172c879f1d9ca8.js","mappings":"i9sCAGEA,EAAOC,QAAU,EAAjBD,K,6GCE8BE,EAAAA,sBAAAA,oBAMzB,ICJCC,EAA+CD,EAAAA,sBAAAA,sBAEjDE,GAFiDF,EAAAA,sBAAAA,oBAEhC,CACrBG,KAAK,EACLC,KAAK,EACLC,QAAQ,EACRC,UAAU,IAUCC,EAAM,SACjBC,EACAC,EACAC,EACAC,EACAC,G,MAEMC,EAAe,CAAC,EAElBV,EAAqB,KACrBC,EAAiC,KAerC,IAAK,IAAMU,UAbMC,IAAbL,IACFP,EAAM,GAAKO,QAIOK,KAAhBN,aAAM,EAANA,EAAQN,OACVA,EAAM,GAAKM,EAAON,MAGhBM,aAAM,EAANA,EAAQL,OACVA,EAAMK,EAAOL,KAGSK,EAClBO,OAAOC,UAAUC,eAAeC,KAAKV,EAAQK,KAAeE,OAAOC,UAAUC,eAAeC,KAAKjB,EAAgBY,KACnHD,EAAMC,GAAaL,EAAOK,IAI9B,GAAIN,IAAyB,mBAATA,GAAuC,YAAhBY,EAAAA,EAAAA,GAAOZ,IAAoB,CACpE,IAAMa,EAAYb,EAClBQ,OAAOM,MAAKD,aAAA,EAAAA,EAAWE,eAAgB,CAAC,GAAGC,SAAQ,SAACrB,G,MAClDU,EAAMV,QAAsBY,IAAfF,EAAMV,GAA8C,QAAzBsB,EAAAJ,EAAUE,oBAAe,IAAAE,OAAA,EAAAA,EAAAtB,GAAOU,EAAMV,EAChF,GACD,CAoBD,OAlBasB,EAAA,IACVC,EAAAA,SAAUC,EAAAA,QACXF,EAAAjB,KAAIA,EACJiB,EAAAtB,IAAGA,EACHsB,EAAArB,IAAGA,EACHqB,EAAAZ,MAAKA,EACLY,EAAAG,MAAM,EACNH,EAAAI,MAAOjB,EACPa,EAAAK,QAASnB,EACTc,EAAMM,OAAE9B,EAAsB+B,QAC9BP,EAAAQ,OAAQ,CAAC,EAA4B,CASzC,EAoCaC,EAAO,SAAC1B,EAA0BC,EAAeN,EAAoBQ,EAAuCC,GAIrH,OAAOL,EAAIC,EAAMC,EAAQN,EAAKQ,EAAQC,EAE1C,C,q3wCCvHEd,EAAOC,QAAU,EAAjBD,K,i6KCAAA,EAAOC,QAAU,EAAjBD,K,g8YCAAA,EAAOC,QAAU,EAAjBD,I,wlBCDK,ICOHqC,ECsHQC,EAsiBAC,EA6oBAC,EAwCAC,EAmKAC,EAQAC,EAyTAC,EAmDAC,EAoBAC,EAwYAC,EAqLAC,EAquCAC,EA2aAC,EA0NAC,EAiDAC,EAmGAC,EAiCAC,EAsEAC,EAoBAC,EAyXAC,EA2BAC,EAgRAC,EAMAC,EA2CAC,EAcAC,EAUAC,EA0EAC,EAQAC,EAcAC,EAgiBAC,EA+GAC,EAcAC,EAwDAC,EAMAC,EA2EAC,EAQAC,EAmQAC,EA+EAC,EA0PAC,EAUAC,GAyGAC,GA2KAC,GA0DAC,GAwDAC,GAQAC,GAsYAC,GA0FAC,GAUAC,GA+HAC,GAwKAC,GA+EAC,GA6FAC,GAoiBAC,GAuBAC,GAkEAC,GAcAC,GAgHAC,GAYAC,GAu8CAC,GAiCAC,GAyEAC,GAUAC,GAkBAC,GAgGAC,GA0LAC,GAkSAC,GAoSAC,GAwDAC,GA0BAC,GA4DAC,GAiBAC,GA6MAC,GA0DAC,GAsDAC,GAytBAC,GAYAC,GAkCAC,GAQAC,GAoBAC,GAkKAC,GAcAC,GA0CAC,GAoFAC,GA0BAC,GAwEAC,GAmEAC,GAcAC,GAoWAC,GAyCAC,GA2EAC,GAgCAC,GA8KAC,GAmIAC,GA4CAC,GA4DAC,GAQAC,GA+EAC,GAwlBAC,GAkBAC,GAuPAC,GAuCAC,GAmBAC,GAYAC,GAgGAC,GAsKAC,GAwHAC,GAwXAC,GAyEAC,GAiHAC,GAmSAC,GAkVAC,GA+DAC,GAuHAC,GAiEAC,GAikBAC,GA+DAC,GA+DAC,GAkEAC,GA4lBAC,GAsGAC,GAsIAC,GAYAC,GAcAC,GA0DAC,GAMAC,GAiEAC,GAQAC,GAoBAC,GAwDAC,GAiBAC,GA2CAC,GAuKAC,GAqCAC,GAuSAC,GAUAC,GAYAC,GA0DAC,GA2CAC,GAmFAC,GA8CAC,GAgBAC,GA+BAC,GAmEAC,GAgKAC,GAiJAC,GAwBAC,GA8CAC,GAMAC,GA8BAC,GAiIAC,GA2HAC,GAcAC,GAMAC,GAgBAC,GA2NAC,GA+FAC,GAooBAC,GAoCAC,GAkDAC,GAQAC,GAQAC,GAkBAC,GAMAC,GA0JAC,GAgBAC,GAQAC,GAwFAC,GAYAC,GAwnEAC,GA6JAC,GAsEAC,GFjtvBCC,GAAiB,IAAIC,EAAAA,EAAc,CAC9CC,aAAc,CACZC,WAAY,CACVC,OAAQ,CACNC,OAAQ,CACNC,SAAS,EACTC,MAAK,SAACC,EAA0BC,G,QAC9B,YADI,IAAAD,IAAAA,EAAA,CAAaE,MAAO,MACA,QAApBhM,EAAA8L,aAAA,EAAAA,EAAUG,gBAAU,IAAAjM,OAAA,EAAAA,EAAAkM,gBAAoC,QAApBC,EAAAJ,aAAQ,EAARA,EAAUE,gBAAU,IAAAE,OAAA,EAAAA,EAAAD,aAAoBJ,EAChFM,EAAAA,EAAAA,EAAA,GACKN,GACAC,GAAQ,CACXC,MAAKK,EAAAA,EAAA,GAAMP,EAASE,OAAO,GAAGD,EAASC,OACvC,I,KAKVM,MAAO,CACLZ,OAAQ,CACNa,SAAU,CACRX,SAAS,EACTC,MAAK,SAACC,EAA0BC,G,QAC9B,YADI,IAAAD,IAAAA,EAAA,CAAaE,MAAO,MACA,QAApBhM,EAAA8L,aAAA,EAAAA,EAAUG,gBAAU,IAAAjM,OAAA,EAAAA,EAAAkM,gBAAoC,QAApBC,EAAAJ,aAAQ,EAARA,EAAUE,gBAAU,IAAAE,OAAA,EAAAA,EAAAD,aAAoBJ,EAChFM,EAAAA,EAAAA,EAAA,GACKN,GACAC,GAAQ,CACXC,MAAKK,EAAAA,EAAA,GAAMP,EAASE,OAAO,GAAGD,EAASC,OACvC,I,QAQDQ,GAAa,IAAIjB,EAAAA,EG7BxBkB,GAA8B,oBAAXC,OAEZC,GAAW,IAAIC,EAAAA,EAAS,CACnCC,IALe,iCAMfC,MAAKA,EAAAA,QAGMC,IAAcC,EAAAA,EAAAA,IAAQ,SAAChN,G,IAAEiN,EAAYjN,EAAAiN,aAAEC,EAAalN,EAAAkN,cAC3DD,GACFE,QAAQC,MAAM,8BAAAC,OAA8BJ,EAAaK,QAAO,iBAAAD,OAAgBJ,EAAaM,SAE3FL,aAAa,EAAbA,EAAeM,SACjBN,EAAcnN,SAAQ,SAACqN,GACrBD,QAAQC,MAAM,8BAAAC,OAA8BD,EAAME,QAAO,gBAAAD,OAAeD,EAAMG,OAChF,GAEJ,IAEaE,IAAWC,EAAAA,EAAAA,IAAW,SAACC,EAAG3N,GAAE,IAAA4N,EAAO5N,EAAA4N,QAC9C,MAAO,CACLA,QAAOxB,EAAAA,EAAA,GACFwB,GAAO,CACVC,cAAe,SAAAR,OACbZ,GACIqB,KAAK,4DACLC,OAAOC,KAAK,2DAA4D,UAAUC,cAI9F,IF1BMC,GAA+B,oBAAXxB,OAUpByB,GAAqB,SAACC,EAA0CC,QAA1C,IAAAD,IAAAA,EAAwC,IAClE,IAAME,EAAgB5N,QAAAA,EATI,SAACV,EAAkFqO,QAAlF,IAAArO,IAAAA,EAAgF,I,IAA3EuO,E,yUAASC,CAAAxO,EAAd,IAC3B,YAD6G,IAAAqO,IAAAA,GAAyB,GACtI,IAAII,EAAAA,EACFrC,EAAA,CAAAsC,QAASR,GACTS,MAAMX,EAAAA,EAAAA,GAAK,CAACjB,GAAaU,GAAUd,KACnCiC,MAAOP,EAAqB/C,GAAiBkB,IAC1C+B,G,CAIiCM,CAAoB,CAAC,EAAGR,GAG9D,GAAIH,GACFI,EAAcM,MAAME,QAAQ,CAAC,OACxB,CAEL,IAAMC,EAAiBT,EAAcM,MAAMI,UAC3CV,EAAcM,MAAME,SAAQjD,EAAAA,EAAAA,GAAMkD,EAAgBX,GACnD,CAID,OAFKF,KAAYxN,EAAe4N,GAEzBA,CACT,EAIaW,GAAY,SAACb,EAAqCC,GAE7D,OADca,EAAAA,EAAAA,UAAQ,WAAM,OAAAf,GAAmBC,EAAcC,EAAmB,GAAE,CAACD,EAAcC,GAEnG,EGwEac,GAAoB,CAC/BC,KAAM,WACNC,YAAa,CACX,CACED,KAAM,sBACNE,UAAW,QACXC,KAAM,CAAEH,KAAM,OAAQI,MAAO,aAC7BC,oBAAqB,CACnB,CACEL,KAAM,qBACNM,SAAU,CAAEN,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,UAC3DzQ,KAAM,CAAEqQ,KAAM,YAAaG,KAAM,CAAEH,KAAM,OAAQI,MAAO,QACxDG,aAAc,CAAEP,KAAM,WAAYI,MAAO,QAG7CI,aAAc,CACZR,KAAM,eACNS,WAAY,CACV,CACET,KAAM,QACNG,KAAM,CAAEH,KAAM,OAAQI,MAAO,UAC7BI,aAAc,CACZR,KAAM,eACNS,WAAY,CACV,CAAET,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,OAC9C,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,SAC9C,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,UAC9C,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,UAC9C,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,cAC9C,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,cAC9C,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,eAC9C,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,gBAC9C,CACEJ,KAAM,QACNG,KAAM,CAAEH,KAAM,OAAQI,MAAO,aAC7BM,UAAW,CACT,CAAEV,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,SAAWA,MAAO,CAAEJ,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,YAEtHI,aAAc,CACZR,KAAM,eACNS,WAAY,CACV,CACET,KAAM,QACNG,KAAM,CAAEH,KAAM,OAAQI,MAAO,SAC7BI,aAAc,CACZR,KAAM,eACNS,WAAY,CACV,CAAET,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,OAC9C,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,SAC9C,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,UAC9C,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,UAC9C,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,YAC9C,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,oBAO1D,CACEJ,KAAM,QACNG,KAAM,CAAEH,KAAM,OAAQI,MAAO,aAC7BM,UAAW,CACT,CAAEV,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,SAAWA,MAAO,CAAEJ,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,YAEtHI,aAAc,CACZR,KAAM,eACNS,WAAY,CACV,CACET,KAAM,QACNG,KAAM,CAAEH,KAAM,OAAQI,MAAO,SAC7BI,aAAc,CACZR,KAAM,eACNS,WAAY,CACV,CAAET,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,OAC9C,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,SAC9C,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,UAC9C,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,UAC9C,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,YAC9C,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,4BAe7DO,GAAsB,CACjCX,KAAM,WACNC,YAAa,CACX,CACED,KAAM,sBACNE,UAAW,QACXC,KAAM,CAAEH,KAAM,OAAQI,MAAO,eAC7BC,oBAAqB,CACnB,CACEL,KAAM,qBACNM,SAAU,CAAEN,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,SAC3DzQ,KAAM,CAAEqQ,KAAM,cAAerQ,KAAM,CAAEqQ,KAAM,YAAaG,KAAM,CAAEH,KAAM,OAAQI,MAAO,aAEvF,CACEJ,KAAM,qBACNM,SAAU,CAAEN,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,UAC3DzQ,KAAM,CAAEqQ,KAAM,cAAerQ,KAAM,CAAEqQ,KAAM,YAAaG,KAAM,CAAEH,KAAM,OAAQI,MAAO,aAEvF,CACEJ,KAAM,qBACNM,SAAU,CAAEN,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,UAC3DzQ,KAAM,CAAEqQ,KAAM,YAAaG,KAAM,CAAEH,KAAM,OAAQI,MAAO,SAE1D,CACEJ,KAAM,qBACNM,SAAU,CAAEN,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,SAC3DzQ,KAAM,CAAEqQ,KAAM,YAAaG,KAAM,CAAEH,KAAM,OAAQI,MAAO,SAE1D,CACEJ,KAAM,qBACNM,SAAU,CAAEN,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,UAC3DzQ,KAAM,CAAEqQ,KAAM,YAAaG,KAAM,CAAEH,KAAM,OAAQI,MAAO,YAE1D,CACEJ,KAAM,qBACNM,SAAU,CAAEN,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,WAC3DzQ,KAAM,CAAEqQ,KAAM,YAAaG,KAAM,CAAEH,KAAM,OAAQI,MAAO,YAE1D,CACEJ,KAAM,qBACNM,SAAU,CAAEN,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,WAC3DzQ,KAAM,CAAEqQ,KAAM,WAAYrQ,KAAM,CAAEqQ,KAAM,cAAerQ,KAAM,CAAEqQ,KAAM,YAAaG,KAAM,CAAEH,KAAM,OAAQI,MAAO,cAEjH,CACEJ,KAAM,qBACNM,SAAU,CAAEN,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,YAC3DzQ,KAAM,CAAEqQ,KAAM,YAAaG,KAAM,CAAEH,KAAM,OAAQI,MAAO,gBAE1D,CACEJ,KAAM,qBACNM,SAAU,CAAEN,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,WAC3DzQ,KAAM,CAAEqQ,KAAM,WAAYrQ,KAAM,CAAEqQ,KAAM,cAAerQ,KAAM,CAAEqQ,KAAM,YAAaG,KAAM,CAAEH,KAAM,OAAQI,MAAO,kBAEjH,CACEJ,KAAM,qBACNM,SAAU,CAAEN,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,aAC3DzQ,KAAM,CAAEqQ,KAAM,YAAaG,KAAM,CAAEH,KAAM,OAAQI,MAAO,mBAG5DI,aAAc,CACZR,KAAM,eACNS,WAAY,CACV,CACET,KAAM,QACNG,KAAM,CAAEH,KAAM,OAAQI,MAAO,cAC7BM,UAAW,CACT,CAAEV,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,QAAUA,MAAO,CAAEJ,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,UACnH,CAAEJ,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,SAAWA,MAAO,CAAEJ,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,YAEtHI,aAAc,CACZR,KAAM,eACNS,WAAY,CACV,CAAET,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,OAC9C,CACEJ,KAAM,QACNG,KAAM,CAAEH,KAAM,OAAQI,MAAO,UAC7BM,UAAW,CACT,CAAEV,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,SAAWA,MAAO,CAAEJ,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,WACpH,CAAEJ,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,QAAUA,MAAO,CAAEJ,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,UACnH,CAAEJ,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,SAAWA,MAAO,CAAEJ,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,WACpH,CAAEJ,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,UAAYA,MAAO,CAAEJ,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,YACrH,CAAEJ,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,UAAYA,MAAO,CAAEJ,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,YACrH,CAAEJ,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,WAAaA,MAAO,CAAEJ,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,aACtH,CAAEJ,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,UAAYA,MAAO,CAAEJ,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,YACrH,CAAEJ,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,YAAcA,MAAO,CAAEJ,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,eAEzHI,aAAc,CACZR,KAAM,eACNS,WAAY,CACV,CACET,KAAM,QACNG,KAAM,CAAEH,KAAM,OAAQI,MAAO,SAC7BI,aAAc,CACZR,KAAM,eACNS,WAAY,CACV,CAAET,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,OAC9C,CACEJ,KAAM,QACNG,KAAM,CAAEH,KAAM,OAAQI,MAAO,UAC7BI,aAAc,CACZR,KAAM,eACNS,WAAY,CACV,CAAET,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,UAC9C,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,iBAIpD,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,WAC9C,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,cAC9C,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,gBAC9C,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,cAC9C,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,UAC9C,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,UAC9C,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,SAC9C,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,aAC9C,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,WAIpD,CACEJ,KAAM,QACNG,KAAM,CAAEH,KAAM,OAAQI,MAAO,YAC7BI,aAAc,CACZR,KAAM,eACNS,WAAY,CACV,CAAET,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,cAC9C,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,gBAC9C,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,gBAC9C,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,uBAIpD,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,0BAYvDQ,GAAwB,CACnCZ,KAAM,WACNC,YAAa,CACX,CACED,KAAM,sBACNE,UAAW,QACXC,KAAM,CAAEH,KAAM,OAAQI,MAAO,iBAC7BC,oBAAqB,CACnB,CACEL,KAAM,qBACNM,SAAU,CAAEN,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,SAC3DzQ,KAAM,CAAEqQ,KAAM,cAAerQ,KAAM,CAAEqQ,KAAM,YAAaG,KAAM,CAAEH,KAAM,OAAQI,MAAO,aAEvF,CACEJ,KAAM,qBACNM,SAAU,CAAEN,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,UAC3DzQ,KAAM,CAAEqQ,KAAM,cAAerQ,KAAM,CAAEqQ,KAAM,YAAaG,KAAM,CAAEH,KAAM,OAAQI,MAAO,aAEvF,CACEJ,KAAM,qBACNM,SAAU,CAAEN,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,WAC3DzQ,KAAM,CAAEqQ,KAAM,cAAerQ,KAAM,CAAEqQ,KAAM,YAAaG,KAAM,CAAEH,KAAM,OAAQI,MAAO,UAEvF,CACEJ,KAAM,qBACNM,SAAU,CAAEN,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,UAC3DzQ,KAAM,CAAEqQ,KAAM,YAAaG,KAAM,CAAEH,KAAM,OAAQI,MAAO,QACxDG,aAAc,CAAEP,KAAM,WAAYI,MAAO,OAE3C,CACEJ,KAAM,qBACNM,SAAU,CAAEN,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,UAC3DzQ,KAAM,CAAEqQ,KAAM,YAAaG,KAAM,CAAEH,KAAM,OAAQI,MAAO,aAG5DI,aAAc,CACZR,KAAM,eACNS,WAAY,CACV,CACET,KAAM,QACNG,KAAM,CAAEH,KAAM,OAAQI,MAAO,cAC7BM,UAAW,CACT,CAAEV,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,QAAUA,MAAO,CAAEJ,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,UACnH,CAAEJ,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,SAAWA,MAAO,CAAEJ,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,YAEtHI,aAAc,CACZR,KAAM,eACNS,WAAY,CACV,CAAET,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,OAC9C,CACEJ,KAAM,QACNG,KAAM,CAAEH,KAAM,OAAQI,MAAO,SAC7BM,UAAW,CACT,CAAEV,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,UAAYA,MAAO,CAAEJ,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,aAEvHI,aAAc,CACZR,KAAM,eACNS,WAAY,CACV,CACET,KAAM,QACNG,KAAM,CAAEH,KAAM,OAAQI,MAAO,UAC7BI,aAAc,CACZR,KAAM,eACNS,WAAY,CACV,CAAET,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,UAC9C,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,iBAIpD,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,OAC9C,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,SAC9C,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,UAC9C,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,WAC9C,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,cAC9C,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,gBAC9C,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,cAC9C,CACEJ,KAAM,QACNG,KAAM,CAAEH,KAAM,OAAQI,MAAO,YAC7BM,UAAW,CACT,CAAEV,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,SAAWA,MAAO,CAAEJ,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,WACpH,CAAEJ,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,SAAWA,MAAO,CAAEJ,KAAM,WAAYG,KAAM,CAAEH,KAAM,OAAQI,MAAO,YAEtHI,aAAc,CACZR,KAAM,eACNS,WAAY,CACV,CACET,KAAM,QACNG,KAAM,CAAEH,KAAM,OAAQI,MAAO,SAC7BI,aAAc,CACZR,KAAM,eACNS,WAAY,CACV,CAAET,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,OAC9C,CACEJ,KAAM,QACNG,KAAM,CAAEH,KAAM,OAAQI,MAAO,UAC7BI,aAAc,CACZR,KAAM,eACNS,WAAY,CACV,CAAET,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,UAC9C,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,iBAIpD,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,SAC9C,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,cAC9C,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,cAC9C,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,uBAIpD,CACEJ,KAAM,QACNG,KAAM,CAAEH,KAAM,OAAQI,MAAO,YAC7BI,aAAc,CACZR,KAAM,eACNS,WAAY,CACV,CAAET,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,cAC9C,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,gBAC9C,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,gBAC9C,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,uBAIpD,CAAEJ,KAAM,QAASG,KAAM,CAAEH,KAAM,OAAQI,MAAO,8BF9V1E,SAAY7O,GAEVA,EAAA,YAEAA,EAAA,WACD,CALD,CAAYA,IAAAA,EAKX,KAiiBD,SAAYC,GAEVA,EAAA,sBACD,CAHD,CAAYA,IAAAA,EAGX,KA0oBD,SAAYC,GAEVA,EAAA,kBAEAA,EAAA,gBAEAA,EAAA,iBACD,CAPD,CAAYA,IAAAA,EAOX,KAiCD,SAAYC,GAEVA,EAAA,iCAEAA,EAAA,sBAEAA,EAAA,kBAEAA,EAAA,kBAEAA,EAAA,kBAEAA,EAAA,cAEAA,EAAA,iCAEAA,EAAA,kBAEAA,EAAA,oBACD,CAnBD,CAAYA,IAAAA,EAmBX,KAgJD,SAAYC,GAEVA,EAAA,UAEAA,EAAA,eACD,CALD,CAAYA,IAAAA,EAKX,KAGD,SAAYC,GAEVA,EAAA,sBAEAA,EAAA,yBAEAA,EAAA,kBAEAA,EAAA,gBAEAA,EAAA,sBAEAA,EAAA,iBACD,CAbD,CAAYA,IAAAA,EAaX,KA4SD,SAAYC,GAEVA,EAAA,UAEAA,EAAA,gBAEAA,EAAA,iBACD,CAPD,CAAYA,IAAAA,EAOX,KA4CD,SAAYC,GAEVA,EAAA,4BAEAA,EAAA,0BAEAA,EAAA,yBAEAA,EAAA,8CAEAA,EAAA,sBAEAA,EAAA,gBAEAA,EAAA,YAEAA,EAAA,aACD,CAjBD,CAAYA,IAAAA,EAiBX,KAGD,SAAYC,GAEVA,EAAA,oBAEAA,EAAA,gBAEAA,EAAA,yCAEAA,EAAA,gBAEAA,EAAA,+BAEAA,EAAA,0BAEAA,EAAA,+CACD,CAfD,CAAYA,IAAAA,EAeX,KAyXD,SAAYC,GAEVA,EAAA,2BAEAA,EAAA,wBACD,CALD,CAAYA,IAAAA,EAKX,KAgLD,SAAYC,GAEVA,EAAA,+BAEAA,EAAA,iCAEAA,EAAA,YAEAA,EAAA,iCAEAA,EAAA,8BACD,CAXD,CAAYA,IAAAA,EAWX,KA0tCD,SAAYC,GAEVA,EAAA,cAEAA,EAAA,YAEAA,EAAA,YAEAA,EAAA,aACD,CATD,CAAYA,IAAAA,EASX,KAkaD,SAAYC,GAEVA,EAAA,kBAEAA,EAAA,oBAEAA,EAAA,QAEAA,EAAA,cAEAA,EAAA,UAEAA,EAAA,cAEAA,EAAA,UAEAA,EAAA,mBACD,CAjBD,CAAYA,IAAAA,EAiBX,KAyMD,SAAYC,GAEVA,EAAA,sBACD,CAHD,CAAYA,IAAAA,EAGX,KA8CD,SAAYC,GAEVA,EAAA,uCAEAA,EAAA,sBACD,CALD,CAAYA,IAAAA,EAKX,KA8FD,SAAYC,GAEVA,EAAA,oBAEAA,EAAA,mBACD,CALD,CAAYA,IAAAA,EAKX,KA4BD,SAAYC,GAEVA,EAAA,sBAEAA,EAAA,gBAEAA,EAAA,sBAEAA,EAAA,cAEAA,EAAA,kBAEAA,EAAA,oBAEAA,EAAA,yBAEAA,EAAA,kBAEAA,EAAA,gBAEAA,EAAA,iBACD,CArBD,CAAYA,IAAAA,EAqBX,KAiDD,SAAYC,GAEVA,EAAA,cAEAA,EAAA,kBAEAA,EAAA,oBAEAA,EAAA,yBAEAA,EAAA,kBAEAA,EAAA,gBAEAA,EAAA,kBAEAA,EAAA,iBACD,CAjBD,CAAYA,IAAAA,EAiBX,KAGD,SAAYC,GAEVA,EAAA,YAEAA,EAAA,aACD,CALD,CAAYA,IAAAA,EAKX,KAoXD,SAAYC,GAEVA,EAAA,uBAEAA,EAAA,sBACD,CALD,CAAYA,IAAAA,EAKX,KAsBD,SAAYC,GAEVA,EAAA,yBAEAA,EAAA,wBAEAA,EAAA,mBAEAA,EAAA,2BAEAA,EAAA,8BACD,CAXD,CAAYA,IAAAA,EAWX,KAqQD,SAAYC,GAEVA,EAAA,sBACD,CAHD,CAAYA,IAAAA,EAGX,KAGD,SAAYC,GAEVA,EAAA,iCAEAA,EAAA,aACD,CALD,CAAYA,IAAAA,EAKX,KAsCD,SAAYC,GAEVA,EAAA,cAEAA,EAAA,YAEAA,EAAA,qBAEAA,EAAA,YAEAA,EAAA,aACD,CAXD,CAAYA,IAAAA,EAWX,KAGD,SAAYC,GAEVA,EAAA,oBAEAA,EAAA,kBAEAA,EAAA,oBACD,CAPD,CAAYA,IAAAA,EAOX,KAGD,SAAYC,GAEVA,EAAA,kBAEAA,EAAA,oBACD,CALD,CAAYA,IAAAA,EAKX,KAqED,SAAYC,GAEVA,EAAA,uBAEAA,EAAA,aACD,CALD,CAAYA,IAAAA,EAKX,KAGD,SAAYC,GAEVA,EAAA,UAEAA,EAAA,oBAEAA,EAAA,qBAEAA,EAAA,kBAEAA,EAAA,eACD,CAXD,CAAYA,IAAAA,EAWX,KAGD,SAAYC,GAEVA,EAAA,oBAEAA,EAAA,iBACD,CALD,CAAYA,IAAAA,EAKX,KA2hBD,SAAYC,GAEVA,EAAA,uBAEAA,EAAA,6BAEAA,EAAA,oBACD,CAPD,CAAYA,IAAAA,EAOX,KAwGD,SAAYC,GAEVA,EAAA,aACD,CAHD,CAAYA,IAAAA,EAGX,KAWD,SAAYC,GAEVA,EAAA,cAEAA,EAAA,mCACD,CALD,CAAYA,IAAAA,EAKX,KAmDD,SAAYC,GAEVA,EAAA,sBACD,CAHD,CAAYA,IAAAA,EAGX,KAGD,SAAYC,GAEVA,EAAA,kBAEAA,EAAA,kBAEAA,EAAA,iBACD,CAPD,CAAYA,IAAAA,EAOX,KAoED,SAAYC,GAEVA,EAAA,gBAEAA,EAAA,aACD,CALD,CAAYA,IAAAA,EAKX,KAGD,SAAYC,GAEVA,EAAA,cAEAA,EAAA,eACD,CALD,CAAYA,IAAAA,EAKX,KA8PD,SAAYC,GAEVA,EAAA,sBAEAA,EAAA,oBAEAA,EAAA,eACD,CAPD,CAAYA,IAAAA,EAOX,KAwED,SAAYC,GAEVA,EAAA,mCAEAA,EAAA,gBAEAA,EAAA,gBAEAA,EAAA,sBAEAA,EAAA,aAEAA,EAAA,mCAEAA,EAAA,sBAEAA,EAAA,iCAEAA,EAAA,kBAEAA,EAAA,kBAEAA,EAAA,mBACD,CAvBD,CAAYA,IAAAA,EAuBX,KAmOD,SAAYC,GAEVA,EAAA,uBAEAA,EAAA,qBAEAA,EAAA,sBACD,CAPD,CAAYA,IAAAA,EAOX,KAGD,SAAYC,GAEVA,EAAA,UAEAA,EAAA,gBAEAA,EAAA,eACD,CAPD,CAAYA,KAAAA,GAOX,KAkGD,SAAYC,GAEVA,EAAA,mBAEAA,EAAA,qBAEAA,EAAA,yBAEAA,EAAA,iCAEAA,EAAA,6CAEAA,EAAA,kBAEAA,EAAA,6BAEAA,EAAA,gCAEAA,EAAA,iBAEAA,EAAA,uBAEAA,EAAA,2BAEAA,EAAA,2BAEAA,EAAA,yBAEAA,EAAA,kCAEAA,EAAA,oBAEAA,EAAA,mCAEAA,EAAA,aACD,CAnCD,CAAYA,KAAAA,GAmCX,KAwID,SAAYC,GAEVA,EAAA,wBAEAA,EAAA,oBAEAA,EAAA,2BACD,CAPD,CAAYA,KAAAA,GAOX,KAmDD,SAAYC,GAEVA,EAAA,oBAEAA,EAAA,iBACD,CALD,CAAYA,KAAAA,GAKX,KAmDD,SAAYC,GAEVA,EAAA,kCAEAA,EAAA,sBACD,CALD,CAAYA,KAAAA,GAKX,KAGD,SAAYC,GAEVA,EAAA,oBAEAA,EAAA,iBACD,CALD,CAAYA,KAAAA,GAKX,KAiYD,SAAYC,GAEVA,EAAA,sBACD,CAHD,CAAYA,KAAAA,GAGX,KAuFD,SAAYC,GAEVA,EAAA,oBAEAA,EAAA,uBAEAA,EAAA,sBACD,CAPD,CAAYA,KAAAA,GAOX,KAGD,SAAYC,GAEVA,EAAA,gBAEAA,EAAA,WACD,CALD,CAAYA,KAAAA,GAKX,KA0HD,SAAYC,GAEVA,EAAA,6CAEAA,EAAA,+BAEAA,EAAA,2BAEAA,EAAA,4CAEAA,EAAA,iCAEAA,EAAA,0DAEAA,EAAA,2DAEAA,EAAA,8CAEAA,EAAA,uCAEAA,EAAA,uCAEAA,EAAA,6BAEAA,EAAA,6BAEAA,EAAA,2BAEAA,EAAA,mDAEAA,EAAA,iCAEAA,EAAA,mCAEAA,EAAA,4DAEAA,EAAA,2BAEAA,EAAA,mCAEAA,EAAA,qDAEAA,EAAA,wCAEAA,EAAA,+BAEAA,EAAA,mCAEAA,EAAA,qCAEAA,EAAA,mCAEAA,EAAA,iCAEAA,EAAA,+BAEAA,EAAA,uDAEAA,EAAA,+BAEAA,EAAA,uCAEAA,EAAA,qCACD,CA/DD,CAAYA,KAAAA,GA+DX,KAyGD,SAAYC,GAEVA,EAAA,uBAEAA,EAAA,WACD,CALD,CAAYA,KAAAA,GAKX,KA0ED,SAAYC,GAEVA,EAAA,WACD,CAHD,CAAYA,KAAAA,GAGX,KA0FD,SAAYC,GAEVA,EAAA,qBAEAA,EAAA,oBAEAA,EAAA,YAEAA,EAAA,sBACD,CATD,CAAYA,KAAAA,GASX,KA2hBD,SAAYC,GAEVA,EAAA,gBAEAA,EAAA,kBAEAA,EAAA,cAEAA,EAAA,cAKAA,EAAA,cAEAA,EAAA,qBAEAA,EAAA,kBAEAA,EAAA,mBACD,CApBD,CAAYA,KAAAA,GAoBX,KAGD,SAAYC,GAEVA,EAAA,0BAEAA,EAAA,sBAEAA,EAAA,iBACD,CAPD,CAAYA,KAAAA,GAOX,KA2DD,SAAYC,GAEVA,EAAA,2BAEAA,EAAA,mCAEAA,EAAA,gBAEAA,EAAA,+BAEAA,EAAA,eACD,CAXD,CAAYA,KAAAA,GAWX,KAGD,SAAYC,GAEVA,EAAA,gBAEAA,EAAA,yBAEAA,EAAA,yBAEAA,EAAA,gBAEAA,EAAA,qBACD,CAXD,CAAYA,KAAAA,GAWX,KAqGD,SAAYC,GAEVA,EAAA,uBAEAA,EAAA,mBAEAA,EAAA,gBAEAA,EAAA,sBACD,CATD,CAAYA,KAAAA,GASX,KAGD,SAAYC,GAEVA,EAAA,gBAEAA,EAAA,WACD,CALD,CAAYA,KAAAA,GAKX,KAk8CD,SAAYC,GAEVA,EAAA,oBAEAA,EAAA,iBACD,CALD,CAAYA,KAAAA,GAKX,KA4BD,SAAYC,GAEVA,EAAA,SACD,CAHD,CAAYA,KAAAA,GAGX,KAsED,SAAYC,GAEVA,EAAA,gBAEAA,EAAA,mCAEAA,EAAA,qBACD,CAPD,CAAYA,KAAAA,GAOX,KAGD,SAAYC,GAEVA,EAAA,gBAEAA,EAAA,gCAEAA,EAAA,gBAEAA,EAAA,gBAEAA,EAAA,gBAEAA,EAAA,kBAEAA,EAAA,mBACD,CAfD,CAAYA,KAAAA,GAeX,KAGD,SAAYC,GAEVA,EAAA,UAEAA,EAAA,WACD,CALD,CAAYA,KAAAA,GAKX,KA2FD,SAAYC,GAEVA,EAAA,cAEAA,EAAA,WACD,CALD,CAAYA,KAAAA,GAKX,KAqLD,SAAYC,GAEVA,EAAA,oBAEAA,EAAA,6BAEAA,EAAA,YAEAA,EAAA,gCAEAA,EAAA,qBACD,CAXD,CAAYA,KAAAA,GAWX,KAuRD,SAAYC,GAEVA,EAAA,aACD,CAHD,CAAYA,KAAAA,GAGX,KAiSD,SAAYC,GAEVA,EAAA,6DAEAA,EAAA,6FAEAA,EAAA,yEACD,CAPD,CAAYA,KAAAA,GAOX,KAiDD,SAAYC,GAOVA,EAAA,cAEAA,EAAA,iCAEAA,EAAA,6BAMAA,EAAA,2CAKAA,EAAA,2BACD,CAvBD,CAAYA,KAAAA,GAuBX,KAGD,SAAYC,GAEVA,EAAA,6DAEAA,EAAA,6FAEAA,EAAA,uDAEAA,EAAA,0EAEAA,EAAA,yCACD,CAXD,CAAYA,KAAAA,GAWX,KAiDD,SAAYC,GAEVA,EAAA,iCAMAA,EAAA,2CAKAA,EAAA,2BACD,CAdD,CAAYA,KAAAA,GAcX,KAGD,SAAYC,GAEVA,EAAA,6DAEAA,EAAA,yEACD,CALD,CAAYA,KAAAA,GAKX,KAwMD,SAAYC,GAEVA,EAAA,cAEAA,EAAA,YAEAA,EAAA,YAEAA,EAAA,aACD,CATD,CAAYA,KAAAA,GASX,KAiDD,SAAYC,GAEVA,EAAA,cAEAA,EAAA,WACD,CALD,CAAYA,KAAAA,GAKX,KAiDD,SAAYC,GAEVA,EAAA,UAEAA,EAAA,oBAEAA,EAAA,YAEAA,EAAA,kBAEAA,EAAA,mCAEAA,EAAA,gBAEAA,EAAA,iCAEAA,EAAA,8BACD,CAjBD,CAAYA,KAAAA,GAiBX,KAwsBD,SAAYC,GAEVA,EAAA,cAEAA,EAAA,iCAEAA,EAAA,6BAEAA,EAAA,qBACD,CATD,CAAYA,KAAAA,GASX,KAGD,SAAYC,GAEVA,EAAA,cAEAA,EAAA,WACD,CALD,CAAYA,KAAAA,GAKX,KA6BD,SAAYC,GAEVA,EAAA,cAEAA,EAAA,eACD,CALD,CAAYA,KAAAA,GAKX,KAGD,SAAYC,GAEVA,EAAA,UAEAA,EAAA,oBAEAA,EAAA,oBAEAA,EAAA,iBACD,CATD,CAAYA,KAAAA,GASX,KAWD,SAAYC,GAEVA,EAAA,uBAEAA,EAAA,aACD,CALD,CAAYA,KAAAA,GAKX,KA6JD,SAAYC,GAEVA,EAAA,sBACD,CAHD,CAAYA,KAAAA,GAGX,KAWD,SAAYC,GAEVA,EAAA,sBACD,CAHD,CAAYA,KAAAA,GAGX,KAuCD,SAAYC,GAEVA,EAAA,gBAKAA,EAAA,gBAEAA,EAAA,cAEAA,EAAA,UAEAA,EAAA,cAEAA,EAAA,YAEAA,EAAA,mBACD,CAlBD,CAAYA,KAAAA,GAkBX,KAkED,SAAYC,GAEVA,EAAA,sBACD,CAHD,CAAYA,KAAAA,GAGX,KAuBD,SAAYC,GAEVA,EAAA,cAEAA,EAAA,kBAEAA,EAAA,gBAEAA,EAAA,kBAEAA,EAAA,oBAEAA,EAAA,iBACD,CAbD,CAAYA,KAAAA,GAaX,KA2DD,SAAYC,GAEVA,EAAA,YAEAA,EAAA,cAEAA,EAAA,4BAEAA,EAAA,kBAEAA,EAAA,2BAEAA,EAAA,wBAEAA,EAAA,YAEAA,EAAA,WACD,CAjBD,CAAYA,KAAAA,GAiBX,KAkDD,SAAYC,GAEVA,EAAA,qBAEAA,EAAA,yBAEAA,EAAA,qBAEAA,EAAA,2BAEAA,EAAA,sBACD,CAXD,CAAYA,KAAAA,GAWX,KAGD,SAAYC,GAEVA,EAAA,uBAEAA,EAAA,UAEAA,EAAA,mBAEAA,EAAA,uBAEAA,EAAA,YAEAA,EAAA,SACD,CAbD,CAAYA,KAAAA,GAaX,KAuVD,SAAYC,GAEVA,EAAA,oBAEAA,EAAA,0BACD,CALD,CAAYA,KAAAA,GAKX,KAoCD,SAAYC,GAEVA,EAAA,2BAEAA,EAAA,qBAEAA,EAAA,mBACD,CAPD,CAAYA,KAAAA,GAOX,KAoED,SAAYC,GAEVA,EAAA,YAEAA,EAAA,yBAEAA,EAAA,WACD,CAPD,CAAYA,KAAAA,GAOX,KAyBD,SAAYC,GAEVA,EAAA,yBAEAA,EAAA,cAEAA,EAAA,2BAEAA,EAAA,mBACD,CATD,CAAYA,KAAAA,GASX,KAqKD,SAAYC,GAEVA,EAAA,sBAEAA,EAAA,YAEAA,EAAA,sBAEAA,EAAA,gBAEAA,EAAA,0CAEAA,EAAA,sBAEAA,EAAA,gBAEAA,EAAA,wBAEAA,EAAA,sBAEAA,EAAA,6BAEAA,EAAA,YAEAA,EAAA,cAEAA,EAAA,eACD,CA3BD,CAAYA,KAAAA,GA2BX,KAwGD,SAAYC,GAEVA,EAAA,uBAEAA,EAAA,gBAEAA,EAAA,cAEAA,EAAA,sBACD,CATD,CAAYA,KAAAA,GASX,KAmCD,SAAYC,GAEVA,EAAA,uBAEAA,EAAA,YAEAA,EAAA,sBACD,CAPD,CAAYA,KAAAA,GAOX,KAqDD,SAAYC,GAEVA,EAAA,gBAEAA,EAAA,WACD,CALD,CAAYA,KAAAA,GAKX,KAGD,SAAYC,GAEVA,EAAA,wCAEAA,EAAA,kDAEAA,EAAA,2BAEAA,EAAA,sBACD,CATD,CAAYA,KAAAA,GASX,KAsED,SAAYC,GAEVA,EAAA,2BAEAA,EAAA,0BACD,CALD,CAAYA,KAAAA,GAKX,KAmlBD,SAAYC,GAEVA,EAAA,cAEAA,EAAA,gBAEAA,EAAA,eACD,CAPD,CAAYA,KAAAA,GAOX,KAWD,SAAYC,GAEVA,EAAA,uBAEAA,EAAA,sBACD,CALD,CAAYA,KAAAA,GAKX,KAkPD,SAAYC,GAEVA,EAAA,kBAEAA,EAAA,qBACD,CALD,CAAYA,KAAAA,GAKX,KAkCD,SAAYC,GAEVA,EAAA,oBAEAA,EAAA,qCAEAA,EAAA,gCACD,CAPD,CAAYA,KAAAA,GAOX,KAYD,SAAYC,GAEVA,EAAA,kBAEAA,EAAA,kBAEAA,EAAA,kBAEAA,EAAA,gCACD,CATD,CAAYA,KAAAA,GASX,KAGD,SAAYC,GAEVA,EAAA,oBAEAA,EAAA,qCAEAA,EAAA,sBAEAA,EAAA,sBAEAA,EAAA,iBACD,CAXD,CAAYA,KAAAA,GAWX,KAqFD,SAAYC,GAEVA,EAAA,gBAEAA,EAAA,gBAEAA,EAAA,WACD,CAPD,CAAYA,KAAAA,GAOX,KA+JD,SAAYC,GAEVA,EAAA,oDAEAA,EAAA,6CAEAA,EAAA,+BAEAA,EAAA,oEAEAA,EAAA,0EAEAA,EAAA,mDAEAA,EAAA,iDAEAA,EAAA,mDAEAA,EAAA,mDAEAA,EAAA,6CAEAA,EAAA,6CAEAA,EAAA,sDAEAA,EAAA,2BAEAA,EAAA,4CAEAA,EAAA,iCAEAA,EAAA,0DAEAA,EAAA,2DAEAA,EAAA,6CAEAA,EAAA,8CAEAA,EAAA,uCAEAA,EAAA,+BAEAA,EAAA,yEAEAA,EAAA,uCAEAA,EAAA,6CAEAA,EAAA,sDAEAA,EAAA,+CAEAA,EAAA,6BAEAA,EAAA,6BAEAA,EAAA,2BAEAA,EAAA,mDAEAA,EAAA,iCAEAA,EAAA,2BAEAA,EAAA,mCAEAA,EAAA,4DAEAA,EAAA,2BAEAA,EAAA,wCAEAA,EAAA,oEAEAA,EAAA,wCAEAA,EAAA,qDAEAA,EAAA,yDAEAA,EAAA,6CAEAA,EAAA,mCAEAA,EAAA,4DAEAA,EAAA,qDAEAA,EAAA,wCAEAA,EAAA,+BAEAA,EAAA,8CAEAA,EAAA,8CAEAA,EAAA,yDAEAA,EAAA,mCAEAA,EAAA,qCAEAA,EAAA,mCAEAA,EAAA,iCAEAA,EAAA,+BAEAA,EAAA,uDAEAA,EAAA,+BAEAA,EAAA,uCAEAA,EAAA,qCACD,CArHD,CAAYA,KAAAA,GAqHX,KAGD,SAAYC,GAEVA,EAAA,gBAEAA,EAAA,WACD,CALD,CAAYA,KAAAA,GAKX,KAmXD,SAAYC,GAEVA,EAAA,oBAEAA,EAAA,YAEAA,EAAA,cAEAA,EAAA,gBAEAA,EAAA,cAEAA,EAAA,gBAEAA,EAAA,yBAEAA,EAAA,oBACD,CAjBD,CAAYA,KAAAA,GAiBX,KAwDD,SAAYC,GAEVA,EAAA,sBACD,CAHD,CAAYA,KAAAA,GAGX,KA8GD,SAAYC,GAEVA,EAAA,4BAEAA,EAAA,+BACD,CALD,CAAYA,KAAAA,GAKX,KA8RD,SAAYC,GAEVA,EAAA,uBAEAA,EAAA,WACD,CALD,CAAYA,KAAAA,GAKX,KA6UD,SAAYC,GAEVA,EAAA,oBAEAA,EAAA,kBAEAA,EAAA,eACD,CAPD,CAAYA,KAAAA,GAOX,KAwDD,SAAYC,GAEVA,EAAA,oBAEAA,EAAA,kBAEAA,EAAA,eACD,CAPD,CAAYA,KAAAA,GAOX,KAgHD,SAAYC,GAEVA,EAAA,oBAEAA,EAAA,kBAEAA,EAAA,eACD,CAPD,CAAYA,KAAAA,GAOX,KA0DD,SAAYC,GAEVA,EAAA,cAEAA,EAAA,gBAEAA,EAAA,eACD,CAPD,CAAYA,KAAAA,GAOX,KA0jBD,SAAYC,GAEVA,EAAA,oBAEAA,EAAA,kBAEAA,EAAA,eACD,CAPD,CAAYA,KAAAA,GAOX,KAwDD,SAAYC,GAEVA,EAAA,oBAEAA,EAAA,kBAEAA,EAAA,eACD,CAPD,CAAYA,KAAAA,GAOX,KAwDD,SAAYC,GAEVA,EAAA,oBAEAA,EAAA,kBAEAA,EAAA,eACD,CAPD,CAAYA,KAAAA,GAOX,KA2DD,SAAYC,GAEVA,EAAA,cAEAA,EAAA,sBAEAA,EAAA,qBAEAA,EAAA,oBAEAA,EAAA,oBAEAA,EAAA,WACD,CAbD,CAAYA,KAAAA,GAaX,KA+kBD,SAAYC,GAEVA,EAAA,4BAKAA,EAAA,yCAEAA,EAAA,aACD,CAVD,CAAYA,KAAAA,GAUX,KA4FD,SAAYC,GAEVA,EAAA,gBAEAA,EAAA,cAEAA,EAAA,2BAEAA,EAAA,wCAEAA,EAAA,uBACD,CAXD,CAAYA,KAAAA,GAWX,KA2HD,SAAYC,GAEVA,EAAA,uCAEAA,EAAA,qCAEAA,EAAA,+BAEAA,EAAA,kBACD,CATD,CAAYA,KAAAA,GASX,KAGD,SAAYC,GAEVA,EAAA,iBAEAA,EAAA,qBAEAA,EAAA,mBAEAA,EAAA,uBAEAA,EAAA,sBACD,CAXD,CAAYA,KAAAA,GAWX,KAGD,SAAYC,GAEVA,EAAA,4BAEAA,EAAA,wBAEAA,EAAA,WACD,CAPD,CAAYA,KAAAA,GAOX,KAmDD,SAAYC,GAEVA,EAAA,sBACD,CAHD,CAAYA,KAAAA,GAGX,KAGD,SAAYC,GAEVA,EAAA,kBAEAA,EAAA,sBAEAA,EAAA,gBAEAA,EAAA,eACD,CATD,CAAYA,KAAAA,GASX,KAwDD,SAAYC,GAEVA,EAAA,UAEAA,EAAA,WACD,CALD,CAAYA,KAAAA,GAKX,KAGD,SAAYC,GAEVA,EAAA,sBACD,CAHD,CAAYA,KAAAA,GAGX,KAiBD,SAAYC,GAEVA,EAAA,uBAEAA,EAAA,YAEAA,EAAA,qBAEAA,EAAA,wBAEAA,EAAA,sBACD,CAXD,CAAYA,KAAAA,GAWX,KA6CD,SAAYC,GAKVA,EAAA,cAEAA,EAAA,oBAEAA,EAAA,YAEAA,EAAA,gBAEAA,EAAA,aACD,CAdD,CAAYA,KAAAA,GAcX,KAGD,SAAYC,GAEVA,EAAA,kBAEAA,EAAA,eACD,CALD,CAAYA,KAAAA,GAKX,KAsCD,SAAYC,GAEVA,EAAA,oBAEAA,EAAA,kBAEAA,EAAA,eACD,CAPD,CAAYA,KAAAA,GAOX,KAgKD,SAAYC,GAEVA,EAAA,sBAEAA,EAAA,cAEAA,EAAA,WACD,CAPD,CAAYA,KAAAA,GAOX,KA8BD,SAAYC,GAEVA,EAAA,sBAEAA,EAAA,yBAEAA,EAAA,kBAEAA,EAAA,gBAEAA,EAAA,iBACD,CAXD,CAAYA,KAAAA,GAWX,KA4RD,SAAYC,GAEVA,EAAA,6BAEAA,EAAA,cAEAA,EAAA,2BACD,CAPD,CAAYA,KAAAA,GAOX,KAGD,SAAYC,GAEVA,EAAA,YAEAA,EAAA,gBAEAA,EAAA,gBAEAA,EAAA,eACD,CATD,CAAYA,KAAAA,GASX,KAGD,SAAYC,GAEVA,EAAA,mBAEAA,EAAA,uBAEAA,EAAA,uBAEAA,EAAA,sBACD,CATD,CAAYA,KAAAA,GASX,KAiDD,SAAYC,GAEVA,EAAA,sBACD,CAHD,CAAYA,KAAAA,GAGX,KAwCD,SAAYC,GAEVA,EAAA,wBAEAA,EAAA,cAEAA,EAAA,wBAEAA,EAAA,WACD,CATD,CAAYA,KAAAA,GASX,KA0ED,SAAYC,GAEVA,EAAA,oBAEAA,EAAA,QAEAA,EAAA,cAEAA,EAAA,UAEAA,EAAA,cAEAA,EAAA,UAEAA,EAAA,oBAEAA,EAAA,WACD,CAjBD,CAAYA,KAAAA,GAiBX,KA6BD,SAAYC,GAEVA,EAAA,UAEAA,EAAA,WACD,CALD,CAAYA,KAAAA,GAKX,KAWD,SAAYC,GAEVA,EAAA,2BAEAA,EAAA,sBACD,CALD,CAAYA,KAAAA,GAKX,KA0BD,SAAYC,GAEVA,EAAA,oBAEAA,EAAA,YAEAA,EAAA,UAEAA,EAAA,mBACD,CATD,CAAYA,KAAAA,GASX,KA0DD,SAAYC,GAEVA,EAAA,sBACD,CAHD,CAAYA,KAAAA,GAGX,KA6JD,SAAYC,GAEVA,EAAA,cAEAA,EAAA,qBACD,CALD,CAAYA,KAAAA,GAKX,KA4ID,SAAYC,GAEVA,EAAA,aACD,CAHD,CAAYA,KAAAA,GAGX,KAqBD,SAAYC,GAEVA,EAAA,6CAEAA,EAAA,iCAEAA,EAAA,+BAEAA,EAAA,gBAEAA,EAAA,8CAEAA,EAAA,wBACD,CAbD,CAAYA,KAAAA,GAaX,KAiCD,SAAYC,GAEVA,EAAA,qBACD,CAHD,CAAYA,KAAAA,GAGX,KAGD,SAAYC,GAEVA,EAAA,UAEAA,EAAA,UAEAA,EAAA,cAEAA,EAAA,WACD,CATD,CAAYA,KAAAA,GASX,KAqBD,SAAYC,GAEVA,EAAA,sDAEAA,EAAA,yCACD,CALD,CAAYA,KAAAA,GAKX,KA4HD,SAAYC,GAEVA,EAAA,uBAEAA,EAAA,4CACD,CALD,CAAYA,KAAAA,GAKX,KAsHD,SAAYC,GAEVA,EAAA,sBACD,CAHD,CAAYA,KAAAA,GAGX,KAWD,SAAYC,GAEVA,EAAA,sBACD,CAHD,CAAYA,KAAAA,GAGX,KAGD,SAAYC,GAEVA,EAAA,kBAEAA,EAAA,eACD,CALD,CAAYA,KAAAA,GAKX,KAWD,SAAYC,GAEVA,EAAA,sBACD,CAHD,CAAYA,KAAAA,GAGX,KAwND,SAAYC,GAEVA,EAAA,cAEAA,EAAA,oBAEAA,EAAA,kBAEAA,EAAA,kBAEAA,EAAA,iBACD,CAXD,CAAYA,KAAAA,GAWX,KAoFD,SAAYC,GAEVA,EAAA,kBAEAA,EAAA,wBAEAA,EAAA,2BACD,CAPD,CAAYA,KAAAA,GAOX,KA6nBD,SAAYC,GAEVA,EAAA,eACD,CAHD,CAAYA,KAAAA,GAGX,KAiCD,SAAYC,GAEVA,EAAA,sBACD,CAHD,CAAYA,KAAAA,GAGX,KA+CD,SAAYC,GAEVA,EAAA,uBAEAA,EAAA,aACD,CALD,CAAYA,KAAAA,GAKX,KAGD,SAAYC,GAEVA,EAAA,wBAEAA,EAAA,eACD,CALD,CAAYA,KAAAA,GAKX,KAGD,SAAYC,GAEVA,EAAA,UAEAA,EAAA,uBAEAA,EAAA,qBACD,CAPD,CAAYA,KAAAA,GAOX,KAWD,SAAYC,GAEVA,EAAA,WACD,CAHD,CAAYA,KAAAA,GAGX,KAGD,SAAYC,GAEVA,EAAA,gBAEAA,EAAA,iBACD,CALD,CAAYA,KAAAA,GAKX,KAqJD,SAAYC,GAEVA,EAAA,uBAEAA,EAAA,YAEAA,EAAA,wBAEAA,EAAA,qBAEAA,EAAA,wBAEAA,EAAA,sBACD,CAbD,CAAYA,KAAAA,GAaX,KAGD,SAAYC,GAEVA,EAAA,2BAEAA,EAAA,wBACD,CALD,CAAYA,KAAAA,GAKX,KAGD,SAAYC,GAEVA,EAAA,cAEAA,EAAA,eACD,CALD,CAAYA,KAAAA,GAKX,KAmFD,SAAYC,GAEVA,EAAA,2BAEAA,EAAA,yCAEAA,EAAA,yBAEAA,EAAA,0BACD,CATD,CAAYA,KAAAA,GASX,KAGD,SAAYC,GAEVA,EAAA,gBAEAA,EAAA,WACD,CALD,CAAYA,KAAAA,GAKX,KAmnED,SAAYC,GAEVA,EAAA,iBAEAA,EAAA,qBAEAA,EAAA,mBAEAA,EAAA,sBAEAA,EAAA,sBACD,CAXD,CAAYA,KAAAA,GAWX,KAkJD,SAAYC,GAEVA,EAAA,sBACD,CAHD,CAAYA,KAAAA,GAGX,KAmED,SAAYC,GAEVA,EAAA,uBAEAA,EAAA,eACD,CALD,CAAYA,KAAAA,GAKX,I,wTGltvBM,IAAM4E,EAAkB,SAACC,GAAkD,IAAfC,EAAIL,UAAAtC,OAAA,QAAAlO,IAAAwQ,UAAA,GAAAA,UAAA,GAAG,IAClEM,GAAgBC,EAAAA,EAAAA,MAAKH,GAQ3B,OANiC,WAC/B,IAAM9Q,GAAQkR,EAAAA,EAAAA,IAAmBH,GAEjC,OAAOhQ,EAAAA,EAAAA,IAACiQ,E,qWAAaG,CAAA,GAAKnR,GAC5B,CAGF,C,0FCZaoR,GAAsBC,EAAAA,EAAAA,eAGhC,CAAEC,SAAS,EAAOC,WAAY,WAAY,IAEhCC,EAAiB,SAAHC,GAA8C,IAAxCC,EAAQD,EAARC,SAC/BC,GAA8BC,EAAAA,EAAAA,WAAS,GAAMC,GAAAC,EAAAA,EAAAA,GAAAH,EAAA,GAAtCL,EAAOO,EAAA,GAAEN,EAAUM,EAAA,GAC1B,OAAO9Q,EAAAA,EAAAA,IAACqQ,EAAoBW,SAAQ,CAAC3B,MAAO,CAAEkB,QAAAA,EAASC,WAAAA,GAAaG,SAAEA,GACxE,EAEaM,EAAkB,WAAH,OAASC,EAAAA,EAAAA,YAAWb,EAAoB,C,sKCPhEc,E,UAEEC,GAAOC,EAAAA,EAAAA,aAA2B,SAAa7D,EAAGhP,GAWtD,OAVA8S,EAAAA,EAAAA,KAAc,WACPH,IACHA,EAAMI,SAASC,cAAc,QAE/BL,EAAIM,GAAK,kBACTF,SAASG,KAAKC,QAAQR,EACxB,KAEkBS,EAAAA,EAAAA,OAECC,EAAAA,EAAAA,eAAa7R,EAAAA,EAAAA,IAAA,OAAKxB,IAAKA,EAAKsT,UCnBpB,SDmBiDC,MAAO,CAAEC,OAAQ,MAAOC,UAAW,iBAAqBd,GAAkB,IACxJ,IACae,GAAMhC,EAAAA,EAAAA,MAAKkB,GEbXe,EAAoC,WAC/C,IAAQ5B,GAAYU,EAAAA,EAAAA,MAAZV,QACA/R,GAAQ4T,EAAAA,EAAAA,IAAc,CAAE7B,QAAAA,IAAxB/R,IACR,OAAOwB,EAAAA,EAAAA,IAACkS,EAAG,CAAC1T,IAAKA,GACnB,E,wCCNa6T,GAAwB/B,EAAAA,EAAAA,eAA8D,MAEtFgC,EAAiC,SAAH5B,GAAyC,IAAnCC,EAAQD,EAARC,SAAU4B,EAAM7B,EAAN6B,OAAQJ,EAAUzB,EAAVyB,WACzDK,GAAWC,EAAAA,EAAAA,IAAW,CAAEF,OAAAA,EAAQG,QAAAA,EAAAA,KAAhCF,OAGR,OAAKA,GAGHG,EAAAA,EAAAA,IAACN,EAAsBrB,SAAQ,CAAC3B,MAAOmD,EAAO7B,SAAA,EAC5C3Q,EAAAA,EAAAA,IAACmS,EAAU,IACVxB,KALe,IAQtB,ECXaiC,EAAc,WACzB,IAAMJ,GDY+BtB,EAAAA,EAAAA,YAAWmB,GCX1CQ,GAAMC,EAAAA,EAAAA,IAAUC,EAAAA,EAAWP,aAAM,EAANA,EAAQQ,UAEzC,OACEhT,EAAAA,EAAAA,IAAAiT,EAAAA,GAAA,CAAAtC,UACGuC,EAAAA,EAAAA,uBACClT,EAAAA,EAAAA,IAACmT,EAAAA,EAAe,CAACC,iBAAe,EAAAzC,UAC9B3Q,EAAAA,EAAAA,IAACqT,EAAAA,SAAQ,CAAA1C,UACP3Q,EAAAA,EAAAA,IAACsT,EAAAA,EAAAA,IAAU,CACTC,QAAQ,UACRC,QAAQ,KACRC,KAAK,MACLC,SAAU,CACRH,QAAS,CACPI,QAAS,GAEXC,GAAI,CACFD,QAAS,GAEXE,IAAK,CACHF,QAAS,IAGbG,WAAY,CACVlV,KAAM,SACNmV,QAAS,GACTC,UAAW,IACXrD,SAEDkC,KAtBUL,aAAM,EAANA,EAAQQ,SAASiB,YA2BlCpB,GAIR,E,oBC5CaqB,EAAgB,SAAHxD,GAA8C,IAAxCC,EAAQD,EAARC,SACxBpQ,GAAeuO,EAAAA,EAAAA,KAAU,MAAM,GAErC,OAAO9O,EAAAA,EAAAA,IAACmU,EAAAA,EAAc,CAACC,OAAQ7T,EAAaoQ,SAAEA,GAChD,E,kDCLO,IAAM0D,EAAiB,SAAAC,IAAAC,EAAAA,EAAAA,GAAAF,EAAAC,GAAA,I,IAAAE,G,EAAAH,E,gaAAA,SAAAA,IAAA,IAAAI,GAAAC,EAAAA,EAAAA,GAAA,KAAAL,GAAA,QAAAM,EAAAhF,UAAAtC,OAAAuH,EAAA,IAAAC,MAAAF,GAAAG,EAAA,EAAAA,EAAAH,EAAAG,IAAAF,EAAAE,GAAAnF,UAAAmF,GAK3B,OAL2BL,EAAAD,EAAAjV,KAAAwV,MAAAP,EAAA,OAAAtH,OAAA0H,KAC5BI,MAAQ,CACN5H,MAAO,GACPH,MAAO,GACPgI,UAAU,GACXR,CAAA,CAIA,OAJAS,EAAAA,EAAAA,GAAAb,EAAA,EAAA9V,IAAA,oBAAA8Q,MAMD,SAAkBpC,EAAckI,GAC9BC,KAAKC,SAAS,CACZpI,MAAOA,EAAME,QACbC,MAAO+H,EAAKG,gBAEhB,GAAC,CAAA/W,IAAA,SAAA8Q,MAED,WACE,OAAI+F,KAAKJ,MAAMC,UAEXtC,EAAAA,EAAAA,IAAA,OAAAhC,SAAA,EACE3Q,EAAAA,EAAAA,IAAA,KAAG+R,MAAO,CAAEwD,MAAO,MAAOC,WAAY,YAAa7E,SAAEyE,KAAKJ,MAAM/H,QAC/DmI,KAAKJ,MAAM5H,SAGXgI,KAAKnW,MAAM0R,QACpB,IAAC,EAAApS,IAAA,2BAAA8Q,MApBD,WACE,MAAO,CAAE4F,UAAU,EACrB,KAACZ,CAAA,CAT2B,CAAStE,EAAAA,W,UCG1B0F,EAAc,SAAH/E,GAA8C,IAAxCC,EAAQD,EAARC,SACtB+E,GAAUC,EAAAA,EAAAA,QAA+B,MAEzCC,GAAOC,EAAAA,EAAAA,iBAAe,SAACb,GAAK,OAAKA,EAAMc,OAAOC,WAAWH,IAAI,IAC7DI,GAAOH,EAAAA,EAAAA,iBAAe,SAACb,GAAK,OAAKA,EAAMZ,OAAO6B,WAAWL,IAAI,IAWnE,OATAM,EAAAA,EAAAA,YAAU,WACHR,EAAQtV,UACXsV,EAAQtV,QAAUmR,SAAS4E,cAAc,SAEvCT,EAAQtV,UACVsV,EAAQtV,QAAQ4V,KAAOA,EAE3B,GAAG,CAACA,KAGFhW,EAAAA,EAAAA,IAACoW,EAAAA,EAAY,CAACC,OAAQL,EAAMM,SAAUV,EAAKI,IAAS,CAAC,EAAGO,cAAeC,EAAAA,YAAY7F,SAChFA,GAGP,ECjBa8F,EAAM,WACjB,OACEzW,EAAAA,EAAAA,IAACkU,EAAa,CAAAvD,UACZ3Q,EAAAA,EAAAA,IAACyQ,EAAAA,GAAc,CAAAE,UACb3Q,EAAAA,EAAAA,IAACyV,EAAW,CAAA9E,UACV3Q,EAAAA,EAAAA,IAACsS,EAAY,CAACC,OAAQQ,EAAAA,EAAWZ,WAAYA,EAAWxB,UACtD3Q,EAAAA,EAAAA,IAACqU,EAAiB,CAAA1D,UAChB3Q,EAAAA,EAAAA,IAAC4S,EAAW,aAO1B,ECXM8D,GAAeC,EAAAA,EAAAA,sBAEfC,EAAO,SAAHlG,GAAsE,IAAhEmG,EAAKnG,EAALmG,MAERC,GAAcC,EAAAA,EAAAA,IAAqBxF,SAASyF,QAElD,OACEhX,EAAAA,EAAAA,IAACiX,EAAAA,WAAU,CAAAtG,UACT3Q,EAAAA,EAAAA,IAACkX,EAAAA,EAAa,CAAC7H,MAAOqH,EAAa/F,UACjC3Q,EAAAA,EAAAA,IAACmX,EAAAA,IAAc,CAACC,MAAOA,EAAAA,MAAOC,iBAAkBP,EAAYnG,UAC1D3Q,EAAAA,EAAAA,IAACgR,EAAAA,GAAQ,CAAC6F,MAAOA,EAAOS,YAAaT,EAAMU,WAAW5G,UACpD3Q,EAAAA,EAAAA,IAACwX,EAAAA,GAAM,CAAA7G,UACL3Q,EAAAA,EAAAA,IAACyX,EAAAA,GAAc,CAAA9G,UACb3Q,EAAAA,EAAAA,IAACyW,EAAG,eAQpB,ECpBMiB,EAAQnG,SAAS4E,cAAc,gBAE/BwB,EAAoBpG,SAAS4E,cAAc,0BAE3CyB,EAAsBrG,SAAS4E,cAAc,4BAE7CU,GAAQgB,EAAAA,EAAAA,sBAAqB,CACjCC,eAAgBC,KAAKC,OAAMJ,aAAmB,EAAnBA,EAAqBK,YAAa,QAG/D1L,OAAO2L,QAAUH,KAAKC,OAAML,aAAiB,EAAjBA,EAAmBM,YAAa,MAE5D1L,OAAO4L,wBAA0BJ,KAAKC,OAAMJ,aAAmB,EAAnBA,EAAqBK,YAAa,OAE9EG,EAAAA,EAAAA,UAAS7L,OAAO2L,UAEhBE,EAAAA,EAAAA,UAAS7L,OAA8C,YAEvD6L,EAAAA,EAAAA,UAAS7L,OAAO4L,0BAEhBC,EAAAA,EAAAA,UAAS7L,OAA8C,2BAEvDS,QAAQqL,IAAI,4BAADnL,OAA6BX,OAAO2L,QAAQI,SAAQ,gBAE3D/L,OAAO2L,QAAQK,YAEjBC,EAD4BC,EAAQ,MAA5BD,iBACQ3B,EAAM6B,SAAUnM,OAAO2L,QAAQS,MAAqBC,MAAK,kBAAMC,EAAAA,EAAAA,KAAc,kBAAMC,EAAAA,EAAAA,SAAO9Y,EAAAA,EAAAA,IAAC4W,EAAI,CAACC,MAAOA,IAAWa,EAAM,GAAC,KAEpInL,OAAO2L,QAAQa,OAAUxM,OAAO2L,QAAQc,eAAiBzM,OAAO2L,QAAQe,cAC3EJ,EAAAA,EAAAA,KAAc,kBAAMC,EAAAA,EAAAA,SAAO9Y,EAAAA,EAAAA,IAAC4W,EAAI,CAACC,MAAOA,IAAWa,EAAM,KAEzDmB,EAAAA,EAAAA,KAAc,kBAAMK,EAAAA,EAAAA,UAAQlZ,EAAAA,EAAAA,IAAC4W,EAAI,CAACC,MAAOA,IAAWa,EAAM,G,uQCxCjDyB,EAAoB,SAAIlL,GAA8E,IAAjDmL,EAAIzJ,UAAAtC,OAAA,QAAAlO,IAAAwQ,UAAA,GAAAA,UAAA,GAAG,IACvEiB,GAA0BC,EAAAA,EAAAA,UAAS5C,GAAa6C,GAAAC,EAAAA,EAAAA,GAAAH,EAAA,GAAzCoE,EAAKlE,EAAA,GAAEuE,EAAQvE,EAAA,GAItB,MAAO,CAACkE,GAFiBjG,EAAAA,EAAAA,UAAQ,kBAAMsK,EAAAA,EAAAA,GAAShE,EAAU+D,EAAK,GAAE,CAACA,IAGpE,ECMME,EAA4B,CAChCC,MAAO,EACPvH,OAAQ,EACRwH,KAAM,EACNC,MAAO,EACPC,IAAK,EACLC,OAAQ,EACRC,EAAG,EACHC,EAAG,GAKE,SAASC,EAAUpJ,GAAsF,IAAnFlS,EAAGkS,EAAHlS,IAAKub,EAAWrJ,EAAXqJ,YAChCC,EAAwBb,EAA+BG,EAAc,KAAIW,GAAAlJ,EAAAA,EAAAA,GAAAiJ,EAAA,GAAlEE,EAAID,EAAA,GAAEE,EAAOF,EAAA,GAyBpB,OAvBA/D,EAAAA,EAAAA,YAAU,WACR,IAAMkE,EAAa5b,EAAMA,EAAI4B,QAAU2Z,EAAcxI,SAAS4E,cAAc4D,GAAe,KAC3F,GAAIK,EAAY,CACd,GAAI7N,OAAO8N,eAAgB,CACzB,IAAMC,EAAiB,IAAID,gBAAe,WACxCF,EAAQC,EAAWG,wBACrB,IAIA,OAFAD,EAAeE,QAAQJ,GAEhB,kBAAME,EAAeG,YAAY,CAC1C,CACE,IAAMC,EAAe,WAAH,OAASP,EAAQC,EAAWG,wBAAwB,EAMtE,OAJAG,IAEAnO,OAAOoO,iBAAiB,SAAUD,EAAc,CAAEE,SAAS,IAEpD,kBAAMrO,OAAOsO,oBAAoB,SAAUH,EAAa,CAEnE,CACF,GAAG,CAAClc,EAAKub,EAAaI,IAEfD,CACT,CCvDO,I,6BCYDzH,EAA6B,SAAH/B,GAA4B,IAAtB6B,EAAM7B,EAAN6B,OAAQG,EAAOhC,EAAPgC,QACtCoI,GAAanF,EAAAA,EAAAA,UACbkB,GAAQkE,EAAAA,EAAAA,MACR/H,GAAWgI,EAAAA,EAAAA,MACXC,GAAWC,EAAAA,EAAAA,MACjBC,GAAgBC,EAAAA,EAAAA,MAATC,GAA0BtK,EAAAA,EAAAA,GAAAoK,EAAA,GAArB,GACJ3K,GAAeS,EAAAA,EAAAA,MAAfT,WAEF8K,GAAY3F,EAAAA,EAAAA,WAAO4F,EAAAA,EAAAA,eACnBC,GAAa7F,EAAAA,EAAAA,QAA2B,IACxC8F,GAAc9F,EAAAA,EAAAA,QAAsB,IACpC+F,GAAS/F,EAAAA,EAAAA,QAA8B,MACvCgG,GAAShG,EAAAA,EAAAA,QAA8B,MACvCiG,GAAWjG,EAAAA,EAAAA,QAAOkB,GAGxBjG,GAA4CC,EAAAA,EAAAA,WAAS0K,EAAAA,EAAAA,mBAAepc,EAAY,CAAE6T,SAAAA,EAAUqI,MAAAA,IAAQvK,GAAAC,EAAAA,EAAAA,GAAAH,EAAA,GAA7FiL,EAAc/K,EAAA,GAAEgL,EAAiBhL,EAAA,GAgExC,OA9DA2K,EAAYrb,QAAU,GAAH8M,OAAM8F,EAASiB,SAAQ,KAAA/G,OAAImO,EAAMvN,YAEpD0N,EAAWpb,QAAUyb,EAAiB,GAAH3O,OAAM2O,EAAe7I,SAASiB,SAAQ,KAAA/G,OAAI2O,EAAeR,MAAMvN,YAAe,GAEjH8N,EAASxb,QAAUyW,GAEnBX,EAAAA,EAAAA,YAAU,WAER,GAAKoF,EAAUlb,QAkDbkb,EAAUlb,SAAU,MAlDE,CACtB,IAAM2b,EAAwBjB,EAAW1a,SAAW0a,EAAW1a,UAAY,GAAL8M,OAAQ8F,EAASiB,SAAQ,KAAA/G,OAAImO,EAAMvN,YACpGiO,GACHvL,GAAW,GAETgL,EAAWpb,UAAY,GAAL8M,OAAQ8F,EAASiB,SAAQ,KAAA/G,OAAImO,EAAMvN,cAClDiO,IACHL,EAAOtb,SAAW4b,aAAaN,EAAOtb,SACtCsb,EAAOtb,QAAU,KACjBub,EAAOvb,SAAW4b,aAAaL,EAAOvb,SACtCub,EAAOvb,QAAU,KACjBsb,EAAOtb,QAAU6b,YAAW,WAC1BzL,GAAW,EACb,GAAG,MAIe,SAACwC,EAA0CqI,GAC7D3I,EAAQH,EAAQS,EAASiB,SAAUoH,EAAOO,EAASxb,SAASwY,MAAK,SAAC/Z,GAChE,IAAMqd,EAAiB,GAAHhP,OAAM8F,EAASiB,SAAQ,KAAA/G,OAAImO,EAAMvN,YACrD,GAAIoO,IAAmBT,EAAYrb,QAAS,CAC1C,IACc+b,EADdC,EAAmCvd,GAAU,CAAC,EAAtCwd,EAAQD,EAARC,SAAUpP,EAAKmP,EAALnP,MAAOhO,EAAKmd,EAALnd,MAEvB6b,EAAW1a,QADTic,EACmB,GAAHnP,OAAMmP,EAASrJ,SAASsJ,SAAQ,KAAApP,OAA2B,QAA3BiP,EAAIE,EAASrJ,SAASqI,aAAK,IAAAc,OAAA,EAAvBA,EAAyBrO,YAE1D,GAEnBb,GACFD,QAAQC,MAAMA,GACduD,GAAW,IACF6L,EACTpB,EAASH,EAAW1a,SAEpBub,EAAOvb,QAAU6b,YAAW,WAC1BP,EAAOtb,SAAW4b,aAAaN,EAAOtb,SACtCsb,EAAOtb,QAAU,KACbqb,EAAYrb,UAAY8b,IAC1Bjd,GAAS2c,EAASxb,QAAQsY,UAAS6D,EAAAA,EAAAA,IAAsB,CAAEnN,KAAMoN,EAAAA,EAAAA,YAA8B5G,KAAM3W,KACrGuR,GAAW,GACXsL,EAAkB,CAAE9I,SAAAA,EAAUqI,MAAAA,IAElC,GAAG,GAEP,CACF,GACF,CAEAoB,CAAYzJ,EAAUqI,GAE1B,CAGF,GAAG,CAACrI,EAAUN,EAASH,EAAQ0I,EAAUI,EAAO7K,IAEzC,CAAEgC,OAAQqJ,EACnB,E,6BCjFMa,EAAoB,SAACC,GACzB,IAAMC,EAAOrL,SAASsL,eAAeF,GAQjCC,IAEFA,EAAK7K,MAAM+K,eAAe,aAC1BF,EAAK7K,MAAM+K,eAAe,UAC1BF,EAAKjC,iBAAiB,iBAVxB,WACEiC,EAAK7K,MAAM+K,eAAe,YAC1BF,EAAK7K,MAAM+K,eAAe,eAC1BF,EAAK7K,MAAM+K,eAAe,aAC5B,GAM0D,CAAEC,MAAM,IAEpE,EAMaC,EAAwB,SAACC,GACpCA,EAAIrd,QAAQ8c,EACd,EC3BMQ,EAAY,SAuBdC,EAAQ,EAECC,GAAqB9M,EAAAA,EAAAA,gBAAkC,WAAY,IAEnE+M,GAAsB/M,EAAAA,EAAAA,gBAA0F,WAAY,IAE5HgN,GAAsBhN,EAAAA,EAAAA,eAGhC,CAAEiN,QAAS,GAAIC,OAAQ,KAEbC,EAAmB,WAC9B,IH1CAC,EG0CA9M,GAAgCC,EAAAA,EAAAA,UAAyB,IAAGC,GAAAC,EAAAA,EAAAA,GAAAH,EAAA,GAArD+M,EAAQ7M,EAAA,GAAE8M,EAAW9M,EAAA,GACtB+M,GAAclI,EAAAA,EAAAA,QAAOgI,GACrBG,GH5CNJ,GAAmBK,EAAAA,EAAAA,aAAW,SAACC,GAAC,OAAKA,EAAI,CAAC,GAAE,IAAEjN,EAAAA,EAAAA,GAAA2M,EAAA,GAA/B,IG6CfG,EAAYzd,QAAUud,EACtB,IAAMM,GAAoBC,EAAAA,EAAAA,cAAY,SAACzM,EAAY0M,IACjDC,EAAAA,EAAAA,IACE,GACA,WACE,IACMC,EADiBR,EAAYzd,QACFke,QAAO,SAACC,GACvC,OAAIJ,EACKI,EAAEC,WAAaD,EAAE9M,KAAOA,EAExB8M,EAAEC,WAAaD,EAAE9M,KAAOA,CAEnC,IACA,GAAI4M,EAAUhR,OAAQ,CACpB,IAAMoR,EAASJ,EAAUK,KAAI,SAACH,GAAC,OAAKA,EAAE9M,EAAE,IAClCkN,EAAiBF,EAAOG,MAAM,GAAI,GAClCC,EAAcJ,EAAOA,EAAOpR,OAAS,GACvB,CAAC6P,GAAShQ,QAAA4R,EAAAA,EAAAA,GAAKH,IDjCvCI,UAAUnf,SAAQ,SAAC6R,EAAIuN,GAAK,OAhCV,SAACrC,EAAgBqB,GACvC,IAAMpB,EAAOrL,SAAS4E,cAAc,IAADjJ,OAAKyP,IAExC,GAAIC,EAAM,CACR,IAAMqC,EAAI1S,OAAO2S,YACXC,GAAKF,EAAIjB,GAAKiB,EACpBrC,EAAK7K,MAAMqN,SAAW,SACtBxC,EAAK7K,MAAMsN,WAAa,YACxBzC,EAAK7K,MAAM+B,WAAa,yBACxB8I,EAAK7K,MAAME,UAAY,8CAAH/E,OAAiD8Q,EAAI,EAAC,eAAA9Q,OAAciS,EAAC,KACzFvC,EAAK7K,MAAMuM,OAAS,aACtB,CACF,CAoBuCgB,CAAgB7N,EAAI,GAAa,EAARuN,EAAU,ICkChEhC,EAAsB,CAAC6B,GACzB,MACE7B,EAAsB,CAACE,GAE3B,GA1DgB,iBA6DpB,GAAG,IAyDH,MAAO,CAAES,SAAAA,EAAU4B,MAxDNrB,EAAAA,EAAAA,cACX,SAACjf,GACC,IAAMugB,EAAevgB,EACfwgB,EAAa5B,EAAYzd,QACzBsf,GAAWC,EAAAA,EAAAA,GAASF,GAAY,SAAClB,GAAC,OAAKA,EAAEC,SAAS,IACxDgB,EAAajhB,IAAM,aAAH2O,OAAgBiQ,KAChCqC,EAAa/N,GAAK,aAAHvE,OAAgBiQ,KAC/BqC,EAAaxN,OAAS0N,EAAWA,EAAS1N,OAAS,EAAI,GACvDwN,EAAaI,SAAUF,EACvBF,EAAahB,WAAY,EACzB,IAAMqB,EAAeL,EAAaK,aAC5BC,EAAgBN,EAAaM,cACnCN,EAAaK,aAAe,WAC1BL,EAAahB,WAAY,EACzBqB,GAAgBA,IAChB/B,GACF,EACA0B,EAAaM,cAAgB,WAC3BA,GAAiBA,IACjBlC,GAAY,SAACmC,GACX,IAAMC,EAAiBD,EAAKzB,QAAO,SAACC,GAAC,OAAKA,IAAMiB,CAAY,IAY5D,OAXIQ,EAAe3S,QACjB2S,EAAeC,QAAO,SAACjC,EAAGkC,GACxB,OAAIlC,EAAEQ,WACJ0B,EAAEN,SAAU,EACLM,GACEA,EAAE1B,WACX0B,EAAEN,SAAU,EACLM,QAFF,CAIT,IAEKF,CACT,GACF,EACAR,EAAaW,aAAelC,EAC5BL,GAAY,SAACmC,GACX,IAAMC,EAAiBD,EAAKzB,QAAO,SAACC,GAAC,OAAKA,EAAEC,SAAS,IACrD,MAAO,GAAPtR,QAAA4R,EAAAA,EAAAA,GAAWkB,GAAc,CAAER,GAC7B,GACF,GACA,CAAC1B,EAAaG,IAeSmC,OAbXlC,EAAAA,EAAAA,cAAY,SAACjf,GACzB,IAAMwgB,EAAa5B,EAAYzd,QAC/BsQ,EAA8BzR,GAAS,CAAC,EAAhCohB,EAAO3P,EAAP2P,QAASC,EAAQ5P,EAAR4P,SACjB,QAAgBnhB,IAAZkhB,EAAuB,CACzB,IAAME,EAAiBd,EAAWe,MAAK,SAACjC,GAAC,OAAKA,EAAE9M,KAAO4O,CAAO,IAC9DE,SAAAA,EAAgBV,cAClB,MAAO,GAAIS,EACTb,EAAWnB,QAAO,SAACC,GAAC,OAAKA,EAAEC,SAAS,IAAE5e,SAAQ,SAAC2e,GAAC,OAAKA,aAAC,EAADA,EAAGsB,cAAc,QACjE,CACL,IAAMY,GAAoBd,EAAAA,EAAAA,GAASF,GAAY,SAAClB,GAAC,OAAKA,EAAEC,SAAS,IACjEiC,SAAAA,EAAmBZ,cACrB,CACF,GAAG,IAEL,EAEaa,EAAkB,WAAH,OAASxP,EAAAA,EAAAA,YAAWkM,EAAmB,EAEtDuD,EAAmB,WAAH,OAASzP,EAAAA,EAAAA,YAAWmM,EAAoB,EAExDuD,EAAkB,WAAH,OAAS1P,EAAAA,EAAAA,YAAWoM,EAAoB,E,UCvIvDuD,EAAc,WACzB,OAAOC,EAAAA,EAAAA,IAAmB,CAAEC,MAAM,EAAMC,IAAI,GAC9C,ECFapP,EAAe,WAC1B,IAAAhB,GAA8BC,EAAAA,EAAAA,WAAS,GAAMC,GAAAC,EAAAA,EAAAA,GAAAH,EAAA,GAAtCqQ,EAAOnQ,EAAA,GAAEoQ,EAAUpQ,EAAA,GAK1B,OAJAoF,EAAAA,EAAAA,YAAU,WACRgL,GAAW,EACb,GAAG,IAEID,CACT,ECCM7O,EAAgB,WAAiC,IAAhCnT,EAAsB0Q,UAAAtC,OAAA,QAAAlO,IAAAwQ,UAAA,GAAAA,UAAA,GAAG,CAAC,EAC/CwR,EAA+CliB,EAAvC+S,OAAAA,OAAM,IAAAmP,EAAG,IAAGA,EAAAC,EAA2BniB,EAAzBoiB,QAAAA,OAAO,IAAAD,EAAG,EAACA,EAAE7Q,EAAYtR,EAAZsR,QAE7B/R,GAAMmX,EAAAA,EAAAA,QAAuB,MAE7BX,GAAQW,EAAAA,EAAAA,QAAwB,CAAE0L,QAAAA,EAASrP,OAAAA,IAmCjD,OAjCAkE,EAAAA,EAAAA,YAAU,WACH3F,IACHyE,EAAM5U,QAAQ4R,OAASA,EACvBgD,EAAM5U,QAAQihB,QAAUA,EAE5B,GAAG,CAAC9Q,EAASyB,EAAQqP,KAErBnL,EAAAA,EAAAA,YAAU,WACR,GAAI1X,EAAI4B,QAAS,CACf,IAAMkhB,EAAM9iB,EAAI4B,QAChB,GAAImQ,EAAS,CACX,IACIkB,EADA0L,EAAQ,EAcZ,OADA1L,EAAK8P,uBAXS,SAARC,IACArE,EAAQ,MACVA,GAAS,KAEX,IAAIsE,GAAQzM,EAAM5U,QAAQihB,SAAW,GAAKlE,EAC1CsE,EAAOA,EAAO,KAAOA,EAAO,KAC5BH,EAAIvP,MAAM2P,QACR,WAAAxU,OAAW8H,EAAM5U,QAAQ4R,OAAM,2BAAA9E,OAA4BuU,EAAO,IAAG,SAAU,2DACjFzM,EAAM5U,QAAQihB,QAAUI,EACxBhQ,EAAK8P,sBAAsBC,EAC7B,IAEO,kBAAMG,qBAAqBlQ,EAAG,CACvC,CAEE,OADA2M,EAAAA,EAAAA,IAAM,IAAI,kBAAOkD,EAAIvP,MAAME,UAAY,UAAU,GAAG,cAAc2G,MAAK,kBAAMwF,EAAAA,EAAAA,IAAM,IAAI,kBAAOkD,EAAIvP,MAAMC,OAAS,KAAK,GAAG,aAAa,IAC/H,kBAAM4P,EAAAA,EAAAA,IAAO,aAAa,CAErC,CACF,GAAG,CAACrR,IAEG,CAAE/R,IAAAA,EACX,ECjDa8S,EAAgB,SAACuQ,IAC5B3L,EAAAA,EAAAA,YAAU,WACR2L,GAEF,GAAG,GACL,E,UCFaC,EAAgB,WAC3B,IAAA9H,EAA0Bb,EAAkB,CAC1CnH,OAAQ1F,EAAAA,EAAYC,OAAO2S,YAAc,EACzC3F,MAAOjN,EAAAA,EAAYC,OAAO2S,YAAc,IACxCjF,GAAAlJ,EAAAA,EAAAA,GAAAiJ,EAAA,GAHKhF,EAAKiF,EAAA,GAAE5E,EAAQ4E,EAAA,GAetB,OAVA/D,EAAAA,EAAAA,YAAU,WACR,IAAM6L,EAAS,WAAH,OAAS1M,EAAS,CAAErD,OAAQzF,OAAO2S,YAAa3F,MAAOhN,OAAOyV,YAAa,EAMvF,OAJAD,IAEAxV,OAAOoO,iBAAiB,SAAUoH,EAAQ,CAAEnH,SAAS,IAE9CrO,OAAOsO,oBAAoB,QAASkH,EAC7C,GAAG,CAAC1M,IAEGL,CACT,EClBMiN,GAAqBC,E,QAAAA,KAIxB,SAACC,EAAKC,GAAG,MAAM,CAChBjF,MAAO,EACPkF,KAAM,kBAAMF,EAAI,CAAEhF,MAAOiF,IAAMjF,MAAQ,GAAI,EAC3CmF,OAAQ,kBAAMH,EAAI,CAAEhF,MAAOiF,IAAMjF,MAAQ,GAAI,EAC9C,IAYYoF,EAAmB,WAAH,OAASN,GAAmB,SAACjN,GAAK,OAAKA,EAAMmI,KAAK,GAAC,ECpBnEhN,EAAqB,SAACqS,GAKjC,OAJmB3M,EAAAA,EAAAA,iBAAe,SAACb,GAAK,OAAKA,EAAMZ,OAAOqO,YAAY7M,IAAI,KAEzD8M,EAAAA,EAAAA,IAAgBF,GAGnC,ECJMG,EACJ,SAACpJ,GAAa,OACd,SAACyF,EAAevN,EAAYmR,GAC1B,IAAM3D,EALsB,GAKC4D,KAAKC,MAAMF,EAAa,IAC/CG,EAAO9D,EAAI,GAAK,GAAKA,EAC3B,MAAO,CACL+D,EAAGvR,EAAKuN,EACRpF,EAAGiJ,KAAKC,MAAM9D,EAAQzF,GACtBM,EAAGgJ,KAAKC,MAAM9D,EAAQzF,GACtB0J,EAAG,EACHC,KAAM3J,EACN0F,EAAG8D,EACHI,KAd0B,GAgB9B,CAAC,EAEGC,EAAaT,EAAkB,GAC/BU,EAAaV,EAAkB,GAC/BW,EAAaX,EAAkB,GAExBY,EAA2B,SAACC,GACvC,OAAOzU,EAAAA,EAAAA,UAAQ,WACb,IAAM0U,EAAKD,EAAM9E,KAAI,SAAAhO,EAAmBsS,GAAC,IAAjBvR,EAAEf,EAAFe,GAAIiS,EAAQhT,EAARgT,SAAQ,OAAUN,EAAWJ,EAAGvR,EAAIiS,EAASrW,OAAO,IAC1EsW,EAAKH,EAAM9E,KAAI,SAAAtC,EAAmB4G,GAAC,IAAjBvR,EAAE2K,EAAF3K,GAAIiS,EAAQtH,EAARsH,SAAQ,OAAUL,EAAWL,EAAGvR,EAAIiS,EAASrW,OAAO,IAC1E2T,EAAKwC,EAAM9E,KAAI,SAAAkF,EAAmBZ,GAAC,IAAjBvR,EAAEmS,EAAFnS,GAAIiS,EAAQE,EAARF,SAAQ,OAAUJ,EAAWN,EAAGvR,EAAIiS,EAASrW,OAAO,IAChF,MAAO,CACL2T,GAAAA,EACA2C,GAAI3C,EACJyC,GAAIE,EACJE,GAAIJ,EACJK,IAAKL,EAET,GAAG,CAACD,GACN,C,+CCnCO,IAAMO,EAA2C,CAAC,CAAC,KAAO,QAAQ,cAAgB,QAAQ,CAAC,KAAO,OAAO,cAAgB,OAAO,CAAC,KAAO,IAAI,cAAgB,SAAS,CAAC,KAAO,KAAK,cAAgB,O,0FCKnMC,GAASC,EAAAA,EAAAA,IAAS,CAADC,SAAA,GAAAC,UAAA,kCAAAC,QAAA,SAAAnlB,GAAA,IAAAV,EAAA,KAAA8lB,QAAAplB,GAAA,gBAAAilB,SAAA3lB,MAAA+lB,EAAAA,EAAA/lB,EAAA,EAAAgmB,YAAC,kBAAM,8EAA0B,EAAAC,aAAA,SAAAvlB,GAAA,IAAAwV,EAAA,KAAAlW,EAAA,KAAA8lB,QAAAplB,GAAA,YAAAilB,SAAA3lB,IAAA,OAAAgmB,YAAAtlB,GAAA2Z,MAAA,SAAAsL,GAAA,OAAAzP,EAAAyP,SAAA3lB,IAAA,EAAA2lB,CAAA,KAAAO,YAAA,SAAAxlB,GAAA,IAAAwS,EAAA,KAAA4S,QAAAplB,GAAA,OAAAylB,EAAAjT,EAAA,EAAA4S,QAAA,yBAAE,CACxDM,iBAAkB,SAACzmB,GAAM,OAAK4R,EAAAA,EAAAA,GAAgB5R,EAAO0mB,QAAQ,IAGzDC,EAAiC,CACrCC,UAAWd,EACXe,SAASvT,EAAAA,EAAAA,eAAcwS,IAGnBgB,EAAgBjB,EAAAA,EAAAA,KACf,SAAArT,GAA6B,IAA1BV,EAAIU,EAAJV,KAAMiV,EAAavU,EAAbuU,cAGV,OAAIjV,EAAKkV,WAAW,KACX,CACLlV,KAAM,YAAF9C,OAAc8C,EAAK4O,MAAM,IAC7BqG,cAAAA,GAGK,CACLjV,KAAM,YAAF9C,OAAc8C,GAClBiV,cAAAA,EAMR,IACCvG,KAAI,SAACyG,GAAE,MAAM,CACZnV,KAAMmV,EAAGnV,KACT8U,WAAWb,EAAAA,EAAAA,IAAS,CAADC,SAAA,GAAAC,UAAA,0BAAAjX,OAA0BiY,EAAGF,eAAaG,QAAA,kCAAAhB,QAAA,SAAAnlB,GAAA,IAAAV,EAAA,KAAA8lB,QAAAplB,GAAA,gBAAAilB,SAAA3lB,MAAA+lB,EAAAA,EAAA/lB,EAAA,EAAAgmB,YAAzC,kBAAM,QAAM,KAAArX,OAAaiY,EAAGF,eAAgB,EAAAT,aAAA,SAAAvlB,GAAA,IAAAwV,EAAA,KAAAlW,EAAA,KAAA8lB,QAAAplB,GAAA,YAAAilB,SAAA3lB,IAAA,OAAAgmB,YAAAtlB,GAAA2Z,MAAA,SAAAsL,GAAA,OAAAzP,EAAAyP,SAAA3lB,IAAA,EAAA2lB,CAAA,KAAAO,YAAA,SAAAxlB,GAAA,IAAAwS,EAAA,KAAA4S,QAAAplB,GAAA,OAAAylB,EAAAjT,EAAA,EAAA4S,QAAA,uCAAAnX,OAAnBiY,EAAGF,eAAa,GAAK,CAAEN,iBAAkB,SAACzmB,GAAM,OAAK4R,EAAAA,EAAAA,GAAgB5R,EAAO0mB,QAASO,EAAGnV,KAAK,IAC3I,IACA0O,KAAI,SAAAtC,GAAA,IAAGpM,EAAIoM,EAAJpM,KAAM8U,EAAS1I,EAAT0I,UAAS,MAAQ,CAC7B9U,KAAMA,EACN8U,UAAAA,EACAC,SAASvT,EAAAA,EAAAA,eAAcsT,GACxB,IAEHD,EAAWlU,SAAWqU,EAEf,IAAMjS,EAAY,CAAC8R,GAER,oBAAXtY,SAA4BA,OAAe8Y,WAAatS,E,8LCjD/D,IAAMuS,EAAyB,CAAC,EAC1BC,EAAuB,CAAC,EACxBC,EAAiB,CAAC,EACpBC,EAAY,EAGV7D,EAAiB,SAACrjB,GACtB,GAAI+mB,EAAW/mB,GAAM,CACnB,IAAM8O,EAASiY,EAAW/mB,GAAK8O,OAC/BiY,EAAW/mB,GAAO+mB,EAAW/mB,GAAKmgB,KAAI,SAACjN,GAAE,OAAKA,GAAMuK,aAAavK,EAAG,IAAEmN,MAAMvR,GAC5EkY,EAAUhnB,GAAOgnB,EAAUhnB,GAAKmgB,KAAI,SAACgH,GAAM,OAAKA,GAAUA,GAAQ,IAAE9G,MAAMvR,EAC5E,CACA,GAAIoY,EARe,IAQW,CAC5B,IAC0BE,EADoEC,E,25BAAAC,CAAjFzmB,OAAOM,KAAK8lB,GAAQM,MAAK,SAACC,EAAMC,GAAI,OAAMR,EAAOO,GAAQP,EAAOQ,GAAQ,GAAK,CAAC,KACjE,IAA1B,IAAAJ,EAAAzG,MAAAwG,EAAAC,EAAArH,KAAA0H,MAA4B,KAAjBC,EAAOP,EAAAtW,MACZ6W,IAAY3nB,GAAQgnB,EAAUW,GAAS7Y,gBAClCmY,EAAOU,UACPZ,EAAWY,UACXX,EAAUW,GACjBT,IAEJ,CAAC,OAAAU,GAAAP,EAAAQ,EAAAD,EAAA,SAAAP,EAAAS,GAAA,CACH,CACF,EAEMjI,EAAe,SAAChF,EAAMkN,EAAQ/nB,GAClC,YAAYY,IAARZ,EACK,IAAIgoB,SAAc,SAAClC,GACxBpI,YAAW,WACToI,GACF,GAAGjL,EACL,IAAGR,MAAK,WACN,GAAI0N,EAAQ,OAAOA,GACrB,KAEM/nB,KAAOinB,EAMXA,EAAOjnB,MALPinB,EAAOjnB,GAAO,EACd+mB,EAAW/mB,GAAO,GAClBgnB,EAAUhnB,GAAO,GACjBknB,KAIF7D,EAAOrjB,GACA,IAAIgoB,SAAc,SAAClC,EAASqB,GACjCH,EAAUhnB,GAAKioB,KAAKd,GACpBJ,EAAW/mB,GAAKioB,KACdvK,YAAW,WACToI,GACF,GAAGjL,GAEP,IACGR,MAAK,WACJ,GAAI0N,EAAQ,OAAOA,GACrB,IACCG,OAAM,WAAY,IAEzB,E,goBC5CA,SAAS/T,EACPH,EACA0B,EACAoH,EACAxE,GAQA,IAAM6P,GAASC,EAAAA,EAAAA,IAAYpU,EAAQ0B,IAAa,GAE1C2S,EAAmB3S,EAEnB4S,EAKQ,GAOd,OALAH,EAAO9mB,SAAQ,SAAA8Q,GAAiC,IAA9BoW,EAAKpW,EAALoW,MACVC,EAAQ,CAAEC,OADatW,EAANsW,OACC/S,SADevD,EAARuD,UAE/B4S,EAASL,KAAKS,EAAS,CAAEH,MAAOA,EAA6BjQ,MAAAA,EAAOkQ,MAAAA,EAAO1L,MAAAA,EAAOuL,iBAAAA,IACpF,IAEOL,QAAQ1T,IAAIgU,GAAUjO,MAAK,SAACsO,GACjC,OAAIA,EAAI7Z,OACkB6Z,EAAI5I,OAAO6I,SAASlH,QAKzC,SAACd,EAAGe,GACL,OAAKA,GAGLf,EAAElgB,OAAQyM,EAAAA,EAAAA,GAAMyT,EAAElgB,MAAOihB,EAAEjhB,OAC3BkgB,EAAEiI,MAAQjI,EAAEiI,MAAQ,IAAIla,OAAOgT,EAAEkH,MAAQ,IACzCjI,EAAElS,MAAQ,CAACkS,EAAElS,MAAOiT,EAAEjT,OAAOqR,OAAO6I,SAASE,KAAK,QAClDlI,EAAE9C,SAAW6D,EAAE7D,SAAW6D,EAAE7D,SAAW8C,EAAE9C,SAClC8C,GANEA,CAOX,GAAG,CAAC,GAGC,CACL9C,SAAU,CACRiL,KAAM,IACNtU,SAAU,CAAEsJ,SAAU,SAG5B,GACF,CAEA,IAAMoG,EAAkB,SAACpG,GAAgB,oBAAApP,OAAmBoP,EAAQ,cAiB9DiL,EAA2B,eAAA3D,GAAA4D,EAAAA,EAAAA,GAAAC,IAAAA,MAAG,SAAAC,EAAAtL,GAAA,IAAA0K,EAAAa,EAAAC,EAAAC,EAAAC,EAAA5H,EAAA6H,EAAA,OAAAN,IAAAA,MAAA,SAAAO,GAAA,cAAAA,EAAAC,KAAAD,EAAAvG,MAAA,OAKjC,GAL0CqF,EAAK1K,EAAL0K,MACrCa,EAAwC,GAE1Cb,EAAMoB,iBACRP,EAAkBnB,KAAKM,EAAMoB,kBAE3BpB,EAAMhC,UAAW,CAAFkD,EAAAvG,KAAA,SACuB,KAAlCmG,EAAmBd,EAAMhC,WACJ,MAAyC,mBAA7B8C,EAAuB,KAAgB,CAAAI,EAAAvG,KAAA,SAClC,OAApCoG,EAAoBD,EAAgBI,EAAAvG,KAAA,EACyDoG,EAAkBM,OAAM,QAArHL,EAAoFE,EAAAI,MACrEF,iBAA+D,mBAArCJ,EAAiBI,iBAC9DP,EAAkBnB,KAAKsB,EAAiBI,sBAEF,IAA7BJ,EAAiBlD,UACpB1E,EAAI4H,EAAiBlD,SACrBsD,iBAAgD,mBAAtBhI,EAAEgI,iBAChCP,EAAkBnB,KAAKtG,EAAEgI,iBAE5BF,EAAAvG,KAAA,kBAEKqG,EAAmBF,GACJM,iBAA+D,mBAArCJ,EAAiBI,iBAC9DP,EAAkBnB,KAAKsB,EAAiBI,iBACzC,YAIDP,EAAkBta,OAAQ,CAAF2a,EAAAvG,KAAA,gBAAAuG,EAAAK,OAAA,wBAAAC,GAAAd,EAAAA,EAAAA,GAAAC,IAAAA,MACnB,SAAAc,EAAAC,GAAA,IAAA3R,EAAAyF,EAAA0K,EAAAJ,EAAAvL,EAAAoN,EAAAC,EAAAC,EAAA,OAAAlB,IAAAA,MAAA,SAAAmB,GAAA,cAAAA,EAAAX,KAAAW,EAAAnH,MAAA,OACqC,OAD5B5K,EAAK2R,EAAL3R,MAAOyF,EAAQkM,EAARlM,SAAU0K,EAAMwB,EAANxB,OAAQJ,EAAgB4B,EAAhB5B,iBAAkBvL,EAAKmN,EAALnN,MACnDoN,EAAW/F,EAAgBpG,GAASsM,EAAAnH,KAAA,EACxB8E,QAAQ1T,IACxB8U,EAAkBjJ,KAAI,SAACmD,GAAE,OACvB0E,QAAQlC,UACLzL,MAAK,kBAAMiJ,EAAG,CAAEhL,MAAAA,EAAOyF,SAAAA,EAAU0K,OAAAA,EAAQJ,iBAAAA,EAAkBvL,MAAAA,GAAQ,IACnEoL,OAAM,SAACL,GAGN,OADApZ,QAAQC,MAAM,IAADC,OAAkB,SAAmB,4BAAAA,OAA2BkZ,EAAEtY,aACxE,IACT,GAAE,KAEP,OAcK,OAxBA4a,EAAGE,EAAAR,KAYHO,EAASD,EAAIpK,OAAO6I,SAASlH,QAIhC,SAACd,EAAGe,GACL,OAAKA,GAGLf,EAAElS,MAAQ,CAACkS,EAAElS,MAAOiT,EAAEjT,OAAOqR,OAAO6I,SAASE,KAAK,QAClDlI,EAAElgB,OAAQyM,EAAAA,EAAAA,GAAMyT,EAAElgB,MAAOihB,EAAEjhB,OAC3BkgB,EAAE9C,SAAW6D,EAAE7D,SAAW6D,EAAE7D,SAAW8C,EAAE9C,SAClC8C,GALEA,CAMX,GAAG,CAAC,GAAEyJ,EAAAP,OAAA,SAAAjY,EAAAA,EAAA,GAGDuY,GAAM,IACT1pB,OAAK4pB,EAAAA,EAAAA,GAAA,GAAKJ,EAAWE,EAAO1pB,OAAS,CAAC,MAAG,wBAAA2pB,EAAAE,OAAA,GAAAP,EAAA,KAE5C,gBAAAQ,GAAA,OAAAT,EAAAvT,MAAA,KAAApF,UAAA,EAjCyB,IAiCzB,eAAAqY,EAAAK,OAAA,SAEM,MAAI,yBAAAL,EAAAc,OAAA,GAAApB,EAAA,KAEd,gBAjEgCsB,GAAA,OAAApF,EAAA7O,MAAA,KAAApF,UAAA,KAmE3BsX,EAAqB,eAAAgC,GAAAzB,EAAAA,EAAAA,GAAAC,IAAAA,MAAG,SAAAyB,EAAAC,GAAA,IAAArC,EAAAjQ,EAAAkQ,EAAA1L,EAAAuL,EAAAsB,EAAAja,EAAA,OAAAwZ,IAAAA,MAAA,SAAA2B,GAAA,cAAAA,EAAAnB,KAAAmB,EAAA3H,MAAA,OAAqD,OAA5CqF,EAAKqC,EAALrC,MAAOjQ,EAAKsS,EAALtS,MAAOkQ,EAAKoC,EAALpC,MAAO1L,EAAK8N,EAAL9N,MAAOuL,EAAgBuC,EAAhBvC,iBAAgBwC,EAAA3H,KAAA,EACnD8F,EAA4B,CAAET,MAAAA,IAAQ,OAA/C,KAAfoB,EAAekB,EAAAhB,MACA,CAAFgB,EAAA3H,KAAA,gBAAA2H,EAAA3H,KAAA,EACUyG,EAAgB,CACzCrR,MAAAA,EACAyF,SAAUyK,EAAM9S,SAChB+S,OAAQD,EAAMC,OACdJ,iBAAAA,EACAvL,MAAAA,IACA,OANgB,GAAZpN,EAAYmb,EAAAhB,MAOdtB,EAAM9W,KAAM,CAAFoZ,EAAA3H,KAAA,gBAAA2H,EAAAf,OAAA,SAAAjY,EAAAA,EAAA,GACAnC,GAAY,IAAEmZ,KAAM,CAACN,EAAM9W,SAAK,eAAAoZ,EAAAf,OAAA,SAErCpa,GAAY,QAAAmb,EAAA3H,KAAA,qBAEZqF,EAAM9W,KAAM,CAAFoZ,EAAA3H,KAAA,gBAAA2H,EAAAf,OAAA,SACZ,CAAEjB,KAAM,CAACN,EAAM9W,QAAO,yBAAAoZ,EAAAN,OAAA,GAAAI,EAAA,KAEhC,gBAlB0BG,GAAA,OAAAJ,EAAAlU,MAAA,KAAApF,UAAA,KAoB3B,SAAS2Z,EAAuDpB,GAI9D,OAHA,SAAiBnY,GACfA,EAAUmY,gBAAkBA,CAC9B,CAEF,C,wXClLaqB,GAAkBC,EAAAA,EAAAA,IAAQ,kBAAoEjd,OAAO2L,QAAQe,YAAY,IAEzHwQ,GAAWD,EAAAA,EAAAA,IAAQ,kBAA6Djd,OAAO2L,QAAQa,KAAK,IAEpG7F,GAAqBsW,EAAAA,EAAAA,IAAQ,kBAAwEjd,OAAO2L,QAAQwR,gBAAgB,IAEpInO,GAAaiO,EAAAA,EAAAA,IAAQ,kBAA4Bjd,OAAO2L,QAAQK,UAAU,IAE1EoR,GAAsBH,EAAAA,EAAAA,IAAQ,kBACkEjd,OAAO2L,QAAQ0R,QAAQ,IAGvHC,GAAeL,EAAAA,EAAAA,IAAQ,kBACoEjd,OAAO2L,QAAQ4R,eAAe,I,+CCVzHC,EAAgB,CAC3BC,GAAI,UACJC,GAAI,MAGOzR,EAAe,eAAA9H,GAAA8W,EAAAA,EAAAA,GAAAC,IAAAA,MAAG,SAAAc,EAAO7P,EAAuB1C,GAAgC,OAAAyR,IAAAA,MAAA,SAAAmB,GAAA,cAAAA,EAAAX,KAAAW,EAAAnH,MAAA,cAAAmH,EAAAnH,KAAA,EACrF/I,GAASwR,EAAAA,EAAAA,IAAqB,CAAE9a,KAAM+a,EAAAA,EAAAA,WAA6BnU,KAAAA,KAAQ,wBAAA4S,EAAAE,OAAA,GAAAP,EAAA,KAClF,gBAF2BS,EAAAD,GAAA,OAAArY,EAAAqE,MAAA,KAAApF,UAAA,KAIf6G,EAAc,K,uFCLpB,SAAU4T,EAAQ1Z,GAAA,IAAGuV,EAAIvV,EAAJuV,KAAMjQ,EAAItF,EAAJsF,KAAI,OAAAyR,IAAAA,MAAA,SAAAc,IAAA,IAAA8B,EAAAC,EAAA1U,EAAA,OAAA6R,IAAAA,MAAA,SAAAmB,GAAA,cAAAA,EAAAX,KAAAW,EAAAnH,MAAA,OAES,OAFTmH,EAAAX,KAAA,EAAAW,EAAAnH,KAAA,GAEe8I,EAAAA,EAAAA,KAAwD,SAACvV,GAAK,OAAKA,EAAMc,OAAOC,WAAWH,IAAI,IAAC,OAAzG,GAAAgT,EAAAR,KAC1BpS,GAAO,CAAF4S,EAAAnH,KAAA,SACjB,OADiBmH,EAAAnH,KAAA,GACX+I,EAAAA,EAAAA,KAAIC,EAAAA,EAAAA,IAAsB,CAAErb,KAAM+a,EAAAA,EAAAA,cAA+B,OAInE,OAHEE,EAAUK,IAAAA,OAAa,CAAEC,QAASd,MAAiBjB,EAAAnH,KAAA,IAG/CliB,EAAAA,EAAAA,KAAK,SAACqrB,GAAe,OAAKP,EAAQjI,IAAIwI,EAAS,CAAE5D,OAAQ,CAAEhR,KAAAA,IAAS,GAAE,aAAY,QAC5F,OAD4FsU,EAAA1B,EAAAR,KADlFxS,EAAI0U,EAAZ1U,KAAQA,KAAIgT,EAAAnH,KAAA,IAER+I,EAAAA,EAAAA,KAAIK,EAAAA,EAAAA,IAAsB,CAAEzb,KAAM+a,EAAAA,EAAAA,WAA6BvU,MAAIiT,EAAAA,EAAAA,GAAA,GAAK7S,EAAOJ,MAAU,QAEjG,OAFiGgT,EAAAnH,KAAA,IAE3F+I,EAAAA,EAAAA,KAAIjO,EAAAA,EAAAA,IAAsB,CAAEnN,KAAMoN,EAAAA,EAAAA,WAA6B5G,KAAMI,KAAQ,QAAA4S,EAAAnH,KAAA,iBAKnF,OALmFmH,EAAAX,KAAA,GAAAW,EAAAkC,GAAAlC,EAAA,SAIlFA,EAAAnH,KAAA,IACK+I,EAAAA,EAAAA,KAAIO,EAAAA,EAAAA,IAAmB,CAAE3b,KAAM+a,EAAAA,EAAAA,WAA6Bld,MAAO2b,EAAAkC,GAAahd,cAAc,QAE7F,OAF6F8a,EAAAX,KAAA,GAEpGhC,IAAO2C,EAAAoC,OAAA,6BAAApC,EAAAE,OAAA,GAAAP,EAAA,uBAlB2Bd,EAkB3B,C,eClBDwD,GAAV,SAAUA,IAAQ,OAAAxD,IAAAA,MAAC,SAADmB,GAAA,cAAAA,EAAAX,KAAAW,EAAAnH,MAAA,OAChB,OADgBmH,EAAAnH,KAAA,GACV5O,EAAAA,EAAAA,IAAI,EAACqY,EAAAA,EAAAA,IAA4BC,EAAAA,GAAAA,gBAA6BhB,EAAAA,EAAAA,aAA8B,SAAAzZ,GAAa,OAAO0Z,EAAS,CAAEnE,KAAxBvV,EAAJuV,KAAkCjQ,KAAxBtF,EAAJsF,MAAmC,MAAG,wBAAA4S,EAAAE,OAAA,GAAAsC,EAAA,CCYnJ,IAAMC,EAAc,CAClBC,WAAU,SAACC,EAAuBC,GAChC,OAAOA,EAAeC,IAAwBF,EAChD,EAEAG,YAAW,SAAC7U,GACVA,EAAM6B,SAAS,CACb9Z,KAtB0B,qBAwB9B,GCVI+sB,EAFiE,mBAAhDpf,OAAOqf,sCAAuDrf,OAAOqf,qCAAqC,CAAEC,gBAAiB,MAE/GC,EAAAA,GAExBjU,EAAuB,WAA6C,IAA5C5Y,EAAuB0Q,UAAAtC,OAAA,QAAAlO,IAAAwQ,UAAA,GAAAA,UAAA,GAAG,CAAC,EACtDmI,EAAoC7Y,EAApC6Y,eAAciU,EAAsB9sB,EAApB+sB,WAAAA,OAAU,IAAAD,EAAG,GAAEA,EACjCP,GAAiBS,EAAAA,EAAAA,MACjBC,EAAgB,CAACC,EAAAA,EAAiBX,GAActe,QAAA4R,EAAAA,EAAAA,GAAKkN,IACrDnV,GAAQuV,EAAAA,EAAAA,IAAYC,EAAAA,GAAavU,EAAgB6T,EAAiBW,EAAAA,GAAAA,WAAgB,GAADxN,EAAAA,EAAAA,GAAIoN,MAmB3F,OAlBArV,EAAM0V,SAAWlB,EAAYC,WAAWL,EAAUO,GAkB3C3U,CACT,EAQa2V,EAAoCC,EAAAA,GAEpC5W,EAAkD6W,EAAAA,GCjDlDtV,GAA8BuV,E,QAAAA,KAAY,CACrDC,OCP2C,CAC3CC,OAAQ,CACNnb,KAAM,CACJob,WAAY,8MDKhBC,eER2D,CAC3DC,OAAQ,CACNC,0BAA2B,CACzBrI,QAAS,QACTsI,MAAO,YAETC,oBAAqB,CACnBvI,QAAS,iBACTsI,MAAO,kBAETE,iBAAkB,CAChBxI,QAAS,qBACTsI,MAAO,YAETG,gBAAiB,CACfzI,QAAS,WACTsI,MAAO,YAETI,eAAgB,CACd1I,QAAS,WACTsI,MAAO,YAETK,oBAAqB,CACnB3I,QAAS,2BACTsI,MAAO,yBAETM,sBAAuB,CACrB5I,QAAS,qBACTsI,MAAO,e,UC5BAO,EAAO,SAAH/c,GAAA,IAAMC,EAAQD,EAARC,SAAQ+c,EAAAhd,EAAEid,OAAAA,OAAM,IAAAD,EAAG,GAAEA,EAAA,OAC1C/a,EAAAA,EAAAA,IAAA,QAAAhC,SAAA,EACE3Q,EAAAA,EAAAA,IAAA,OAAKyR,GAAG,cAAcmc,wBAAyB,CAAEC,OAAQld,GAAY,MACpEgd,EAAOrP,OAAO6I,SAASzI,KAAI,SAAC4C,GAAG,OAAKA,CAAG,MACnC,ECFIwM,EAAO,SAAHpd,GAAA,IAAAqd,EAAArd,EAAMsd,IAAAA,OAAG,IAAAD,EAAG,KAAIA,EAAAE,EAAAvd,EAAElC,KAAAA,OAAI,IAAAyf,EAAG,GAAEA,EAAAC,EAAAxd,EAAEgC,QAAAA,OAAO,IAAAwb,EAAG,GAAEA,EAAAC,EAAAzd,EAAEoH,eAAAA,OAAc,IAAAqW,EAAG,KAAIA,EAAAC,EAAA1d,EAAE2d,cAAiBC,QAAJ,IAAAF,EAAe,CAAC,EAACA,GAAbE,OAAeC,EAAa7d,EAAb6d,cAAa,OAC9H5b,EAAAA,EAAAA,IAAA,QAAAhC,SAAA,EACE3Q,EAAAA,EAAAA,IAAA,QAAMwuB,QAAQ,WACdxuB,EAAAA,EAAAA,IAAA,QAAMoP,KAAK,aAAaqf,QAASC,2BACjC1uB,EAAAA,EAAAA,IAAA,QAAMoP,KAAK,WAAWqf,QAAO,4BAC7BzuB,EAAAA,EAAAA,IAAA,QAAMoP,KAAK,SAASqf,QAAQ,oBAC5BzuB,EAAAA,EAAAA,IAAA,QACEoP,KAAK,cACLqf,QAAQ,gMAEVzuB,EAAAA,EAAAA,IAAA,QAAMoP,KAAK,WAAWqf,QAAQ,qCAC9BzuB,EAAAA,EAAAA,IAAA,QAAM2uB,KAAMhF,IAAwB,YAAc,OAClD3pB,EAAAA,EAAAA,IAAA,QAAMoP,KAAK,WAAWqf,QAAQ,mGAC9BzuB,EAAAA,EAAAA,IAAA,QAAM4uB,IAAI,gBAAgBD,KAAK,gBAAgB/vB,KAAK,kBAEpD+T,EAAAA,EAAAA,IAAAM,EAAAA,GAAA,CAAAtC,SAAA,CACG2d,aAAM,EAANA,EAAQvN,KAAK8N,cACbP,aAAM,EAANA,EAAQQ,MAAMD,cACdP,aAAM,EAANA,EAAQS,KAAKF,cACbP,aAAM,EAANA,EAAQ9f,KAAKqgB,cACbP,aAAM,EAANA,EAAQU,SAASH,cACjBP,aAAM,EAANA,EAAQvc,MAAM8c,cACdP,aAAM,EAANA,EAAQX,OAAOkB,iBAEjBnc,EAAQ4L,OAAO6I,SAASzI,KAAI,SAAC4C,GAAG,OAAKA,CAAG,IACxC9S,EAAK8P,OAAO6I,SAASzI,KAAI,SAAC4C,GAAG,OAAKA,CAAG,IACrCiN,aAAa,EAAbA,EAAe3B,OAAOlO,KAAI,SAAC3M,EAAOiN,GAAK,OACtChf,EAAAA,EAAAA,IAAA,SAAO,iBAAY,kBAAAkN,OAAiB6E,EAAMxT,IAAG,KAAA2O,OAAI6E,EAAMkL,IAAIoK,KAAK,MAAsCuG,wBAAyB,CAAEC,OAAQ9b,EAAMkd,MAAlEld,EAAMxT,IAAM,IAAMygB,EAAyD,KAE1Jhf,EAAAA,EAAAA,IAAA,UAAQyR,GAAG,kBAAkB7S,KAAK,mBAAmBgvB,wBAAyB,CAAEC,OAAQ,GAAF3gB,OAAK8gB,OAC3FhuB,EAAAA,EAAAA,IAAA,UAAQyR,GAAG,oBAAoB7S,KAAK,mBAAmBgvB,wBAAyB,CAAEC,OAAQ,GAAF3gB,OAAK4K,QACxF,E,qkBChBF,IAAMoX,EAAO,SAACjwB,GACnB,OACE0T,EAAAA,EAAAA,IAAA,QAAMqD,KAAM/W,EAAM+W,MAAQ,GAAGrF,SAAA,EAC3B3Q,EAAAA,EAAAA,IAAC8tB,EAAI1d,EAAA,GAAKnR,KACVe,EAAAA,EAAAA,IAACytB,EAAIrd,EAAA,GAAKnR,MAGhB,EC1BamZ,EAAW,SAAoCxC,EAASrX,GACnE,GAAIA,EAAK,CACP,IAAM4wB,EAAYvZ,EAAKrX,GAOvB,OANAa,OAAOgwB,eAAexZ,EAAMrX,EAAK,CAC/B6jB,IAAK,WACH,OAAO+M,CACT,EACAE,cAAc,IAETzZ,CACT,CAUE,OATAxW,OAAOM,KAAKkW,GAAMhW,SAAQ,SAACrB,GACzB,IAAM4wB,EAAYvZ,EAAKrX,GACvBa,OAAOgwB,eAAexZ,EAAMrX,EAAK,CAC/B6jB,IAAK,WACH,OAAO+M,CACT,EACAE,cAAc,GAElB,IACOzZ,CAEX,E,UCpBae,EAAqB,WAAH,OAAS2Y,EAAAA,EAAAA,GAAY,CAAE/wB,IAAK,OAAQ,C,8BCF5D,IAAKie,EAKA2N,E,yBAFX,SAHW3N,GAAAA,EAAgB,wBAAhBA,EAAgB,0BAG3B,CAHWA,IAAAA,EAAgB,KAO3B,SAFW2N,GAAAA,EAAgB,wBAE3B,CAFWA,IAAAA,EAAgB,I,sJCHtBoF,EAEc,SAACngB,GAAI,wBAAAlC,OAAuBkC,EAAI,aAF9CmgB,EAGc,SAACngB,GAAI,wBAAAlC,OAAuBkC,EAAI,aAH9CmgB,EAIW,SAACngB,GAAI,wBAAAlC,OAAuBkC,EAAI,UAQ3CmN,EAAgD,SAAHqH,GAAA,IAASxU,EAAIwU,EAAJxU,KAAMwG,EAAIgO,EAAJhO,KAAI,MAAoC,CACxGhX,KAAM2wB,EAA8BngB,GACpCwG,KAAAA,EACA4Z,cAAc,EACf,ECPKC,EAA0B,CAAE7Z,KAAM,GAAI3I,MAAO,KAAMuF,QAAQ,EAAOjC,SAAS,GAW3Emf,GAAmDC,EAAG,CAAC,GAAJ9G,EAAAA,EAAAA,GAAA8G,EACtDJ,EAA8B/S,EAAAA,EAAAA,aAA+B,SAACxH,EAAOsR,GAAM,OAC1EsJ,EAAAA,EAAAA,IAAQ5a,GAAO,SAAC6a,GACdA,EAAMja,KAAO,GACbia,EAAM5iB,MAAQ,KACd4iB,EAAMtf,QAAU+V,EAAOkJ,eAAgB,EACvCK,EAAMrd,QAAS,CACjB,GAAE,KAAAqW,EAAAA,EAAAA,GAAA8G,EACHJ,EAA8B/S,EAAAA,EAAAA,aAA+B,SAACxH,EAAOsR,GAAM,OAC1EsJ,EAAAA,EAAAA,IAAQ5a,GAAO,SAAC6a,GACdA,EAAMja,KAAO0Q,EAAO1Q,MAAQ,GAC5Bia,EAAM5iB,MAAQ,KACd4iB,EAAMtf,SAAU,EAChBsf,EAAMrd,QAAS,CACjB,GAAE,KAAAqW,EAAAA,EAAAA,GAAA8G,EACHJ,EAA2B/S,EAAAA,EAAAA,aAA+B,SAACxH,EAAOsR,GAAM,OACvEsJ,EAAAA,EAAAA,IAAQ5a,GAAO,SAAC6a,GACdA,EAAMja,KAAO,GACbia,EAAM5iB,MAAQqZ,EAAOrZ,MACrB4iB,EAAMtf,SAAU,EAChBsf,EAAMrd,QAAS,CACjB,GAAE,IAAAmd,GC9BAF,EAA0B,CAAE7Z,KAAM,CAAC,EAAG3I,MAAO,KAAMuF,QAAQ,EAAOjC,SAAS,GAW3Emf,GAAkDC,EAAG,CAAC,GAAJ9G,EAAAA,EAAAA,GAAA8G,EACrDJ,EAA8B/S,EAAAA,EAAAA,cAAgC,SAACxH,EAAOsR,GAAM,OAC3EsJ,EAAAA,EAAAA,IAAQ5a,GAAO,SAAC6a,GACdA,EAAM5iB,MAAQ,KACd4iB,EAAMtf,QAAU+V,EAAOkJ,eAAgB,EACvCK,EAAMrd,QAAS,CACjB,GAAE,KAAAqW,EAAAA,EAAAA,GAAA8G,EACHJ,EAA8B/S,EAAAA,EAAAA,cAAgC,SAACxH,EAAOsR,GAAM,OAC3EsJ,EAAAA,EAAAA,IAAQ5a,GAAO,SAAC6a,GACdA,EAAMja,KAAO0Q,EAAO1Q,KACpBia,EAAM5iB,MAAQ,KACd4iB,EAAMtf,SAAU,EAChBsf,EAAMrd,QAAS,CACjB,GAAE,KAAAqW,EAAAA,EAAAA,GAAA8G,EACHJ,EAA2B/S,EAAAA,EAAAA,cAAgC,SAACxH,EAAOsR,GAAM,OACxEsJ,EAAAA,EAAAA,IAAQ5a,GAAO,SAAC6a,GACdA,EAAMja,KAAO,CAAC,EACdia,EAAM5iB,MAAQqZ,EAAOrZ,MACrB4iB,EAAMtf,SAAU,EAChBsf,EAAMrd,QAAS,CACjB,GAAE,IAAAmd,GCtCOvb,GAAS0b,EAAAA,EAAAA,KAAeC,EAAA,IAAAlH,EAAAA,EAAAA,GAAAkH,EAClCvT,EAAAA,EAAAA,YFM8C,WAAyE,IAAxExH,EAAmBrF,UAAAtC,OAAA,QAAAlO,IAAAwQ,UAAA,GAAAA,UAAA,GAAG8f,EAAWnJ,EAAkC3W,UAAAtC,OAAA,EAAAsC,UAAA,QAAAxQ,EAC7G6wB,EAAgBN,EAAiBpJ,EAAO1nB,MAC9C,OAAIoxB,EACKA,EAAchb,EAAOsR,GAErBtR,CAEX,KEbkD6T,EAAAA,EAAAA,GAAAkH,EAC/CvT,EAAAA,EAAAA,aDO+C,WAAwE,IAAvExH,EAAmBrF,UAAAtC,OAAA,QAAAlO,IAAAwQ,UAAA,GAAAA,UAAA,GAAG8f,EAAWnJ,EAAiC3W,UAAAtC,OAAA,EAAAsC,UAAA,QAAAxQ,EAC7G6wB,EAAgBN,EAAiBpJ,EAAO1nB,MAC9C,OAAIoxB,EACKA,EAAchb,EAAOsR,GAErBtR,CAEX,ICdoD+a,I,kPCNpD,I,EAAM5E,EAAiC,CACrC8E,gBAAiB,SAAC7gB,GAAI,wBAAAlC,OAAuBkC,EAAI,mBACjD8gB,iBAAkB,SAAC9gB,GAAI,wBAAAlC,OAAuBkC,EAAI,aAClD+gB,iBAAkB,SAAC/gB,GAAI,wBAAAlC,OAAuBkC,EAAI,aAClDghB,cAAe,SAAChhB,GAAI,wBAAAlC,OAAuBkC,EAAI,WAI3C8a,EACJ,SAD4DxZ,GAAA,IACzDtB,EAAIsB,EAAJtB,KAASihB,GAAQC,EAAAA,EAAAA,GAAA5f,EAAA6f,GAAA,OACpB,SAAC7X,GACC,IAAIuN,EAA4B,KAC1BuK,EAAO,IAAIjK,SAAc,SAACkK,GAC9BxK,EAAOwK,CACT,IAEA,OADA/X,E,qWAAQtI,CAAC,CAAExR,KAAMusB,EAAa8E,gBAAgB7gB,GAAO6W,KAAAA,GAASoK,IACvDG,CACT,CAAC,EAEG/F,EAAgD,SAAHrO,GAAA,IAAMhN,EAAIgN,EAAJhN,KAAI,MAAQ,CAAExQ,KAAMusB,EAAa+E,iBAAiB9gB,GAAOogB,cAAc,EAAM,EAEhI3E,EAAgD,SAAHjH,GAAA,IAASxU,EAAIwU,EAAJxU,KAAMwG,EAAIgO,EAAJhO,KAAI,MAA6C,CACjHhX,KAAMusB,EAAagF,iBAAiB/gB,GACpCwG,KAAAA,EACA4Z,cAAc,EACf,EAEKzE,EAA6C,SAAHvC,GAAA,IAASpZ,EAAIoZ,EAAJpZ,KAAMnC,EAAKub,EAALvb,MAAK,MAA6C,CAC/GrO,KAAMusB,EAAaiF,cAAchhB,GACjCnC,MAAAA,EACAuiB,cAAc,EACf,E,qkBCpBD,IAAMC,EAA0B,CAAE7Z,KAAM,CAAC,EAAG3I,MAAO,KAAMuF,QAAQ,EAAOjC,SAAS,GAW3Emf,GAAuDC,EAAG,CAAC,GAAJ9G,EAAAA,EAAAA,GAAA8G,EAC1DxE,EAAa+E,iBAAiB/F,EAAAA,EAAAA,aAA+B,SAACnV,EAAOsR,GAAM,OAC1EsJ,EAAAA,EAAAA,IAAQ5a,GAAO,SAAC6a,GACdA,EAAM5iB,MAAQ,KACd4iB,EAAMtf,QAAU+V,EAAOkJ,eAAgB,EACvCK,EAAMrd,QAAS,CACjB,GAAE,KAAAqW,EAAAA,EAAAA,GAAA8G,EACHxE,EAAagF,iBAAiBhG,EAAAA,EAAAA,aAA+B,SAACnV,EAAOsR,GAAM,OAC1EsJ,EAAAA,EAAAA,IAAQ5a,GAAO,SAAC6a,GACdA,EAAMja,KAAIxF,EAAAA,EAAA,GAAQyf,EAAMja,MAAS0Q,EAAO1Q,MACxCia,EAAM5iB,MAAQ,KACd4iB,EAAMtf,SAAU,EAChBsf,EAAMrd,QAAS,CACjB,GAAE,KAAAqW,EAAAA,EAAAA,GAAA8G,EACHxE,EAAaiF,cAAcjG,EAAAA,EAAAA,aAA+B,SAACnV,EAAOsR,GAAM,OACvEsJ,EAAAA,EAAAA,IAAQ5a,GAAO,SAAC6a,GACdA,EAAM5iB,MAAQqZ,EAAOrZ,MACrB4iB,EAAMtf,SAAU,EAChBsf,EAAMrd,QAAS,CACjB,GAAE,IAAAmd,GCrCO7Z,GAASga,EAAAA,EAAAA,KAAejH,EAAAA,EAAAA,GAAC,CAAC,EACpCsB,EAAAA,EAAAA,YDQ8C,WAA6E,IAA5EnV,EAAmBrF,UAAAtC,OAAA,QAAAlO,IAAAwQ,UAAA,GAAAA,UAAA,GAAG8f,EAAWnJ,EAAsC3W,UAAAtC,OAAA,EAAAsC,UAAA,QAAAxQ,EACjH6wB,EAAgBN,EAAiBpJ,EAAO1nB,MAC9C,OAAIoxB,EACKA,EAAchb,EAAOsR,GAErBtR,CAEX,KEjBaqX,GAAcyD,EAAAA,EAAAA,IAAgB,CACzC1b,OAAAA,EACA0B,OAAAA,G,iBCPF,IAAI4I,EAAM,CACT,KAAM,CACL,KACA,GACA,IACA,IACA,IACA,KAED,QAAS,CACR,KACA,GACA,IACA,KAED,YAAa,CACZ,KACA,GACA,IACA,KAED,SAAU,CACT,KACA,GACA,IACA,IACA,IACA,GACA,KAED,aAAc,CACb,KACA,GACA,IACA,IACA,IACA,GACA,KAED,QAAS,CACR,KACA,GACA,IAED,YAAa,CACZ,KACA,GACA,IAED,UAAW,CACV,KACA,GACA,IACA,IACA,IACA,KAED,cAAe,CACd,KACA,GACA,IACA,IACA,IACA,MAGF,SAASgS,EAAoBC,GAC5B,IAAIjM,EAAoBkM,EAAElS,EAAKiS,GAC9B,OAAOpK,QAAQlC,UAAUzL,MAAK,KAC7B,IAAIwN,EAAI,IAAIyK,MAAM,uBAAyBF,EAAM,KAEjD,MADAvK,EAAEkB,KAAO,mBACHlB,CAAC,IAIT,IAAInJ,EAAMyB,EAAIiS,GAAMlf,EAAKwL,EAAI,GAC7B,OAAOsJ,QAAQ1T,IAAIoK,EAAI2B,MAAM,GAAGF,IAAIgG,EAAoB0B,IAAIxN,MAAK,IACzD8L,EAAoBjT,IAE7B,CACAif,EAAoBhxB,KAAO,IAAON,OAAOM,KAAKgf,GAC9CgS,EAAoBjf,GAAK,KACzBvT,EAAOC,QAAUuyB,C,iBClFjB,IAAIhS,EAAM,CACT,KAAM,KACN,QAAS,KACT,YAAa,KACb,SAAU,KACV,aAAc,KACd,QAAS,KACT,YAAa,KACb,UAAW,KACX,cAAe,MAIhB,SAASoS,EAAeH,GACvB,IAAIlf,EAAKsf,EAAsBJ,GAC/B,IAAIjM,EAAoBsM,EAAEvf,GAAK,CAC9B,IAAI2U,EAAI,IAAIyK,MAAM,WAAaF,EAAM,OAASlf,EAAK,yCAEnD,MADA2U,EAAEkB,KAAO,mBACHlB,CACP,CACA,OAAO1B,EAAoBjT,EAC5B,CACA,SAASsf,EAAsBJ,GAC9B,IAAIjM,EAAoBkM,EAAElS,EAAKiS,GAAM,CACpC,IAAIvK,EAAI,IAAIyK,MAAM,uBAAyBF,EAAM,KAEjD,MADAvK,EAAEkB,KAAO,mBACHlB,CACP,CACA,OAAO1H,EAAIiS,EACZ,CACAG,EAAepxB,KAAO,WACrB,OAAON,OAAOM,KAAKgf,EACpB,EACAoS,EAAezM,QAAU0M,EACzBD,EAAerf,GAAK,KACpBvT,EAAOC,QAAU2yB,C","sources":["webpack://@my-react/ssr-example/../../packages/myreact-dom/index.js","webpack://@my-react/ssr-example/../../src/check.ts","webpack://@my-react/ssr-example/../../src/instance.ts","webpack://@my-react/ssr-example/../../packages/myreact-reconciler/index.js","webpack://@my-react/ssr-example/../../packages/myreact-shared/index.js","webpack://@my-react/ssr-example/../../packages/myreact/index.js","webpack://@my-react/ssr-example/../../src/apollo/cache.ts","webpack://@my-react/ssr-example/../../src/apollo/client.ts","webpack://@my-react/ssr-example/../../src/schema.ts","webpack://@my-react/ssr-example/../../src/apollo/links.ts","webpack://@my-react/ssr-example/../../src/generated.ts","webpack://@my-react/ssr-example/./src/client/common/AutoInjectProps.tsx","webpack://@my-react/ssr-example/./src/client/common/WrapperLoading/index.tsx","webpack://@my-react/ssr-example/./src/client/common/LoadingBar/LoadingBar.tsx","webpack://@my-react/ssr-example/./src/client/common/LoadingBar/index.module.scss?2ea7","webpack://@my-react/ssr-example/./src/client/common/LoadingBar/index.tsx","webpack://@my-react/ssr-example/./src/client/common/WrapperRoute/index.tsx","webpack://@my-react/ssr-example/./src/client/common/RenderMatch.tsx","webpack://@my-react/ssr-example/./src/client/common/WrapperApollo/index.tsx","webpack://@my-react/ssr-example/./src/client/common/WrapperCatch/index.tsx","webpack://@my-react/ssr-example/./src/client/common/WrapperLang/index.tsx","webpack://@my-react/ssr-example/./src/client/common/App.tsx","webpack://@my-react/ssr-example/./src/client/app.tsx","webpack://@my-react/ssr-example/./src/client/entry.tsx","webpack://@my-react/ssr-example/./src/client/hooks/useDebouncedState.ts","webpack://@my-react/ssr-example/./src/client/hooks/useSize.ts","webpack://@my-react/ssr-example/./src/client/hooks/useUpdate.ts","webpack://@my-react/ssr-example/./src/client/hooks/usePreLoad.ts","webpack://@my-react/ssr-example/./src/client/utils/dom.ts","webpack://@my-react/ssr-example/./src/client/hooks/useOverlay.ts","webpack://@my-react/ssr-example/./src/client/hooks/useIsMobile.ts","webpack://@my-react/ssr-example/./src/client/hooks/useIsMounted.ts","webpack://@my-react/ssr-example/./src/client/hooks/useLoadingBar.ts","webpack://@my-react/ssr-example/./src/client/hooks/useEffectOnce.ts","webpack://@my-react/ssr-example/./src/client/hooks/useWindowSize.ts","webpack://@my-react/ssr-example/./src/client/hooks/useLockBodyScroll.ts","webpack://@my-react/ssr-example/./src/client/hooks/useGetInitialProps.ts","webpack://@my-react/ssr-example/./src/client/hooks/useGetResponseListLayout.ts","webpack://@my-react/ssr-example/./src/client/router/dynamicRoutes.ts","webpack://@my-react/ssr-example/./src/client/router/routes.ts","webpack://@my-react/ssr-example/./src/client/utils/delay.ts","webpack://@my-react/ssr-example/./src/client/utils/preLoad.ts","webpack://@my-react/ssr-example/./src/shared/env.ts","webpack://@my-react/ssr-example/./src/shared/i18n.ts","webpack://@my-react/ssr-example/./src/shared/store/saga/action/langSaga.ts","webpack://@my-react/ssr-example/./src/shared/store/saga/index.ts","webpack://@my-react/ssr-example/./src/shared/store/saga/utils.ts","webpack://@my-react/ssr-example/./src/shared/store/index.ts","webpack://@my-react/ssr-example/./src/shared/theme/index.ts","webpack://@my-react/ssr-example/./src/shared/theme/styles.ts","webpack://@my-react/ssr-example/./src/shared/theme/semanticTokens.ts","webpack://@my-react/ssr-example/./src/shared/template/Body.tsx","webpack://@my-react/ssr-example/./src/shared/template/Head.tsx","webpack://@my-react/ssr-example/./src/shared/template/index.tsx","webpack://@my-react/ssr-example/./src/shared/safeData.ts","webpack://@my-react/ssr-example/./src/shared/emotionCache.ts","webpack://@my-react/ssr-example/./src/shared/store/action.ts","webpack://@my-react/ssr-example/./src/shared/store/reducer/client/share/action.ts","webpack://@my-react/ssr-example/./src/shared/store/reducer/client/action/clientLang.ts","webpack://@my-react/ssr-example/./src/shared/store/reducer/client/action/clientProps.ts","webpack://@my-react/ssr-example/./src/shared/store/reducer/client/index.ts","webpack://@my-react/ssr-example/./src/shared/store/reducer/server/share/action.ts","webpack://@my-react/ssr-example/./src/shared/store/reducer/server/action/serverLang.ts","webpack://@my-react/ssr-example/./src/shared/store/reducer/server/index.ts","webpack://@my-react/ssr-example/./src/shared/store/reducer/index.ts","webpack://@my-react/ssr-example/./src/client/pages/ lazy ^\\.\\/.*$ chunkName: pages-[request] namespace object","webpack://@my-react/ssr-example/./src/client/pages/ weak ^\\.\\/.*$"],"sourcesContent":["\"use strict\";\n\nif (process.env.NODE_ENV === \"production\") {\n  module.exports = require(\"./dist/cjs/index.production\");\n} else {\n  module.exports = require(\"./dist/cjs/index.development\");\n}\n","import { __my_react_internal__ } from \"@my-react/react\";\nimport { once, TYPEKEY, Element } from \"@my-react/react-shared\";\n\nimport type { MyReactElementNode, MyReactElement, MaybeArrayMyReactElementNode } from \"@my-react/react\";\n\nconst { currentRunningFiber } = __my_react_internal__;\n\nexport function isValidElement(element?: MyReactElementNode): element is MyReactElement {\n  return typeof element === \"object\" && !Array.isArray(element) && element?.[TYPEKEY] === Element;\n}\n\nexport const checkValidKey = (children: MyReactElementNode[]) => {\n  const obj: Record<string, boolean> = {};\n\n  const onceWarnDuplicate = once(currentRunningFiber.current?.root.renderPlatform.log);\n\n  const onceWarnUndefined = once(currentRunningFiber.current?.root.renderPlatform.log);\n\n  const validElement = children.filter((c) => isValidElement(c)) as MyReactElement[];\n\n  if (validElement.length > 1) {\n    validElement.forEach((c) => {\n      if (!c._store[\"validKey\"]) {\n        if (typeof c.key === \"string\") {\n          if (obj[c.key]) onceWarnDuplicate({ message: `array child have duplicate key` });\n\n          obj[c.key] = true;\n        } else {\n          onceWarnUndefined({\n            message: \"each array child must have a unique key props\",\n            triggerOnce: true,\n          });\n        }\n        c._store[\"validKey\"] = true;\n      }\n    });\n  }\n};\n\nexport const checkSingleChildrenKey = (children: MaybeArrayMyReactElementNode) => {\n  if (Array.isArray(children)) {\n    checkValidKey(children);\n  } else {\n    if (isValidElement(children)) children._store[\"validKey\"] = true;\n  }\n};\n","import { __my_react_internal__ } from \"@my-react/react\";\nimport { TYPEKEY, Element } from \"@my-react/react-shared\";\n\nimport { checkSingleChildrenKey } from \"./check\";\n\nimport type { CreateElementProps, MixinMyReactClassComponent, MixinMyReactFunctionComponent, MyReactElement, MyReactElementType, Props } from \"@my-react/react\";\n\nconst { currentComponentFiber, currentRunningFiber } = __my_react_internal__;\n\nconst RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true,\n};\n\ntype JSXMyReactElement = MyReactElement & {\n  _jsx: boolean;\n};\n\nexport { Fragment } from \"@my-react/react-shared\";\n\n// todo\nexport const jsx = (\n  type: MyReactElementType,\n  config: Props,\n  maybeKey: string | null,\n  source: CreateElementProps[\"_source\"],\n  self: CreateElementProps[\"_self\"]\n) => {\n  const props: Props = {};\n\n  let key: string | null = null;\n  let ref: CreateElementProps[\"ref\"] = null;\n\n  if (maybeKey !== undefined) {\n    key = \"\" + maybeKey;\n  }\n\n  // <div {...props} /> we can not make sure this usage will contain `key` of not\n  if (config?.key !== undefined) {\n    key = \"\" + config.key;\n  }\n\n  if (config?.ref) {\n    ref = config.ref as CreateElementProps[\"ref\"];\n  }\n\n  for (const propsName in config) {\n    if (Object.prototype.hasOwnProperty.call(config, propsName) && !Object.prototype.hasOwnProperty.call(RESERVED_PROPS, propsName)) {\n      props[propsName] = config[propsName];\n    }\n  }\n\n  if (type && (typeof type === \"function\" || typeof type === \"object\")) {\n    const typedType = type as MixinMyReactClassComponent | MixinMyReactFunctionComponent;\n    Object.keys(typedType?.defaultProps || {}).forEach((key) => {\n      props[key] = props[key] === undefined ? typedType.defaultProps?.[key] : props[key];\n    });\n  }\n\n  const element: JSXMyReactElement = {\n    [TYPEKEY]: Element,\n    type,\n    key,\n    ref,\n    props,\n    _jsx: true,\n    _self: self,\n    _source: source,\n    _owner: currentComponentFiber.current,\n    _store: {} as Record<string, unknown>,\n  };\n\n  if (__DEV__ && typeof Object.freeze === \"function\") {\n    Object.freeze(element.props);\n    Object.freeze(element);\n  }\n\n  return element;\n};\n\nexport const jsxDEV = (\n  type: MyReactElementType,\n  config: Props,\n  key: string | null,\n  isStaticChildren: boolean,\n  source: CreateElementProps[\"_source\"],\n  self: CreateElementProps[\"_self\"]\n) => {\n  const element = jsx(type, config, key, source, self);\n\n  if (config.children) {\n    const children = config.children;\n\n    if (isStaticChildren) {\n      if (Array.isArray(children)) {\n        children.forEach((c) => checkSingleChildrenKey(c));\n\n        if (__DEV__) Object.freeze(children);\n      } else {\n        const fiber = currentRunningFiber.current;\n        fiber?.root.renderPlatform.log({ message: \"Static children should always be an array.\", level: \"warn\" });\n      }\n      if (!Array.isArray(children)) {\n        const fiber = currentRunningFiber.current;\n        fiber?.root.renderPlatform.log({ message: \"Static children should always be an array.\", level: \"warn\" });\n      }\n    } else {\n      checkSingleChildrenKey(children);\n    }\n  }\n\n  return element;\n};\n\nexport const jsxs = (type: MyReactElementType, config: Props, key: string | null, source: CreateElementProps[\"_source\"], self: CreateElementProps[\"_self\"]) => {\n  if (__DEV__) {\n    return jsxDEV(type, config, key, true, source, self);\n  } else {\n    return jsx(type, config, key, source, self);\n  }\n};\n","\"use strict\";\n\nif (process.env.NODE_ENV === \"production\") {\n  module.exports = require(\"./dist/cjs/index.production\");\n} else {\n  module.exports = require(\"./dist/cjs/index.development\");\n}\n","\"use strict\";\n\nif (process.env.NODE_ENV === \"production\") {\n  module.exports = require(\"./dist/cjs/index.production\");\n} else {\n  module.exports = require(\"./dist/cjs/index.development\");\n}\n","\"use strict\";\n\nif (process.env.NODE_ENV === \"production\") {\n  module.exports = require(\"./dist/cjs/index.production\");\n} else {\n  module.exports = require(\"./dist/cjs/index.development\");\n}\n","import { InMemoryCache } from \"@apollo/client\";\n\nexport const autoMergeCache = new InMemoryCache({\n  typePolicies: {\n    Repository: {\n      fields: {\n        issues: {\n          keyArgs: false,\n          merge(existing = { nodes: [] }, incoming) {\n            if (existing?.pageInfo?.startCursor === incoming?.pageInfo?.startCursor) return existing;\n            return {\n              ...existing,\n              ...incoming,\n              nodes: [...existing.nodes, ...incoming.nodes],\n            };\n          },\n        },\n      },\n    },\n    Issue: {\n      fields: {\n        comments: {\n          keyArgs: false,\n          merge(existing = { nodes: [] }, incoming) {\n            if (existing?.pageInfo?.startCursor === incoming?.pageInfo?.startCursor) return existing;\n            return {\n              ...existing,\n              ...incoming,\n              nodes: [...existing.nodes, ...incoming.nodes],\n            };\n          },\n        },\n      },\n    },\n  },\n});\n\nexport const plainCache = new InMemoryCache();\n","import { ApolloClient, from } from \"@apollo/client\";\nimport merge from \"lodash/merge\";\nimport { useMemo } from \"react\";\n\nimport { autoMergeCache, plainCache } from \"./cache\";\nimport { authLink, httpLink, onErrorLink } from \"./links\";\n\nimport type { ApolloClientOptions, NormalizedCacheObject } from \"@apollo/client\";\n\nlet apolloClient: ApolloClient<NormalizedCacheObject> | undefined;\n\nconst __SERVER__ = typeof window === \"undefined\";\n\nconst _createApolloClient = ({ ...restProps }: Omit<ApolloClientOptions<NormalizedCacheObject>, \"cache\"> = {}, enableInfinityLoad = true) =>\n  new ApolloClient<NormalizedCacheObject>({\n    ssrMode: __SERVER__,\n    link: from([onErrorLink, authLink, httpLink]),\n    cache: enableInfinityLoad ? autoMergeCache : plainCache,\n    ...restProps,\n  });\n\nconst createApolloClient = (initialState: NormalizedCacheObject = {}, enableInfinityLoad?: boolean) => {\n  const _apolloClient = apolloClient ?? _createApolloClient({}, enableInfinityLoad);\n\n  // for server side, every apollo request should clean the cache\n  if (__SERVER__) {\n    _apolloClient.cache.restore({});\n  } else {\n    // for client side, should merge exist cacheData\n    const existCacheData = _apolloClient.cache.extract();\n    _apolloClient.cache.restore(merge(existCacheData, initialState));\n  }\n\n  if (!__SERVER__) apolloClient = _apolloClient;\n\n  return _apolloClient;\n};\n\nexport const getApolloClient = createApolloClient;\n\nexport const useApollo = (initialState: NormalizedCacheObject, enableInfinityLoad?: boolean): ApolloClient<any> => {\n  const store = useMemo(() => createApolloClient(initialState, enableInfinityLoad), [initialState, enableInfinityLoad]);\n  return store;\n};\n","/* eslint-disable */\n// @ts-nocheck\n\nexport type Maybe<T> = T | null;\nexport type InputMaybe<T> = Maybe<T>;\nexport type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\n/** All built-in and custom scalars, mapped to their actual values */\nexport type Scalars = {\n  ID: string;\n  String: string;\n  Boolean: boolean;\n  Int: number;\n  Float: number;\n  /** A (potentially binary) string encoded using base64. */\n  Base64String: any;\n  /** An ISO-8601 encoded date string. */\n  Date: any;\n  /** An ISO-8601 encoded UTC date string. */\n  DateTime: any;\n  /** A Git object ID. */\n  GitObjectID: any;\n  /** A fully qualified reference name (e.g. `refs/heads/master`). */\n  GitRefname: any;\n  /** Git SSH string */\n  GitSSHRemote: any;\n  /** An ISO-8601 encoded date string. Unlike the DateTime type, GitTimestamp is not converted in UTC. */\n  GitTimestamp: any;\n  /** A string containing HTML code. */\n  HTML: any;\n  /** An ISO-8601 encoded UTC date string with millisecond precision. */\n  PreciseDateTime: any;\n  /** An RFC 3986, RFC 3987, and RFC 6570 (level 4) compliant URI string. */\n  URI: any;\n  /** A valid x509 certificate string */\n  X509Certificate: any;\n};\n\n/** Autogenerated input type of AbortQueuedMigrations */\nexport type AbortQueuedMigrationsInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the organization that is running the migrations. */\n  ownerId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of AbortQueuedMigrations */\nexport type AbortQueuedMigrationsPayload = {\n  __typename?: \"AbortQueuedMigrationsPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** Did the operation succeed? */\n  success?: Maybe<Scalars[\"Boolean\"]>;\n};\n\n/** Autogenerated input type of AcceptEnterpriseAdministratorInvitation */\nexport type AcceptEnterpriseAdministratorInvitationInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The id of the invitation being accepted */\n  invitationId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of AcceptEnterpriseAdministratorInvitation */\nexport type AcceptEnterpriseAdministratorInvitationPayload = {\n  __typename?: \"AcceptEnterpriseAdministratorInvitationPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The invitation that was accepted. */\n  invitation?: Maybe<EnterpriseAdministratorInvitation>;\n  /** A message confirming the result of accepting an administrator invitation. */\n  message?: Maybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated input type of AcceptTopicSuggestion */\nexport type AcceptTopicSuggestionInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The name of the suggested topic. */\n  name: Scalars[\"String\"];\n  /** The Node ID of the repository. */\n  repositoryId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of AcceptTopicSuggestion */\nexport type AcceptTopicSuggestionPayload = {\n  __typename?: \"AcceptTopicSuggestionPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The accepted topic. */\n  topic?: Maybe<Topic>;\n};\n\n/** Represents an object which can take actions on GitHub. Typically a User or Bot. */\nexport type Actor = {\n  /** A URL pointing to the actor's public avatar. */\n  avatarUrl: Scalars[\"URI\"];\n  /** The username of the actor. */\n  login: Scalars[\"String\"];\n  /** The HTTP path for this actor. */\n  resourcePath: Scalars[\"URI\"];\n  /** The HTTP URL for this actor. */\n  url: Scalars[\"URI\"];\n};\n\n/** Represents an object which can take actions on GitHub. Typically a User or Bot. */\nexport type ActorAvatarUrlArgs = {\n  size?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** Location information for an actor */\nexport type ActorLocation = {\n  __typename?: \"ActorLocation\";\n  /** City */\n  city?: Maybe<Scalars[\"String\"]>;\n  /** Country name */\n  country?: Maybe<Scalars[\"String\"]>;\n  /** Country code */\n  countryCode?: Maybe<Scalars[\"String\"]>;\n  /** Region name */\n  region?: Maybe<Scalars[\"String\"]>;\n  /** Region or state code */\n  regionCode?: Maybe<Scalars[\"String\"]>;\n};\n\n/** The actor's type. */\nexport enum ActorType {\n  /** Indicates a team actor. */\n  Team = \"TEAM\",\n  /** Indicates a user actor. */\n  User = \"USER\",\n}\n\n/** Autogenerated input type of AddAssigneesToAssignable */\nexport type AddAssigneesToAssignableInput = {\n  /** The id of the assignable object to add assignees to. */\n  assignableId: Scalars[\"ID\"];\n  /** The id of users to add as assignees. */\n  assigneeIds: Array<Scalars[\"ID\"]>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated return type of AddAssigneesToAssignable */\nexport type AddAssigneesToAssignablePayload = {\n  __typename?: \"AddAssigneesToAssignablePayload\";\n  /** The item that was assigned. */\n  assignable?: Maybe<Assignable>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated input type of AddComment */\nexport type AddCommentInput = {\n  /** The contents of the comment. */\n  body: Scalars[\"String\"];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The Node ID of the subject to modify. */\n  subjectId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of AddComment */\nexport type AddCommentPayload = {\n  __typename?: \"AddCommentPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The edge from the subject's comment connection. */\n  commentEdge?: Maybe<IssueCommentEdge>;\n  /** The subject */\n  subject?: Maybe<Node>;\n  /** The edge from the subject's timeline connection. */\n  timelineEdge?: Maybe<IssueTimelineItemEdge>;\n};\n\n/** Autogenerated input type of AddDiscussionComment */\nexport type AddDiscussionCommentInput = {\n  /** The contents of the comment. */\n  body: Scalars[\"String\"];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The Node ID of the discussion to comment on. */\n  discussionId: Scalars[\"ID\"];\n  /** The Node ID of the discussion comment within this discussion to reply to. */\n  replyToId?: InputMaybe<Scalars[\"ID\"]>;\n};\n\n/** Autogenerated return type of AddDiscussionComment */\nexport type AddDiscussionCommentPayload = {\n  __typename?: \"AddDiscussionCommentPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The newly created discussion comment. */\n  comment?: Maybe<DiscussionComment>;\n};\n\n/** Autogenerated input type of AddEnterpriseSupportEntitlement */\nexport type AddEnterpriseSupportEntitlementInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the Enterprise which the admin belongs to. */\n  enterpriseId: Scalars[\"ID\"];\n  /** The login of a member who will receive the support entitlement. */\n  login: Scalars[\"String\"];\n};\n\n/** Autogenerated return type of AddEnterpriseSupportEntitlement */\nexport type AddEnterpriseSupportEntitlementPayload = {\n  __typename?: \"AddEnterpriseSupportEntitlementPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** A message confirming the result of adding the support entitlement. */\n  message?: Maybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated input type of AddLabelsToLabelable */\nexport type AddLabelsToLabelableInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ids of the labels to add. */\n  labelIds: Array<Scalars[\"ID\"]>;\n  /** The id of the labelable object to add labels to. */\n  labelableId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of AddLabelsToLabelable */\nexport type AddLabelsToLabelablePayload = {\n  __typename?: \"AddLabelsToLabelablePayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The item that was labeled. */\n  labelable?: Maybe<Labelable>;\n};\n\n/** Autogenerated input type of AddProjectCard */\nexport type AddProjectCardInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The content of the card. Must be a member of the ProjectCardItem union */\n  contentId?: InputMaybe<Scalars[\"ID\"]>;\n  /** The note on the card. */\n  note?: InputMaybe<Scalars[\"String\"]>;\n  /** The Node ID of the ProjectColumn. */\n  projectColumnId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of AddProjectCard */\nexport type AddProjectCardPayload = {\n  __typename?: \"AddProjectCardPayload\";\n  /** The edge from the ProjectColumn's card connection. */\n  cardEdge?: Maybe<ProjectCardEdge>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The ProjectColumn */\n  projectColumn?: Maybe<ProjectColumn>;\n};\n\n/** Autogenerated input type of AddProjectColumn */\nexport type AddProjectColumnInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The name of the column. */\n  name: Scalars[\"String\"];\n  /** The Node ID of the project. */\n  projectId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of AddProjectColumn */\nexport type AddProjectColumnPayload = {\n  __typename?: \"AddProjectColumnPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The edge from the project's column connection. */\n  columnEdge?: Maybe<ProjectColumnEdge>;\n  /** The project */\n  project?: Maybe<Project>;\n};\n\n/** Autogenerated input type of AddProjectDraftIssue */\nexport type AddProjectDraftIssueInput = {\n  /** The IDs of the assignees of the draft issue. */\n  assigneeIds?: InputMaybe<Array<Scalars[\"ID\"]>>;\n  /** The body of the draft issue. */\n  body?: InputMaybe<Scalars[\"String\"]>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the Project to add the draft issue to. */\n  projectId: Scalars[\"ID\"];\n  /** The title of the draft issue. */\n  title: Scalars[\"String\"];\n};\n\n/** Autogenerated return type of AddProjectDraftIssue */\nexport type AddProjectDraftIssuePayload = {\n  __typename?: \"AddProjectDraftIssuePayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The draft issue added to the project. */\n  projectNextItem?: Maybe<ProjectNextItem>;\n};\n\n/** Autogenerated input type of AddProjectNextItem */\nexport type AddProjectNextItemInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The content id of the item (Issue or PullRequest). */\n  contentId: Scalars[\"ID\"];\n  /** The ID of the Project to add the item to. */\n  projectId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of AddProjectNextItem */\nexport type AddProjectNextItemPayload = {\n  __typename?: \"AddProjectNextItemPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The item added to the project. */\n  projectNextItem?: Maybe<ProjectNextItem>;\n};\n\n/** Autogenerated input type of AddPullRequestReviewComment */\nexport type AddPullRequestReviewCommentInput = {\n  /** The text of the comment. */\n  body: Scalars[\"String\"];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The SHA of the commit to comment on. */\n  commitOID?: InputMaybe<Scalars[\"GitObjectID\"]>;\n  /** The comment id to reply to. */\n  inReplyTo?: InputMaybe<Scalars[\"ID\"]>;\n  /** The relative path of the file to comment on. */\n  path?: InputMaybe<Scalars[\"String\"]>;\n  /** The line index in the diff to comment on. */\n  position?: InputMaybe<Scalars[\"Int\"]>;\n  /** The node ID of the pull request reviewing */\n  pullRequestId?: InputMaybe<Scalars[\"ID\"]>;\n  /** The Node ID of the review to modify. */\n  pullRequestReviewId?: InputMaybe<Scalars[\"ID\"]>;\n};\n\n/** Autogenerated return type of AddPullRequestReviewComment */\nexport type AddPullRequestReviewCommentPayload = {\n  __typename?: \"AddPullRequestReviewCommentPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The newly created comment. */\n  comment?: Maybe<PullRequestReviewComment>;\n  /** The edge from the review's comment connection. */\n  commentEdge?: Maybe<PullRequestReviewCommentEdge>;\n};\n\n/** Autogenerated input type of AddPullRequestReview */\nexport type AddPullRequestReviewInput = {\n  /** The contents of the review body comment. */\n  body?: InputMaybe<Scalars[\"String\"]>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The review line comments. */\n  comments?: InputMaybe<Array<InputMaybe<DraftPullRequestReviewComment>>>;\n  /** The commit OID the review pertains to. */\n  commitOID?: InputMaybe<Scalars[\"GitObjectID\"]>;\n  /** The event to perform on the pull request review. */\n  event?: InputMaybe<PullRequestReviewEvent>;\n  /** The Node ID of the pull request to modify. */\n  pullRequestId: Scalars[\"ID\"];\n  /** The review line comment threads. */\n  threads?: InputMaybe<Array<InputMaybe<DraftPullRequestReviewThread>>>;\n};\n\n/** Autogenerated return type of AddPullRequestReview */\nexport type AddPullRequestReviewPayload = {\n  __typename?: \"AddPullRequestReviewPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The newly created pull request review. */\n  pullRequestReview?: Maybe<PullRequestReview>;\n  /** The edge from the pull request's review connection. */\n  reviewEdge?: Maybe<PullRequestReviewEdge>;\n};\n\n/** Autogenerated input type of AddPullRequestReviewThread */\nexport type AddPullRequestReviewThreadInput = {\n  /** Body of the thread's first comment. */\n  body: Scalars[\"String\"];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The line of the blob to which the thread refers. The end of the line range for multi-line comments. */\n  line: Scalars[\"Int\"];\n  /** Path to the file being commented on. */\n  path: Scalars[\"String\"];\n  /** The node ID of the pull request reviewing */\n  pullRequestId?: InputMaybe<Scalars[\"ID\"]>;\n  /** The Node ID of the review to modify. */\n  pullRequestReviewId?: InputMaybe<Scalars[\"ID\"]>;\n  /** The side of the diff on which the line resides. For multi-line comments, this is the side for the end of the line range. */\n  side?: InputMaybe<DiffSide>;\n  /** The first line of the range to which the comment refers. */\n  startLine?: InputMaybe<Scalars[\"Int\"]>;\n  /** The side of the diff on which the start line resides. */\n  startSide?: InputMaybe<DiffSide>;\n};\n\n/** Autogenerated return type of AddPullRequestReviewThread */\nexport type AddPullRequestReviewThreadPayload = {\n  __typename?: \"AddPullRequestReviewThreadPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The newly created thread. */\n  thread?: Maybe<PullRequestReviewThread>;\n};\n\n/** Autogenerated input type of AddReaction */\nexport type AddReactionInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The name of the emoji to react with. */\n  content: ReactionContent;\n  /** The Node ID of the subject to modify. */\n  subjectId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of AddReaction */\nexport type AddReactionPayload = {\n  __typename?: \"AddReactionPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The reaction object. */\n  reaction?: Maybe<Reaction>;\n  /** The reactable subject. */\n  subject?: Maybe<Reactable>;\n};\n\n/** Autogenerated input type of AddStar */\nexport type AddStarInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The Starrable ID to star. */\n  starrableId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of AddStar */\nexport type AddStarPayload = {\n  __typename?: \"AddStarPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The starrable. */\n  starrable?: Maybe<Starrable>;\n};\n\n/** Autogenerated input type of AddUpvote */\nexport type AddUpvoteInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The Node ID of the discussion or comment to upvote. */\n  subjectId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of AddUpvote */\nexport type AddUpvotePayload = {\n  __typename?: \"AddUpvotePayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The votable subject. */\n  subject?: Maybe<Votable>;\n};\n\n/** Autogenerated input type of AddVerifiableDomain */\nexport type AddVerifiableDomainInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The URL of the domain */\n  domain: Scalars[\"URI\"];\n  /** The ID of the owner to add the domain to */\n  ownerId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of AddVerifiableDomain */\nexport type AddVerifiableDomainPayload = {\n  __typename?: \"AddVerifiableDomainPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The verifiable domain that was added. */\n  domain?: Maybe<VerifiableDomain>;\n};\n\n/** Represents a 'added_to_project' event on a given issue or pull request. */\nexport type AddedToProjectEvent = Node & {\n  __typename?: \"AddedToProjectEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars[\"Int\"]>;\n  id: Scalars[\"ID\"];\n  /** Project referenced by event. */\n  project?: Maybe<Project>;\n  /** Project card referenced by this project event. */\n  projectCard?: Maybe<ProjectCard>;\n  /** Column name referenced by this project event. */\n  projectColumnName: Scalars[\"String\"];\n};\n\n/** A GitHub App. */\nexport type App = Node & {\n  __typename?: \"App\";\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars[\"Int\"]>;\n  /** The description of the app. */\n  description?: Maybe<Scalars[\"String\"]>;\n  id: Scalars[\"ID\"];\n  /** The IP addresses of the app. */\n  ipAllowListEntries: IpAllowListEntryConnection;\n  /** The hex color code, without the leading '#', for the logo background. */\n  logoBackgroundColor: Scalars[\"String\"];\n  /** A URL pointing to the app's logo. */\n  logoUrl: Scalars[\"URI\"];\n  /** The name of the app. */\n  name: Scalars[\"String\"];\n  /** A slug based on the name of the app for use in URLs. */\n  slug: Scalars[\"String\"];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars[\"DateTime\"];\n  /** The URL to the app's homepage. */\n  url: Scalars[\"URI\"];\n};\n\n/** A GitHub App. */\nexport type AppIpAllowListEntriesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<IpAllowListEntryOrder>;\n};\n\n/** A GitHub App. */\nexport type AppLogoUrlArgs = {\n  size?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** Autogenerated input type of ApproveDeployments */\nexport type ApproveDeploymentsInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** Optional comment for approving deployments */\n  comment?: InputMaybe<Scalars[\"String\"]>;\n  /** The ids of environments to reject deployments */\n  environmentIds: Array<Scalars[\"ID\"]>;\n  /** The node ID of the workflow run containing the pending deployments. */\n  workflowRunId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of ApproveDeployments */\nexport type ApproveDeploymentsPayload = {\n  __typename?: \"ApproveDeploymentsPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The affected deployments. */\n  deployments?: Maybe<Array<Deployment>>;\n};\n\n/** Autogenerated input type of ApproveVerifiableDomain */\nexport type ApproveVerifiableDomainInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the verifiable domain to approve. */\n  id: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of ApproveVerifiableDomain */\nexport type ApproveVerifiableDomainPayload = {\n  __typename?: \"ApproveVerifiableDomainPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The verifiable domain that was approved. */\n  domain?: Maybe<VerifiableDomain>;\n};\n\n/** Autogenerated input type of ArchiveRepository */\nexport type ArchiveRepositoryInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the repository to mark as archived. */\n  repositoryId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of ArchiveRepository */\nexport type ArchiveRepositoryPayload = {\n  __typename?: \"ArchiveRepositoryPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The repository that was marked as archived. */\n  repository?: Maybe<Repository>;\n};\n\n/** An object that can have users assigned to it. */\nexport type Assignable = {\n  /** A list of Users assigned to this object. */\n  assignees: UserConnection;\n};\n\n/** An object that can have users assigned to it. */\nexport type AssignableAssigneesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** Represents an 'assigned' event on any assignable object. */\nexport type AssignedEvent = Node & {\n  __typename?: \"AssignedEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the assignable associated with the event. */\n  assignable: Assignable;\n  /** Identifies the user or mannequin that was assigned. */\n  assignee?: Maybe<Assignee>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  id: Scalars[\"ID\"];\n  /**\n   * Identifies the user who was assigned.\n   * @deprecated Assignees can now be mannequins. Use the `assignee` field instead. Removal on 2020-01-01 UTC.\n   */\n  user?: Maybe<User>;\n};\n\n/** Types that can be assigned to issues. */\nexport type Assignee = Bot | Mannequin | Organization | User;\n\n/** An entry in the audit log. */\nexport type AuditEntry = {\n  /** The action name */\n  action: Scalars[\"String\"];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars[\"String\"]>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars[\"String\"]>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars[\"URI\"]>;\n  /** The time the action was initiated */\n  createdAt: Scalars[\"PreciseDateTime\"];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars[\"String\"]>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars[\"URI\"]>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars[\"URI\"]>;\n};\n\n/** Types that can initiate an audit log event. */\nexport type AuditEntryActor = Bot | Organization | User;\n\n/** Ordering options for Audit Log connections. */\nexport type AuditLogOrder = {\n  /** The ordering direction. */\n  direction?: InputMaybe<OrderDirection>;\n  /** The field to order Audit Logs by. */\n  field?: InputMaybe<AuditLogOrderField>;\n};\n\n/** Properties by which Audit Log connections can be ordered. */\nexport enum AuditLogOrderField {\n  /** Order audit log entries by timestamp */\n  CreatedAt = \"CREATED_AT\",\n}\n\n/** Represents a 'auto_merge_disabled' event on a given pull request. */\nexport type AutoMergeDisabledEvent = Node & {\n  __typename?: \"AutoMergeDisabledEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** The user who disabled auto-merge for this Pull Request */\n  disabler?: Maybe<User>;\n  id: Scalars[\"ID\"];\n  /** PullRequest referenced by event */\n  pullRequest?: Maybe<PullRequest>;\n  /** The reason auto-merge was disabled */\n  reason?: Maybe<Scalars[\"String\"]>;\n  /** The reason_code relating to why auto-merge was disabled */\n  reasonCode?: Maybe<Scalars[\"String\"]>;\n};\n\n/** Represents a 'auto_merge_enabled' event on a given pull request. */\nexport type AutoMergeEnabledEvent = Node & {\n  __typename?: \"AutoMergeEnabledEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** The user who enabled auto-merge for this Pull Request */\n  enabler?: Maybe<User>;\n  id: Scalars[\"ID\"];\n  /** PullRequest referenced by event. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Represents an auto-merge request for a pull request */\nexport type AutoMergeRequest = {\n  __typename?: \"AutoMergeRequest\";\n  /** The email address of the author of this auto-merge request. */\n  authorEmail?: Maybe<Scalars[\"String\"]>;\n  /** The commit message of the auto-merge request. */\n  commitBody?: Maybe<Scalars[\"String\"]>;\n  /** The commit title of the auto-merge request. */\n  commitHeadline?: Maybe<Scalars[\"String\"]>;\n  /** When was this auto-merge request was enabled. */\n  enabledAt?: Maybe<Scalars[\"DateTime\"]>;\n  /** The actor who created the auto-merge request. */\n  enabledBy?: Maybe<Actor>;\n  /** The merge method of the auto-merge request. */\n  mergeMethod: PullRequestMergeMethod;\n  /** The pull request that this auto-merge request is set against. */\n  pullRequest: PullRequest;\n};\n\n/** Represents a 'auto_rebase_enabled' event on a given pull request. */\nexport type AutoRebaseEnabledEvent = Node & {\n  __typename?: \"AutoRebaseEnabledEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** The user who enabled auto-merge (rebase) for this Pull Request */\n  enabler?: Maybe<User>;\n  id: Scalars[\"ID\"];\n  /** PullRequest referenced by event. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Represents a 'auto_squash_enabled' event on a given pull request. */\nexport type AutoSquashEnabledEvent = Node & {\n  __typename?: \"AutoSquashEnabledEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** The user who enabled auto-merge (squash) for this Pull Request */\n  enabler?: Maybe<User>;\n  id: Scalars[\"ID\"];\n  /** PullRequest referenced by event. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Represents a 'automatic_base_change_failed' event on a given pull request. */\nexport type AutomaticBaseChangeFailedEvent = Node & {\n  __typename?: \"AutomaticBaseChangeFailedEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  id: Scalars[\"ID\"];\n  /** The new base for this PR */\n  newBase: Scalars[\"String\"];\n  /** The old base for this PR */\n  oldBase: Scalars[\"String\"];\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest;\n};\n\n/** Represents a 'automatic_base_change_succeeded' event on a given pull request. */\nexport type AutomaticBaseChangeSucceededEvent = Node & {\n  __typename?: \"AutomaticBaseChangeSucceededEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  id: Scalars[\"ID\"];\n  /** The new base for this PR */\n  newBase: Scalars[\"String\"];\n  /** The old base for this PR */\n  oldBase: Scalars[\"String\"];\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest;\n};\n\n/** Represents a 'base_ref_changed' event on a given issue or pull request. */\nexport type BaseRefChangedEvent = Node & {\n  __typename?: \"BaseRefChangedEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** Identifies the name of the base ref for the pull request after it was changed. */\n  currentRefName: Scalars[\"String\"];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars[\"Int\"]>;\n  id: Scalars[\"ID\"];\n  /** Identifies the name of the base ref for the pull request before it was changed. */\n  previousRefName: Scalars[\"String\"];\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest;\n};\n\n/** Represents a 'base_ref_deleted' event on a given pull request. */\nexport type BaseRefDeletedEvent = Node & {\n  __typename?: \"BaseRefDeletedEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the name of the Ref associated with the `base_ref_deleted` event. */\n  baseRefName?: Maybe<Scalars[\"String\"]>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  id: Scalars[\"ID\"];\n  /** PullRequest referenced by event. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Represents a 'base_ref_force_pushed' event on a given pull request. */\nexport type BaseRefForcePushedEvent = Node & {\n  __typename?: \"BaseRefForcePushedEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the after commit SHA for the 'base_ref_force_pushed' event. */\n  afterCommit?: Maybe<Commit>;\n  /** Identifies the before commit SHA for the 'base_ref_force_pushed' event. */\n  beforeCommit?: Maybe<Commit>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  id: Scalars[\"ID\"];\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest;\n  /** Identifies the fully qualified ref name for the 'base_ref_force_pushed' event. */\n  ref?: Maybe<Ref>;\n};\n\n/** Represents a Git blame. */\nexport type Blame = {\n  __typename?: \"Blame\";\n  /** The list of ranges from a Git blame. */\n  ranges: Array<BlameRange>;\n};\n\n/** Represents a range of information from a Git blame. */\nexport type BlameRange = {\n  __typename?: \"BlameRange\";\n  /**\n   * Identifies the recency of the change, from 1 (new) to 10 (old). This is\n   * calculated as a 2-quantile and determines the length of distance between the\n   * median age of all the changes in the file and the recency of the current\n   * range's change.\n   */\n  age: Scalars[\"Int\"];\n  /** Identifies the line author */\n  commit: Commit;\n  /** The ending line for the range */\n  endingLine: Scalars[\"Int\"];\n  /** The starting line for the range */\n  startingLine: Scalars[\"Int\"];\n};\n\n/** Represents a Git blob. */\nexport type Blob = GitObject &\n  Node & {\n    __typename?: \"Blob\";\n    /** An abbreviated version of the Git object ID */\n    abbreviatedOid: Scalars[\"String\"];\n    /** Byte size of Blob object */\n    byteSize: Scalars[\"Int\"];\n    /** The HTTP path for this Git object */\n    commitResourcePath: Scalars[\"URI\"];\n    /** The HTTP URL for this Git object */\n    commitUrl: Scalars[\"URI\"];\n    id: Scalars[\"ID\"];\n    /** Indicates whether the Blob is binary or text. Returns null if unable to determine the encoding. */\n    isBinary?: Maybe<Scalars[\"Boolean\"]>;\n    /** Indicates whether the contents is truncated */\n    isTruncated: Scalars[\"Boolean\"];\n    /** The Git object ID */\n    oid: Scalars[\"GitObjectID\"];\n    /** The Repository the Git object belongs to */\n    repository: Repository;\n    /** UTF8 text data or null if the Blob is binary */\n    text?: Maybe<Scalars[\"String\"]>;\n  };\n\n/** A special type of user which takes actions on behalf of GitHub Apps. */\nexport type Bot = Actor &\n  Node &\n  UniformResourceLocatable & {\n    __typename?: \"Bot\";\n    /** A URL pointing to the GitHub App's public avatar. */\n    avatarUrl: Scalars[\"URI\"];\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars[\"DateTime\"];\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars[\"Int\"]>;\n    id: Scalars[\"ID\"];\n    /** The username of the actor. */\n    login: Scalars[\"String\"];\n    /** The HTTP path for this bot */\n    resourcePath: Scalars[\"URI\"];\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars[\"DateTime\"];\n    /** The HTTP URL for this bot */\n    url: Scalars[\"URI\"];\n  };\n\n/** A special type of user which takes actions on behalf of GitHub Apps. */\nexport type BotAvatarUrlArgs = {\n  size?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** Types which can be actors for `BranchActorAllowance` objects. */\nexport type BranchActorAllowanceActor = Team | User;\n\n/** A branch protection rule. */\nexport type BranchProtectionRule = Node & {\n  __typename?: \"BranchProtectionRule\";\n  /** Can this branch be deleted. */\n  allowsDeletions: Scalars[\"Boolean\"];\n  /** Are force pushes allowed on this branch. */\n  allowsForcePushes: Scalars[\"Boolean\"];\n  /** Is branch creation a protected operation. */\n  blocksCreations: Scalars[\"Boolean\"];\n  /** A list of conflicts matching branches protection rule and other branch protection rules */\n  branchProtectionRuleConflicts: BranchProtectionRuleConflictConnection;\n  /** A list of actors able to force push for this branch protection rule. */\n  bypassForcePushAllowances: BypassForcePushAllowanceConnection;\n  /** A list of actors able to bypass PRs for this branch protection rule. */\n  bypassPullRequestAllowances: BypassPullRequestAllowanceConnection;\n  /** The actor who created this branch protection rule. */\n  creator?: Maybe<Actor>;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars[\"Int\"]>;\n  /** Will new commits pushed to matching branches dismiss pull request review approvals. */\n  dismissesStaleReviews: Scalars[\"Boolean\"];\n  id: Scalars[\"ID\"];\n  /** Can admins overwrite branch protection. */\n  isAdminEnforced: Scalars[\"Boolean\"];\n  /** Repository refs that are protected by this rule */\n  matchingRefs: RefConnection;\n  /** Identifies the protection rule pattern. */\n  pattern: Scalars[\"String\"];\n  /** A list push allowances for this branch protection rule. */\n  pushAllowances: PushAllowanceConnection;\n  /** The repository associated with this branch protection rule. */\n  repository?: Maybe<Repository>;\n  /** Number of approving reviews required to update matching branches. */\n  requiredApprovingReviewCount?: Maybe<Scalars[\"Int\"]>;\n  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */\n  requiredStatusCheckContexts?: Maybe<Array<Maybe<Scalars[\"String\"]>>>;\n  /** List of required status checks that must pass for commits to be accepted to matching branches. */\n  requiredStatusChecks?: Maybe<Array<RequiredStatusCheckDescription>>;\n  /** Are approving reviews required to update matching branches. */\n  requiresApprovingReviews: Scalars[\"Boolean\"];\n  /** Are reviews from code owners required to update matching branches. */\n  requiresCodeOwnerReviews: Scalars[\"Boolean\"];\n  /** Are commits required to be signed. */\n  requiresCommitSignatures: Scalars[\"Boolean\"];\n  /** Are conversations required to be resolved before merging. */\n  requiresConversationResolution: Scalars[\"Boolean\"];\n  /** Are merge commits prohibited from being pushed to this branch. */\n  requiresLinearHistory: Scalars[\"Boolean\"];\n  /** Are status checks required to update matching branches. */\n  requiresStatusChecks: Scalars[\"Boolean\"];\n  /** Are branches required to be up to date before merging. */\n  requiresStrictStatusChecks: Scalars[\"Boolean\"];\n  /** Is pushing to matching branches restricted. */\n  restrictsPushes: Scalars[\"Boolean\"];\n  /** Is dismissal of pull request reviews restricted. */\n  restrictsReviewDismissals: Scalars[\"Boolean\"];\n  /** A list review dismissal allowances for this branch protection rule. */\n  reviewDismissalAllowances: ReviewDismissalAllowanceConnection;\n};\n\n/** A branch protection rule. */\nexport type BranchProtectionRuleBranchProtectionRuleConflictsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A branch protection rule. */\nexport type BranchProtectionRuleBypassForcePushAllowancesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A branch protection rule. */\nexport type BranchProtectionRuleBypassPullRequestAllowancesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A branch protection rule. */\nexport type BranchProtectionRuleMatchingRefsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  query?: InputMaybe<Scalars[\"String\"]>;\n};\n\n/** A branch protection rule. */\nexport type BranchProtectionRulePushAllowancesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A branch protection rule. */\nexport type BranchProtectionRuleReviewDismissalAllowancesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A conflict between two branch protection rules. */\nexport type BranchProtectionRuleConflict = {\n  __typename?: \"BranchProtectionRuleConflict\";\n  /** Identifies the branch protection rule. */\n  branchProtectionRule?: Maybe<BranchProtectionRule>;\n  /** Identifies the conflicting branch protection rule. */\n  conflictingBranchProtectionRule?: Maybe<BranchProtectionRule>;\n  /** Identifies the branch ref that has conflicting rules */\n  ref?: Maybe<Ref>;\n};\n\n/** The connection type for BranchProtectionRuleConflict. */\nexport type BranchProtectionRuleConflictConnection = {\n  __typename?: \"BranchProtectionRuleConflictConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<BranchProtectionRuleConflictEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<BranchProtectionRuleConflict>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type BranchProtectionRuleConflictEdge = {\n  __typename?: \"BranchProtectionRuleConflictEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<BranchProtectionRuleConflict>;\n};\n\n/** The connection type for BranchProtectionRule. */\nexport type BranchProtectionRuleConnection = {\n  __typename?: \"BranchProtectionRuleConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<BranchProtectionRuleEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<BranchProtectionRule>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type BranchProtectionRuleEdge = {\n  __typename?: \"BranchProtectionRuleEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<BranchProtectionRule>;\n};\n\n/** A team or user who has the ability to bypass a force push requirement on a protected branch. */\nexport type BypassForcePushAllowance = Node & {\n  __typename?: \"BypassForcePushAllowance\";\n  /** The actor that can dismiss. */\n  actor?: Maybe<BranchActorAllowanceActor>;\n  /** Identifies the branch protection rule associated with the allowed user or team. */\n  branchProtectionRule?: Maybe<BranchProtectionRule>;\n  id: Scalars[\"ID\"];\n};\n\n/** The connection type for BypassForcePushAllowance. */\nexport type BypassForcePushAllowanceConnection = {\n  __typename?: \"BypassForcePushAllowanceConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<BypassForcePushAllowanceEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<BypassForcePushAllowance>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type BypassForcePushAllowanceEdge = {\n  __typename?: \"BypassForcePushAllowanceEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<BypassForcePushAllowance>;\n};\n\n/** A team or user who has the ability to bypass a pull request requirement on a protected branch. */\nexport type BypassPullRequestAllowance = Node & {\n  __typename?: \"BypassPullRequestAllowance\";\n  /** The actor that can dismiss. */\n  actor?: Maybe<BranchActorAllowanceActor>;\n  /** Identifies the branch protection rule associated with the allowed user or team. */\n  branchProtectionRule?: Maybe<BranchProtectionRule>;\n  id: Scalars[\"ID\"];\n};\n\n/** The connection type for BypassPullRequestAllowance. */\nexport type BypassPullRequestAllowanceConnection = {\n  __typename?: \"BypassPullRequestAllowanceConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<BypassPullRequestAllowanceEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<BypassPullRequestAllowance>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type BypassPullRequestAllowanceEdge = {\n  __typename?: \"BypassPullRequestAllowanceEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<BypassPullRequestAllowance>;\n};\n\n/** The Common Vulnerability Scoring System */\nexport type Cvss = {\n  __typename?: \"CVSS\";\n  /** The CVSS score associated with this advisory */\n  score: Scalars[\"Float\"];\n  /** The CVSS vector string associated with this advisory */\n  vectorString?: Maybe<Scalars[\"String\"]>;\n};\n\n/** A common weakness enumeration */\nexport type Cwe = Node & {\n  __typename?: \"CWE\";\n  /** The id of the CWE */\n  cweId: Scalars[\"String\"];\n  /** A detailed description of this CWE */\n  description: Scalars[\"String\"];\n  id: Scalars[\"ID\"];\n  /** The name of this CWE */\n  name: Scalars[\"String\"];\n};\n\n/** The connection type for CWE. */\nexport type CweConnection = {\n  __typename?: \"CWEConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CweEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Cwe>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type CweEdge = {\n  __typename?: \"CWEEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<Cwe>;\n};\n\n/** Autogenerated input type of CancelEnterpriseAdminInvitation */\nexport type CancelEnterpriseAdminInvitationInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The Node ID of the pending enterprise administrator invitation. */\n  invitationId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of CancelEnterpriseAdminInvitation */\nexport type CancelEnterpriseAdminInvitationPayload = {\n  __typename?: \"CancelEnterpriseAdminInvitationPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The invitation that was canceled. */\n  invitation?: Maybe<EnterpriseAdministratorInvitation>;\n  /** A message confirming the result of canceling an administrator invitation. */\n  message?: Maybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated input type of CancelSponsorship */\nexport type CancelSponsorshipInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /**\n   * The ID of the user or organization who is acting as the sponsor, paying for\n   * the sponsorship. Required if sponsorLogin is not given.\n   */\n  sponsorId?: InputMaybe<Scalars[\"ID\"]>;\n  /**\n   * The username of the user or organization who is acting as the sponsor, paying\n   * for the sponsorship. Required if sponsorId is not given.\n   */\n  sponsorLogin?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given. */\n  sponsorableId?: InputMaybe<Scalars[\"ID\"]>;\n  /** The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given. */\n  sponsorableLogin?: InputMaybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated return type of CancelSponsorship */\nexport type CancelSponsorshipPayload = {\n  __typename?: \"CancelSponsorshipPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The tier that was being used at the time of cancellation. */\n  sponsorsTier?: Maybe<SponsorsTier>;\n};\n\n/** Autogenerated input type of ChangeUserStatus */\nexport type ChangeUserStatusInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The emoji to represent your status. Can either be a native Unicode emoji or an emoji name with colons, e.g., :grinning:. */\n  emoji?: InputMaybe<Scalars[\"String\"]>;\n  /** If set, the user status will not be shown after this date. */\n  expiresAt?: InputMaybe<Scalars[\"DateTime\"]>;\n  /** Whether this status should indicate you are not fully available on GitHub, e.g., you are away. */\n  limitedAvailability?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** A short description of your current status. */\n  message?: InputMaybe<Scalars[\"String\"]>;\n  /**\n   * The ID of the organization whose members will be allowed to see the status. If\n   * omitted, the status will be publicly visible.\n   */\n  organizationId?: InputMaybe<Scalars[\"ID\"]>;\n};\n\n/** Autogenerated return type of ChangeUserStatus */\nexport type ChangeUserStatusPayload = {\n  __typename?: \"ChangeUserStatusPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** Your updated status. */\n  status?: Maybe<UserStatus>;\n};\n\n/** A single check annotation. */\nexport type CheckAnnotation = {\n  __typename?: \"CheckAnnotation\";\n  /** The annotation's severity level. */\n  annotationLevel?: Maybe<CheckAnnotationLevel>;\n  /** The path to the file that this annotation was made on. */\n  blobUrl: Scalars[\"URI\"];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars[\"Int\"]>;\n  /** The position of this annotation. */\n  location: CheckAnnotationSpan;\n  /** The annotation's message. */\n  message: Scalars[\"String\"];\n  /** The path that this annotation was made on. */\n  path: Scalars[\"String\"];\n  /** Additional information about the annotation. */\n  rawDetails?: Maybe<Scalars[\"String\"]>;\n  /** The annotation's title */\n  title?: Maybe<Scalars[\"String\"]>;\n};\n\n/** The connection type for CheckAnnotation. */\nexport type CheckAnnotationConnection = {\n  __typename?: \"CheckAnnotationConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CheckAnnotationEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<CheckAnnotation>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** Information from a check run analysis to specific lines of code. */\nexport type CheckAnnotationData = {\n  /** Represents an annotation's information level */\n  annotationLevel: CheckAnnotationLevel;\n  /** The location of the annotation */\n  location: CheckAnnotationRange;\n  /** A short description of the feedback for these lines of code. */\n  message: Scalars[\"String\"];\n  /** The path of the file to add an annotation to. */\n  path: Scalars[\"String\"];\n  /** Details about this annotation. */\n  rawDetails?: InputMaybe<Scalars[\"String\"]>;\n  /** The title that represents the annotation. */\n  title?: InputMaybe<Scalars[\"String\"]>;\n};\n\n/** An edge in a connection. */\nexport type CheckAnnotationEdge = {\n  __typename?: \"CheckAnnotationEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<CheckAnnotation>;\n};\n\n/** Represents an annotation's information level. */\nexport enum CheckAnnotationLevel {\n  /** An annotation indicating an inescapable error. */\n  Failure = \"FAILURE\",\n  /** An annotation indicating some information. */\n  Notice = \"NOTICE\",\n  /** An annotation indicating an ignorable error. */\n  Warning = \"WARNING\",\n}\n\n/** A character position in a check annotation. */\nexport type CheckAnnotationPosition = {\n  __typename?: \"CheckAnnotationPosition\";\n  /** Column number (1 indexed). */\n  column?: Maybe<Scalars[\"Int\"]>;\n  /** Line number (1 indexed). */\n  line: Scalars[\"Int\"];\n};\n\n/** Information from a check run analysis to specific lines of code. */\nexport type CheckAnnotationRange = {\n  /** The ending column of the range. */\n  endColumn?: InputMaybe<Scalars[\"Int\"]>;\n  /** The ending line of the range. */\n  endLine: Scalars[\"Int\"];\n  /** The starting column of the range. */\n  startColumn?: InputMaybe<Scalars[\"Int\"]>;\n  /** The starting line of the range. */\n  startLine: Scalars[\"Int\"];\n};\n\n/** An inclusive pair of positions for a check annotation. */\nexport type CheckAnnotationSpan = {\n  __typename?: \"CheckAnnotationSpan\";\n  /** End position (inclusive). */\n  end: CheckAnnotationPosition;\n  /** Start position (inclusive). */\n  start: CheckAnnotationPosition;\n};\n\n/** The possible states for a check suite or run conclusion. */\nexport enum CheckConclusionState {\n  /** The check suite or run requires action. */\n  ActionRequired = \"ACTION_REQUIRED\",\n  /** The check suite or run has been cancelled. */\n  Cancelled = \"CANCELLED\",\n  /** The check suite or run has failed. */\n  Failure = \"FAILURE\",\n  /** The check suite or run was neutral. */\n  Neutral = \"NEUTRAL\",\n  /** The check suite or run was skipped. */\n  Skipped = \"SKIPPED\",\n  /** The check suite or run was marked stale by GitHub. Only GitHub can use this conclusion. */\n  Stale = \"STALE\",\n  /** The check suite or run has failed at startup. */\n  StartupFailure = \"STARTUP_FAILURE\",\n  /** The check suite or run has succeeded. */\n  Success = \"SUCCESS\",\n  /** The check suite or run has timed out. */\n  TimedOut = \"TIMED_OUT\",\n}\n\n/** A check run. */\nexport type CheckRun = Node &\n  RequirableByPullRequest &\n  UniformResourceLocatable & {\n    __typename?: \"CheckRun\";\n    /** The check run's annotations */\n    annotations?: Maybe<CheckAnnotationConnection>;\n    /** The check suite that this run is a part of. */\n    checkSuite: CheckSuite;\n    /** Identifies the date and time when the check run was completed. */\n    completedAt?: Maybe<Scalars[\"DateTime\"]>;\n    /** The conclusion of the check run. */\n    conclusion?: Maybe<CheckConclusionState>;\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars[\"Int\"]>;\n    /** The corresponding deployment for this job, if any */\n    deployment?: Maybe<Deployment>;\n    /** The URL from which to find full details of the check run on the integrator's site. */\n    detailsUrl?: Maybe<Scalars[\"URI\"]>;\n    /** A reference for the check run on the integrator's system. */\n    externalId?: Maybe<Scalars[\"String\"]>;\n    id: Scalars[\"ID\"];\n    /** Whether this is required to pass before merging for a specific pull request. */\n    isRequired: Scalars[\"Boolean\"];\n    /** The name of the check for this check run. */\n    name: Scalars[\"String\"];\n    /** Information about a pending deployment, if any, in this check run */\n    pendingDeploymentRequest?: Maybe<DeploymentRequest>;\n    /** The permalink to the check run summary. */\n    permalink: Scalars[\"URI\"];\n    /** The repository associated with this check run. */\n    repository: Repository;\n    /** The HTTP path for this check run. */\n    resourcePath: Scalars[\"URI\"];\n    /** Identifies the date and time when the check run was started. */\n    startedAt?: Maybe<Scalars[\"DateTime\"]>;\n    /** The current status of the check run. */\n    status: CheckStatusState;\n    /** The check run's steps */\n    steps?: Maybe<CheckStepConnection>;\n    /** A string representing the check run's summary */\n    summary?: Maybe<Scalars[\"String\"]>;\n    /** A string representing the check run's text */\n    text?: Maybe<Scalars[\"String\"]>;\n    /** A string representing the check run */\n    title?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP URL for this check run. */\n    url: Scalars[\"URI\"];\n  };\n\n/** A check run. */\nexport type CheckRunAnnotationsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A check run. */\nexport type CheckRunIsRequiredArgs = {\n  pullRequestId?: InputMaybe<Scalars[\"ID\"]>;\n  pullRequestNumber?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A check run. */\nexport type CheckRunStepsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  number?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** Possible further actions the integrator can perform. */\nexport type CheckRunAction = {\n  /** A short explanation of what this action would do. */\n  description: Scalars[\"String\"];\n  /** A reference for the action on the integrator's system. */\n  identifier: Scalars[\"String\"];\n  /** The text to be displayed on a button in the web UI. */\n  label: Scalars[\"String\"];\n};\n\n/** The connection type for CheckRun. */\nexport type CheckRunConnection = {\n  __typename?: \"CheckRunConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CheckRunEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<CheckRun>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type CheckRunEdge = {\n  __typename?: \"CheckRunEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<CheckRun>;\n};\n\n/** The filters that are available when fetching check runs. */\nexport type CheckRunFilter = {\n  /** Filters the check runs created by this application ID. */\n  appId?: InputMaybe<Scalars[\"Int\"]>;\n  /** Filters the check runs by this name. */\n  checkName?: InputMaybe<Scalars[\"String\"]>;\n  /** Filters the check runs by this type. */\n  checkType?: InputMaybe<CheckRunType>;\n  /** Filters the check runs by this status. */\n  status?: InputMaybe<CheckStatusState>;\n};\n\n/** Descriptive details about the check run. */\nexport type CheckRunOutput = {\n  /** The annotations that are made as part of the check run. */\n  annotations?: InputMaybe<Array<CheckAnnotationData>>;\n  /** Images attached to the check run output displayed in the GitHub pull request UI. */\n  images?: InputMaybe<Array<CheckRunOutputImage>>;\n  /** The summary of the check run (supports Commonmark). */\n  summary: Scalars[\"String\"];\n  /** The details of the check run (supports Commonmark). */\n  text?: InputMaybe<Scalars[\"String\"]>;\n  /** A title to provide for this check run. */\n  title: Scalars[\"String\"];\n};\n\n/** Images attached to the check run output displayed in the GitHub pull request UI. */\nexport type CheckRunOutputImage = {\n  /** The alternative text for the image. */\n  alt: Scalars[\"String\"];\n  /** A short image description. */\n  caption?: InputMaybe<Scalars[\"String\"]>;\n  /** The full URL of the image. */\n  imageUrl: Scalars[\"URI\"];\n};\n\n/** The possible types of check runs. */\nexport enum CheckRunType {\n  /** Every check run available. */\n  All = \"ALL\",\n  /** The latest check run. */\n  Latest = \"LATEST\",\n}\n\n/** The possible states for a check suite or run status. */\nexport enum CheckStatusState {\n  /** The check suite or run has been completed. */\n  Completed = \"COMPLETED\",\n  /** The check suite or run is in progress. */\n  InProgress = \"IN_PROGRESS\",\n  /** The check suite or run is in pending state. */\n  Pending = \"PENDING\",\n  /** The check suite or run has been queued. */\n  Queued = \"QUEUED\",\n  /** The check suite or run has been requested. */\n  Requested = \"REQUESTED\",\n  /** The check suite or run is in waiting state. */\n  Waiting = \"WAITING\",\n}\n\n/** A single check step. */\nexport type CheckStep = {\n  __typename?: \"CheckStep\";\n  /** Identifies the date and time when the check step was completed. */\n  completedAt?: Maybe<Scalars[\"DateTime\"]>;\n  /** The conclusion of the check step. */\n  conclusion?: Maybe<CheckConclusionState>;\n  /** A reference for the check step on the integrator's system. */\n  externalId?: Maybe<Scalars[\"String\"]>;\n  /** The step's name. */\n  name: Scalars[\"String\"];\n  /** The index of the step in the list of steps of the parent check run. */\n  number: Scalars[\"Int\"];\n  /** Number of seconds to completion. */\n  secondsToCompletion?: Maybe<Scalars[\"Int\"]>;\n  /** Identifies the date and time when the check step was started. */\n  startedAt?: Maybe<Scalars[\"DateTime\"]>;\n  /** The current status of the check step. */\n  status: CheckStatusState;\n};\n\n/** The connection type for CheckStep. */\nexport type CheckStepConnection = {\n  __typename?: \"CheckStepConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CheckStepEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<CheckStep>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type CheckStepEdge = {\n  __typename?: \"CheckStepEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<CheckStep>;\n};\n\n/** A check suite. */\nexport type CheckSuite = Node & {\n  __typename?: \"CheckSuite\";\n  /** The GitHub App which created this check suite. */\n  app?: Maybe<App>;\n  /** The name of the branch for this check suite. */\n  branch?: Maybe<Ref>;\n  /** The check runs associated with a check suite. */\n  checkRuns?: Maybe<CheckRunConnection>;\n  /** The commit for this check suite */\n  commit: Commit;\n  /** The conclusion of this check suite. */\n  conclusion?: Maybe<CheckConclusionState>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** The user who triggered the check suite. */\n  creator?: Maybe<User>;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars[\"Int\"]>;\n  id: Scalars[\"ID\"];\n  /** A list of open pull requests matching the check suite. */\n  matchingPullRequests?: Maybe<PullRequestConnection>;\n  /** The push that triggered this check suite. */\n  push?: Maybe<Push>;\n  /** The repository associated with this check suite. */\n  repository: Repository;\n  /** The HTTP path for this check suite */\n  resourcePath: Scalars[\"URI\"];\n  /** The status of this check suite. */\n  status: CheckStatusState;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars[\"DateTime\"];\n  /** The HTTP URL for this check suite */\n  url: Scalars[\"URI\"];\n  /** The workflow run associated with this check suite. */\n  workflowRun?: Maybe<WorkflowRun>;\n};\n\n/** A check suite. */\nexport type CheckSuiteCheckRunsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  filterBy?: InputMaybe<CheckRunFilter>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A check suite. */\nexport type CheckSuiteMatchingPullRequestsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  baseRefName?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  headRefName?: InputMaybe<Scalars[\"String\"]>;\n  labels?: InputMaybe<Array<Scalars[\"String\"]>>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<IssueOrder>;\n  states?: InputMaybe<Array<PullRequestState>>;\n};\n\n/** The auto-trigger preferences that are available for check suites. */\nexport type CheckSuiteAutoTriggerPreference = {\n  /** The node ID of the application that owns the check suite. */\n  appId: Scalars[\"ID\"];\n  /** Set to `true` to enable automatic creation of CheckSuite events upon pushes to the repository. */\n  setting: Scalars[\"Boolean\"];\n};\n\n/** The connection type for CheckSuite. */\nexport type CheckSuiteConnection = {\n  __typename?: \"CheckSuiteConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CheckSuiteEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<CheckSuite>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type CheckSuiteEdge = {\n  __typename?: \"CheckSuiteEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<CheckSuite>;\n};\n\n/** The filters that are available when fetching check suites. */\nexport type CheckSuiteFilter = {\n  /** Filters the check suites created by this application ID. */\n  appId?: InputMaybe<Scalars[\"Int\"]>;\n  /** Filters the check suites by this name. */\n  checkName?: InputMaybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated input type of ClearLabelsFromLabelable */\nexport type ClearLabelsFromLabelableInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The id of the labelable object to clear the labels from. */\n  labelableId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of ClearLabelsFromLabelable */\nexport type ClearLabelsFromLabelablePayload = {\n  __typename?: \"ClearLabelsFromLabelablePayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The item that was unlabeled. */\n  labelable?: Maybe<Labelable>;\n};\n\n/** Autogenerated input type of CloneProject */\nexport type CloneProjectInput = {\n  /** The description of the project. */\n  body?: InputMaybe<Scalars[\"String\"]>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** Whether or not to clone the source project's workflows. */\n  includeWorkflows: Scalars[\"Boolean\"];\n  /** The name of the project. */\n  name: Scalars[\"String\"];\n  /** The visibility of the project, defaults to false (private). */\n  public?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** The source project to clone. */\n  sourceId: Scalars[\"ID\"];\n  /** The owner ID to create the project under. */\n  targetOwnerId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of CloneProject */\nexport type CloneProjectPayload = {\n  __typename?: \"CloneProjectPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The id of the JobStatus for populating cloned fields. */\n  jobStatusId?: Maybe<Scalars[\"String\"]>;\n  /** The new cloned project. */\n  project?: Maybe<Project>;\n};\n\n/** Autogenerated input type of CloneTemplateRepository */\nexport type CloneTemplateRepositoryInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** A short description of the new repository. */\n  description?: InputMaybe<Scalars[\"String\"]>;\n  /**\n   * Whether to copy all branches from the template to the new repository. Defaults\n   * to copying only the default branch of the template.\n   */\n  includeAllBranches?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** The name of the new repository. */\n  name: Scalars[\"String\"];\n  /** The ID of the owner for the new repository. */\n  ownerId: Scalars[\"ID\"];\n  /** The Node ID of the template repository. */\n  repositoryId: Scalars[\"ID\"];\n  /** Indicates the repository's visibility level. */\n  visibility: RepositoryVisibility;\n};\n\n/** Autogenerated return type of CloneTemplateRepository */\nexport type CloneTemplateRepositoryPayload = {\n  __typename?: \"CloneTemplateRepositoryPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The new repository. */\n  repository?: Maybe<Repository>;\n};\n\n/** An object that can be closed */\nexport type Closable = {\n  /** `true` if the object is closed (definition of closed may depend on type) */\n  closed: Scalars[\"Boolean\"];\n  /** Identifies the date and time when the object was closed. */\n  closedAt?: Maybe<Scalars[\"DateTime\"]>;\n};\n\n/** Autogenerated input type of CloseIssue */\nexport type CloseIssueInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** ID of the issue to be closed. */\n  issueId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of CloseIssue */\nexport type CloseIssuePayload = {\n  __typename?: \"CloseIssuePayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The issue that was closed. */\n  issue?: Maybe<Issue>;\n};\n\n/** Autogenerated input type of ClosePullRequest */\nexport type ClosePullRequestInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** ID of the pull request to be closed. */\n  pullRequestId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of ClosePullRequest */\nexport type ClosePullRequestPayload = {\n  __typename?: \"ClosePullRequestPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The pull request that was closed. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Represents a 'closed' event on any `Closable`. */\nexport type ClosedEvent = Node &\n  UniformResourceLocatable & {\n    __typename?: \"ClosedEvent\";\n    /** Identifies the actor who performed the event. */\n    actor?: Maybe<Actor>;\n    /** Object that was closed. */\n    closable: Closable;\n    /** Object which triggered the creation of this event. */\n    closer?: Maybe<Closer>;\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars[\"DateTime\"];\n    id: Scalars[\"ID\"];\n    /** The HTTP path for this closed event. */\n    resourcePath: Scalars[\"URI\"];\n    /** The HTTP URL for this closed event. */\n    url: Scalars[\"URI\"];\n  };\n\n/** The object which triggered a `ClosedEvent`. */\nexport type Closer = Commit | PullRequest;\n\n/** The Code of Conduct for a repository */\nexport type CodeOfConduct = Node & {\n  __typename?: \"CodeOfConduct\";\n  /** The body of the Code of Conduct */\n  body?: Maybe<Scalars[\"String\"]>;\n  id: Scalars[\"ID\"];\n  /** The key for the Code of Conduct */\n  key: Scalars[\"String\"];\n  /** The formal name of the Code of Conduct */\n  name: Scalars[\"String\"];\n  /** The HTTP path for this Code of Conduct */\n  resourcePath?: Maybe<Scalars[\"URI\"]>;\n  /** The HTTP URL for this Code of Conduct */\n  url?: Maybe<Scalars[\"URI\"]>;\n};\n\n/** Collaborators affiliation level with a subject. */\nexport enum CollaboratorAffiliation {\n  /** All collaborators the authenticated user can see. */\n  All = \"ALL\",\n  /** All collaborators with permissions to an organization-owned subject, regardless of organization membership status. */\n  Direct = \"DIRECT\",\n  /** All outside collaborators of an organization-owned subject. */\n  Outside = \"OUTSIDE\",\n}\n\n/** Represents a comment. */\nexport type Comment = {\n  /** The actor who authored the comment. */\n  author?: Maybe<Actor>;\n  /** Author's association with the subject of the comment. */\n  authorAssociation: CommentAuthorAssociation;\n  /** The body as Markdown. */\n  body: Scalars[\"String\"];\n  /** The body rendered to HTML. */\n  bodyHTML: Scalars[\"HTML\"];\n  /** The body rendered to text. */\n  bodyText: Scalars[\"String\"];\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** Check if this comment was created via an email reply. */\n  createdViaEmail: Scalars[\"Boolean\"];\n  /** The actor who edited the comment. */\n  editor?: Maybe<Actor>;\n  id: Scalars[\"ID\"];\n  /** Check if this comment was edited and includes an edit with the creation data */\n  includesCreatedEdit: Scalars[\"Boolean\"];\n  /** The moment the editor made the last edit */\n  lastEditedAt?: Maybe<Scalars[\"DateTime\"]>;\n  /** Identifies when the comment was published at. */\n  publishedAt?: Maybe<Scalars[\"DateTime\"]>;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars[\"DateTime\"];\n  /** A list of edits to this content. */\n  userContentEdits?: Maybe<UserContentEditConnection>;\n  /** Did the viewer author this comment. */\n  viewerDidAuthor: Scalars[\"Boolean\"];\n};\n\n/** Represents a comment. */\nexport type CommentUserContentEditsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A comment author association with repository. */\nexport enum CommentAuthorAssociation {\n  /** Author has been invited to collaborate on the repository. */\n  Collaborator = \"COLLABORATOR\",\n  /** Author has previously committed to the repository. */\n  Contributor = \"CONTRIBUTOR\",\n  /** Author has not previously committed to GitHub. */\n  FirstTimer = \"FIRST_TIMER\",\n  /** Author has not previously committed to the repository. */\n  FirstTimeContributor = \"FIRST_TIME_CONTRIBUTOR\",\n  /** Author is a placeholder for an unclaimed user. */\n  Mannequin = \"MANNEQUIN\",\n  /** Author is a member of the organization that owns the repository. */\n  Member = \"MEMBER\",\n  /** Author has no association with the repository. */\n  None = \"NONE\",\n  /** Author is the owner of the repository. */\n  Owner = \"OWNER\",\n}\n\n/** The possible errors that will prevent a user from updating a comment. */\nexport enum CommentCannotUpdateReason {\n  /** Unable to create comment because repository is archived. */\n  Archived = \"ARCHIVED\",\n  /** You cannot update this comment */\n  Denied = \"DENIED\",\n  /** You must be the author or have write access to this repository to update this comment. */\n  InsufficientAccess = \"INSUFFICIENT_ACCESS\",\n  /** Unable to create comment because issue is locked. */\n  Locked = \"LOCKED\",\n  /** You must be logged in to update this comment. */\n  LoginRequired = \"LOGIN_REQUIRED\",\n  /** Repository is under maintenance. */\n  Maintenance = \"MAINTENANCE\",\n  /** At least one email address must be verified to update this comment. */\n  VerifiedEmailRequired = \"VERIFIED_EMAIL_REQUIRED\",\n}\n\n/** Represents a 'comment_deleted' event on a given issue or pull request. */\nexport type CommentDeletedEvent = Node & {\n  __typename?: \"CommentDeletedEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars[\"Int\"]>;\n  /** The user who authored the deleted comment. */\n  deletedCommentAuthor?: Maybe<Actor>;\n  id: Scalars[\"ID\"];\n};\n\n/** Represents a Git commit. */\nexport type Commit = GitObject &\n  Node &\n  Subscribable &\n  UniformResourceLocatable & {\n    __typename?: \"Commit\";\n    /** An abbreviated version of the Git object ID */\n    abbreviatedOid: Scalars[\"String\"];\n    /** The number of additions in this commit. */\n    additions: Scalars[\"Int\"];\n    /**\n     * The merged Pull Request that introduced the commit to the repository. If the\n     * commit is not present in the default branch, additionally returns open Pull\n     * Requests associated with the commit\n     */\n    associatedPullRequests?: Maybe<PullRequestConnection>;\n    /** Authorship details of the commit. */\n    author?: Maybe<GitActor>;\n    /** Check if the committer and the author match. */\n    authoredByCommitter: Scalars[\"Boolean\"];\n    /** The datetime when this commit was authored. */\n    authoredDate: Scalars[\"DateTime\"];\n    /**\n     * The list of authors for this commit based on the git author and the Co-authored-by\n     * message trailer. The git author will always be first.\n     */\n    authors: GitActorConnection;\n    /** Fetches `git blame` information. */\n    blame: Blame;\n    /** The number of changed files in this commit. */\n    changedFiles: Scalars[\"Int\"];\n    /** The check suites associated with a commit. */\n    checkSuites?: Maybe<CheckSuiteConnection>;\n    /** Comments made on the commit. */\n    comments: CommitCommentConnection;\n    /** The HTTP path for this Git object */\n    commitResourcePath: Scalars[\"URI\"];\n    /** The HTTP URL for this Git object */\n    commitUrl: Scalars[\"URI\"];\n    /** The datetime when this commit was committed. */\n    committedDate: Scalars[\"DateTime\"];\n    /** Check if committed via GitHub web UI. */\n    committedViaWeb: Scalars[\"Boolean\"];\n    /** Committer details of the commit. */\n    committer?: Maybe<GitActor>;\n    /** The number of deletions in this commit. */\n    deletions: Scalars[\"Int\"];\n    /** The deployments associated with a commit. */\n    deployments?: Maybe<DeploymentConnection>;\n    /** The tree entry representing the file located at the given path. */\n    file?: Maybe<TreeEntry>;\n    /** The linear commit history starting from (and including) this commit, in the same order as `git log`. */\n    history: CommitHistoryConnection;\n    id: Scalars[\"ID\"];\n    /** The Git commit message */\n    message: Scalars[\"String\"];\n    /** The Git commit message body */\n    messageBody: Scalars[\"String\"];\n    /** The commit message body rendered to HTML. */\n    messageBodyHTML: Scalars[\"HTML\"];\n    /** The Git commit message headline */\n    messageHeadline: Scalars[\"String\"];\n    /** The commit message headline rendered to HTML. */\n    messageHeadlineHTML: Scalars[\"HTML\"];\n    /** The Git object ID */\n    oid: Scalars[\"GitObjectID\"];\n    /** The organization this commit was made on behalf of. */\n    onBehalfOf?: Maybe<Organization>;\n    /** The parents of a commit. */\n    parents: CommitConnection;\n    /** The datetime when this commit was pushed. */\n    pushedDate?: Maybe<Scalars[\"DateTime\"]>;\n    /** The Repository this commit belongs to */\n    repository: Repository;\n    /** The HTTP path for this commit */\n    resourcePath: Scalars[\"URI\"];\n    /** Commit signing information, if present. */\n    signature?: Maybe<GitSignature>;\n    /** Status information for this commit */\n    status?: Maybe<Status>;\n    /** Check and Status rollup information for this commit. */\n    statusCheckRollup?: Maybe<StatusCheckRollup>;\n    /** Returns a list of all submodules in this repository as of this Commit parsed from the .gitmodules file. */\n    submodules: SubmoduleConnection;\n    /**\n     * Returns a URL to download a tarball archive for a repository.\n     * Note: For private repositories, these links are temporary and expire after five minutes.\n     */\n    tarballUrl: Scalars[\"URI\"];\n    /** Commit's root Tree */\n    tree: Tree;\n    /** The HTTP path for the tree of this commit */\n    treeResourcePath: Scalars[\"URI\"];\n    /** The HTTP URL for the tree of this commit */\n    treeUrl: Scalars[\"URI\"];\n    /** The HTTP URL for this commit */\n    url: Scalars[\"URI\"];\n    /** Check if the viewer is able to change their subscription status for the repository. */\n    viewerCanSubscribe: Scalars[\"Boolean\"];\n    /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */\n    viewerSubscription?: Maybe<SubscriptionState>;\n    /**\n     * Returns a URL to download a zipball archive for a repository.\n     * Note: For private repositories, these links are temporary and expire after five minutes.\n     */\n    zipballUrl: Scalars[\"URI\"];\n  };\n\n/** Represents a Git commit. */\nexport type CommitAssociatedPullRequestsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<PullRequestOrder>;\n};\n\n/** Represents a Git commit. */\nexport type CommitAuthorsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** Represents a Git commit. */\nexport type CommitBlameArgs = {\n  path: Scalars[\"String\"];\n};\n\n/** Represents a Git commit. */\nexport type CommitCheckSuitesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  filterBy?: InputMaybe<CheckSuiteFilter>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** Represents a Git commit. */\nexport type CommitCommentsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** Represents a Git commit. */\nexport type CommitDeploymentsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  environments?: InputMaybe<Array<Scalars[\"String\"]>>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<DeploymentOrder>;\n};\n\n/** Represents a Git commit. */\nexport type CommitFileArgs = {\n  path: Scalars[\"String\"];\n};\n\n/** Represents a Git commit. */\nexport type CommitHistoryArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  author?: InputMaybe<CommitAuthor>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  path?: InputMaybe<Scalars[\"String\"]>;\n  since?: InputMaybe<Scalars[\"GitTimestamp\"]>;\n  until?: InputMaybe<Scalars[\"GitTimestamp\"]>;\n};\n\n/** Represents a Git commit. */\nexport type CommitParentsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** Represents a Git commit. */\nexport type CommitSubmodulesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** Specifies an author for filtering Git commits. */\nexport type CommitAuthor = {\n  /** Email addresses to filter by. Commits authored by any of the specified email addresses will be returned. */\n  emails?: InputMaybe<Array<Scalars[\"String\"]>>;\n  /**\n   * ID of a User to filter by. If non-null, only commits authored by this user\n   * will be returned. This field takes precedence over emails.\n   */\n  id?: InputMaybe<Scalars[\"ID\"]>;\n};\n\n/** Represents a comment on a given Commit. */\nexport type CommitComment = Comment &\n  Deletable &\n  Minimizable &\n  Node &\n  Reactable &\n  RepositoryNode &\n  Updatable &\n  UpdatableComment & {\n    __typename?: \"CommitComment\";\n    /** The actor who authored the comment. */\n    author?: Maybe<Actor>;\n    /** Author's association with the subject of the comment. */\n    authorAssociation: CommentAuthorAssociation;\n    /** Identifies the comment body. */\n    body: Scalars[\"String\"];\n    /** The body rendered to HTML. */\n    bodyHTML: Scalars[\"HTML\"];\n    /** The body rendered to text. */\n    bodyText: Scalars[\"String\"];\n    /** Identifies the commit associated with the comment, if the commit exists. */\n    commit?: Maybe<Commit>;\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars[\"DateTime\"];\n    /** Check if this comment was created via an email reply. */\n    createdViaEmail: Scalars[\"Boolean\"];\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars[\"Int\"]>;\n    /** The actor who edited the comment. */\n    editor?: Maybe<Actor>;\n    id: Scalars[\"ID\"];\n    /** Check if this comment was edited and includes an edit with the creation data */\n    includesCreatedEdit: Scalars[\"Boolean\"];\n    /** Returns whether or not a comment has been minimized. */\n    isMinimized: Scalars[\"Boolean\"];\n    /** The moment the editor made the last edit */\n    lastEditedAt?: Maybe<Scalars[\"DateTime\"]>;\n    /** Returns why the comment was minimized. */\n    minimizedReason?: Maybe<Scalars[\"String\"]>;\n    /** Identifies the file path associated with the comment. */\n    path?: Maybe<Scalars[\"String\"]>;\n    /** Identifies the line position associated with the comment. */\n    position?: Maybe<Scalars[\"Int\"]>;\n    /** Identifies when the comment was published at. */\n    publishedAt?: Maybe<Scalars[\"DateTime\"]>;\n    /** A list of reactions grouped by content left on the subject. */\n    reactionGroups?: Maybe<Array<ReactionGroup>>;\n    /** A list of Reactions left on the Issue. */\n    reactions: ReactionConnection;\n    /** The repository associated with this node. */\n    repository: Repository;\n    /** The HTTP path permalink for this commit comment. */\n    resourcePath: Scalars[\"URI\"];\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars[\"DateTime\"];\n    /** The HTTP URL permalink for this commit comment. */\n    url: Scalars[\"URI\"];\n    /** A list of edits to this content. */\n    userContentEdits?: Maybe<UserContentEditConnection>;\n    /** Check if the current viewer can delete this object. */\n    viewerCanDelete: Scalars[\"Boolean\"];\n    /** Check if the current viewer can minimize this object. */\n    viewerCanMinimize: Scalars[\"Boolean\"];\n    /** Can user react to this subject */\n    viewerCanReact: Scalars[\"Boolean\"];\n    /** Check if the current viewer can update this object. */\n    viewerCanUpdate: Scalars[\"Boolean\"];\n    /** Reasons why the current viewer can not update this comment. */\n    viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;\n    /** Did the viewer author this comment. */\n    viewerDidAuthor: Scalars[\"Boolean\"];\n  };\n\n/** Represents a comment on a given Commit. */\nexport type CommitCommentReactionsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  content?: InputMaybe<ReactionContent>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<ReactionOrder>;\n};\n\n/** Represents a comment on a given Commit. */\nexport type CommitCommentUserContentEditsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** The connection type for CommitComment. */\nexport type CommitCommentConnection = {\n  __typename?: \"CommitCommentConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CommitCommentEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<CommitComment>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type CommitCommentEdge = {\n  __typename?: \"CommitCommentEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<CommitComment>;\n};\n\n/** A thread of comments on a commit. */\nexport type CommitCommentThread = Node &\n  RepositoryNode & {\n    __typename?: \"CommitCommentThread\";\n    /** The comments that exist in this thread. */\n    comments: CommitCommentConnection;\n    /** The commit the comments were made on. */\n    commit?: Maybe<Commit>;\n    id: Scalars[\"ID\"];\n    /** The file the comments were made on. */\n    path?: Maybe<Scalars[\"String\"]>;\n    /** The position in the diff for the commit that the comment was made on. */\n    position?: Maybe<Scalars[\"Int\"]>;\n    /** The repository associated with this node. */\n    repository: Repository;\n  };\n\n/** A thread of comments on a commit. */\nexport type CommitCommentThreadCommentsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** The connection type for Commit. */\nexport type CommitConnection = {\n  __typename?: \"CommitConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CommitEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Commit>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** Ordering options for commit contribution connections. */\nexport type CommitContributionOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field by which to order commit contributions. */\n  field: CommitContributionOrderField;\n};\n\n/** Properties by which commit contribution connections can be ordered. */\nexport enum CommitContributionOrderField {\n  /** Order commit contributions by how many commits they represent. */\n  CommitCount = \"COMMIT_COUNT\",\n  /** Order commit contributions by when they were made. */\n  OccurredAt = \"OCCURRED_AT\",\n}\n\n/** This aggregates commits made by a user within one repository. */\nexport type CommitContributionsByRepository = {\n  __typename?: \"CommitContributionsByRepository\";\n  /** The commit contributions, each representing a day. */\n  contributions: CreatedCommitContributionConnection;\n  /** The repository in which the commits were made. */\n  repository: Repository;\n  /** The HTTP path for the user's commits to the repository in this time range. */\n  resourcePath: Scalars[\"URI\"];\n  /** The HTTP URL for the user's commits to the repository in this time range. */\n  url: Scalars[\"URI\"];\n};\n\n/** This aggregates commits made by a user within one repository. */\nexport type CommitContributionsByRepositoryContributionsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<CommitContributionOrder>;\n};\n\n/** An edge in a connection. */\nexport type CommitEdge = {\n  __typename?: \"CommitEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<Commit>;\n};\n\n/** The connection type for Commit. */\nexport type CommitHistoryConnection = {\n  __typename?: \"CommitHistoryConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CommitEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Commit>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** A message to include with a new commit */\nexport type CommitMessage = {\n  /** The body of the message. */\n  body?: InputMaybe<Scalars[\"String\"]>;\n  /** The headline of the message. */\n  headline: Scalars[\"String\"];\n};\n\n/**\n * A git ref for a commit to be appended to.\n *\n * The ref must be a branch, i.e. its fully qualified name must start\n * with `refs/heads/` (although the input is not required to be fully\n * qualified).\n *\n * The Ref may be specified by its global node ID or by the\n * repository nameWithOwner and branch name.\n *\n * ### Examples\n *\n * Specify a branch using a global node ID:\n *\n *     { \"id\": \"MDM6UmVmMTpyZWZzL2hlYWRzL21haW4=\" }\n *\n * Specify a branch using nameWithOwner and branch name:\n *\n *     {\n *       \"nameWithOwner\": \"github/graphql-client\",\n *       \"branchName\": \"main\"\n *     }\n */\nexport type CommittableBranch = {\n  /** The unqualified name of the branch to append the commit to. */\n  branchName?: InputMaybe<Scalars[\"String\"]>;\n  /** The Node ID of the Ref to be updated. */\n  id?: InputMaybe<Scalars[\"ID\"]>;\n  /** The nameWithOwner of the repository to commit to. */\n  repositoryNameWithOwner?: InputMaybe<Scalars[\"String\"]>;\n};\n\n/** Represents a 'connected' event on a given issue or pull request. */\nexport type ConnectedEvent = Node & {\n  __typename?: \"ConnectedEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  id: Scalars[\"ID\"];\n  /** Reference originated in a different repository. */\n  isCrossRepository: Scalars[\"Boolean\"];\n  /** Issue or pull request that made the reference. */\n  source: ReferencedSubject;\n  /** Issue or pull request which was connected. */\n  subject: ReferencedSubject;\n};\n\n/** Represents a contribution a user made on GitHub, such as opening an issue. */\nexport type Contribution = {\n  /**\n   * Whether this contribution is associated with a record you do not have access to. For\n   * example, your own 'first issue' contribution may have been made on a repository you can no\n   * longer access.\n   */\n  isRestricted: Scalars[\"Boolean\"];\n  /** When this contribution was made. */\n  occurredAt: Scalars[\"DateTime\"];\n  /** The HTTP path for this contribution. */\n  resourcePath: Scalars[\"URI\"];\n  /** The HTTP URL for this contribution. */\n  url: Scalars[\"URI\"];\n  /** The user who made this contribution. */\n  user: User;\n};\n\n/** A calendar of contributions made on GitHub by a user. */\nexport type ContributionCalendar = {\n  __typename?: \"ContributionCalendar\";\n  /** A list of hex color codes used in this calendar. The darker the color, the more contributions it represents. */\n  colors: Array<Scalars[\"String\"]>;\n  /** Determine if the color set was chosen because it's currently Halloween. */\n  isHalloween: Scalars[\"Boolean\"];\n  /** A list of the months of contributions in this calendar. */\n  months: Array<ContributionCalendarMonth>;\n  /** The count of total contributions in the calendar. */\n  totalContributions: Scalars[\"Int\"];\n  /** A list of the weeks of contributions in this calendar. */\n  weeks: Array<ContributionCalendarWeek>;\n};\n\n/** Represents a single day of contributions on GitHub by a user. */\nexport type ContributionCalendarDay = {\n  __typename?: \"ContributionCalendarDay\";\n  /** The hex color code that represents how many contributions were made on this day compared to others in the calendar. */\n  color: Scalars[\"String\"];\n  /** How many contributions were made by the user on this day. */\n  contributionCount: Scalars[\"Int\"];\n  /**\n   * Indication of contributions, relative to other days. Can be used to indicate\n   * which color to represent this day on a calendar.\n   */\n  contributionLevel: ContributionLevel;\n  /** The day this square represents. */\n  date: Scalars[\"Date\"];\n  /** A number representing which day of the week this square represents, e.g., 1 is Monday. */\n  weekday: Scalars[\"Int\"];\n};\n\n/** A month of contributions in a user's contribution graph. */\nexport type ContributionCalendarMonth = {\n  __typename?: \"ContributionCalendarMonth\";\n  /** The date of the first day of this month. */\n  firstDay: Scalars[\"Date\"];\n  /** The name of the month. */\n  name: Scalars[\"String\"];\n  /** How many weeks started in this month. */\n  totalWeeks: Scalars[\"Int\"];\n  /** The year the month occurred in. */\n  year: Scalars[\"Int\"];\n};\n\n/** A week of contributions in a user's contribution graph. */\nexport type ContributionCalendarWeek = {\n  __typename?: \"ContributionCalendarWeek\";\n  /** The days of contributions in this week. */\n  contributionDays: Array<ContributionCalendarDay>;\n  /** The date of the earliest square in this week. */\n  firstDay: Scalars[\"Date\"];\n};\n\n/** Varying levels of contributions from none to many. */\nexport enum ContributionLevel {\n  /** Lowest 25% of days of contributions. */\n  FirstQuartile = \"FIRST_QUARTILE\",\n  /** Highest 25% of days of contributions. More contributions than the third quartile. */\n  FourthQuartile = \"FOURTH_QUARTILE\",\n  /** No contributions occurred. */\n  None = \"NONE\",\n  /** Second lowest 25% of days of contributions. More contributions than the first quartile. */\n  SecondQuartile = \"SECOND_QUARTILE\",\n  /** Second highest 25% of days of contributions. More contributions than second quartile, less than the fourth quartile. */\n  ThirdQuartile = \"THIRD_QUARTILE\",\n}\n\n/** Ordering options for contribution connections. */\nexport type ContributionOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n};\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollection = {\n  __typename?: \"ContributionsCollection\";\n  /** Commit contributions made by the user, grouped by repository. */\n  commitContributionsByRepository: Array<CommitContributionsByRepository>;\n  /** A calendar of this user's contributions on GitHub. */\n  contributionCalendar: ContributionCalendar;\n  /** The years the user has been making contributions with the most recent year first. */\n  contributionYears: Array<Scalars[\"Int\"]>;\n  /** Determine if this collection's time span ends in the current month. */\n  doesEndInCurrentMonth: Scalars[\"Boolean\"];\n  /**\n   * The date of the first restricted contribution the user made in this time\n   * period. Can only be non-null when the user has enabled private contribution counts.\n   */\n  earliestRestrictedContributionDate?: Maybe<Scalars[\"Date\"]>;\n  /** The ending date and time of this collection. */\n  endedAt: Scalars[\"DateTime\"];\n  /**\n   * The first issue the user opened on GitHub. This will be null if that issue was\n   * opened outside the collection's time range and ignoreTimeRange is false. If\n   * the issue is not visible but the user has opted to show private contributions,\n   * a RestrictedContribution will be returned.\n   */\n  firstIssueContribution?: Maybe<CreatedIssueOrRestrictedContribution>;\n  /**\n   * The first pull request the user opened on GitHub. This will be null if that\n   * pull request was opened outside the collection's time range and\n   * ignoreTimeRange is not true. If the pull request is not visible but the user\n   * has opted to show private contributions, a RestrictedContribution will be returned.\n   */\n  firstPullRequestContribution?: Maybe<CreatedPullRequestOrRestrictedContribution>;\n  /**\n   * The first repository the user created on GitHub. This will be null if that\n   * first repository was created outside the collection's time range and\n   * ignoreTimeRange is false. If the repository is not visible, then a\n   * RestrictedContribution is returned.\n   */\n  firstRepositoryContribution?: Maybe<CreatedRepositoryOrRestrictedContribution>;\n  /** Does the user have any more activity in the timeline that occurred prior to the collection's time range? */\n  hasActivityInThePast: Scalars[\"Boolean\"];\n  /** Determine if there are any contributions in this collection. */\n  hasAnyContributions: Scalars[\"Boolean\"];\n  /**\n   * Determine if the user made any contributions in this time frame whose details\n   * are not visible because they were made in a private repository. Can only be\n   * true if the user enabled private contribution counts.\n   */\n  hasAnyRestrictedContributions: Scalars[\"Boolean\"];\n  /** Whether or not the collector's time span is all within the same day. */\n  isSingleDay: Scalars[\"Boolean\"];\n  /** A list of issues the user opened. */\n  issueContributions: CreatedIssueContributionConnection;\n  /** Issue contributions made by the user, grouped by repository. */\n  issueContributionsByRepository: Array<IssueContributionsByRepository>;\n  /**\n   * When the user signed up for GitHub. This will be null if that sign up date\n   * falls outside the collection's time range and ignoreTimeRange is false.\n   */\n  joinedGitHubContribution?: Maybe<JoinedGitHubContribution>;\n  /**\n   * The date of the most recent restricted contribution the user made in this time\n   * period. Can only be non-null when the user has enabled private contribution counts.\n   */\n  latestRestrictedContributionDate?: Maybe<Scalars[\"Date\"]>;\n  /**\n   * When this collection's time range does not include any activity from the user, use this\n   * to get a different collection from an earlier time range that does have activity.\n   */\n  mostRecentCollectionWithActivity?: Maybe<ContributionsCollection>;\n  /**\n   * Returns a different contributions collection from an earlier time range than this one\n   * that does not have any contributions.\n   */\n  mostRecentCollectionWithoutActivity?: Maybe<ContributionsCollection>;\n  /**\n   * The issue the user opened on GitHub that received the most comments in the specified\n   * time frame.\n   */\n  popularIssueContribution?: Maybe<CreatedIssueContribution>;\n  /**\n   * The pull request the user opened on GitHub that received the most comments in the\n   * specified time frame.\n   */\n  popularPullRequestContribution?: Maybe<CreatedPullRequestContribution>;\n  /** Pull request contributions made by the user. */\n  pullRequestContributions: CreatedPullRequestContributionConnection;\n  /** Pull request contributions made by the user, grouped by repository. */\n  pullRequestContributionsByRepository: Array<PullRequestContributionsByRepository>;\n  /** Pull request review contributions made by the user. */\n  pullRequestReviewContributions: CreatedPullRequestReviewContributionConnection;\n  /** Pull request review contributions made by the user, grouped by repository. */\n  pullRequestReviewContributionsByRepository: Array<PullRequestReviewContributionsByRepository>;\n  /** A list of repositories owned by the user that the user created in this time range. */\n  repositoryContributions: CreatedRepositoryContributionConnection;\n  /**\n   * A count of contributions made by the user that the viewer cannot access. Only\n   * non-zero when the user has chosen to share their private contribution counts.\n   */\n  restrictedContributionsCount: Scalars[\"Int\"];\n  /** The beginning date and time of this collection. */\n  startedAt: Scalars[\"DateTime\"];\n  /** How many commits were made by the user in this time span. */\n  totalCommitContributions: Scalars[\"Int\"];\n  /** How many issues the user opened. */\n  totalIssueContributions: Scalars[\"Int\"];\n  /** How many pull requests the user opened. */\n  totalPullRequestContributions: Scalars[\"Int\"];\n  /** How many pull request reviews the user left. */\n  totalPullRequestReviewContributions: Scalars[\"Int\"];\n  /** How many different repositories the user committed to. */\n  totalRepositoriesWithContributedCommits: Scalars[\"Int\"];\n  /** How many different repositories the user opened issues in. */\n  totalRepositoriesWithContributedIssues: Scalars[\"Int\"];\n  /** How many different repositories the user left pull request reviews in. */\n  totalRepositoriesWithContributedPullRequestReviews: Scalars[\"Int\"];\n  /** How many different repositories the user opened pull requests in. */\n  totalRepositoriesWithContributedPullRequests: Scalars[\"Int\"];\n  /** How many repositories the user created. */\n  totalRepositoryContributions: Scalars[\"Int\"];\n  /** The user who made the contributions in this collection. */\n  user: User;\n};\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionCommitContributionsByRepositoryArgs = {\n  maxRepositories?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionIssueContributionsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  excludeFirst?: InputMaybe<Scalars[\"Boolean\"]>;\n  excludePopular?: InputMaybe<Scalars[\"Boolean\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<ContributionOrder>;\n};\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionIssueContributionsByRepositoryArgs = {\n  excludeFirst?: InputMaybe<Scalars[\"Boolean\"]>;\n  excludePopular?: InputMaybe<Scalars[\"Boolean\"]>;\n  maxRepositories?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionPullRequestContributionsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  excludeFirst?: InputMaybe<Scalars[\"Boolean\"]>;\n  excludePopular?: InputMaybe<Scalars[\"Boolean\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<ContributionOrder>;\n};\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionPullRequestContributionsByRepositoryArgs = {\n  excludeFirst?: InputMaybe<Scalars[\"Boolean\"]>;\n  excludePopular?: InputMaybe<Scalars[\"Boolean\"]>;\n  maxRepositories?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionPullRequestReviewContributionsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<ContributionOrder>;\n};\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionPullRequestReviewContributionsByRepositoryArgs = {\n  maxRepositories?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionRepositoryContributionsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  excludeFirst?: InputMaybe<Scalars[\"Boolean\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<ContributionOrder>;\n};\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionTotalIssueContributionsArgs = {\n  excludeFirst?: InputMaybe<Scalars[\"Boolean\"]>;\n  excludePopular?: InputMaybe<Scalars[\"Boolean\"]>;\n};\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionTotalPullRequestContributionsArgs = {\n  excludeFirst?: InputMaybe<Scalars[\"Boolean\"]>;\n  excludePopular?: InputMaybe<Scalars[\"Boolean\"]>;\n};\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionTotalRepositoriesWithContributedIssuesArgs = {\n  excludeFirst?: InputMaybe<Scalars[\"Boolean\"]>;\n  excludePopular?: InputMaybe<Scalars[\"Boolean\"]>;\n};\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionTotalRepositoriesWithContributedPullRequestsArgs = {\n  excludeFirst?: InputMaybe<Scalars[\"Boolean\"]>;\n  excludePopular?: InputMaybe<Scalars[\"Boolean\"]>;\n};\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionTotalRepositoryContributionsArgs = {\n  excludeFirst?: InputMaybe<Scalars[\"Boolean\"]>;\n};\n\n/** Autogenerated input type of ConvertProjectCardNoteToIssue */\nexport type ConvertProjectCardNoteToIssueInput = {\n  /** The body of the newly created issue. */\n  body?: InputMaybe<Scalars[\"String\"]>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ProjectCard ID to convert. */\n  projectCardId: Scalars[\"ID\"];\n  /** The ID of the repository to create the issue in. */\n  repositoryId: Scalars[\"ID\"];\n  /** The title of the newly created issue. Defaults to the card's note text. */\n  title?: InputMaybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated return type of ConvertProjectCardNoteToIssue */\nexport type ConvertProjectCardNoteToIssuePayload = {\n  __typename?: \"ConvertProjectCardNoteToIssuePayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The updated ProjectCard. */\n  projectCard?: Maybe<ProjectCard>;\n};\n\n/** Autogenerated input type of ConvertPullRequestToDraft */\nexport type ConvertPullRequestToDraftInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** ID of the pull request to convert to draft */\n  pullRequestId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of ConvertPullRequestToDraft */\nexport type ConvertPullRequestToDraftPayload = {\n  __typename?: \"ConvertPullRequestToDraftPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The pull request that is now a draft. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Represents a 'convert_to_draft' event on a given pull request. */\nexport type ConvertToDraftEvent = Node &\n  UniformResourceLocatable & {\n    __typename?: \"ConvertToDraftEvent\";\n    /** Identifies the actor who performed the event. */\n    actor?: Maybe<Actor>;\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars[\"DateTime\"];\n    id: Scalars[\"ID\"];\n    /** PullRequest referenced by event. */\n    pullRequest: PullRequest;\n    /** The HTTP path for this convert to draft event. */\n    resourcePath: Scalars[\"URI\"];\n    /** The HTTP URL for this convert to draft event. */\n    url: Scalars[\"URI\"];\n  };\n\n/** Represents a 'converted_note_to_issue' event on a given issue or pull request. */\nexport type ConvertedNoteToIssueEvent = Node & {\n  __typename?: \"ConvertedNoteToIssueEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars[\"Int\"]>;\n  id: Scalars[\"ID\"];\n  /** Project referenced by event. */\n  project?: Maybe<Project>;\n  /** Project card referenced by this project event. */\n  projectCard?: Maybe<ProjectCard>;\n  /** Column name referenced by this project event. */\n  projectColumnName: Scalars[\"String\"];\n};\n\n/** Represents a 'converted_to_discussion' event on a given issue. */\nexport type ConvertedToDiscussionEvent = Node & {\n  __typename?: \"ConvertedToDiscussionEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** The discussion that the issue was converted into. */\n  discussion?: Maybe<Discussion>;\n  id: Scalars[\"ID\"];\n};\n\n/** Autogenerated input type of CreateBranchProtectionRule */\nexport type CreateBranchProtectionRuleInput = {\n  /** Can this branch be deleted. */\n  allowsDeletions?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** Are force pushes allowed on this branch. */\n  allowsForcePushes?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** Is branch creation a protected operation. */\n  blocksCreations?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** A list of User or Team IDs allowed to bypass force push targeting matching branches. */\n  bypassForcePushActorIds?: InputMaybe<Array<Scalars[\"ID\"]>>;\n  /** A list of User or Team IDs allowed to bypass pull requests targeting matching branches. */\n  bypassPullRequestActorIds?: InputMaybe<Array<Scalars[\"ID\"]>>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** Will new commits pushed to matching branches dismiss pull request review approvals. */\n  dismissesStaleReviews?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** Can admins overwrite branch protection. */\n  isAdminEnforced?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** The glob-like pattern used to determine matching branches. */\n  pattern: Scalars[\"String\"];\n  /** A list of User, Team or App IDs allowed to push to matching branches. */\n  pushActorIds?: InputMaybe<Array<Scalars[\"ID\"]>>;\n  /** The global relay id of the repository in which a new branch protection rule should be created in. */\n  repositoryId: Scalars[\"ID\"];\n  /** Number of approving reviews required to update matching branches. */\n  requiredApprovingReviewCount?: InputMaybe<Scalars[\"Int\"]>;\n  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */\n  requiredStatusCheckContexts?: InputMaybe<Array<Scalars[\"String\"]>>;\n  /** The list of required status checks */\n  requiredStatusChecks?: InputMaybe<Array<RequiredStatusCheckInput>>;\n  /** Are approving reviews required to update matching branches. */\n  requiresApprovingReviews?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** Are reviews from code owners required to update matching branches. */\n  requiresCodeOwnerReviews?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** Are commits required to be signed. */\n  requiresCommitSignatures?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** Are conversations required to be resolved before merging. */\n  requiresConversationResolution?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** Are merge commits prohibited from being pushed to this branch. */\n  requiresLinearHistory?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** Are status checks required to update matching branches. */\n  requiresStatusChecks?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** Are branches required to be up to date before merging. */\n  requiresStrictStatusChecks?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** Is pushing to matching branches restricted. */\n  restrictsPushes?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** Is dismissal of pull request reviews restricted. */\n  restrictsReviewDismissals?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** A list of User or Team IDs allowed to dismiss reviews on pull requests targeting matching branches. */\n  reviewDismissalActorIds?: InputMaybe<Array<Scalars[\"ID\"]>>;\n};\n\n/** Autogenerated return type of CreateBranchProtectionRule */\nexport type CreateBranchProtectionRulePayload = {\n  __typename?: \"CreateBranchProtectionRulePayload\";\n  /** The newly created BranchProtectionRule. */\n  branchProtectionRule?: Maybe<BranchProtectionRule>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated input type of CreateCheckRun */\nexport type CreateCheckRunInput = {\n  /** Possible further actions the integrator can perform, which a user may trigger. */\n  actions?: InputMaybe<Array<CheckRunAction>>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The time that the check run finished. */\n  completedAt?: InputMaybe<Scalars[\"DateTime\"]>;\n  /** The final conclusion of the check. */\n  conclusion?: InputMaybe<CheckConclusionState>;\n  /** The URL of the integrator's site that has the full details of the check. */\n  detailsUrl?: InputMaybe<Scalars[\"URI\"]>;\n  /** A reference for the run on the integrator's system. */\n  externalId?: InputMaybe<Scalars[\"String\"]>;\n  /** The SHA of the head commit. */\n  headSha: Scalars[\"GitObjectID\"];\n  /** The name of the check. */\n  name: Scalars[\"String\"];\n  /** Descriptive details about the run. */\n  output?: InputMaybe<CheckRunOutput>;\n  /** The node ID of the repository. */\n  repositoryId: Scalars[\"ID\"];\n  /** The time that the check run began. */\n  startedAt?: InputMaybe<Scalars[\"DateTime\"]>;\n  /** The current status. */\n  status?: InputMaybe<RequestableCheckStatusState>;\n};\n\n/** Autogenerated return type of CreateCheckRun */\nexport type CreateCheckRunPayload = {\n  __typename?: \"CreateCheckRunPayload\";\n  /** The newly created check run. */\n  checkRun?: Maybe<CheckRun>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated input type of CreateCheckSuite */\nexport type CreateCheckSuiteInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The SHA of the head commit. */\n  headSha: Scalars[\"GitObjectID\"];\n  /** The Node ID of the repository. */\n  repositoryId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of CreateCheckSuite */\nexport type CreateCheckSuitePayload = {\n  __typename?: \"CreateCheckSuitePayload\";\n  /** The newly created check suite. */\n  checkSuite?: Maybe<CheckSuite>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated input type of CreateCommitOnBranch */\nexport type CreateCommitOnBranchInput = {\n  /** The Ref to be updated.  Must be a branch. */\n  branch: CommittableBranch;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The git commit oid expected at the head of the branch prior to the commit */\n  expectedHeadOid: Scalars[\"GitObjectID\"];\n  /** A description of changes to files in this commit. */\n  fileChanges?: InputMaybe<FileChanges>;\n  /** The commit message the be included with the commit. */\n  message: CommitMessage;\n};\n\n/** Autogenerated return type of CreateCommitOnBranch */\nexport type CreateCommitOnBranchPayload = {\n  __typename?: \"CreateCommitOnBranchPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The new commit. */\n  commit?: Maybe<Commit>;\n  /** The ref which has been updated to point to the new commit. */\n  ref?: Maybe<Ref>;\n};\n\n/** Autogenerated input type of CreateDeployment */\nexport type CreateDeploymentInput = {\n  /** Attempt to automatically merge the default branch into the requested ref, defaults to true. */\n  autoMerge?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** Short description of the deployment. */\n  description?: InputMaybe<Scalars[\"String\"]>;\n  /** Name for the target deployment environment. */\n  environment?: InputMaybe<Scalars[\"String\"]>;\n  /** JSON payload with extra information about the deployment. */\n  payload?: InputMaybe<Scalars[\"String\"]>;\n  /** The node ID of the ref to be deployed. */\n  refId: Scalars[\"ID\"];\n  /** The node ID of the repository. */\n  repositoryId: Scalars[\"ID\"];\n  /**\n   * The status contexts to verify against commit status checks. To bypass required\n   * contexts, pass an empty array. Defaults to all unique contexts.\n   */\n  requiredContexts?: InputMaybe<Array<Scalars[\"String\"]>>;\n  /** Specifies a task to execute. */\n  task?: InputMaybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated return type of CreateDeployment */\nexport type CreateDeploymentPayload = {\n  __typename?: \"CreateDeploymentPayload\";\n  /** True if the default branch has been auto-merged into the deployment ref. */\n  autoMerged?: Maybe<Scalars[\"Boolean\"]>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The new deployment. */\n  deployment?: Maybe<Deployment>;\n};\n\n/** Autogenerated input type of CreateDeploymentStatus */\nexport type CreateDeploymentStatusInput = {\n  /**\n   * Adds a new inactive status to all non-transient, non-production environment\n   * deployments with the same repository and environment name as the created\n   * status's deployment.\n   */\n  autoInactive?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The node ID of the deployment. */\n  deploymentId: Scalars[\"ID\"];\n  /** A short description of the status. Maximum length of 140 characters. */\n  description?: InputMaybe<Scalars[\"String\"]>;\n  /** If provided, updates the environment of the deploy. Otherwise, does not modify the environment. */\n  environment?: InputMaybe<Scalars[\"String\"]>;\n  /** Sets the URL for accessing your environment. */\n  environmentUrl?: InputMaybe<Scalars[\"String\"]>;\n  /**\n   * The log URL to associate with this status.       This URL should contain\n   * output to keep the user updated while the task is running       or serve as\n   * historical information for what happened in the deployment.\n   */\n  logUrl?: InputMaybe<Scalars[\"String\"]>;\n  /** The state of the deployment. */\n  state: DeploymentStatusState;\n};\n\n/** Autogenerated return type of CreateDeploymentStatus */\nexport type CreateDeploymentStatusPayload = {\n  __typename?: \"CreateDeploymentStatusPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The new deployment status. */\n  deploymentStatus?: Maybe<DeploymentStatus>;\n};\n\n/** Autogenerated input type of CreateDiscussion */\nexport type CreateDiscussionInput = {\n  /** The body of the discussion. */\n  body: Scalars[\"String\"];\n  /** The id of the discussion category to associate with this discussion. */\n  categoryId: Scalars[\"ID\"];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The id of the repository on which to create the discussion. */\n  repositoryId: Scalars[\"ID\"];\n  /** The title of the discussion. */\n  title: Scalars[\"String\"];\n};\n\n/** Autogenerated return type of CreateDiscussion */\nexport type CreateDiscussionPayload = {\n  __typename?: \"CreateDiscussionPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The discussion that was just created. */\n  discussion?: Maybe<Discussion>;\n};\n\n/** Autogenerated input type of CreateEnterpriseOrganization */\nexport type CreateEnterpriseOrganizationInput = {\n  /** The logins for the administrators of the new organization. */\n  adminLogins: Array<Scalars[\"String\"]>;\n  /** The email used for sending billing receipts. */\n  billingEmail: Scalars[\"String\"];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the enterprise owning the new organization. */\n  enterpriseId: Scalars[\"ID\"];\n  /** The login of the new organization. */\n  login: Scalars[\"String\"];\n  /** The profile name of the new organization. */\n  profileName: Scalars[\"String\"];\n};\n\n/** Autogenerated return type of CreateEnterpriseOrganization */\nexport type CreateEnterpriseOrganizationPayload = {\n  __typename?: \"CreateEnterpriseOrganizationPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The enterprise that owns the created organization. */\n  enterprise?: Maybe<Enterprise>;\n  /** The organization that was created. */\n  organization?: Maybe<Organization>;\n};\n\n/** Autogenerated input type of CreateEnvironment */\nexport type CreateEnvironmentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The name of the environment. */\n  name: Scalars[\"String\"];\n  /** The node ID of the repository. */\n  repositoryId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of CreateEnvironment */\nexport type CreateEnvironmentPayload = {\n  __typename?: \"CreateEnvironmentPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The new or existing environment. */\n  environment?: Maybe<Environment>;\n};\n\n/** Autogenerated input type of CreateIpAllowListEntry */\nexport type CreateIpAllowListEntryInput = {\n  /** An IP address or range of addresses in CIDR notation. */\n  allowListValue: Scalars[\"String\"];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** Whether the IP allow list entry is active when an IP allow list is enabled. */\n  isActive: Scalars[\"Boolean\"];\n  /** An optional name for the IP allow list entry. */\n  name?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the owner for which to create the new IP allow list entry. */\n  ownerId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of CreateIpAllowListEntry */\nexport type CreateIpAllowListEntryPayload = {\n  __typename?: \"CreateIpAllowListEntryPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The IP allow list entry that was created. */\n  ipAllowListEntry?: Maybe<IpAllowListEntry>;\n};\n\n/** Autogenerated input type of CreateIssue */\nexport type CreateIssueInput = {\n  /** The Node ID for the user assignee for this issue. */\n  assigneeIds?: InputMaybe<Array<Scalars[\"ID\"]>>;\n  /** The body for the issue description. */\n  body?: InputMaybe<Scalars[\"String\"]>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The name of an issue template in the repository, assigns labels and assignees from the template to the issue */\n  issueTemplate?: InputMaybe<Scalars[\"String\"]>;\n  /** An array of Node IDs of labels for this issue. */\n  labelIds?: InputMaybe<Array<Scalars[\"ID\"]>>;\n  /** The Node ID of the milestone for this issue. */\n  milestoneId?: InputMaybe<Scalars[\"ID\"]>;\n  /** An array of Node IDs for projects associated with this issue. */\n  projectIds?: InputMaybe<Array<Scalars[\"ID\"]>>;\n  /** The Node ID of the repository. */\n  repositoryId: Scalars[\"ID\"];\n  /** The title for the issue. */\n  title: Scalars[\"String\"];\n};\n\n/** Autogenerated return type of CreateIssue */\nexport type CreateIssuePayload = {\n  __typename?: \"CreateIssuePayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The new issue. */\n  issue?: Maybe<Issue>;\n};\n\n/** Autogenerated input type of CreateLabel */\nexport type CreateLabelInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** A 6 character hex code, without the leading #, identifying the color of the label. */\n  color: Scalars[\"String\"];\n  /** A brief description of the label, such as its purpose. */\n  description?: InputMaybe<Scalars[\"String\"]>;\n  /** The name of the label. */\n  name: Scalars[\"String\"];\n  /** The Node ID of the repository. */\n  repositoryId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of CreateLabel */\nexport type CreateLabelPayload = {\n  __typename?: \"CreateLabelPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The new label. */\n  label?: Maybe<Label>;\n};\n\n/** Autogenerated input type of CreateMigrationSource */\nexport type CreateMigrationSourceInput = {\n  /** The Octoshift migration source access token. */\n  accessToken?: InputMaybe<Scalars[\"String\"]>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The GitHub personal access token of the user importing to the target repository. */\n  githubPat?: InputMaybe<Scalars[\"String\"]>;\n  /** The Octoshift migration source name. */\n  name: Scalars[\"String\"];\n  /** The ID of the organization that will own the Octoshift migration source. */\n  ownerId: Scalars[\"ID\"];\n  /** The Octoshift migration source type. */\n  type: MigrationSourceType;\n  /** The Octoshift migration source URL. */\n  url: Scalars[\"String\"];\n};\n\n/** Autogenerated return type of CreateMigrationSource */\nexport type CreateMigrationSourcePayload = {\n  __typename?: \"CreateMigrationSourcePayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The created Octoshift migration source. */\n  migrationSource?: Maybe<MigrationSource>;\n};\n\n/** Autogenerated input type of CreateProject */\nexport type CreateProjectInput = {\n  /** The description of project. */\n  body?: InputMaybe<Scalars[\"String\"]>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The name of project. */\n  name: Scalars[\"String\"];\n  /** The owner ID to create the project under. */\n  ownerId: Scalars[\"ID\"];\n  /** A list of repository IDs to create as linked repositories for the project */\n  repositoryIds?: InputMaybe<Array<Scalars[\"ID\"]>>;\n  /** The name of the GitHub-provided template. */\n  template?: InputMaybe<ProjectTemplate>;\n};\n\n/** Autogenerated return type of CreateProject */\nexport type CreateProjectPayload = {\n  __typename?: \"CreateProjectPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The new project. */\n  project?: Maybe<Project>;\n};\n\n/** Autogenerated input type of CreatePullRequest */\nexport type CreatePullRequestInput = {\n  /**\n   * The name of the branch you want your changes pulled into. This should be an existing branch\n   * on the current repository. You cannot update the base branch on a pull request to point\n   * to another repository.\n   */\n  baseRefName: Scalars[\"String\"];\n  /** The contents of the pull request. */\n  body?: InputMaybe<Scalars[\"String\"]>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** Indicates whether this pull request should be a draft. */\n  draft?: InputMaybe<Scalars[\"Boolean\"]>;\n  /**\n   * The name of the branch where your changes are implemented. For cross-repository pull requests\n   * in the same network, namespace `head_ref_name` with a user like this: `username:branch`.\n   */\n  headRefName: Scalars[\"String\"];\n  /** Indicates whether maintainers can modify the pull request. */\n  maintainerCanModify?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** The Node ID of the repository. */\n  repositoryId: Scalars[\"ID\"];\n  /** The title of the pull request. */\n  title: Scalars[\"String\"];\n};\n\n/** Autogenerated return type of CreatePullRequest */\nexport type CreatePullRequestPayload = {\n  __typename?: \"CreatePullRequestPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The new pull request. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Autogenerated input type of CreateRef */\nexport type CreateRefInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The fully qualified name of the new Ref (ie: `refs/heads/my_new_branch`). */\n  name: Scalars[\"String\"];\n  /** The GitObjectID that the new Ref shall target. Must point to a commit. */\n  oid: Scalars[\"GitObjectID\"];\n  /** The Node ID of the Repository to create the Ref in. */\n  repositoryId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of CreateRef */\nexport type CreateRefPayload = {\n  __typename?: \"CreateRefPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The newly created ref. */\n  ref?: Maybe<Ref>;\n};\n\n/** Autogenerated input type of CreateRepository */\nexport type CreateRepositoryInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** A short description of the new repository. */\n  description?: InputMaybe<Scalars[\"String\"]>;\n  /** Indicates if the repository should have the issues feature enabled. */\n  hasIssuesEnabled?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** Indicates if the repository should have the wiki feature enabled. */\n  hasWikiEnabled?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** The URL for a web page about this repository. */\n  homepageUrl?: InputMaybe<Scalars[\"URI\"]>;\n  /** The name of the new repository. */\n  name: Scalars[\"String\"];\n  /** The ID of the owner for the new repository. */\n  ownerId?: InputMaybe<Scalars[\"ID\"]>;\n  /**\n   * When an organization is specified as the owner, this ID identifies the team\n   * that should be granted access to the new repository.\n   */\n  teamId?: InputMaybe<Scalars[\"ID\"]>;\n  /**\n   * Whether this repository should be marked as a template such that anyone who\n   * can access it can create new repositories with the same files and directory structure.\n   */\n  template?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** Indicates the repository's visibility level. */\n  visibility: RepositoryVisibility;\n};\n\n/** Autogenerated return type of CreateRepository */\nexport type CreateRepositoryPayload = {\n  __typename?: \"CreateRepositoryPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The new repository. */\n  repository?: Maybe<Repository>;\n};\n\n/** Autogenerated input type of CreateSponsorsTier */\nexport type CreateSponsorsTierInput = {\n  /** The value of the new tier in US dollars. Valid values: 1-12000. */\n  amount: Scalars[\"Int\"];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** A description of what this tier is, what perks sponsors might receive, what a sponsorship at this tier means for you, etc. */\n  description: Scalars[\"String\"];\n  /** Whether sponsorships using this tier should happen monthly/yearly or just once. */\n  isRecurring?: InputMaybe<Scalars[\"Boolean\"]>;\n  /**\n   * Whether to make the tier available immediately for sponsors to choose.\n   * Defaults to creating a draft tier that will not be publicly visible.\n   */\n  publish?: InputMaybe<Scalars[\"Boolean\"]>;\n  /**\n   * Optional ID of the private repository that sponsors at this tier should gain\n   * read-only access to. Must be owned by an organization.\n   */\n  repositoryId?: InputMaybe<Scalars[\"ID\"]>;\n  /**\n   * Optional name of the private repository that sponsors at this tier should gain\n   * read-only access to. Must be owned by an organization. Necessary if\n   * repositoryOwnerLogin is given. Will be ignored if repositoryId is given.\n   */\n  repositoryName?: InputMaybe<Scalars[\"String\"]>;\n  /**\n   * Optional login of the organization owner of the private repository that\n   * sponsors at this tier should gain read-only access to. Necessary if\n   * repositoryName is given. Will be ignored if repositoryId is given.\n   */\n  repositoryOwnerLogin?: InputMaybe<Scalars[\"String\"]>;\n  /**\n   * The ID of the user or organization who owns the GitHub Sponsors profile.\n   * Defaults to the current user if omitted and sponsorableLogin is not given.\n   */\n  sponsorableId?: InputMaybe<Scalars[\"ID\"]>;\n  /**\n   * The username of the user or organization who owns the GitHub Sponsors profile.\n   * Defaults to the current user if omitted and sponsorableId is not given.\n   */\n  sponsorableLogin?: InputMaybe<Scalars[\"String\"]>;\n  /** Optional message new sponsors at this tier will receive. */\n  welcomeMessage?: InputMaybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated return type of CreateSponsorsTier */\nexport type CreateSponsorsTierPayload = {\n  __typename?: \"CreateSponsorsTierPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The new tier. */\n  sponsorsTier?: Maybe<SponsorsTier>;\n};\n\n/** Autogenerated input type of CreateSponsorship */\nexport type CreateSponsorshipInput = {\n  /** The amount to pay to the sponsorable in US dollars. Required if a tierId is not specified. Valid values: 1-12000. */\n  amount?: InputMaybe<Scalars[\"Int\"]>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** Whether the sponsorship should happen monthly/yearly or just this one time. Required if a tierId is not specified. */\n  isRecurring?: InputMaybe<Scalars[\"Boolean\"]>;\n  /**\n   * Specify whether others should be able to see that the sponsor is sponsoring\n   * the sponsorable. Public visibility still does not reveal which tier is used.\n   */\n  privacyLevel?: InputMaybe<SponsorshipPrivacy>;\n  /** Whether the sponsor should receive email updates from the sponsorable. */\n  receiveEmails?: InputMaybe<Scalars[\"Boolean\"]>;\n  /**\n   * The ID of the user or organization who is acting as the sponsor, paying for\n   * the sponsorship. Required if sponsorLogin is not given.\n   */\n  sponsorId?: InputMaybe<Scalars[\"ID\"]>;\n  /**\n   * The username of the user or organization who is acting as the sponsor, paying\n   * for the sponsorship. Required if sponsorId is not given.\n   */\n  sponsorLogin?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given. */\n  sponsorableId?: InputMaybe<Scalars[\"ID\"]>;\n  /** The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given. */\n  sponsorableLogin?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of one of sponsorable's existing tiers to sponsor at. Required if amount is not specified. */\n  tierId?: InputMaybe<Scalars[\"ID\"]>;\n};\n\n/** Autogenerated return type of CreateSponsorship */\nexport type CreateSponsorshipPayload = {\n  __typename?: \"CreateSponsorshipPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The sponsorship that was started. */\n  sponsorship?: Maybe<Sponsorship>;\n};\n\n/** Autogenerated input type of CreateTeamDiscussionComment */\nexport type CreateTeamDiscussionCommentInput = {\n  /** The content of the comment. */\n  body: Scalars[\"String\"];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the discussion to which the comment belongs. */\n  discussionId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of CreateTeamDiscussionComment */\nexport type CreateTeamDiscussionCommentPayload = {\n  __typename?: \"CreateTeamDiscussionCommentPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The new comment. */\n  teamDiscussionComment?: Maybe<TeamDiscussionComment>;\n};\n\n/** Autogenerated input type of CreateTeamDiscussion */\nexport type CreateTeamDiscussionInput = {\n  /** The content of the discussion. */\n  body: Scalars[\"String\"];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /**\n   * If true, restricts the visibility of this discussion to team members and\n   * organization admins. If false or not specified, allows any organization member\n   * to view this discussion.\n   */\n  private?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** The ID of the team to which the discussion belongs. */\n  teamId: Scalars[\"ID\"];\n  /** The title of the discussion. */\n  title: Scalars[\"String\"];\n};\n\n/** Autogenerated return type of CreateTeamDiscussion */\nexport type CreateTeamDiscussionPayload = {\n  __typename?: \"CreateTeamDiscussionPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The new discussion. */\n  teamDiscussion?: Maybe<TeamDiscussion>;\n};\n\n/** Represents the contribution a user made by committing to a repository. */\nexport type CreatedCommitContribution = Contribution & {\n  __typename?: \"CreatedCommitContribution\";\n  /** How many commits were made on this day to this repository by the user. */\n  commitCount: Scalars[\"Int\"];\n  /**\n   * Whether this contribution is associated with a record you do not have access to. For\n   * example, your own 'first issue' contribution may have been made on a repository you can no\n   * longer access.\n   */\n  isRestricted: Scalars[\"Boolean\"];\n  /** When this contribution was made. */\n  occurredAt: Scalars[\"DateTime\"];\n  /** The repository the user made a commit in. */\n  repository: Repository;\n  /** The HTTP path for this contribution. */\n  resourcePath: Scalars[\"URI\"];\n  /** The HTTP URL for this contribution. */\n  url: Scalars[\"URI\"];\n  /** The user who made this contribution. */\n  user: User;\n};\n\n/** The connection type for CreatedCommitContribution. */\nexport type CreatedCommitContributionConnection = {\n  __typename?: \"CreatedCommitContributionConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CreatedCommitContributionEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<CreatedCommitContribution>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of commits across days and repositories in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type CreatedCommitContributionEdge = {\n  __typename?: \"CreatedCommitContributionEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<CreatedCommitContribution>;\n};\n\n/** Represents the contribution a user made on GitHub by opening an issue. */\nexport type CreatedIssueContribution = Contribution & {\n  __typename?: \"CreatedIssueContribution\";\n  /**\n   * Whether this contribution is associated with a record you do not have access to. For\n   * example, your own 'first issue' contribution may have been made on a repository you can no\n   * longer access.\n   */\n  isRestricted: Scalars[\"Boolean\"];\n  /** The issue that was opened. */\n  issue: Issue;\n  /** When this contribution was made. */\n  occurredAt: Scalars[\"DateTime\"];\n  /** The HTTP path for this contribution. */\n  resourcePath: Scalars[\"URI\"];\n  /** The HTTP URL for this contribution. */\n  url: Scalars[\"URI\"];\n  /** The user who made this contribution. */\n  user: User;\n};\n\n/** The connection type for CreatedIssueContribution. */\nexport type CreatedIssueContributionConnection = {\n  __typename?: \"CreatedIssueContributionConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CreatedIssueContributionEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<CreatedIssueContribution>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type CreatedIssueContributionEdge = {\n  __typename?: \"CreatedIssueContributionEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<CreatedIssueContribution>;\n};\n\n/** Represents either a issue the viewer can access or a restricted contribution. */\nexport type CreatedIssueOrRestrictedContribution = CreatedIssueContribution | RestrictedContribution;\n\n/** Represents the contribution a user made on GitHub by opening a pull request. */\nexport type CreatedPullRequestContribution = Contribution & {\n  __typename?: \"CreatedPullRequestContribution\";\n  /**\n   * Whether this contribution is associated with a record you do not have access to. For\n   * example, your own 'first issue' contribution may have been made on a repository you can no\n   * longer access.\n   */\n  isRestricted: Scalars[\"Boolean\"];\n  /** When this contribution was made. */\n  occurredAt: Scalars[\"DateTime\"];\n  /** The pull request that was opened. */\n  pullRequest: PullRequest;\n  /** The HTTP path for this contribution. */\n  resourcePath: Scalars[\"URI\"];\n  /** The HTTP URL for this contribution. */\n  url: Scalars[\"URI\"];\n  /** The user who made this contribution. */\n  user: User;\n};\n\n/** The connection type for CreatedPullRequestContribution. */\nexport type CreatedPullRequestContributionConnection = {\n  __typename?: \"CreatedPullRequestContributionConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CreatedPullRequestContributionEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<CreatedPullRequestContribution>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type CreatedPullRequestContributionEdge = {\n  __typename?: \"CreatedPullRequestContributionEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<CreatedPullRequestContribution>;\n};\n\n/** Represents either a pull request the viewer can access or a restricted contribution. */\nexport type CreatedPullRequestOrRestrictedContribution = CreatedPullRequestContribution | RestrictedContribution;\n\n/** Represents the contribution a user made by leaving a review on a pull request. */\nexport type CreatedPullRequestReviewContribution = Contribution & {\n  __typename?: \"CreatedPullRequestReviewContribution\";\n  /**\n   * Whether this contribution is associated with a record you do not have access to. For\n   * example, your own 'first issue' contribution may have been made on a repository you can no\n   * longer access.\n   */\n  isRestricted: Scalars[\"Boolean\"];\n  /** When this contribution was made. */\n  occurredAt: Scalars[\"DateTime\"];\n  /** The pull request the user reviewed. */\n  pullRequest: PullRequest;\n  /** The review the user left on the pull request. */\n  pullRequestReview: PullRequestReview;\n  /** The repository containing the pull request that the user reviewed. */\n  repository: Repository;\n  /** The HTTP path for this contribution. */\n  resourcePath: Scalars[\"URI\"];\n  /** The HTTP URL for this contribution. */\n  url: Scalars[\"URI\"];\n  /** The user who made this contribution. */\n  user: User;\n};\n\n/** The connection type for CreatedPullRequestReviewContribution. */\nexport type CreatedPullRequestReviewContributionConnection = {\n  __typename?: \"CreatedPullRequestReviewContributionConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CreatedPullRequestReviewContributionEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<CreatedPullRequestReviewContribution>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type CreatedPullRequestReviewContributionEdge = {\n  __typename?: \"CreatedPullRequestReviewContributionEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<CreatedPullRequestReviewContribution>;\n};\n\n/** Represents the contribution a user made on GitHub by creating a repository. */\nexport type CreatedRepositoryContribution = Contribution & {\n  __typename?: \"CreatedRepositoryContribution\";\n  /**\n   * Whether this contribution is associated with a record you do not have access to. For\n   * example, your own 'first issue' contribution may have been made on a repository you can no\n   * longer access.\n   */\n  isRestricted: Scalars[\"Boolean\"];\n  /** When this contribution was made. */\n  occurredAt: Scalars[\"DateTime\"];\n  /** The repository that was created. */\n  repository: Repository;\n  /** The HTTP path for this contribution. */\n  resourcePath: Scalars[\"URI\"];\n  /** The HTTP URL for this contribution. */\n  url: Scalars[\"URI\"];\n  /** The user who made this contribution. */\n  user: User;\n};\n\n/** The connection type for CreatedRepositoryContribution. */\nexport type CreatedRepositoryContributionConnection = {\n  __typename?: \"CreatedRepositoryContributionConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CreatedRepositoryContributionEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<CreatedRepositoryContribution>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type CreatedRepositoryContributionEdge = {\n  __typename?: \"CreatedRepositoryContributionEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<CreatedRepositoryContribution>;\n};\n\n/** Represents either a repository the viewer can access or a restricted contribution. */\nexport type CreatedRepositoryOrRestrictedContribution = CreatedRepositoryContribution | RestrictedContribution;\n\n/** Represents a mention made by one issue or pull request to another. */\nexport type CrossReferencedEvent = Node &\n  UniformResourceLocatable & {\n    __typename?: \"CrossReferencedEvent\";\n    /** Identifies the actor who performed the event. */\n    actor?: Maybe<Actor>;\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars[\"DateTime\"];\n    id: Scalars[\"ID\"];\n    /** Reference originated in a different repository. */\n    isCrossRepository: Scalars[\"Boolean\"];\n    /** Identifies when the reference was made. */\n    referencedAt: Scalars[\"DateTime\"];\n    /** The HTTP path for this pull request. */\n    resourcePath: Scalars[\"URI\"];\n    /** Issue or pull request that made the reference. */\n    source: ReferencedSubject;\n    /** Issue or pull request to which the reference was made. */\n    target: ReferencedSubject;\n    /** The HTTP URL for this pull request. */\n    url: Scalars[\"URI\"];\n    /** Checks if the target will be closed when the source is merged. */\n    willCloseTarget: Scalars[\"Boolean\"];\n  };\n\n/** Autogenerated input type of DeclineTopicSuggestion */\nexport type DeclineTopicSuggestionInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The name of the suggested topic. */\n  name: Scalars[\"String\"];\n  /** The reason why the suggested topic is declined. */\n  reason: TopicSuggestionDeclineReason;\n  /** The Node ID of the repository. */\n  repositoryId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of DeclineTopicSuggestion */\nexport type DeclineTopicSuggestionPayload = {\n  __typename?: \"DeclineTopicSuggestionPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The declined topic. */\n  topic?: Maybe<Topic>;\n};\n\n/** The possible base permissions for repositories. */\nexport enum DefaultRepositoryPermissionField {\n  /** Can read, write, and administrate repos by default */\n  Admin = \"ADMIN\",\n  /** No access */\n  None = \"NONE\",\n  /** Can read repos by default */\n  Read = \"READ\",\n  /** Can read and write repos by default */\n  Write = \"WRITE\",\n}\n\n/** Entities that can be deleted. */\nexport type Deletable = {\n  /** Check if the current viewer can delete this object. */\n  viewerCanDelete: Scalars[\"Boolean\"];\n};\n\n/** Autogenerated input type of DeleteBranchProtectionRule */\nexport type DeleteBranchProtectionRuleInput = {\n  /** The global relay id of the branch protection rule to be deleted. */\n  branchProtectionRuleId: Scalars[\"ID\"];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated return type of DeleteBranchProtectionRule */\nexport type DeleteBranchProtectionRulePayload = {\n  __typename?: \"DeleteBranchProtectionRulePayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated input type of DeleteDeployment */\nexport type DeleteDeploymentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The Node ID of the deployment to be deleted. */\n  id: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of DeleteDeployment */\nexport type DeleteDeploymentPayload = {\n  __typename?: \"DeleteDeploymentPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated input type of DeleteDiscussionComment */\nexport type DeleteDiscussionCommentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The Node id of the discussion comment to delete. */\n  id: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of DeleteDiscussionComment */\nexport type DeleteDiscussionCommentPayload = {\n  __typename?: \"DeleteDiscussionCommentPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The discussion comment that was just deleted. */\n  comment?: Maybe<DiscussionComment>;\n};\n\n/** Autogenerated input type of DeleteDiscussion */\nexport type DeleteDiscussionInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The id of the discussion to delete. */\n  id: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of DeleteDiscussion */\nexport type DeleteDiscussionPayload = {\n  __typename?: \"DeleteDiscussionPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The discussion that was just deleted. */\n  discussion?: Maybe<Discussion>;\n};\n\n/** Autogenerated input type of DeleteEnvironment */\nexport type DeleteEnvironmentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The Node ID of the environment to be deleted. */\n  id: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of DeleteEnvironment */\nexport type DeleteEnvironmentPayload = {\n  __typename?: \"DeleteEnvironmentPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated input type of DeleteIpAllowListEntry */\nexport type DeleteIpAllowListEntryInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the IP allow list entry to delete. */\n  ipAllowListEntryId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of DeleteIpAllowListEntry */\nexport type DeleteIpAllowListEntryPayload = {\n  __typename?: \"DeleteIpAllowListEntryPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The IP allow list entry that was deleted. */\n  ipAllowListEntry?: Maybe<IpAllowListEntry>;\n};\n\n/** Autogenerated input type of DeleteIssueComment */\nexport type DeleteIssueCommentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the comment to delete. */\n  id: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of DeleteIssueComment */\nexport type DeleteIssueCommentPayload = {\n  __typename?: \"DeleteIssueCommentPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated input type of DeleteIssue */\nexport type DeleteIssueInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the issue to delete. */\n  issueId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of DeleteIssue */\nexport type DeleteIssuePayload = {\n  __typename?: \"DeleteIssuePayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The repository the issue belonged to */\n  repository?: Maybe<Repository>;\n};\n\n/** Autogenerated input type of DeleteLabel */\nexport type DeleteLabelInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The Node ID of the label to be deleted. */\n  id: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of DeleteLabel */\nexport type DeleteLabelPayload = {\n  __typename?: \"DeleteLabelPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated input type of DeletePackageVersion */\nexport type DeletePackageVersionInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the package version to be deleted. */\n  packageVersionId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of DeletePackageVersion */\nexport type DeletePackageVersionPayload = {\n  __typename?: \"DeletePackageVersionPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** Whether or not the operation succeeded. */\n  success?: Maybe<Scalars[\"Boolean\"]>;\n};\n\n/** Autogenerated input type of DeleteProjectCard */\nexport type DeleteProjectCardInput = {\n  /** The id of the card to delete. */\n  cardId: Scalars[\"ID\"];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated return type of DeleteProjectCard */\nexport type DeleteProjectCardPayload = {\n  __typename?: \"DeleteProjectCardPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The column the deleted card was in. */\n  column?: Maybe<ProjectColumn>;\n  /** The deleted card ID. */\n  deletedCardId?: Maybe<Scalars[\"ID\"]>;\n};\n\n/** Autogenerated input type of DeleteProjectColumn */\nexport type DeleteProjectColumnInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The id of the column to delete. */\n  columnId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of DeleteProjectColumn */\nexport type DeleteProjectColumnPayload = {\n  __typename?: \"DeleteProjectColumnPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The deleted column ID. */\n  deletedColumnId?: Maybe<Scalars[\"ID\"]>;\n  /** The project the deleted column was in. */\n  project?: Maybe<Project>;\n};\n\n/** Autogenerated input type of DeleteProject */\nexport type DeleteProjectInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The Project ID to update. */\n  projectId: Scalars[\"ID\"];\n};\n\n/** Autogenerated input type of DeleteProjectNextItem */\nexport type DeleteProjectNextItemInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the item to be removed. */\n  itemId: Scalars[\"ID\"];\n  /** The ID of the Project from which the item should be removed. */\n  projectId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of DeleteProjectNextItem */\nexport type DeleteProjectNextItemPayload = {\n  __typename?: \"DeleteProjectNextItemPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The ID of the deleted item. */\n  deletedItemId?: Maybe<Scalars[\"ID\"]>;\n};\n\n/** Autogenerated return type of DeleteProject */\nexport type DeleteProjectPayload = {\n  __typename?: \"DeleteProjectPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The repository or organization the project was removed from. */\n  owner?: Maybe<ProjectOwner>;\n};\n\n/** Autogenerated input type of DeletePullRequestReviewComment */\nexport type DeletePullRequestReviewCommentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the comment to delete. */\n  id: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of DeletePullRequestReviewComment */\nexport type DeletePullRequestReviewCommentPayload = {\n  __typename?: \"DeletePullRequestReviewCommentPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The pull request review the deleted comment belonged to. */\n  pullRequestReview?: Maybe<PullRequestReview>;\n};\n\n/** Autogenerated input type of DeletePullRequestReview */\nexport type DeletePullRequestReviewInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The Node ID of the pull request review to delete. */\n  pullRequestReviewId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of DeletePullRequestReview */\nexport type DeletePullRequestReviewPayload = {\n  __typename?: \"DeletePullRequestReviewPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The deleted pull request review. */\n  pullRequestReview?: Maybe<PullRequestReview>;\n};\n\n/** Autogenerated input type of DeleteRef */\nexport type DeleteRefInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The Node ID of the Ref to be deleted. */\n  refId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of DeleteRef */\nexport type DeleteRefPayload = {\n  __typename?: \"DeleteRefPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated input type of DeleteTeamDiscussionComment */\nexport type DeleteTeamDiscussionCommentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the comment to delete. */\n  id: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of DeleteTeamDiscussionComment */\nexport type DeleteTeamDiscussionCommentPayload = {\n  __typename?: \"DeleteTeamDiscussionCommentPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated input type of DeleteTeamDiscussion */\nexport type DeleteTeamDiscussionInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The discussion ID to delete. */\n  id: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of DeleteTeamDiscussion */\nexport type DeleteTeamDiscussionPayload = {\n  __typename?: \"DeleteTeamDiscussionPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated input type of DeleteVerifiableDomain */\nexport type DeleteVerifiableDomainInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the verifiable domain to delete. */\n  id: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of DeleteVerifiableDomain */\nexport type DeleteVerifiableDomainPayload = {\n  __typename?: \"DeleteVerifiableDomainPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The owning account from which the domain was deleted. */\n  owner?: Maybe<VerifiableDomainOwner>;\n};\n\n/** Represents a 'demilestoned' event on a given issue or pull request. */\nexport type DemilestonedEvent = Node & {\n  __typename?: \"DemilestonedEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  id: Scalars[\"ID\"];\n  /** Identifies the milestone title associated with the 'demilestoned' event. */\n  milestoneTitle: Scalars[\"String\"];\n  /** Object referenced by event. */\n  subject: MilestoneItem;\n};\n\n/** A Dependabot Update for a dependency in a repository */\nexport type DependabotUpdate = RepositoryNode & {\n  __typename?: \"DependabotUpdate\";\n  /** The error from a dependency update */\n  error?: Maybe<DependabotUpdateError>;\n  /** The associated pull request */\n  pullRequest?: Maybe<PullRequest>;\n  /** The repository associated with this node. */\n  repository: Repository;\n};\n\n/** An error produced from a Dependabot Update */\nexport type DependabotUpdateError = {\n  __typename?: \"DependabotUpdateError\";\n  /** The body of the error */\n  body: Scalars[\"String\"];\n  /** The error code */\n  errorType: Scalars[\"String\"];\n  /** The title of the error */\n  title: Scalars[\"String\"];\n};\n\n/** A dependency manifest entry */\nexport type DependencyGraphDependency = {\n  __typename?: \"DependencyGraphDependency\";\n  /** Does the dependency itself have dependencies? */\n  hasDependencies: Scalars[\"Boolean\"];\n  /** The original name of the package, as it appears in the manifest. */\n  packageLabel: Scalars[\"String\"];\n  /** The dependency package manager */\n  packageManager?: Maybe<Scalars[\"String\"]>;\n  /**\n   * The name of the package in the canonical form used by the package manager.\n   * This may differ from the original textual form (see packageLabel), for example\n   * in a package manager that uses case-insensitive comparisons.\n   */\n  packageName: Scalars[\"String\"];\n  /** The repository containing the package */\n  repository?: Maybe<Repository>;\n  /** The dependency version requirements */\n  requirements: Scalars[\"String\"];\n};\n\n/** The connection type for DependencyGraphDependency. */\nexport type DependencyGraphDependencyConnection = {\n  __typename?: \"DependencyGraphDependencyConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DependencyGraphDependencyEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<DependencyGraphDependency>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type DependencyGraphDependencyEdge = {\n  __typename?: \"DependencyGraphDependencyEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<DependencyGraphDependency>;\n};\n\n/** The possible ecosystems of a dependency graph package. */\nexport enum DependencyGraphEcosystem {\n  /** GitHub Actions */\n  Actions = \"ACTIONS\",\n  /** PHP packages hosted at packagist.org */\n  Composer = \"COMPOSER\",\n  /** Go modules */\n  Go = \"GO\",\n  /** Java artifacts hosted at the Maven central repository */\n  Maven = \"MAVEN\",\n  /** JavaScript packages hosted at npmjs.com */\n  Npm = \"NPM\",\n  /** .NET packages hosted at the NuGet Gallery */\n  Nuget = \"NUGET\",\n  /** Python packages hosted at PyPI.org */\n  Pip = \"PIP\",\n  /** Ruby gems hosted at RubyGems.org */\n  Rubygems = \"RUBYGEMS\",\n}\n\n/** Dependency manifest for a repository */\nexport type DependencyGraphManifest = Node & {\n  __typename?: \"DependencyGraphManifest\";\n  /** Path to view the manifest file blob */\n  blobPath: Scalars[\"String\"];\n  /** A list of manifest dependencies */\n  dependencies?: Maybe<DependencyGraphDependencyConnection>;\n  /** The number of dependencies listed in the manifest */\n  dependenciesCount?: Maybe<Scalars[\"Int\"]>;\n  /** Is the manifest too big to parse? */\n  exceedsMaxSize: Scalars[\"Boolean\"];\n  /** Fully qualified manifest filename */\n  filename: Scalars[\"String\"];\n  id: Scalars[\"ID\"];\n  /** Were we able to parse the manifest? */\n  parseable: Scalars[\"Boolean\"];\n  /** The repository containing the manifest */\n  repository: Repository;\n};\n\n/** Dependency manifest for a repository */\nexport type DependencyGraphManifestDependenciesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** The connection type for DependencyGraphManifest. */\nexport type DependencyGraphManifestConnection = {\n  __typename?: \"DependencyGraphManifestConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DependencyGraphManifestEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<DependencyGraphManifest>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type DependencyGraphManifestEdge = {\n  __typename?: \"DependencyGraphManifestEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<DependencyGraphManifest>;\n};\n\n/** A repository deploy key. */\nexport type DeployKey = Node & {\n  __typename?: \"DeployKey\";\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  id: Scalars[\"ID\"];\n  /** The deploy key. */\n  key: Scalars[\"String\"];\n  /** Whether or not the deploy key is read only. */\n  readOnly: Scalars[\"Boolean\"];\n  /** The deploy key title. */\n  title: Scalars[\"String\"];\n  /** Whether or not the deploy key has been verified. */\n  verified: Scalars[\"Boolean\"];\n};\n\n/** The connection type for DeployKey. */\nexport type DeployKeyConnection = {\n  __typename?: \"DeployKeyConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DeployKeyEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<DeployKey>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type DeployKeyEdge = {\n  __typename?: \"DeployKeyEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<DeployKey>;\n};\n\n/** Represents a 'deployed' event on a given pull request. */\nexport type DeployedEvent = Node & {\n  __typename?: \"DeployedEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars[\"Int\"]>;\n  /** The deployment associated with the 'deployed' event. */\n  deployment: Deployment;\n  id: Scalars[\"ID\"];\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest;\n  /** The ref associated with the 'deployed' event. */\n  ref?: Maybe<Ref>;\n};\n\n/** Represents triggered deployment instance. */\nexport type Deployment = Node & {\n  __typename?: \"Deployment\";\n  /** Identifies the commit sha of the deployment. */\n  commit?: Maybe<Commit>;\n  /** Identifies the oid of the deployment commit, even if the commit has been deleted. */\n  commitOid: Scalars[\"String\"];\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** Identifies the actor who triggered the deployment. */\n  creator: Actor;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars[\"Int\"]>;\n  /** The deployment description. */\n  description?: Maybe<Scalars[\"String\"]>;\n  /** The latest environment to which this deployment was made. */\n  environment?: Maybe<Scalars[\"String\"]>;\n  id: Scalars[\"ID\"];\n  /** The latest environment to which this deployment was made. */\n  latestEnvironment?: Maybe<Scalars[\"String\"]>;\n  /** The latest status of this deployment. */\n  latestStatus?: Maybe<DeploymentStatus>;\n  /** The original environment to which this deployment was made. */\n  originalEnvironment?: Maybe<Scalars[\"String\"]>;\n  /** Extra information that a deployment system might need. */\n  payload?: Maybe<Scalars[\"String\"]>;\n  /** Identifies the Ref of the deployment, if the deployment was created by ref. */\n  ref?: Maybe<Ref>;\n  /** Identifies the repository associated with the deployment. */\n  repository: Repository;\n  /** The current state of the deployment. */\n  state?: Maybe<DeploymentState>;\n  /** A list of statuses associated with the deployment. */\n  statuses?: Maybe<DeploymentStatusConnection>;\n  /** The deployment task. */\n  task?: Maybe<Scalars[\"String\"]>;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars[\"DateTime\"];\n};\n\n/** Represents triggered deployment instance. */\nexport type DeploymentStatusesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** The connection type for Deployment. */\nexport type DeploymentConnection = {\n  __typename?: \"DeploymentConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DeploymentEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Deployment>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type DeploymentEdge = {\n  __typename?: \"DeploymentEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<Deployment>;\n};\n\n/** Represents a 'deployment_environment_changed' event on a given pull request. */\nexport type DeploymentEnvironmentChangedEvent = Node & {\n  __typename?: \"DeploymentEnvironmentChangedEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** The deployment status that updated the deployment environment. */\n  deploymentStatus: DeploymentStatus;\n  id: Scalars[\"ID\"];\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest;\n};\n\n/** Ordering options for deployment connections */\nexport type DeploymentOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order deployments by. */\n  field: DeploymentOrderField;\n};\n\n/** Properties by which deployment connections can be ordered. */\nexport enum DeploymentOrderField {\n  /** Order collection by creation time */\n  CreatedAt = \"CREATED_AT\",\n}\n\n/** A protection rule. */\nexport type DeploymentProtectionRule = {\n  __typename?: \"DeploymentProtectionRule\";\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars[\"Int\"]>;\n  /** The teams or users that can review the deployment */\n  reviewers: DeploymentReviewerConnection;\n  /** The timeout in minutes for this protection rule. */\n  timeout: Scalars[\"Int\"];\n  /** The type of protection rule. */\n  type: DeploymentProtectionRuleType;\n};\n\n/** A protection rule. */\nexport type DeploymentProtectionRuleReviewersArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** The connection type for DeploymentProtectionRule. */\nexport type DeploymentProtectionRuleConnection = {\n  __typename?: \"DeploymentProtectionRuleConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DeploymentProtectionRuleEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<DeploymentProtectionRule>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type DeploymentProtectionRuleEdge = {\n  __typename?: \"DeploymentProtectionRuleEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<DeploymentProtectionRule>;\n};\n\n/** The possible protection rule types. */\nexport enum DeploymentProtectionRuleType {\n  /** Required reviewers */\n  RequiredReviewers = \"REQUIRED_REVIEWERS\",\n  /** Wait timer */\n  WaitTimer = \"WAIT_TIMER\",\n}\n\n/** A request to deploy a workflow run to an environment. */\nexport type DeploymentRequest = {\n  __typename?: \"DeploymentRequest\";\n  /** Whether or not the current user can approve the deployment */\n  currentUserCanApprove: Scalars[\"Boolean\"];\n  /** The target environment of the deployment */\n  environment: Environment;\n  /** The teams or users that can review the deployment */\n  reviewers: DeploymentReviewerConnection;\n  /** The wait timer in minutes configured in the environment */\n  waitTimer: Scalars[\"Int\"];\n  /** The wait timer in minutes configured in the environment */\n  waitTimerStartedAt?: Maybe<Scalars[\"DateTime\"]>;\n};\n\n/** A request to deploy a workflow run to an environment. */\nexport type DeploymentRequestReviewersArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** The connection type for DeploymentRequest. */\nexport type DeploymentRequestConnection = {\n  __typename?: \"DeploymentRequestConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DeploymentRequestEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<DeploymentRequest>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type DeploymentRequestEdge = {\n  __typename?: \"DeploymentRequestEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<DeploymentRequest>;\n};\n\n/** A deployment review. */\nexport type DeploymentReview = Node & {\n  __typename?: \"DeploymentReview\";\n  /** The comment the user left. */\n  comment: Scalars[\"String\"];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars[\"Int\"]>;\n  /** The environments approved or rejected */\n  environments: EnvironmentConnection;\n  id: Scalars[\"ID\"];\n  /** The decision of the user. */\n  state: DeploymentReviewState;\n  /** The user that reviewed the deployment. */\n  user: User;\n};\n\n/** A deployment review. */\nexport type DeploymentReviewEnvironmentsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** The connection type for DeploymentReview. */\nexport type DeploymentReviewConnection = {\n  __typename?: \"DeploymentReviewConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DeploymentReviewEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<DeploymentReview>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type DeploymentReviewEdge = {\n  __typename?: \"DeploymentReviewEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<DeploymentReview>;\n};\n\n/** The possible states for a deployment review. */\nexport enum DeploymentReviewState {\n  /** The deployment was approved. */\n  Approved = \"APPROVED\",\n  /** The deployment was rejected. */\n  Rejected = \"REJECTED\",\n}\n\n/** Users and teams. */\nexport type DeploymentReviewer = Team | User;\n\n/** The connection type for DeploymentReviewer. */\nexport type DeploymentReviewerConnection = {\n  __typename?: \"DeploymentReviewerConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DeploymentReviewerEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<DeploymentReviewer>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type DeploymentReviewerEdge = {\n  __typename?: \"DeploymentReviewerEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<DeploymentReviewer>;\n};\n\n/** The possible states in which a deployment can be. */\nexport enum DeploymentState {\n  /** The pending deployment was not updated after 30 minutes. */\n  Abandoned = \"ABANDONED\",\n  /** The deployment is currently active. */\n  Active = \"ACTIVE\",\n  /** An inactive transient deployment. */\n  Destroyed = \"DESTROYED\",\n  /** The deployment experienced an error. */\n  Error = \"ERROR\",\n  /** The deployment has failed. */\n  Failure = \"FAILURE\",\n  /** The deployment is inactive. */\n  Inactive = \"INACTIVE\",\n  /** The deployment is in progress. */\n  InProgress = \"IN_PROGRESS\",\n  /** The deployment is pending. */\n  Pending = \"PENDING\",\n  /** The deployment has queued */\n  Queued = \"QUEUED\",\n  /** The deployment is waiting. */\n  Waiting = \"WAITING\",\n}\n\n/** Describes the status of a given deployment attempt. */\nexport type DeploymentStatus = Node & {\n  __typename?: \"DeploymentStatus\";\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** Identifies the actor who triggered the deployment. */\n  creator: Actor;\n  /** Identifies the deployment associated with status. */\n  deployment: Deployment;\n  /** Identifies the description of the deployment. */\n  description?: Maybe<Scalars[\"String\"]>;\n  /** Identifies the environment of the deployment at the time of this deployment status */\n  environment?: Maybe<Scalars[\"String\"]>;\n  /** Identifies the environment URL of the deployment. */\n  environmentUrl?: Maybe<Scalars[\"URI\"]>;\n  id: Scalars[\"ID\"];\n  /** Identifies the log URL of the deployment. */\n  logUrl?: Maybe<Scalars[\"URI\"]>;\n  /** Identifies the current state of the deployment. */\n  state: DeploymentStatusState;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars[\"DateTime\"];\n};\n\n/** The connection type for DeploymentStatus. */\nexport type DeploymentStatusConnection = {\n  __typename?: \"DeploymentStatusConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DeploymentStatusEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<DeploymentStatus>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type DeploymentStatusEdge = {\n  __typename?: \"DeploymentStatusEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<DeploymentStatus>;\n};\n\n/** The possible states for a deployment status. */\nexport enum DeploymentStatusState {\n  /** The deployment experienced an error. */\n  Error = \"ERROR\",\n  /** The deployment has failed. */\n  Failure = \"FAILURE\",\n  /** The deployment is inactive. */\n  Inactive = \"INACTIVE\",\n  /** The deployment is in progress. */\n  InProgress = \"IN_PROGRESS\",\n  /** The deployment is pending. */\n  Pending = \"PENDING\",\n  /** The deployment is queued */\n  Queued = \"QUEUED\",\n  /** The deployment was successful. */\n  Success = \"SUCCESS\",\n  /** The deployment is waiting. */\n  Waiting = \"WAITING\",\n}\n\n/** The possible sides of a diff. */\nexport enum DiffSide {\n  /** The left side of the diff. */\n  Left = \"LEFT\",\n  /** The right side of the diff. */\n  Right = \"RIGHT\",\n}\n\n/** Autogenerated input type of DisablePullRequestAutoMerge */\nexport type DisablePullRequestAutoMergeInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** ID of the pull request to disable auto merge on. */\n  pullRequestId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of DisablePullRequestAutoMerge */\nexport type DisablePullRequestAutoMergePayload = {\n  __typename?: \"DisablePullRequestAutoMergePayload\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The pull request auto merge was disabled on. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Represents a 'disconnected' event on a given issue or pull request. */\nexport type DisconnectedEvent = Node & {\n  __typename?: \"DisconnectedEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  id: Scalars[\"ID\"];\n  /** Reference originated in a different repository. */\n  isCrossRepository: Scalars[\"Boolean\"];\n  /** Issue or pull request from which the issue was disconnected. */\n  source: ReferencedSubject;\n  /** Issue or pull request which was disconnected. */\n  subject: ReferencedSubject;\n};\n\n/** A discussion in a repository. */\nexport type Discussion = Comment &\n  Deletable &\n  Labelable &\n  Lockable &\n  Node &\n  Reactable &\n  RepositoryNode &\n  Subscribable &\n  Updatable &\n  Votable & {\n    __typename?: \"Discussion\";\n    /** Reason that the conversation was locked. */\n    activeLockReason?: Maybe<LockReason>;\n    /** The comment chosen as this discussion's answer, if any. */\n    answer?: Maybe<DiscussionComment>;\n    /** The time when a user chose this discussion's answer, if answered. */\n    answerChosenAt?: Maybe<Scalars[\"DateTime\"]>;\n    /** The user who chose this discussion's answer, if answered. */\n    answerChosenBy?: Maybe<Actor>;\n    /** The actor who authored the comment. */\n    author?: Maybe<Actor>;\n    /** Author's association with the subject of the comment. */\n    authorAssociation: CommentAuthorAssociation;\n    /** The main text of the discussion post. */\n    body: Scalars[\"String\"];\n    /** The body rendered to HTML. */\n    bodyHTML: Scalars[\"HTML\"];\n    /** The body rendered to text. */\n    bodyText: Scalars[\"String\"];\n    /** The category for this discussion. */\n    category: DiscussionCategory;\n    /** The replies to the discussion. */\n    comments: DiscussionCommentConnection;\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars[\"DateTime\"];\n    /** Check if this comment was created via an email reply. */\n    createdViaEmail: Scalars[\"Boolean\"];\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars[\"Int\"]>;\n    /** The actor who edited the comment. */\n    editor?: Maybe<Actor>;\n    id: Scalars[\"ID\"];\n    /** Check if this comment was edited and includes an edit with the creation data */\n    includesCreatedEdit: Scalars[\"Boolean\"];\n    /** A list of labels associated with the object. */\n    labels?: Maybe<LabelConnection>;\n    /** The moment the editor made the last edit */\n    lastEditedAt?: Maybe<Scalars[\"DateTime\"]>;\n    /** `true` if the object is locked */\n    locked: Scalars[\"Boolean\"];\n    /** The number identifying this discussion within the repository. */\n    number: Scalars[\"Int\"];\n    /** Identifies when the comment was published at. */\n    publishedAt?: Maybe<Scalars[\"DateTime\"]>;\n    /** A list of reactions grouped by content left on the subject. */\n    reactionGroups?: Maybe<Array<ReactionGroup>>;\n    /** A list of Reactions left on the Issue. */\n    reactions: ReactionConnection;\n    /** The repository associated with this node. */\n    repository: Repository;\n    /** The path for this discussion. */\n    resourcePath: Scalars[\"URI\"];\n    /** The title of this discussion. */\n    title: Scalars[\"String\"];\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars[\"DateTime\"];\n    /** Number of upvotes that this subject has received. */\n    upvoteCount: Scalars[\"Int\"];\n    /** The URL for this discussion. */\n    url: Scalars[\"URI\"];\n    /** A list of edits to this content. */\n    userContentEdits?: Maybe<UserContentEditConnection>;\n    /** Check if the current viewer can delete this object. */\n    viewerCanDelete: Scalars[\"Boolean\"];\n    /** Can user react to this subject */\n    viewerCanReact: Scalars[\"Boolean\"];\n    /** Check if the viewer is able to change their subscription status for the repository. */\n    viewerCanSubscribe: Scalars[\"Boolean\"];\n    /** Check if the current viewer can update this object. */\n    viewerCanUpdate: Scalars[\"Boolean\"];\n    /** Whether or not the current user can add or remove an upvote on this subject. */\n    viewerCanUpvote: Scalars[\"Boolean\"];\n    /** Did the viewer author this comment. */\n    viewerDidAuthor: Scalars[\"Boolean\"];\n    /** Whether or not the current user has already upvoted this subject. */\n    viewerHasUpvoted: Scalars[\"Boolean\"];\n    /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */\n    viewerSubscription?: Maybe<SubscriptionState>;\n  };\n\n/** A discussion in a repository. */\nexport type DiscussionCommentsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A discussion in a repository. */\nexport type DiscussionLabelsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<LabelOrder>;\n};\n\n/** A discussion in a repository. */\nexport type DiscussionReactionsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  content?: InputMaybe<ReactionContent>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<ReactionOrder>;\n};\n\n/** A discussion in a repository. */\nexport type DiscussionUserContentEditsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A category for discussions in a repository. */\nexport type DiscussionCategory = Node &\n  RepositoryNode & {\n    __typename?: \"DiscussionCategory\";\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars[\"DateTime\"];\n    /** A description of this category. */\n    description?: Maybe<Scalars[\"String\"]>;\n    /** An emoji representing this category. */\n    emoji: Scalars[\"String\"];\n    /** This category's emoji rendered as HTML. */\n    emojiHTML: Scalars[\"HTML\"];\n    id: Scalars[\"ID\"];\n    /** Whether or not discussions in this category support choosing an answer with the markDiscussionCommentAsAnswer mutation. */\n    isAnswerable: Scalars[\"Boolean\"];\n    /** The name of this category. */\n    name: Scalars[\"String\"];\n    /** The repository associated with this node. */\n    repository: Repository;\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars[\"DateTime\"];\n  };\n\n/** The connection type for DiscussionCategory. */\nexport type DiscussionCategoryConnection = {\n  __typename?: \"DiscussionCategoryConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DiscussionCategoryEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<DiscussionCategory>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type DiscussionCategoryEdge = {\n  __typename?: \"DiscussionCategoryEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<DiscussionCategory>;\n};\n\n/** A comment on a discussion. */\nexport type DiscussionComment = Comment &\n  Deletable &\n  Minimizable &\n  Node &\n  Reactable &\n  Updatable &\n  UpdatableComment &\n  Votable & {\n    __typename?: \"DiscussionComment\";\n    /** The actor who authored the comment. */\n    author?: Maybe<Actor>;\n    /** Author's association with the subject of the comment. */\n    authorAssociation: CommentAuthorAssociation;\n    /** The body as Markdown. */\n    body: Scalars[\"String\"];\n    /** The body rendered to HTML. */\n    bodyHTML: Scalars[\"HTML\"];\n    /** The body rendered to text. */\n    bodyText: Scalars[\"String\"];\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars[\"DateTime\"];\n    /** Check if this comment was created via an email reply. */\n    createdViaEmail: Scalars[\"Boolean\"];\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars[\"Int\"]>;\n    /** The time when this replied-to comment was deleted */\n    deletedAt?: Maybe<Scalars[\"DateTime\"]>;\n    /** The discussion this comment was created in */\n    discussion?: Maybe<Discussion>;\n    /** The actor who edited the comment. */\n    editor?: Maybe<Actor>;\n    id: Scalars[\"ID\"];\n    /** Check if this comment was edited and includes an edit with the creation data */\n    includesCreatedEdit: Scalars[\"Boolean\"];\n    /** Has this comment been chosen as the answer of its discussion? */\n    isAnswer: Scalars[\"Boolean\"];\n    /** Returns whether or not a comment has been minimized. */\n    isMinimized: Scalars[\"Boolean\"];\n    /** The moment the editor made the last edit */\n    lastEditedAt?: Maybe<Scalars[\"DateTime\"]>;\n    /** Returns why the comment was minimized. */\n    minimizedReason?: Maybe<Scalars[\"String\"]>;\n    /** Identifies when the comment was published at. */\n    publishedAt?: Maybe<Scalars[\"DateTime\"]>;\n    /** A list of reactions grouped by content left on the subject. */\n    reactionGroups?: Maybe<Array<ReactionGroup>>;\n    /** A list of Reactions left on the Issue. */\n    reactions: ReactionConnection;\n    /** The threaded replies to this comment. */\n    replies: DiscussionCommentConnection;\n    /** The discussion comment this comment is a reply to */\n    replyTo?: Maybe<DiscussionComment>;\n    /** The path for this discussion comment. */\n    resourcePath: Scalars[\"URI\"];\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars[\"DateTime\"];\n    /** Number of upvotes that this subject has received. */\n    upvoteCount: Scalars[\"Int\"];\n    /** The URL for this discussion comment. */\n    url: Scalars[\"URI\"];\n    /** A list of edits to this content. */\n    userContentEdits?: Maybe<UserContentEditConnection>;\n    /** Check if the current viewer can delete this object. */\n    viewerCanDelete: Scalars[\"Boolean\"];\n    /** Can the current user mark this comment as an answer? */\n    viewerCanMarkAsAnswer: Scalars[\"Boolean\"];\n    /** Check if the current viewer can minimize this object. */\n    viewerCanMinimize: Scalars[\"Boolean\"];\n    /** Can user react to this subject */\n    viewerCanReact: Scalars[\"Boolean\"];\n    /** Can the current user unmark this comment as an answer? */\n    viewerCanUnmarkAsAnswer: Scalars[\"Boolean\"];\n    /** Check if the current viewer can update this object. */\n    viewerCanUpdate: Scalars[\"Boolean\"];\n    /** Whether or not the current user can add or remove an upvote on this subject. */\n    viewerCanUpvote: Scalars[\"Boolean\"];\n    /** Reasons why the current viewer can not update this comment. */\n    viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;\n    /** Did the viewer author this comment. */\n    viewerDidAuthor: Scalars[\"Boolean\"];\n    /** Whether or not the current user has already upvoted this subject. */\n    viewerHasUpvoted: Scalars[\"Boolean\"];\n  };\n\n/** A comment on a discussion. */\nexport type DiscussionCommentReactionsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  content?: InputMaybe<ReactionContent>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<ReactionOrder>;\n};\n\n/** A comment on a discussion. */\nexport type DiscussionCommentRepliesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A comment on a discussion. */\nexport type DiscussionCommentUserContentEditsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** The connection type for DiscussionComment. */\nexport type DiscussionCommentConnection = {\n  __typename?: \"DiscussionCommentConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DiscussionCommentEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<DiscussionComment>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type DiscussionCommentEdge = {\n  __typename?: \"DiscussionCommentEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<DiscussionComment>;\n};\n\n/** The connection type for Discussion. */\nexport type DiscussionConnection = {\n  __typename?: \"DiscussionConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DiscussionEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Discussion>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type DiscussionEdge = {\n  __typename?: \"DiscussionEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<Discussion>;\n};\n\n/** Ways in which lists of discussions can be ordered upon return. */\nexport type DiscussionOrder = {\n  /** The direction in which to order discussions by the specified field. */\n  direction: OrderDirection;\n  /** The field by which to order discussions. */\n  field: DiscussionOrderField;\n};\n\n/** Properties by which discussion connections can be ordered. */\nexport enum DiscussionOrderField {\n  /** Order discussions by creation time. */\n  CreatedAt = \"CREATED_AT\",\n  /** Order discussions by most recent modification time. */\n  UpdatedAt = \"UPDATED_AT\",\n}\n\n/** Autogenerated input type of DismissPullRequestReview */\nexport type DismissPullRequestReviewInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The contents of the pull request review dismissal message. */\n  message: Scalars[\"String\"];\n  /** The Node ID of the pull request review to modify. */\n  pullRequestReviewId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of DismissPullRequestReview */\nexport type DismissPullRequestReviewPayload = {\n  __typename?: \"DismissPullRequestReviewPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The dismissed pull request review. */\n  pullRequestReview?: Maybe<PullRequestReview>;\n};\n\n/** The possible reasons that a Dependabot alert was dismissed. */\nexport enum DismissReason {\n  /** A fix has already been started */\n  FixStarted = \"FIX_STARTED\",\n  /** This alert is inaccurate or incorrect */\n  Inaccurate = \"INACCURATE\",\n  /** Vulnerable code is not actually used */\n  NotUsed = \"NOT_USED\",\n  /** No bandwidth to fix this */\n  NoBandwidth = \"NO_BANDWIDTH\",\n  /** Risk is tolerable to this project */\n  TolerableRisk = \"TOLERABLE_RISK\",\n}\n\n/** Autogenerated input type of DismissRepositoryVulnerabilityAlert */\nexport type DismissRepositoryVulnerabilityAlertInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The reason the Dependabot alert is being dismissed. */\n  dismissReason: DismissReason;\n  /** The Dependabot alert ID to dismiss. */\n  repositoryVulnerabilityAlertId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of DismissRepositoryVulnerabilityAlert */\nexport type DismissRepositoryVulnerabilityAlertPayload = {\n  __typename?: \"DismissRepositoryVulnerabilityAlertPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The Dependabot alert that was dismissed */\n  repositoryVulnerabilityAlert?: Maybe<RepositoryVulnerabilityAlert>;\n};\n\n/** A draft issue within a project. */\nexport type DraftIssue = Node & {\n  __typename?: \"DraftIssue\";\n  /** A list of users to assigned to this draft issue. */\n  assignees: UserConnection;\n  /** The body of the draft issue. */\n  body: Scalars[\"String\"];\n  /** The body of the draft issue rendered to HTML. */\n  bodyHTML: Scalars[\"HTML\"];\n  /** The body of the draft issue rendered to text. */\n  bodyText: Scalars[\"String\"];\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** The actor who created this draft issue. */\n  creator?: Maybe<Actor>;\n  id: Scalars[\"ID\"];\n  /** The project (beta) that contains this draft issue. */\n  project: ProjectNext;\n  /** The project (beta) item that wraps this draft issue. */\n  projectItem: ProjectNextItem;\n  /** The title of the draft issue */\n  title: Scalars[\"String\"];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars[\"DateTime\"];\n};\n\n/** A draft issue within a project. */\nexport type DraftIssueAssigneesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** Specifies a review comment to be left with a Pull Request Review. */\nexport type DraftPullRequestReviewComment = {\n  /** Body of the comment to leave. */\n  body: Scalars[\"String\"];\n  /** Path to the file being commented on. */\n  path: Scalars[\"String\"];\n  /** Position in the file to leave a comment on. */\n  position: Scalars[\"Int\"];\n};\n\n/** Specifies a review comment thread to be left with a Pull Request Review. */\nexport type DraftPullRequestReviewThread = {\n  /** Body of the comment to leave. */\n  body: Scalars[\"String\"];\n  /** The line of the blob to which the thread refers. The end of the line range for multi-line comments. */\n  line: Scalars[\"Int\"];\n  /** Path to the file being commented on. */\n  path: Scalars[\"String\"];\n  /** The side of the diff on which the line resides. For multi-line comments, this is the side for the end of the line range. */\n  side?: InputMaybe<DiffSide>;\n  /** The first line of the range to which the comment refers. */\n  startLine?: InputMaybe<Scalars[\"Int\"]>;\n  /** The side of the diff on which the start line resides. */\n  startSide?: InputMaybe<DiffSide>;\n};\n\n/** Autogenerated input type of EnablePullRequestAutoMerge */\nexport type EnablePullRequestAutoMergeInput = {\n  /** The email address to associate with this merge. */\n  authorEmail?: InputMaybe<Scalars[\"String\"]>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** Commit body to use for the commit when the PR is mergable; if omitted, a default message will be used. */\n  commitBody?: InputMaybe<Scalars[\"String\"]>;\n  /** Commit headline to use for the commit when the PR is mergable; if omitted, a default message will be used. */\n  commitHeadline?: InputMaybe<Scalars[\"String\"]>;\n  /** The merge method to use. If omitted, defaults to 'MERGE' */\n  mergeMethod?: InputMaybe<PullRequestMergeMethod>;\n  /** ID of the pull request to enable auto-merge on. */\n  pullRequestId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of EnablePullRequestAutoMerge */\nexport type EnablePullRequestAutoMergePayload = {\n  __typename?: \"EnablePullRequestAutoMergePayload\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The pull request auto-merge was enabled on. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** An account to manage multiple organizations with consolidated policy and billing. */\nexport type Enterprise = Node & {\n  __typename?: \"Enterprise\";\n  /** A URL pointing to the enterprise's public avatar. */\n  avatarUrl: Scalars[\"URI\"];\n  /** Enterprise billing information visible to enterprise billing managers. */\n  billingInfo?: Maybe<EnterpriseBillingInfo>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars[\"Int\"]>;\n  /** The description of the enterprise. */\n  description?: Maybe<Scalars[\"String\"]>;\n  /** The description of the enterprise as HTML. */\n  descriptionHTML: Scalars[\"HTML\"];\n  id: Scalars[\"ID\"];\n  /** The location of the enterprise. */\n  location?: Maybe<Scalars[\"String\"]>;\n  /** A list of users who are members of this enterprise. */\n  members: EnterpriseMemberConnection;\n  /** The name of the enterprise. */\n  name: Scalars[\"String\"];\n  /** A list of organizations that belong to this enterprise. */\n  organizations: OrganizationConnection;\n  /** Enterprise information only visible to enterprise owners. */\n  ownerInfo?: Maybe<EnterpriseOwnerInfo>;\n  /** The HTTP path for this enterprise. */\n  resourcePath: Scalars[\"URI\"];\n  /** The URL-friendly identifier for the enterprise. */\n  slug: Scalars[\"String\"];\n  /** The HTTP URL for this enterprise. */\n  url: Scalars[\"URI\"];\n  /**\n   * A list of user accounts on this enterprise.\n   * @deprecated The `Enterprise.userAccounts` field is being removed. Use the `Enterprise.members` field instead. Removal on 2022-07-01 UTC.\n   */\n  userAccounts: EnterpriseUserAccountConnection;\n  /** Is the current viewer an admin of this enterprise? */\n  viewerIsAdmin: Scalars[\"Boolean\"];\n  /** The URL of the enterprise website. */\n  websiteUrl?: Maybe<Scalars[\"URI\"]>;\n};\n\n/** An account to manage multiple organizations with consolidated policy and billing. */\nexport type EnterpriseAvatarUrlArgs = {\n  size?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** An account to manage multiple organizations with consolidated policy and billing. */\nexport type EnterpriseMembersArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  deployment?: InputMaybe<EnterpriseUserDeployment>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<EnterpriseMemberOrder>;\n  organizationLogins?: InputMaybe<Array<Scalars[\"String\"]>>;\n  query?: InputMaybe<Scalars[\"String\"]>;\n  role?: InputMaybe<EnterpriseUserAccountMembershipRole>;\n};\n\n/** An account to manage multiple organizations with consolidated policy and billing. */\nexport type EnterpriseOrganizationsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  query?: InputMaybe<Scalars[\"String\"]>;\n  viewerOrganizationRole?: InputMaybe<RoleInOrganization>;\n};\n\n/** An account to manage multiple organizations with consolidated policy and billing. */\nexport type EnterpriseUserAccountsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** The connection type for User. */\nexport type EnterpriseAdministratorConnection = {\n  __typename?: \"EnterpriseAdministratorConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseAdministratorEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** A User who is an administrator of an enterprise. */\nexport type EnterpriseAdministratorEdge = {\n  __typename?: \"EnterpriseAdministratorEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<User>;\n  /** The role of the administrator. */\n  role: EnterpriseAdministratorRole;\n};\n\n/** An invitation for a user to become an owner or billing manager of an enterprise. */\nexport type EnterpriseAdministratorInvitation = Node & {\n  __typename?: \"EnterpriseAdministratorInvitation\";\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** The email of the person who was invited to the enterprise. */\n  email?: Maybe<Scalars[\"String\"]>;\n  /** The enterprise the invitation is for. */\n  enterprise: Enterprise;\n  id: Scalars[\"ID\"];\n  /** The user who was invited to the enterprise. */\n  invitee?: Maybe<User>;\n  /** The user who created the invitation. */\n  inviter?: Maybe<User>;\n  /** The invitee's pending role in the enterprise (owner or billing_manager). */\n  role: EnterpriseAdministratorRole;\n};\n\n/** The connection type for EnterpriseAdministratorInvitation. */\nexport type EnterpriseAdministratorInvitationConnection = {\n  __typename?: \"EnterpriseAdministratorInvitationConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseAdministratorInvitationEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<EnterpriseAdministratorInvitation>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type EnterpriseAdministratorInvitationEdge = {\n  __typename?: \"EnterpriseAdministratorInvitationEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<EnterpriseAdministratorInvitation>;\n};\n\n/** Ordering options for enterprise administrator invitation connections */\nexport type EnterpriseAdministratorInvitationOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order enterprise administrator invitations by. */\n  field: EnterpriseAdministratorInvitationOrderField;\n};\n\n/** Properties by which enterprise administrator invitation connections can be ordered. */\nexport enum EnterpriseAdministratorInvitationOrderField {\n  /** Order enterprise administrator member invitations by creation time */\n  CreatedAt = \"CREATED_AT\",\n}\n\n/** The possible administrator roles in an enterprise account. */\nexport enum EnterpriseAdministratorRole {\n  /** Represents a billing manager of the enterprise account. */\n  BillingManager = \"BILLING_MANAGER\",\n  /** Represents an owner of the enterprise account. */\n  Owner = \"OWNER\",\n}\n\n/** Metadata for an audit entry containing enterprise account information. */\nexport type EnterpriseAuditEntryData = {\n  /** The HTTP path for this enterprise. */\n  enterpriseResourcePath?: Maybe<Scalars[\"URI\"]>;\n  /** The slug of the enterprise. */\n  enterpriseSlug?: Maybe<Scalars[\"String\"]>;\n  /** The HTTP URL for this enterprise. */\n  enterpriseUrl?: Maybe<Scalars[\"URI\"]>;\n};\n\n/** Enterprise billing information visible to enterprise billing managers and owners. */\nexport type EnterpriseBillingInfo = {\n  __typename?: \"EnterpriseBillingInfo\";\n  /** The number of licenseable users/emails across the enterprise. */\n  allLicensableUsersCount: Scalars[\"Int\"];\n  /** The number of data packs used by all organizations owned by the enterprise. */\n  assetPacks: Scalars[\"Int\"];\n  /** The bandwidth quota in GB for all organizations owned by the enterprise. */\n  bandwidthQuota: Scalars[\"Float\"];\n  /** The bandwidth usage in GB for all organizations owned by the enterprise. */\n  bandwidthUsage: Scalars[\"Float\"];\n  /** The bandwidth usage as a percentage of the bandwidth quota. */\n  bandwidthUsagePercentage: Scalars[\"Int\"];\n  /** The storage quota in GB for all organizations owned by the enterprise. */\n  storageQuota: Scalars[\"Float\"];\n  /** The storage usage in GB for all organizations owned by the enterprise. */\n  storageUsage: Scalars[\"Float\"];\n  /** The storage usage as a percentage of the storage quota. */\n  storageUsagePercentage: Scalars[\"Int\"];\n  /** The number of available licenses across all owned organizations based on the unique number of billable users. */\n  totalAvailableLicenses: Scalars[\"Int\"];\n  /** The total number of licenses allocated. */\n  totalLicenses: Scalars[\"Int\"];\n};\n\n/** The possible values for the enterprise base repository permission setting. */\nexport enum EnterpriseDefaultRepositoryPermissionSettingValue {\n  /** Organization members will be able to clone, pull, push, and add new collaborators to all organization repositories. */\n  Admin = \"ADMIN\",\n  /** Organization members will only be able to clone and pull public repositories. */\n  None = \"NONE\",\n  /** Organizations in the enterprise choose base repository permissions for their members. */\n  NoPolicy = \"NO_POLICY\",\n  /** Organization members will be able to clone and pull all organization repositories. */\n  Read = \"READ\",\n  /** Organization members will be able to clone, pull, and push all organization repositories. */\n  Write = \"WRITE\",\n}\n\n/** The possible values for an enabled/disabled enterprise setting. */\nexport enum EnterpriseEnabledDisabledSettingValue {\n  /** The setting is disabled for organizations in the enterprise. */\n  Disabled = \"DISABLED\",\n  /** The setting is enabled for organizations in the enterprise. */\n  Enabled = \"ENABLED\",\n  /** There is no policy set for organizations in the enterprise. */\n  NoPolicy = \"NO_POLICY\",\n}\n\n/** The possible values for an enabled/no policy enterprise setting. */\nexport enum EnterpriseEnabledSettingValue {\n  /** The setting is enabled for organizations in the enterprise. */\n  Enabled = \"ENABLED\",\n  /** There is no policy set for organizations in the enterprise. */\n  NoPolicy = \"NO_POLICY\",\n}\n\n/** An identity provider configured to provision identities for an enterprise. */\nexport type EnterpriseIdentityProvider = Node & {\n  __typename?: \"EnterpriseIdentityProvider\";\n  /** The digest algorithm used to sign SAML requests for the identity provider. */\n  digestMethod?: Maybe<SamlDigestAlgorithm>;\n  /** The enterprise this identity provider belongs to. */\n  enterprise?: Maybe<Enterprise>;\n  /** ExternalIdentities provisioned by this identity provider. */\n  externalIdentities: ExternalIdentityConnection;\n  id: Scalars[\"ID\"];\n  /** The x509 certificate used by the identity provider to sign assertions and responses. */\n  idpCertificate?: Maybe<Scalars[\"X509Certificate\"]>;\n  /** The Issuer Entity ID for the SAML identity provider. */\n  issuer?: Maybe<Scalars[\"String\"]>;\n  /** Recovery codes that can be used by admins to access the enterprise if the identity provider is unavailable. */\n  recoveryCodes?: Maybe<Array<Scalars[\"String\"]>>;\n  /** The signature algorithm used to sign SAML requests for the identity provider. */\n  signatureMethod?: Maybe<SamlSignatureAlgorithm>;\n  /** The URL endpoint for the identity provider's SAML SSO. */\n  ssoUrl?: Maybe<Scalars[\"URI\"]>;\n};\n\n/** An identity provider configured to provision identities for an enterprise. */\nexport type EnterpriseIdentityProviderExternalIdentitiesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  login?: InputMaybe<Scalars[\"String\"]>;\n  membersOnly?: InputMaybe<Scalars[\"Boolean\"]>;\n  userName?: InputMaybe<Scalars[\"String\"]>;\n};\n\n/** An object that is a member of an enterprise. */\nexport type EnterpriseMember = EnterpriseUserAccount | User;\n\n/** The connection type for EnterpriseMember. */\nexport type EnterpriseMemberConnection = {\n  __typename?: \"EnterpriseMemberConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseMemberEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<EnterpriseMember>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** A User who is a member of an enterprise through one or more organizations. */\nexport type EnterpriseMemberEdge = {\n  __typename?: \"EnterpriseMemberEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<EnterpriseMember>;\n};\n\n/** Ordering options for enterprise member connections. */\nexport type EnterpriseMemberOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order enterprise members by. */\n  field: EnterpriseMemberOrderField;\n};\n\n/** Properties by which enterprise member connections can be ordered. */\nexport enum EnterpriseMemberOrderField {\n  /** Order enterprise members by creation time */\n  CreatedAt = \"CREATED_AT\",\n  /** Order enterprise members by login */\n  Login = \"LOGIN\",\n}\n\n/** The possible values for the enterprise members can create repositories setting. */\nexport enum EnterpriseMembersCanCreateRepositoriesSettingValue {\n  /** Members will be able to create public and private repositories. */\n  All = \"ALL\",\n  /** Members will not be able to create public or private repositories. */\n  Disabled = \"DISABLED\",\n  /** Organization administrators choose whether to allow members to create repositories. */\n  NoPolicy = \"NO_POLICY\",\n  /** Members will be able to create only private repositories. */\n  Private = \"PRIVATE\",\n  /** Members will be able to create only public repositories. */\n  Public = \"PUBLIC\",\n}\n\n/** The possible values for the members can make purchases setting. */\nexport enum EnterpriseMembersCanMakePurchasesSettingValue {\n  /** The setting is disabled for organizations in the enterprise. */\n  Disabled = \"DISABLED\",\n  /** The setting is enabled for organizations in the enterprise. */\n  Enabled = \"ENABLED\",\n}\n\n/** The connection type for Organization. */\nexport type EnterpriseOrganizationMembershipConnection = {\n  __typename?: \"EnterpriseOrganizationMembershipConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseOrganizationMembershipEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Organization>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An enterprise organization that a user is a member of. */\nexport type EnterpriseOrganizationMembershipEdge = {\n  __typename?: \"EnterpriseOrganizationMembershipEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<Organization>;\n  /** The role of the user in the enterprise membership. */\n  role: EnterpriseUserAccountMembershipRole;\n};\n\n/** The connection type for User. */\nexport type EnterpriseOutsideCollaboratorConnection = {\n  __typename?: \"EnterpriseOutsideCollaboratorConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseOutsideCollaboratorEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** A User who is an outside collaborator of an enterprise through one or more organizations. */\nexport type EnterpriseOutsideCollaboratorEdge = {\n  __typename?: \"EnterpriseOutsideCollaboratorEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<User>;\n  /** The enterprise organization repositories this user is a member of. */\n  repositories: EnterpriseRepositoryInfoConnection;\n};\n\n/** A User who is an outside collaborator of an enterprise through one or more organizations. */\nexport type EnterpriseOutsideCollaboratorEdgeRepositoriesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<RepositoryOrder>;\n};\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfo = {\n  __typename?: \"EnterpriseOwnerInfo\";\n  /** A list of all of the administrators for this enterprise. */\n  admins: EnterpriseAdministratorConnection;\n  /** A list of users in the enterprise who currently have two-factor authentication disabled. */\n  affiliatedUsersWithTwoFactorDisabled: UserConnection;\n  /** Whether or not affiliated users with two-factor authentication disabled exist in the enterprise. */\n  affiliatedUsersWithTwoFactorDisabledExist: Scalars[\"Boolean\"];\n  /** The setting value for whether private repository forking is enabled for repositories in organizations in this enterprise. */\n  allowPrivateRepositoryForkingSetting: EnterpriseEnabledDisabledSettingValue;\n  /** A list of enterprise organizations configured with the provided private repository forking setting value. */\n  allowPrivateRepositoryForkingSettingOrganizations: OrganizationConnection;\n  /** The setting value for base repository permissions for organizations in this enterprise. */\n  defaultRepositoryPermissionSetting: EnterpriseDefaultRepositoryPermissionSettingValue;\n  /** A list of enterprise organizations configured with the provided base repository permission. */\n  defaultRepositoryPermissionSettingOrganizations: OrganizationConnection;\n  /** A list of domains owned by the enterprise. */\n  domains: VerifiableDomainConnection;\n  /** Enterprise Server installations owned by the enterprise. */\n  enterpriseServerInstallations: EnterpriseServerInstallationConnection;\n  /** The setting value for whether the enterprise has an IP allow list enabled. */\n  ipAllowListEnabledSetting: IpAllowListEnabledSettingValue;\n  /** The IP addresses that are allowed to access resources owned by the enterprise. */\n  ipAllowListEntries: IpAllowListEntryConnection;\n  /** The setting value for whether the enterprise has IP allow list configuration for installed GitHub Apps enabled. */\n  ipAllowListForInstalledAppsEnabledSetting: IpAllowListForInstalledAppsEnabledSettingValue;\n  /** Whether or not the base repository permission is currently being updated. */\n  isUpdatingDefaultRepositoryPermission: Scalars[\"Boolean\"];\n  /** Whether the two-factor authentication requirement is currently being enforced. */\n  isUpdatingTwoFactorRequirement: Scalars[\"Boolean\"];\n  /**\n   * The setting value for whether organization members with admin permissions on a\n   * repository can change repository visibility.\n   */\n  membersCanChangeRepositoryVisibilitySetting: EnterpriseEnabledDisabledSettingValue;\n  /** A list of enterprise organizations configured with the provided can change repository visibility setting value. */\n  membersCanChangeRepositoryVisibilitySettingOrganizations: OrganizationConnection;\n  /** The setting value for whether members of organizations in the enterprise can create internal repositories. */\n  membersCanCreateInternalRepositoriesSetting?: Maybe<Scalars[\"Boolean\"]>;\n  /** The setting value for whether members of organizations in the enterprise can create private repositories. */\n  membersCanCreatePrivateRepositoriesSetting?: Maybe<Scalars[\"Boolean\"]>;\n  /** The setting value for whether members of organizations in the enterprise can create public repositories. */\n  membersCanCreatePublicRepositoriesSetting?: Maybe<Scalars[\"Boolean\"]>;\n  /** The setting value for whether members of organizations in the enterprise can create repositories. */\n  membersCanCreateRepositoriesSetting?: Maybe<EnterpriseMembersCanCreateRepositoriesSettingValue>;\n  /** A list of enterprise organizations configured with the provided repository creation setting value. */\n  membersCanCreateRepositoriesSettingOrganizations: OrganizationConnection;\n  /** The setting value for whether members with admin permissions for repositories can delete issues. */\n  membersCanDeleteIssuesSetting: EnterpriseEnabledDisabledSettingValue;\n  /** A list of enterprise organizations configured with the provided members can delete issues setting value. */\n  membersCanDeleteIssuesSettingOrganizations: OrganizationConnection;\n  /** The setting value for whether members with admin permissions for repositories can delete or transfer repositories. */\n  membersCanDeleteRepositoriesSetting: EnterpriseEnabledDisabledSettingValue;\n  /** A list of enterprise organizations configured with the provided members can delete repositories setting value. */\n  membersCanDeleteRepositoriesSettingOrganizations: OrganizationConnection;\n  /** The setting value for whether members of organizations in the enterprise can invite outside collaborators. */\n  membersCanInviteCollaboratorsSetting: EnterpriseEnabledDisabledSettingValue;\n  /** A list of enterprise organizations configured with the provided members can invite collaborators setting value. */\n  membersCanInviteCollaboratorsSettingOrganizations: OrganizationConnection;\n  /** Indicates whether members of this enterprise's organizations can purchase additional services for those organizations. */\n  membersCanMakePurchasesSetting: EnterpriseMembersCanMakePurchasesSettingValue;\n  /** The setting value for whether members with admin permissions for repositories can update protected branches. */\n  membersCanUpdateProtectedBranchesSetting: EnterpriseEnabledDisabledSettingValue;\n  /** A list of enterprise organizations configured with the provided members can update protected branches setting value. */\n  membersCanUpdateProtectedBranchesSettingOrganizations: OrganizationConnection;\n  /** The setting value for whether members can view dependency insights. */\n  membersCanViewDependencyInsightsSetting: EnterpriseEnabledDisabledSettingValue;\n  /** A list of enterprise organizations configured with the provided members can view dependency insights setting value. */\n  membersCanViewDependencyInsightsSettingOrganizations: OrganizationConnection;\n  /** Indicates if email notification delivery for this enterprise is restricted to verified or approved domains. */\n  notificationDeliveryRestrictionEnabledSetting: NotificationRestrictionSettingValue;\n  /** The OIDC Identity Provider for the enterprise. */\n  oidcProvider?: Maybe<OidcProvider>;\n  /** The setting value for whether organization projects are enabled for organizations in this enterprise. */\n  organizationProjectsSetting: EnterpriseEnabledDisabledSettingValue;\n  /** A list of enterprise organizations configured with the provided organization projects setting value. */\n  organizationProjectsSettingOrganizations: OrganizationConnection;\n  /** A list of outside collaborators across the repositories in the enterprise. */\n  outsideCollaborators: EnterpriseOutsideCollaboratorConnection;\n  /** A list of pending administrator invitations for the enterprise. */\n  pendingAdminInvitations: EnterpriseAdministratorInvitationConnection;\n  /** A list of pending collaborator invitations across the repositories in the enterprise. */\n  pendingCollaboratorInvitations: RepositoryInvitationConnection;\n  /** A list of pending member invitations for organizations in the enterprise. */\n  pendingMemberInvitations: EnterprisePendingMemberInvitationConnection;\n  /** The setting value for whether repository projects are enabled in this enterprise. */\n  repositoryProjectsSetting: EnterpriseEnabledDisabledSettingValue;\n  /** A list of enterprise organizations configured with the provided repository projects setting value. */\n  repositoryProjectsSettingOrganizations: OrganizationConnection;\n  /**\n   * The SAML Identity Provider for the enterprise. When used by a GitHub App,\n   * requires an installation token with read and write access to members.\n   */\n  samlIdentityProvider?: Maybe<EnterpriseIdentityProvider>;\n  /** A list of enterprise organizations configured with the SAML single sign-on setting value. */\n  samlIdentityProviderSettingOrganizations: OrganizationConnection;\n  /** A list of members with a support entitlement. */\n  supportEntitlements: EnterpriseMemberConnection;\n  /** The setting value for whether team discussions are enabled for organizations in this enterprise. */\n  teamDiscussionsSetting: EnterpriseEnabledDisabledSettingValue;\n  /** A list of enterprise organizations configured with the provided team discussions setting value. */\n  teamDiscussionsSettingOrganizations: OrganizationConnection;\n  /** The setting value for whether the enterprise requires two-factor authentication for its organizations and users. */\n  twoFactorRequiredSetting: EnterpriseEnabledSettingValue;\n  /** A list of enterprise organizations configured with the two-factor authentication setting value. */\n  twoFactorRequiredSettingOrganizations: OrganizationConnection;\n};\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoAdminsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<EnterpriseMemberOrder>;\n  organizationLogins?: InputMaybe<Array<Scalars[\"String\"]>>;\n  query?: InputMaybe<Scalars[\"String\"]>;\n  role?: InputMaybe<EnterpriseAdministratorRole>;\n};\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoAffiliatedUsersWithTwoFactorDisabledArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoAllowPrivateRepositoryForkingSettingOrganizationsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  value: Scalars[\"Boolean\"];\n};\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoDefaultRepositoryPermissionSettingOrganizationsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  value: DefaultRepositoryPermissionField;\n};\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoDomainsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  isApproved?: InputMaybe<Scalars[\"Boolean\"]>;\n  isVerified?: InputMaybe<Scalars[\"Boolean\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<VerifiableDomainOrder>;\n};\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoEnterpriseServerInstallationsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  connectedOnly?: InputMaybe<Scalars[\"Boolean\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<EnterpriseServerInstallationOrder>;\n};\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoIpAllowListEntriesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<IpAllowListEntryOrder>;\n};\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoMembersCanChangeRepositoryVisibilitySettingOrganizationsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  value: Scalars[\"Boolean\"];\n};\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoMembersCanCreateRepositoriesSettingOrganizationsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  value: OrganizationMembersCanCreateRepositoriesSettingValue;\n};\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoMembersCanDeleteIssuesSettingOrganizationsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  value: Scalars[\"Boolean\"];\n};\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoMembersCanDeleteRepositoriesSettingOrganizationsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  value: Scalars[\"Boolean\"];\n};\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoMembersCanInviteCollaboratorsSettingOrganizationsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  value: Scalars[\"Boolean\"];\n};\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoMembersCanUpdateProtectedBranchesSettingOrganizationsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  value: Scalars[\"Boolean\"];\n};\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoMembersCanViewDependencyInsightsSettingOrganizationsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  value: Scalars[\"Boolean\"];\n};\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoOrganizationProjectsSettingOrganizationsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  value: Scalars[\"Boolean\"];\n};\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoOutsideCollaboratorsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  hasTwoFactorEnabled?: InputMaybe<Scalars[\"Boolean\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  login?: InputMaybe<Scalars[\"String\"]>;\n  orderBy?: InputMaybe<EnterpriseMemberOrder>;\n  organizationLogins?: InputMaybe<Array<Scalars[\"String\"]>>;\n  query?: InputMaybe<Scalars[\"String\"]>;\n  visibility?: InputMaybe<RepositoryVisibility>;\n};\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoPendingAdminInvitationsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<EnterpriseAdministratorInvitationOrder>;\n  query?: InputMaybe<Scalars[\"String\"]>;\n  role?: InputMaybe<EnterpriseAdministratorRole>;\n};\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoPendingCollaboratorInvitationsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<RepositoryInvitationOrder>;\n  query?: InputMaybe<Scalars[\"String\"]>;\n};\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoPendingMemberInvitationsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  organizationLogins?: InputMaybe<Array<Scalars[\"String\"]>>;\n  query?: InputMaybe<Scalars[\"String\"]>;\n};\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoRepositoryProjectsSettingOrganizationsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  value: Scalars[\"Boolean\"];\n};\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoSamlIdentityProviderSettingOrganizationsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  value: IdentityProviderConfigurationState;\n};\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoSupportEntitlementsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<EnterpriseMemberOrder>;\n};\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoTeamDiscussionsSettingOrganizationsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  value: Scalars[\"Boolean\"];\n};\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoTwoFactorRequiredSettingOrganizationsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  value: Scalars[\"Boolean\"];\n};\n\n/** The connection type for OrganizationInvitation. */\nexport type EnterprisePendingMemberInvitationConnection = {\n  __typename?: \"EnterprisePendingMemberInvitationConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterprisePendingMemberInvitationEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<OrganizationInvitation>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n  /** Identifies the total count of unique users in the connection. */\n  totalUniqueUserCount: Scalars[\"Int\"];\n};\n\n/** An invitation to be a member in an enterprise organization. */\nexport type EnterprisePendingMemberInvitationEdge = {\n  __typename?: \"EnterprisePendingMemberInvitationEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<OrganizationInvitation>;\n};\n\n/** A subset of repository information queryable from an enterprise. */\nexport type EnterpriseRepositoryInfo = Node & {\n  __typename?: \"EnterpriseRepositoryInfo\";\n  id: Scalars[\"ID\"];\n  /** Identifies if the repository is private or internal. */\n  isPrivate: Scalars[\"Boolean\"];\n  /** The repository's name. */\n  name: Scalars[\"String\"];\n  /** The repository's name with owner. */\n  nameWithOwner: Scalars[\"String\"];\n};\n\n/** The connection type for EnterpriseRepositoryInfo. */\nexport type EnterpriseRepositoryInfoConnection = {\n  __typename?: \"EnterpriseRepositoryInfoConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseRepositoryInfoEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<EnterpriseRepositoryInfo>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type EnterpriseRepositoryInfoEdge = {\n  __typename?: \"EnterpriseRepositoryInfoEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<EnterpriseRepositoryInfo>;\n};\n\n/** An Enterprise Server installation. */\nexport type EnterpriseServerInstallation = Node & {\n  __typename?: \"EnterpriseServerInstallation\";\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** The customer name to which the Enterprise Server installation belongs. */\n  customerName: Scalars[\"String\"];\n  /** The host name of the Enterprise Server installation. */\n  hostName: Scalars[\"String\"];\n  id: Scalars[\"ID\"];\n  /** Whether or not the installation is connected to an Enterprise Server installation via GitHub Connect. */\n  isConnected: Scalars[\"Boolean\"];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars[\"DateTime\"];\n  /** User accounts on this Enterprise Server installation. */\n  userAccounts: EnterpriseServerUserAccountConnection;\n  /** User accounts uploads for the Enterprise Server installation. */\n  userAccountsUploads: EnterpriseServerUserAccountsUploadConnection;\n};\n\n/** An Enterprise Server installation. */\nexport type EnterpriseServerInstallationUserAccountsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<EnterpriseServerUserAccountOrder>;\n};\n\n/** An Enterprise Server installation. */\nexport type EnterpriseServerInstallationUserAccountsUploadsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<EnterpriseServerUserAccountsUploadOrder>;\n};\n\n/** The connection type for EnterpriseServerInstallation. */\nexport type EnterpriseServerInstallationConnection = {\n  __typename?: \"EnterpriseServerInstallationConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseServerInstallationEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<EnterpriseServerInstallation>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type EnterpriseServerInstallationEdge = {\n  __typename?: \"EnterpriseServerInstallationEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<EnterpriseServerInstallation>;\n};\n\n/** Ordering options for Enterprise Server installation connections. */\nexport type EnterpriseServerInstallationOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order Enterprise Server installations by. */\n  field: EnterpriseServerInstallationOrderField;\n};\n\n/** Properties by which Enterprise Server installation connections can be ordered. */\nexport enum EnterpriseServerInstallationOrderField {\n  /** Order Enterprise Server installations by creation time */\n  CreatedAt = \"CREATED_AT\",\n  /** Order Enterprise Server installations by customer name */\n  CustomerName = \"CUSTOMER_NAME\",\n  /** Order Enterprise Server installations by host name */\n  HostName = \"HOST_NAME\",\n}\n\n/** A user account on an Enterprise Server installation. */\nexport type EnterpriseServerUserAccount = Node & {\n  __typename?: \"EnterpriseServerUserAccount\";\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** User emails belonging to this user account. */\n  emails: EnterpriseServerUserAccountEmailConnection;\n  /** The Enterprise Server installation on which this user account exists. */\n  enterpriseServerInstallation: EnterpriseServerInstallation;\n  id: Scalars[\"ID\"];\n  /** Whether the user account is a site administrator on the Enterprise Server installation. */\n  isSiteAdmin: Scalars[\"Boolean\"];\n  /** The login of the user account on the Enterprise Server installation. */\n  login: Scalars[\"String\"];\n  /** The profile name of the user account on the Enterprise Server installation. */\n  profileName?: Maybe<Scalars[\"String\"]>;\n  /** The date and time when the user account was created on the Enterprise Server installation. */\n  remoteCreatedAt: Scalars[\"DateTime\"];\n  /** The ID of the user account on the Enterprise Server installation. */\n  remoteUserId: Scalars[\"Int\"];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars[\"DateTime\"];\n};\n\n/** A user account on an Enterprise Server installation. */\nexport type EnterpriseServerUserAccountEmailsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<EnterpriseServerUserAccountEmailOrder>;\n};\n\n/** The connection type for EnterpriseServerUserAccount. */\nexport type EnterpriseServerUserAccountConnection = {\n  __typename?: \"EnterpriseServerUserAccountConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseServerUserAccountEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<EnterpriseServerUserAccount>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type EnterpriseServerUserAccountEdge = {\n  __typename?: \"EnterpriseServerUserAccountEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<EnterpriseServerUserAccount>;\n};\n\n/** An email belonging to a user account on an Enterprise Server installation. */\nexport type EnterpriseServerUserAccountEmail = Node & {\n  __typename?: \"EnterpriseServerUserAccountEmail\";\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** The email address. */\n  email: Scalars[\"String\"];\n  id: Scalars[\"ID\"];\n  /** Indicates whether this is the primary email of the associated user account. */\n  isPrimary: Scalars[\"Boolean\"];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars[\"DateTime\"];\n  /** The user account to which the email belongs. */\n  userAccount: EnterpriseServerUserAccount;\n};\n\n/** The connection type for EnterpriseServerUserAccountEmail. */\nexport type EnterpriseServerUserAccountEmailConnection = {\n  __typename?: \"EnterpriseServerUserAccountEmailConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseServerUserAccountEmailEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<EnterpriseServerUserAccountEmail>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type EnterpriseServerUserAccountEmailEdge = {\n  __typename?: \"EnterpriseServerUserAccountEmailEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<EnterpriseServerUserAccountEmail>;\n};\n\n/** Ordering options for Enterprise Server user account email connections. */\nexport type EnterpriseServerUserAccountEmailOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order emails by. */\n  field: EnterpriseServerUserAccountEmailOrderField;\n};\n\n/** Properties by which Enterprise Server user account email connections can be ordered. */\nexport enum EnterpriseServerUserAccountEmailOrderField {\n  /** Order emails by email */\n  Email = \"EMAIL\",\n}\n\n/** Ordering options for Enterprise Server user account connections. */\nexport type EnterpriseServerUserAccountOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order user accounts by. */\n  field: EnterpriseServerUserAccountOrderField;\n};\n\n/** Properties by which Enterprise Server user account connections can be ordered. */\nexport enum EnterpriseServerUserAccountOrderField {\n  /** Order user accounts by login */\n  Login = \"LOGIN\",\n  /** Order user accounts by creation time on the Enterprise Server installation */\n  RemoteCreatedAt = \"REMOTE_CREATED_AT\",\n}\n\n/** A user accounts upload from an Enterprise Server installation. */\nexport type EnterpriseServerUserAccountsUpload = Node & {\n  __typename?: \"EnterpriseServerUserAccountsUpload\";\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** The enterprise to which this upload belongs. */\n  enterprise: Enterprise;\n  /** The Enterprise Server installation for which this upload was generated. */\n  enterpriseServerInstallation: EnterpriseServerInstallation;\n  id: Scalars[\"ID\"];\n  /** The name of the file uploaded. */\n  name: Scalars[\"String\"];\n  /** The synchronization state of the upload */\n  syncState: EnterpriseServerUserAccountsUploadSyncState;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars[\"DateTime\"];\n};\n\n/** The connection type for EnterpriseServerUserAccountsUpload. */\nexport type EnterpriseServerUserAccountsUploadConnection = {\n  __typename?: \"EnterpriseServerUserAccountsUploadConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseServerUserAccountsUploadEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<EnterpriseServerUserAccountsUpload>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type EnterpriseServerUserAccountsUploadEdge = {\n  __typename?: \"EnterpriseServerUserAccountsUploadEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<EnterpriseServerUserAccountsUpload>;\n};\n\n/** Ordering options for Enterprise Server user accounts upload connections. */\nexport type EnterpriseServerUserAccountsUploadOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order user accounts uploads by. */\n  field: EnterpriseServerUserAccountsUploadOrderField;\n};\n\n/** Properties by which Enterprise Server user accounts upload connections can be ordered. */\nexport enum EnterpriseServerUserAccountsUploadOrderField {\n  /** Order user accounts uploads by creation time */\n  CreatedAt = \"CREATED_AT\",\n}\n\n/** Synchronization state of the Enterprise Server user accounts upload */\nexport enum EnterpriseServerUserAccountsUploadSyncState {\n  /** The synchronization of the upload failed. */\n  Failure = \"FAILURE\",\n  /** The synchronization of the upload is pending. */\n  Pending = \"PENDING\",\n  /** The synchronization of the upload succeeded. */\n  Success = \"SUCCESS\",\n}\n\n/** An account for a user who is an admin of an enterprise or a member of an enterprise through one or more organizations. */\nexport type EnterpriseUserAccount = Actor &\n  Node & {\n    __typename?: \"EnterpriseUserAccount\";\n    /** A URL pointing to the enterprise user account's public avatar. */\n    avatarUrl: Scalars[\"URI\"];\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars[\"DateTime\"];\n    /** The enterprise in which this user account exists. */\n    enterprise: Enterprise;\n    id: Scalars[\"ID\"];\n    /** An identifier for the enterprise user account, a login or email address */\n    login: Scalars[\"String\"];\n    /** The name of the enterprise user account */\n    name?: Maybe<Scalars[\"String\"]>;\n    /** A list of enterprise organizations this user is a member of. */\n    organizations: EnterpriseOrganizationMembershipConnection;\n    /** The HTTP path for this user. */\n    resourcePath: Scalars[\"URI\"];\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars[\"DateTime\"];\n    /** The HTTP URL for this user. */\n    url: Scalars[\"URI\"];\n    /** The user within the enterprise. */\n    user?: Maybe<User>;\n  };\n\n/** An account for a user who is an admin of an enterprise or a member of an enterprise through one or more organizations. */\nexport type EnterpriseUserAccountAvatarUrlArgs = {\n  size?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** An account for a user who is an admin of an enterprise or a member of an enterprise through one or more organizations. */\nexport type EnterpriseUserAccountOrganizationsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  query?: InputMaybe<Scalars[\"String\"]>;\n  role?: InputMaybe<EnterpriseUserAccountMembershipRole>;\n};\n\n/** The connection type for EnterpriseUserAccount. */\nexport type EnterpriseUserAccountConnection = {\n  __typename?: \"EnterpriseUserAccountConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseUserAccountEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<EnterpriseUserAccount>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type EnterpriseUserAccountEdge = {\n  __typename?: \"EnterpriseUserAccountEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<EnterpriseUserAccount>;\n};\n\n/** The possible roles for enterprise membership. */\nexport enum EnterpriseUserAccountMembershipRole {\n  /** The user is a member of the enterprise membership. */\n  Member = \"MEMBER\",\n  /** The user is an owner of the enterprise membership. */\n  Owner = \"OWNER\",\n}\n\n/** The possible GitHub Enterprise deployments where this user can exist. */\nexport enum EnterpriseUserDeployment {\n  /** The user is part of a GitHub Enterprise Cloud deployment. */\n  Cloud = \"CLOUD\",\n  /** The user is part of a GitHub Enterprise Server deployment. */\n  Server = \"SERVER\",\n}\n\n/** An environment. */\nexport type Environment = Node & {\n  __typename?: \"Environment\";\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars[\"Int\"]>;\n  id: Scalars[\"ID\"];\n  /** The name of the environment */\n  name: Scalars[\"String\"];\n  /** The protection rules defined for this environment */\n  protectionRules: DeploymentProtectionRuleConnection;\n};\n\n/** An environment. */\nexport type EnvironmentProtectionRulesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** The connection type for Environment. */\nexport type EnvironmentConnection = {\n  __typename?: \"EnvironmentConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnvironmentEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Environment>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type EnvironmentEdge = {\n  __typename?: \"EnvironmentEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<Environment>;\n};\n\n/** An external identity provisioned by SAML SSO or SCIM. */\nexport type ExternalIdentity = Node & {\n  __typename?: \"ExternalIdentity\";\n  /** The GUID for this identity */\n  guid: Scalars[\"String\"];\n  id: Scalars[\"ID\"];\n  /** Organization invitation for this SCIM-provisioned external identity */\n  organizationInvitation?: Maybe<OrganizationInvitation>;\n  /** SAML Identity attributes */\n  samlIdentity?: Maybe<ExternalIdentitySamlAttributes>;\n  /** SCIM Identity attributes */\n  scimIdentity?: Maybe<ExternalIdentityScimAttributes>;\n  /** User linked to this external identity. Will be NULL if this identity has not been claimed by an organization member. */\n  user?: Maybe<User>;\n};\n\n/** The connection type for ExternalIdentity. */\nexport type ExternalIdentityConnection = {\n  __typename?: \"ExternalIdentityConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ExternalIdentityEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ExternalIdentity>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type ExternalIdentityEdge = {\n  __typename?: \"ExternalIdentityEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<ExternalIdentity>;\n};\n\n/** SAML attributes for the External Identity */\nexport type ExternalIdentitySamlAttributes = {\n  __typename?: \"ExternalIdentitySamlAttributes\";\n  /** The emails associated with the SAML identity */\n  emails?: Maybe<Array<UserEmailMetadata>>;\n  /** Family name of the SAML identity */\n  familyName?: Maybe<Scalars[\"String\"]>;\n  /** Given name of the SAML identity */\n  givenName?: Maybe<Scalars[\"String\"]>;\n  /** The groups linked to this identity in IDP */\n  groups?: Maybe<Array<Scalars[\"String\"]>>;\n  /** The NameID of the SAML identity */\n  nameId?: Maybe<Scalars[\"String\"]>;\n  /** The userName of the SAML identity */\n  username?: Maybe<Scalars[\"String\"]>;\n};\n\n/** SCIM attributes for the External Identity */\nexport type ExternalIdentityScimAttributes = {\n  __typename?: \"ExternalIdentityScimAttributes\";\n  /** The emails associated with the SCIM identity */\n  emails?: Maybe<Array<UserEmailMetadata>>;\n  /** Family name of the SCIM identity */\n  familyName?: Maybe<Scalars[\"String\"]>;\n  /** Given name of the SCIM identity */\n  givenName?: Maybe<Scalars[\"String\"]>;\n  /** The groups linked to this identity in IDP */\n  groups?: Maybe<Array<Scalars[\"String\"]>>;\n  /** The userName of the SCIM identity */\n  username?: Maybe<Scalars[\"String\"]>;\n};\n\n/**\n * A command to add a file at the given path with the given contents as part of a\n * commit.  Any existing file at that that path will be replaced.\n */\nexport type FileAddition = {\n  /** The base64 encoded contents of the file */\n  contents: Scalars[\"Base64String\"];\n  /** The path in the repository where the file will be located */\n  path: Scalars[\"String\"];\n};\n\n/**\n * A description of a set of changes to a file tree to be made as part of\n * a git commit, modeled as zero or more file `additions` and zero or more\n * file `deletions`.\n *\n * Both fields are optional; omitting both will produce a commit with no\n * file changes.\n *\n * `deletions` and `additions` describe changes to files identified\n * by their path in the git tree using unix-style path separators, i.e.\n * `/`.  The root of a git tree is an empty string, so paths are not\n * slash-prefixed.\n *\n * `path` values must be unique across all `additions` and `deletions`\n * provided.  Any duplication will result in a validation error.\n *\n * ### Encoding\n *\n * File contents must be provided in full for each `FileAddition`.\n *\n * The `contents` of a `FileAddition` must be encoded using RFC 4648\n * compliant base64, i.e. correct padding is required and no characters\n * outside the standard alphabet may be used.  Invalid base64\n * encoding will be rejected with a validation error.\n *\n * The encoded contents may be binary.\n *\n * For text files, no assumptions are made about the character encoding of\n * the file contents (after base64 decoding).  No charset transcoding or\n * line-ending normalization will be performed; it is the client's\n * responsibility to manage the character encoding of files they provide.\n * However, for maximum compatibility we recommend using UTF-8 encoding\n * and ensuring that all files in a repository use a consistent\n * line-ending convention (`\\n` or `\\r\\n`), and that all files end\n * with a newline.\n *\n * ### Modeling file changes\n *\n * Each of the the five types of conceptual changes that can be made in a\n * git commit can be described using the `FileChanges` type as follows:\n *\n * 1. New file addition: create file `hello world\\n` at path `docs/README.txt`:\n *\n *        {\n *          \"additions\" [\n *            {\n *              \"path\": \"docs/README.txt\",\n *              \"contents\": base64encode(\"hello world\\n\")\n *            }\n *          ]\n *        }\n *\n * 2. Existing file modification: change existing `docs/README.txt` to have new\n *    content `new content here\\n`:\n *\n *        {\n *          \"additions\" [\n *            {\n *              \"path\": \"docs/README.txt\",\n *              \"contents\": base64encode(\"new content here\\n\")\n *            }\n *          ]\n *        }\n *\n * 3. Existing file deletion: remove existing file `docs/README.txt`.\n *    Note that the path is required to exist -- specifying a\n *    path that does not exist on the given branch will abort the\n *    commit and return an error.\n *\n *        {\n *          \"deletions\" [\n *            {\n *              \"path\": \"docs/README.txt\"\n *            }\n *          ]\n *        }\n *\n *\n * 4. File rename with no changes: rename `docs/README.txt` with\n *    previous content `hello world\\n` to the same content at\n *    `newdocs/README.txt`:\n *\n *        {\n *          \"deletions\" [\n *            {\n *              \"path\": \"docs/README.txt\",\n *            }\n *          ],\n *          \"additions\" [\n *            {\n *              \"path\": \"newdocs/README.txt\",\n *              \"contents\": base64encode(\"hello world\\n\")\n *            }\n *          ]\n *        }\n *\n *\n * 5. File rename with changes: rename `docs/README.txt` with\n *    previous content `hello world\\n` to a file at path\n *    `newdocs/README.txt` with content `new contents\\n`:\n *\n *        {\n *          \"deletions\" [\n *            {\n *              \"path\": \"docs/README.txt\",\n *            }\n *          ],\n *          \"additions\" [\n *            {\n *              \"path\": \"newdocs/README.txt\",\n *              \"contents\": base64encode(\"new contents\\n\")\n *            }\n *          ]\n *        }\n */\nexport type FileChanges = {\n  /** File to add or change. */\n  additions?: InputMaybe<Array<FileAddition>>;\n  /** Files to delete. */\n  deletions?: InputMaybe<Array<FileDeletion>>;\n};\n\n/** A command to delete the file at the given path as part of a commit. */\nexport type FileDeletion = {\n  /** The path to delete */\n  path: Scalars[\"String\"];\n};\n\n/** The possible viewed states of a file . */\nexport enum FileViewedState {\n  /** The file has new changes since last viewed. */\n  Dismissed = \"DISMISSED\",\n  /** The file has not been marked as viewed. */\n  Unviewed = \"UNVIEWED\",\n  /** The file has been marked as viewed. */\n  Viewed = \"VIEWED\",\n}\n\n/** Autogenerated input type of FollowOrganization */\nexport type FollowOrganizationInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** ID of the organization to follow. */\n  organizationId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of FollowOrganization */\nexport type FollowOrganizationPayload = {\n  __typename?: \"FollowOrganizationPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The organization that was followed. */\n  organization?: Maybe<Organization>;\n};\n\n/** Autogenerated input type of FollowUser */\nexport type FollowUserInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** ID of the user to follow. */\n  userId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of FollowUser */\nexport type FollowUserPayload = {\n  __typename?: \"FollowUserPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The user that was followed. */\n  user?: Maybe<User>;\n};\n\n/** The connection type for User. */\nexport type FollowerConnection = {\n  __typename?: \"FollowerConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<UserEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** The connection type for User. */\nexport type FollowingConnection = {\n  __typename?: \"FollowingConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<UserEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** A funding platform link for a repository. */\nexport type FundingLink = {\n  __typename?: \"FundingLink\";\n  /** The funding platform this link is for. */\n  platform: FundingPlatform;\n  /** The configured URL for this funding link. */\n  url: Scalars[\"URI\"];\n};\n\n/** The possible funding platforms for repository funding links. */\nexport enum FundingPlatform {\n  /** Community Bridge funding platform. */\n  CommunityBridge = \"COMMUNITY_BRIDGE\",\n  /** Custom funding platform. */\n  Custom = \"CUSTOM\",\n  /** GitHub funding platform. */\n  Github = \"GITHUB\",\n  /** IssueHunt funding platform. */\n  Issuehunt = \"ISSUEHUNT\",\n  /** Ko-fi funding platform. */\n  KoFi = \"KO_FI\",\n  /** LFX Crowdfunding funding platform. */\n  LfxCrowdfunding = \"LFX_CROWDFUNDING\",\n  /** Liberapay funding platform. */\n  Liberapay = \"LIBERAPAY\",\n  /** Open Collective funding platform. */\n  OpenCollective = \"OPEN_COLLECTIVE\",\n  /** Otechie funding platform. */\n  Otechie = \"OTECHIE\",\n  /** Patreon funding platform. */\n  Patreon = \"PATREON\",\n  /** Tidelift funding platform. */\n  Tidelift = \"TIDELIFT\",\n}\n\n/** A generic hovercard context with a message and icon */\nexport type GenericHovercardContext = HovercardContext & {\n  __typename?: \"GenericHovercardContext\";\n  /** A string describing this context */\n  message: Scalars[\"String\"];\n  /** An octicon to accompany this context */\n  octicon: Scalars[\"String\"];\n};\n\n/** A Gist. */\nexport type Gist = Node &\n  Starrable &\n  UniformResourceLocatable & {\n    __typename?: \"Gist\";\n    /** A list of comments associated with the gist */\n    comments: GistCommentConnection;\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars[\"DateTime\"];\n    /** The gist description. */\n    description?: Maybe<Scalars[\"String\"]>;\n    /** The files in this gist. */\n    files?: Maybe<Array<Maybe<GistFile>>>;\n    /** A list of forks associated with the gist */\n    forks: GistConnection;\n    id: Scalars[\"ID\"];\n    /** Identifies if the gist is a fork. */\n    isFork: Scalars[\"Boolean\"];\n    /** Whether the gist is public or not. */\n    isPublic: Scalars[\"Boolean\"];\n    /** The gist name. */\n    name: Scalars[\"String\"];\n    /** The gist owner. */\n    owner?: Maybe<RepositoryOwner>;\n    /** Identifies when the gist was last pushed to. */\n    pushedAt?: Maybe<Scalars[\"DateTime\"]>;\n    /** The HTML path to this resource. */\n    resourcePath: Scalars[\"URI\"];\n    /** Returns a count of how many stargazers there are on this object */\n    stargazerCount: Scalars[\"Int\"];\n    /** A list of users who have starred this starrable. */\n    stargazers: StargazerConnection;\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars[\"DateTime\"];\n    /** The HTTP URL for this Gist. */\n    url: Scalars[\"URI\"];\n    /** Returns a boolean indicating whether the viewing user has starred this starrable. */\n    viewerHasStarred: Scalars[\"Boolean\"];\n  };\n\n/** A Gist. */\nexport type GistCommentsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A Gist. */\nexport type GistFilesArgs = {\n  limit?: InputMaybe<Scalars[\"Int\"]>;\n  oid?: InputMaybe<Scalars[\"GitObjectID\"]>;\n};\n\n/** A Gist. */\nexport type GistForksArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<GistOrder>;\n};\n\n/** A Gist. */\nexport type GistStargazersArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<StarOrder>;\n};\n\n/** Represents a comment on an Gist. */\nexport type GistComment = Comment &\n  Deletable &\n  Minimizable &\n  Node &\n  Updatable &\n  UpdatableComment & {\n    __typename?: \"GistComment\";\n    /** The actor who authored the comment. */\n    author?: Maybe<Actor>;\n    /** Author's association with the gist. */\n    authorAssociation: CommentAuthorAssociation;\n    /** Identifies the comment body. */\n    body: Scalars[\"String\"];\n    /** The body rendered to HTML. */\n    bodyHTML: Scalars[\"HTML\"];\n    /** The body rendered to text. */\n    bodyText: Scalars[\"String\"];\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars[\"DateTime\"];\n    /** Check if this comment was created via an email reply. */\n    createdViaEmail: Scalars[\"Boolean\"];\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars[\"Int\"]>;\n    /** The actor who edited the comment. */\n    editor?: Maybe<Actor>;\n    /** The associated gist. */\n    gist: Gist;\n    id: Scalars[\"ID\"];\n    /** Check if this comment was edited and includes an edit with the creation data */\n    includesCreatedEdit: Scalars[\"Boolean\"];\n    /** Returns whether or not a comment has been minimized. */\n    isMinimized: Scalars[\"Boolean\"];\n    /** The moment the editor made the last edit */\n    lastEditedAt?: Maybe<Scalars[\"DateTime\"]>;\n    /** Returns why the comment was minimized. */\n    minimizedReason?: Maybe<Scalars[\"String\"]>;\n    /** Identifies when the comment was published at. */\n    publishedAt?: Maybe<Scalars[\"DateTime\"]>;\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars[\"DateTime\"];\n    /** A list of edits to this content. */\n    userContentEdits?: Maybe<UserContentEditConnection>;\n    /** Check if the current viewer can delete this object. */\n    viewerCanDelete: Scalars[\"Boolean\"];\n    /** Check if the current viewer can minimize this object. */\n    viewerCanMinimize: Scalars[\"Boolean\"];\n    /** Check if the current viewer can update this object. */\n    viewerCanUpdate: Scalars[\"Boolean\"];\n    /** Reasons why the current viewer can not update this comment. */\n    viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;\n    /** Did the viewer author this comment. */\n    viewerDidAuthor: Scalars[\"Boolean\"];\n  };\n\n/** Represents a comment on an Gist. */\nexport type GistCommentUserContentEditsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** The connection type for GistComment. */\nexport type GistCommentConnection = {\n  __typename?: \"GistCommentConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<GistCommentEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<GistComment>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type GistCommentEdge = {\n  __typename?: \"GistCommentEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<GistComment>;\n};\n\n/** The connection type for Gist. */\nexport type GistConnection = {\n  __typename?: \"GistConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<GistEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Gist>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type GistEdge = {\n  __typename?: \"GistEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<Gist>;\n};\n\n/** A file in a gist. */\nexport type GistFile = {\n  __typename?: \"GistFile\";\n  /** The file name encoded to remove characters that are invalid in URL paths. */\n  encodedName?: Maybe<Scalars[\"String\"]>;\n  /** The gist file encoding. */\n  encoding?: Maybe<Scalars[\"String\"]>;\n  /** The file extension from the file name. */\n  extension?: Maybe<Scalars[\"String\"]>;\n  /** Indicates if this file is an image. */\n  isImage: Scalars[\"Boolean\"];\n  /** Whether the file's contents were truncated. */\n  isTruncated: Scalars[\"Boolean\"];\n  /** The programming language this file is written in. */\n  language?: Maybe<Language>;\n  /** The gist file name. */\n  name?: Maybe<Scalars[\"String\"]>;\n  /** The gist file size in bytes. */\n  size?: Maybe<Scalars[\"Int\"]>;\n  /** UTF8 text data or null if the file is binary */\n  text?: Maybe<Scalars[\"String\"]>;\n};\n\n/** A file in a gist. */\nexport type GistFileTextArgs = {\n  truncate?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** Ordering options for gist connections */\nexport type GistOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order repositories by. */\n  field: GistOrderField;\n};\n\n/** Properties by which gist connections can be ordered. */\nexport enum GistOrderField {\n  /** Order gists by creation time */\n  CreatedAt = \"CREATED_AT\",\n  /** Order gists by push time */\n  PushedAt = \"PUSHED_AT\",\n  /** Order gists by update time */\n  UpdatedAt = \"UPDATED_AT\",\n}\n\n/** The privacy of a Gist */\nexport enum GistPrivacy {\n  /** Gists that are public and secret */\n  All = \"ALL\",\n  /** Public */\n  Public = \"PUBLIC\",\n  /** Secret */\n  Secret = \"SECRET\",\n}\n\n/** Represents an actor in a Git commit (ie. an author or committer). */\nexport type GitActor = {\n  __typename?: \"GitActor\";\n  /** A URL pointing to the author's public avatar. */\n  avatarUrl: Scalars[\"URI\"];\n  /** The timestamp of the Git action (authoring or committing). */\n  date?: Maybe<Scalars[\"GitTimestamp\"]>;\n  /** The email in the Git commit. */\n  email?: Maybe<Scalars[\"String\"]>;\n  /** The name in the Git commit. */\n  name?: Maybe<Scalars[\"String\"]>;\n  /** The GitHub user corresponding to the email field. Null if no such user exists. */\n  user?: Maybe<User>;\n};\n\n/** Represents an actor in a Git commit (ie. an author or committer). */\nexport type GitActorAvatarUrlArgs = {\n  size?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** The connection type for GitActor. */\nexport type GitActorConnection = {\n  __typename?: \"GitActorConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<GitActorEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<GitActor>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type GitActorEdge = {\n  __typename?: \"GitActorEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<GitActor>;\n};\n\n/** Represents information about the GitHub instance. */\nexport type GitHubMetadata = {\n  __typename?: \"GitHubMetadata\";\n  /** Returns a String that's a SHA of `github-services` */\n  gitHubServicesSha: Scalars[\"GitObjectID\"];\n  /** IP addresses that users connect to for git operations */\n  gitIpAddresses?: Maybe<Array<Scalars[\"String\"]>>;\n  /** IP addresses that service hooks are sent from */\n  hookIpAddresses?: Maybe<Array<Scalars[\"String\"]>>;\n  /** IP addresses that the importer connects from */\n  importerIpAddresses?: Maybe<Array<Scalars[\"String\"]>>;\n  /** Whether or not users are verified */\n  isPasswordAuthenticationVerifiable: Scalars[\"Boolean\"];\n  /** IP addresses for GitHub Pages' A records */\n  pagesIpAddresses?: Maybe<Array<Scalars[\"String\"]>>;\n};\n\n/** Represents a Git object. */\nexport type GitObject = {\n  /** An abbreviated version of the Git object ID */\n  abbreviatedOid: Scalars[\"String\"];\n  /** The HTTP path for this Git object */\n  commitResourcePath: Scalars[\"URI\"];\n  /** The HTTP URL for this Git object */\n  commitUrl: Scalars[\"URI\"];\n  id: Scalars[\"ID\"];\n  /** The Git object ID */\n  oid: Scalars[\"GitObjectID\"];\n  /** The Repository the Git object belongs to */\n  repository: Repository;\n};\n\n/** Information about a signature (GPG or S/MIME) on a Commit or Tag. */\nexport type GitSignature = {\n  /** Email used to sign this object. */\n  email: Scalars[\"String\"];\n  /** True if the signature is valid and verified by GitHub. */\n  isValid: Scalars[\"Boolean\"];\n  /** Payload for GPG signing object. Raw ODB object without the signature header. */\n  payload: Scalars[\"String\"];\n  /** ASCII-armored signature header from object. */\n  signature: Scalars[\"String\"];\n  /** GitHub user corresponding to the email signing this commit. */\n  signer?: Maybe<User>;\n  /**\n   * The state of this signature. `VALID` if signature is valid and verified by\n   * GitHub, otherwise represents reason why signature is considered invalid.\n   */\n  state: GitSignatureState;\n  /** True if the signature was made with GitHub's signing key. */\n  wasSignedByGitHub: Scalars[\"Boolean\"];\n};\n\n/** The state of a Git signature. */\nexport enum GitSignatureState {\n  /** The signing certificate or its chain could not be verified */\n  BadCert = \"BAD_CERT\",\n  /** Invalid email used for signing */\n  BadEmail = \"BAD_EMAIL\",\n  /** Signing key expired */\n  ExpiredKey = \"EXPIRED_KEY\",\n  /** Internal error - the GPG verification service misbehaved */\n  GpgverifyError = \"GPGVERIFY_ERROR\",\n  /** Internal error - the GPG verification service is unavailable at the moment */\n  GpgverifyUnavailable = \"GPGVERIFY_UNAVAILABLE\",\n  /** Invalid signature */\n  Invalid = \"INVALID\",\n  /** Malformed signature */\n  MalformedSig = \"MALFORMED_SIG\",\n  /** The usage flags for the key that signed this don't allow signing */\n  NotSigningKey = \"NOT_SIGNING_KEY\",\n  /** Email used for signing not known to GitHub */\n  NoUser = \"NO_USER\",\n  /** Valid signature, though certificate revocation check failed */\n  OcspError = \"OCSP_ERROR\",\n  /** Valid signature, pending certificate revocation checking */\n  OcspPending = \"OCSP_PENDING\",\n  /** One or more certificates in chain has been revoked */\n  OcspRevoked = \"OCSP_REVOKED\",\n  /** Key used for signing not known to GitHub */\n  UnknownKey = \"UNKNOWN_KEY\",\n  /** Unknown signature type */\n  UnknownSigType = \"UNKNOWN_SIG_TYPE\",\n  /** Unsigned */\n  Unsigned = \"UNSIGNED\",\n  /** Email used for signing unverified on GitHub */\n  UnverifiedEmail = \"UNVERIFIED_EMAIL\",\n  /** Valid signature and verified by GitHub */\n  Valid = \"VALID\",\n}\n\n/** Represents a GPG signature on a Commit or Tag. */\nexport type GpgSignature = GitSignature & {\n  __typename?: \"GpgSignature\";\n  /** Email used to sign this object. */\n  email: Scalars[\"String\"];\n  /** True if the signature is valid and verified by GitHub. */\n  isValid: Scalars[\"Boolean\"];\n  /** Hex-encoded ID of the key that signed this object. */\n  keyId?: Maybe<Scalars[\"String\"]>;\n  /** Payload for GPG signing object. Raw ODB object without the signature header. */\n  payload: Scalars[\"String\"];\n  /** ASCII-armored signature header from object. */\n  signature: Scalars[\"String\"];\n  /** GitHub user corresponding to the email signing this commit. */\n  signer?: Maybe<User>;\n  /**\n   * The state of this signature. `VALID` if signature is valid and verified by\n   * GitHub, otherwise represents reason why signature is considered invalid.\n   */\n  state: GitSignatureState;\n  /** True if the signature was made with GitHub's signing key. */\n  wasSignedByGitHub: Scalars[\"Boolean\"];\n};\n\n/** Autogenerated input type of GrantEnterpriseOrganizationsMigratorRole */\nexport type GrantEnterpriseOrganizationsMigratorRoleInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the enterprise to which all organizations managed by it will be granted the migrator role. */\n  enterpriseId: Scalars[\"ID\"];\n  /** The login of the user to grant the migrator role */\n  login: Scalars[\"String\"];\n};\n\n/** Autogenerated return type of GrantEnterpriseOrganizationsMigratorRole */\nexport type GrantEnterpriseOrganizationsMigratorRolePayload = {\n  __typename?: \"GrantEnterpriseOrganizationsMigratorRolePayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The organizations that had the migrator role applied to for the given user. */\n  organizations?: Maybe<OrganizationConnection>;\n};\n\n/** Autogenerated return type of GrantEnterpriseOrganizationsMigratorRole */\nexport type GrantEnterpriseOrganizationsMigratorRolePayloadOrganizationsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** Autogenerated input type of GrantMigratorRole */\nexport type GrantMigratorRoleInput = {\n  /** The user login or Team slug to grant the migrator role. */\n  actor: Scalars[\"String\"];\n  /** Specifies the type of the actor, can be either USER or TEAM. */\n  actorType: ActorType;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the organization that the user/team belongs to. */\n  organizationId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of GrantMigratorRole */\nexport type GrantMigratorRolePayload = {\n  __typename?: \"GrantMigratorRolePayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** Did the operation succeed? */\n  success?: Maybe<Scalars[\"Boolean\"]>;\n};\n\n/** Represents a 'head_ref_deleted' event on a given pull request. */\nexport type HeadRefDeletedEvent = Node & {\n  __typename?: \"HeadRefDeletedEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** Identifies the Ref associated with the `head_ref_deleted` event. */\n  headRef?: Maybe<Ref>;\n  /** Identifies the name of the Ref associated with the `head_ref_deleted` event. */\n  headRefName: Scalars[\"String\"];\n  id: Scalars[\"ID\"];\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest;\n};\n\n/** Represents a 'head_ref_force_pushed' event on a given pull request. */\nexport type HeadRefForcePushedEvent = Node & {\n  __typename?: \"HeadRefForcePushedEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the after commit SHA for the 'head_ref_force_pushed' event. */\n  afterCommit?: Maybe<Commit>;\n  /** Identifies the before commit SHA for the 'head_ref_force_pushed' event. */\n  beforeCommit?: Maybe<Commit>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  id: Scalars[\"ID\"];\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest;\n  /** Identifies the fully qualified ref name for the 'head_ref_force_pushed' event. */\n  ref?: Maybe<Ref>;\n};\n\n/** Represents a 'head_ref_restored' event on a given pull request. */\nexport type HeadRefRestoredEvent = Node & {\n  __typename?: \"HeadRefRestoredEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  id: Scalars[\"ID\"];\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest;\n};\n\n/** Detail needed to display a hovercard for a user */\nexport type Hovercard = {\n  __typename?: \"Hovercard\";\n  /** Each of the contexts for this hovercard */\n  contexts: Array<HovercardContext>;\n};\n\n/** An individual line of a hovercard */\nexport type HovercardContext = {\n  /** A string describing this context */\n  message: Scalars[\"String\"];\n  /** An octicon to accompany this context */\n  octicon: Scalars[\"String\"];\n};\n\n/** The possible states in which authentication can be configured with an identity provider. */\nexport enum IdentityProviderConfigurationState {\n  /** Authentication with an identity provider is configured but not enforced. */\n  Configured = \"CONFIGURED\",\n  /** Authentication with an identity provider is configured and enforced. */\n  Enforced = \"ENFORCED\",\n  /** Authentication with an identity provider is not configured. */\n  Unconfigured = \"UNCONFIGURED\",\n}\n\n/** Autogenerated input type of ImportProject */\nexport type ImportProjectInput = {\n  /** The description of Project. */\n  body?: InputMaybe<Scalars[\"String\"]>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** A list of columns containing issues and pull requests. */\n  columnImports: Array<ProjectColumnImport>;\n  /** The name of Project. */\n  name: Scalars[\"String\"];\n  /** The name of the Organization or User to create the Project under. */\n  ownerName: Scalars[\"String\"];\n  /** Whether the Project is public or not. */\n  public?: InputMaybe<Scalars[\"Boolean\"]>;\n};\n\n/** Autogenerated return type of ImportProject */\nexport type ImportProjectPayload = {\n  __typename?: \"ImportProjectPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The new Project! */\n  project?: Maybe<Project>;\n};\n\n/** Autogenerated input type of InviteEnterpriseAdmin */\nexport type InviteEnterpriseAdminInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The email of the person to invite as an administrator. */\n  email?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the enterprise to which you want to invite an administrator. */\n  enterpriseId: Scalars[\"ID\"];\n  /** The login of a user to invite as an administrator. */\n  invitee?: InputMaybe<Scalars[\"String\"]>;\n  /** The role of the administrator. */\n  role?: InputMaybe<EnterpriseAdministratorRole>;\n};\n\n/** Autogenerated return type of InviteEnterpriseAdmin */\nexport type InviteEnterpriseAdminPayload = {\n  __typename?: \"InviteEnterpriseAdminPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The created enterprise administrator invitation. */\n  invitation?: Maybe<EnterpriseAdministratorInvitation>;\n};\n\n/** The possible values for the IP allow list enabled setting. */\nexport enum IpAllowListEnabledSettingValue {\n  /** The setting is disabled for the owner. */\n  Disabled = \"DISABLED\",\n  /** The setting is enabled for the owner. */\n  Enabled = \"ENABLED\",\n}\n\n/** An IP address or range of addresses that is allowed to access an owner's resources. */\nexport type IpAllowListEntry = Node & {\n  __typename?: \"IpAllowListEntry\";\n  /** A single IP address or range of IP addresses in CIDR notation. */\n  allowListValue: Scalars[\"String\"];\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  id: Scalars[\"ID\"];\n  /** Whether the entry is currently active. */\n  isActive: Scalars[\"Boolean\"];\n  /** The name of the IP allow list entry. */\n  name?: Maybe<Scalars[\"String\"]>;\n  /** The owner of the IP allow list entry. */\n  owner: IpAllowListOwner;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars[\"DateTime\"];\n};\n\n/** The connection type for IpAllowListEntry. */\nexport type IpAllowListEntryConnection = {\n  __typename?: \"IpAllowListEntryConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<IpAllowListEntryEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<IpAllowListEntry>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type IpAllowListEntryEdge = {\n  __typename?: \"IpAllowListEntryEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<IpAllowListEntry>;\n};\n\n/** Ordering options for IP allow list entry connections. */\nexport type IpAllowListEntryOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order IP allow list entries by. */\n  field: IpAllowListEntryOrderField;\n};\n\n/** Properties by which IP allow list entry connections can be ordered. */\nexport enum IpAllowListEntryOrderField {\n  /** Order IP allow list entries by the allow list value. */\n  AllowListValue = \"ALLOW_LIST_VALUE\",\n  /** Order IP allow list entries by creation time. */\n  CreatedAt = \"CREATED_AT\",\n}\n\n/** The possible values for the IP allow list configuration for installed GitHub Apps setting. */\nexport enum IpAllowListForInstalledAppsEnabledSettingValue {\n  /** The setting is disabled for the owner. */\n  Disabled = \"DISABLED\",\n  /** The setting is enabled for the owner. */\n  Enabled = \"ENABLED\",\n}\n\n/** Types that can own an IP allow list. */\nexport type IpAllowListOwner = App | Enterprise | Organization;\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type Issue = Assignable &\n  Closable &\n  Comment &\n  Labelable &\n  Lockable &\n  Node &\n  ProjectNextOwner &\n  ProjectV2Owner &\n  Reactable &\n  RepositoryNode &\n  Subscribable &\n  UniformResourceLocatable &\n  Updatable &\n  UpdatableComment & {\n    __typename?: \"Issue\";\n    /** Reason that the conversation was locked. */\n    activeLockReason?: Maybe<LockReason>;\n    /** A list of Users assigned to this object. */\n    assignees: UserConnection;\n    /** The actor who authored the comment. */\n    author?: Maybe<Actor>;\n    /** Author's association with the subject of the comment. */\n    authorAssociation: CommentAuthorAssociation;\n    /** Identifies the body of the issue. */\n    body: Scalars[\"String\"];\n    /** The body rendered to HTML. */\n    bodyHTML: Scalars[\"HTML\"];\n    /** The http path for this issue body */\n    bodyResourcePath: Scalars[\"URI\"];\n    /** Identifies the body of the issue rendered to text. */\n    bodyText: Scalars[\"String\"];\n    /** The http URL for this issue body */\n    bodyUrl: Scalars[\"URI\"];\n    /** `true` if the object is closed (definition of closed may depend on type) */\n    closed: Scalars[\"Boolean\"];\n    /** Identifies the date and time when the object was closed. */\n    closedAt?: Maybe<Scalars[\"DateTime\"]>;\n    /** A list of comments associated with the Issue. */\n    comments: IssueCommentConnection;\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars[\"DateTime\"];\n    /** Check if this comment was created via an email reply. */\n    createdViaEmail: Scalars[\"Boolean\"];\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars[\"Int\"]>;\n    /** The actor who edited the comment. */\n    editor?: Maybe<Actor>;\n    /** The hovercard information for this issue */\n    hovercard: Hovercard;\n    id: Scalars[\"ID\"];\n    /** Check if this comment was edited and includes an edit with the creation data */\n    includesCreatedEdit: Scalars[\"Boolean\"];\n    /** Indicates whether or not this issue is currently pinned to the repository issues list */\n    isPinned?: Maybe<Scalars[\"Boolean\"]>;\n    /** Is this issue read by the viewer */\n    isReadByViewer?: Maybe<Scalars[\"Boolean\"]>;\n    /** A list of labels associated with the object. */\n    labels?: Maybe<LabelConnection>;\n    /** The moment the editor made the last edit */\n    lastEditedAt?: Maybe<Scalars[\"DateTime\"]>;\n    /** `true` if the object is locked */\n    locked: Scalars[\"Boolean\"];\n    /** Identifies the milestone associated with the issue. */\n    milestone?: Maybe<Milestone>;\n    /** Identifies the issue number. */\n    number: Scalars[\"Int\"];\n    /** A list of Users that are participating in the Issue conversation. */\n    participants: UserConnection;\n    /** List of project cards associated with this issue. */\n    projectCards: ProjectCardConnection;\n    /** Find a project by project (beta) number. */\n    projectNext?: Maybe<ProjectNext>;\n    /** List of project (beta) items associated with this issue. */\n    projectNextItems: ProjectNextItemConnection;\n    /** A list of projects (beta) under the owner. */\n    projectsNext: ProjectNextConnection;\n    /** Identifies when the comment was published at. */\n    publishedAt?: Maybe<Scalars[\"DateTime\"]>;\n    /** A list of reactions grouped by content left on the subject. */\n    reactionGroups?: Maybe<Array<ReactionGroup>>;\n    /** A list of Reactions left on the Issue. */\n    reactions: ReactionConnection;\n    /** The repository associated with this node. */\n    repository: Repository;\n    /** The HTTP path for this issue */\n    resourcePath: Scalars[\"URI\"];\n    /** Identifies the state of the issue. */\n    state: IssueState;\n    /**\n     * A list of events, comments, commits, etc. associated with the issue.\n     * @deprecated `timeline` will be removed Use Issue.timelineItems instead. Removal on 2020-10-01 UTC.\n     */\n    timeline: IssueTimelineConnection;\n    /** A list of events, comments, commits, etc. associated with the issue. */\n    timelineItems: IssueTimelineItemsConnection;\n    /** Identifies the issue title. */\n    title: Scalars[\"String\"];\n    /** Identifies the issue title rendered to HTML. */\n    titleHTML: Scalars[\"String\"];\n    /** A list of issues that track this issue */\n    trackedInIssues: IssueConnection;\n    /** A list of issues tracked inside the current issue */\n    trackedIssues: IssueConnection;\n    /** The number of tracked issues for this issue */\n    trackedIssuesCount: Scalars[\"Int\"];\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars[\"DateTime\"];\n    /** The HTTP URL for this issue */\n    url: Scalars[\"URI\"];\n    /** A list of edits to this content. */\n    userContentEdits?: Maybe<UserContentEditConnection>;\n    /** Can user react to this subject */\n    viewerCanReact: Scalars[\"Boolean\"];\n    /** Check if the viewer is able to change their subscription status for the repository. */\n    viewerCanSubscribe: Scalars[\"Boolean\"];\n    /** Check if the current viewer can update this object. */\n    viewerCanUpdate: Scalars[\"Boolean\"];\n    /** Reasons why the current viewer can not update this comment. */\n    viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;\n    /** Did the viewer author this comment. */\n    viewerDidAuthor: Scalars[\"Boolean\"];\n    /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */\n    viewerSubscription?: Maybe<SubscriptionState>;\n  };\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueAssigneesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueCommentsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<IssueCommentOrder>;\n};\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueHovercardArgs = {\n  includeNotificationContexts?: InputMaybe<Scalars[\"Boolean\"]>;\n};\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueLabelsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<LabelOrder>;\n};\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueParticipantsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueProjectCardsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  archivedStates?: InputMaybe<Array<InputMaybe<ProjectCardArchivedState>>>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueProjectNextArgs = {\n  number: Scalars[\"Int\"];\n};\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueProjectNextItemsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  includeArchived?: InputMaybe<Scalars[\"Boolean\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueProjectsNextArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  query?: InputMaybe<Scalars[\"String\"]>;\n  sortBy?: InputMaybe<ProjectNextOrderField>;\n};\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueReactionsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  content?: InputMaybe<ReactionContent>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<ReactionOrder>;\n};\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueTimelineArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  since?: InputMaybe<Scalars[\"DateTime\"]>;\n};\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueTimelineItemsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  itemTypes?: InputMaybe<Array<IssueTimelineItemsItemType>>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  since?: InputMaybe<Scalars[\"DateTime\"]>;\n  skip?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueTrackedInIssuesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueTrackedIssuesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueTrackedIssuesCountArgs = {\n  states?: InputMaybe<Array<InputMaybe<TrackedIssueStates>>>;\n};\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueUserContentEditsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** Represents a comment on an Issue. */\nexport type IssueComment = Comment &\n  Deletable &\n  Minimizable &\n  Node &\n  Reactable &\n  RepositoryNode &\n  Updatable &\n  UpdatableComment & {\n    __typename?: \"IssueComment\";\n    /** The actor who authored the comment. */\n    author?: Maybe<Actor>;\n    /** Author's association with the subject of the comment. */\n    authorAssociation: CommentAuthorAssociation;\n    /** The body as Markdown. */\n    body: Scalars[\"String\"];\n    /** The body rendered to HTML. */\n    bodyHTML: Scalars[\"HTML\"];\n    /** The body rendered to text. */\n    bodyText: Scalars[\"String\"];\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars[\"DateTime\"];\n    /** Check if this comment was created via an email reply. */\n    createdViaEmail: Scalars[\"Boolean\"];\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars[\"Int\"]>;\n    /** The actor who edited the comment. */\n    editor?: Maybe<Actor>;\n    id: Scalars[\"ID\"];\n    /** Check if this comment was edited and includes an edit with the creation data */\n    includesCreatedEdit: Scalars[\"Boolean\"];\n    /** Returns whether or not a comment has been minimized. */\n    isMinimized: Scalars[\"Boolean\"];\n    /** Identifies the issue associated with the comment. */\n    issue: Issue;\n    /** The moment the editor made the last edit */\n    lastEditedAt?: Maybe<Scalars[\"DateTime\"]>;\n    /** Returns why the comment was minimized. */\n    minimizedReason?: Maybe<Scalars[\"String\"]>;\n    /** Identifies when the comment was published at. */\n    publishedAt?: Maybe<Scalars[\"DateTime\"]>;\n    /**\n     * Returns the pull request associated with the comment, if this comment was made on a\n     * pull request.\n     */\n    pullRequest?: Maybe<PullRequest>;\n    /** A list of reactions grouped by content left on the subject. */\n    reactionGroups?: Maybe<Array<ReactionGroup>>;\n    /** A list of Reactions left on the Issue. */\n    reactions: ReactionConnection;\n    /** The repository associated with this node. */\n    repository: Repository;\n    /** The HTTP path for this issue comment */\n    resourcePath: Scalars[\"URI\"];\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars[\"DateTime\"];\n    /** The HTTP URL for this issue comment */\n    url: Scalars[\"URI\"];\n    /** A list of edits to this content. */\n    userContentEdits?: Maybe<UserContentEditConnection>;\n    /** Check if the current viewer can delete this object. */\n    viewerCanDelete: Scalars[\"Boolean\"];\n    /** Check if the current viewer can minimize this object. */\n    viewerCanMinimize: Scalars[\"Boolean\"];\n    /** Can user react to this subject */\n    viewerCanReact: Scalars[\"Boolean\"];\n    /** Check if the current viewer can update this object. */\n    viewerCanUpdate: Scalars[\"Boolean\"];\n    /** Reasons why the current viewer can not update this comment. */\n    viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;\n    /** Did the viewer author this comment. */\n    viewerDidAuthor: Scalars[\"Boolean\"];\n  };\n\n/** Represents a comment on an Issue. */\nexport type IssueCommentReactionsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  content?: InputMaybe<ReactionContent>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<ReactionOrder>;\n};\n\n/** Represents a comment on an Issue. */\nexport type IssueCommentUserContentEditsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** The connection type for IssueComment. */\nexport type IssueCommentConnection = {\n  __typename?: \"IssueCommentConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<IssueCommentEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<IssueComment>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type IssueCommentEdge = {\n  __typename?: \"IssueCommentEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<IssueComment>;\n};\n\n/** Ways in which lists of issue comments can be ordered upon return. */\nexport type IssueCommentOrder = {\n  /** The direction in which to order issue comments by the specified field. */\n  direction: OrderDirection;\n  /** The field in which to order issue comments by. */\n  field: IssueCommentOrderField;\n};\n\n/** Properties by which issue comment connections can be ordered. */\nexport enum IssueCommentOrderField {\n  /** Order issue comments by update time */\n  UpdatedAt = \"UPDATED_AT\",\n}\n\n/** The connection type for Issue. */\nexport type IssueConnection = {\n  __typename?: \"IssueConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<IssueEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Issue>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** This aggregates issues opened by a user within one repository. */\nexport type IssueContributionsByRepository = {\n  __typename?: \"IssueContributionsByRepository\";\n  /** The issue contributions. */\n  contributions: CreatedIssueContributionConnection;\n  /** The repository in which the issues were opened. */\n  repository: Repository;\n};\n\n/** This aggregates issues opened by a user within one repository. */\nexport type IssueContributionsByRepositoryContributionsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<ContributionOrder>;\n};\n\n/** An edge in a connection. */\nexport type IssueEdge = {\n  __typename?: \"IssueEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<Issue>;\n};\n\n/** Ways in which to filter lists of issues. */\nexport type IssueFilters = {\n  /**\n   * List issues assigned to given name. Pass in `null` for issues with no assigned\n   * user, and `*` for issues assigned to any user.\n   */\n  assignee?: InputMaybe<Scalars[\"String\"]>;\n  /** List issues created by given name. */\n  createdBy?: InputMaybe<Scalars[\"String\"]>;\n  /** List issues where the list of label names exist on the issue. */\n  labels?: InputMaybe<Array<Scalars[\"String\"]>>;\n  /** List issues where the given name is mentioned in the issue. */\n  mentioned?: InputMaybe<Scalars[\"String\"]>;\n  /**\n   * List issues by given milestone argument. If an string representation of an\n   * integer is passed, it should refer to a milestone by its database ID. Pass in\n   * `null` for issues with no milestone, and `*` for issues that are assigned to any milestone.\n   */\n  milestone?: InputMaybe<Scalars[\"String\"]>;\n  /**\n   * List issues by given milestone argument. If an string representation of an\n   * integer is passed, it should refer to a milestone by its number field. Pass in\n   * `null` for issues with no milestone, and `*` for issues that are assigned to any milestone.\n   */\n  milestoneNumber?: InputMaybe<Scalars[\"String\"]>;\n  /** List issues that have been updated at or after the given date. */\n  since?: InputMaybe<Scalars[\"DateTime\"]>;\n  /** List issues filtered by the list of states given. */\n  states?: InputMaybe<Array<IssueState>>;\n  /** List issues subscribed to by viewer. */\n  viewerSubscribed?: InputMaybe<Scalars[\"Boolean\"]>;\n};\n\n/** Used for return value of Repository.issueOrPullRequest. */\nexport type IssueOrPullRequest = Issue | PullRequest;\n\n/** Ways in which lists of issues can be ordered upon return. */\nexport type IssueOrder = {\n  /** The direction in which to order issues by the specified field. */\n  direction: OrderDirection;\n  /** The field in which to order issues by. */\n  field: IssueOrderField;\n};\n\n/** Properties by which issue connections can be ordered. */\nexport enum IssueOrderField {\n  /** Order issues by comment count */\n  Comments = \"COMMENTS\",\n  /** Order issues by creation time */\n  CreatedAt = \"CREATED_AT\",\n  /** Order issues by update time */\n  UpdatedAt = \"UPDATED_AT\",\n}\n\n/** The possible states of an issue. */\nexport enum IssueState {\n  /** An issue that has been closed */\n  Closed = \"CLOSED\",\n  /** An issue that is still open */\n  Open = \"OPEN\",\n}\n\n/** A repository issue template. */\nexport type IssueTemplate = {\n  __typename?: \"IssueTemplate\";\n  /** The template purpose. */\n  about?: Maybe<Scalars[\"String\"]>;\n  /** The suggested issue body. */\n  body?: Maybe<Scalars[\"String\"]>;\n  /** The template name. */\n  name: Scalars[\"String\"];\n  /** The suggested issue title. */\n  title?: Maybe<Scalars[\"String\"]>;\n};\n\n/** The connection type for IssueTimelineItem. */\nexport type IssueTimelineConnection = {\n  __typename?: \"IssueTimelineConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<IssueTimelineItemEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<IssueTimelineItem>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An item in an issue timeline */\nexport type IssueTimelineItem =\n  | AssignedEvent\n  | ClosedEvent\n  | Commit\n  | CrossReferencedEvent\n  | DemilestonedEvent\n  | IssueComment\n  | LabeledEvent\n  | LockedEvent\n  | MilestonedEvent\n  | ReferencedEvent\n  | RenamedTitleEvent\n  | ReopenedEvent\n  | SubscribedEvent\n  | TransferredEvent\n  | UnassignedEvent\n  | UnlabeledEvent\n  | UnlockedEvent\n  | UnsubscribedEvent\n  | UserBlockedEvent;\n\n/** An edge in a connection. */\nexport type IssueTimelineItemEdge = {\n  __typename?: \"IssueTimelineItemEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<IssueTimelineItem>;\n};\n\n/** An item in an issue timeline */\nexport type IssueTimelineItems =\n  | AddedToProjectEvent\n  | AssignedEvent\n  | ClosedEvent\n  | CommentDeletedEvent\n  | ConnectedEvent\n  | ConvertedNoteToIssueEvent\n  | ConvertedToDiscussionEvent\n  | CrossReferencedEvent\n  | DemilestonedEvent\n  | DisconnectedEvent\n  | IssueComment\n  | LabeledEvent\n  | LockedEvent\n  | MarkedAsDuplicateEvent\n  | MentionedEvent\n  | MilestonedEvent\n  | MovedColumnsInProjectEvent\n  | PinnedEvent\n  | ReferencedEvent\n  | RemovedFromProjectEvent\n  | RenamedTitleEvent\n  | ReopenedEvent\n  | SubscribedEvent\n  | TransferredEvent\n  | UnassignedEvent\n  | UnlabeledEvent\n  | UnlockedEvent\n  | UnmarkedAsDuplicateEvent\n  | UnpinnedEvent\n  | UnsubscribedEvent\n  | UserBlockedEvent;\n\n/** The connection type for IssueTimelineItems. */\nexport type IssueTimelineItemsConnection = {\n  __typename?: \"IssueTimelineItemsConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<IssueTimelineItemsEdge>>>;\n  /** Identifies the count of items after applying `before` and `after` filters. */\n  filteredCount: Scalars[\"Int\"];\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<IssueTimelineItems>>>;\n  /** Identifies the count of items after applying `before`/`after` filters and `first`/`last`/`skip` slicing. */\n  pageCount: Scalars[\"Int\"];\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n  /** Identifies the date and time when the timeline was last updated. */\n  updatedAt: Scalars[\"DateTime\"];\n};\n\n/** An edge in a connection. */\nexport type IssueTimelineItemsEdge = {\n  __typename?: \"IssueTimelineItemsEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<IssueTimelineItems>;\n};\n\n/** The possible item types found in a timeline. */\nexport enum IssueTimelineItemsItemType {\n  /** Represents a 'added_to_project' event on a given issue or pull request. */\n  AddedToProjectEvent = \"ADDED_TO_PROJECT_EVENT\",\n  /** Represents an 'assigned' event on any assignable object. */\n  AssignedEvent = \"ASSIGNED_EVENT\",\n  /** Represents a 'closed' event on any `Closable`. */\n  ClosedEvent = \"CLOSED_EVENT\",\n  /** Represents a 'comment_deleted' event on a given issue or pull request. */\n  CommentDeletedEvent = \"COMMENT_DELETED_EVENT\",\n  /** Represents a 'connected' event on a given issue or pull request. */\n  ConnectedEvent = \"CONNECTED_EVENT\",\n  /** Represents a 'converted_note_to_issue' event on a given issue or pull request. */\n  ConvertedNoteToIssueEvent = \"CONVERTED_NOTE_TO_ISSUE_EVENT\",\n  /** Represents a 'converted_to_discussion' event on a given issue. */\n  ConvertedToDiscussionEvent = \"CONVERTED_TO_DISCUSSION_EVENT\",\n  /** Represents a mention made by one issue or pull request to another. */\n  CrossReferencedEvent = \"CROSS_REFERENCED_EVENT\",\n  /** Represents a 'demilestoned' event on a given issue or pull request. */\n  DemilestonedEvent = \"DEMILESTONED_EVENT\",\n  /** Represents a 'disconnected' event on a given issue or pull request. */\n  DisconnectedEvent = \"DISCONNECTED_EVENT\",\n  /** Represents a comment on an Issue. */\n  IssueComment = \"ISSUE_COMMENT\",\n  /** Represents a 'labeled' event on a given issue or pull request. */\n  LabeledEvent = \"LABELED_EVENT\",\n  /** Represents a 'locked' event on a given issue or pull request. */\n  LockedEvent = \"LOCKED_EVENT\",\n  /** Represents a 'marked_as_duplicate' event on a given issue or pull request. */\n  MarkedAsDuplicateEvent = \"MARKED_AS_DUPLICATE_EVENT\",\n  /** Represents a 'mentioned' event on a given issue or pull request. */\n  MentionedEvent = \"MENTIONED_EVENT\",\n  /** Represents a 'milestoned' event on a given issue or pull request. */\n  MilestonedEvent = \"MILESTONED_EVENT\",\n  /** Represents a 'moved_columns_in_project' event on a given issue or pull request. */\n  MovedColumnsInProjectEvent = \"MOVED_COLUMNS_IN_PROJECT_EVENT\",\n  /** Represents a 'pinned' event on a given issue or pull request. */\n  PinnedEvent = \"PINNED_EVENT\",\n  /** Represents a 'referenced' event on a given `ReferencedSubject`. */\n  ReferencedEvent = \"REFERENCED_EVENT\",\n  /** Represents a 'removed_from_project' event on a given issue or pull request. */\n  RemovedFromProjectEvent = \"REMOVED_FROM_PROJECT_EVENT\",\n  /** Represents a 'renamed' event on a given issue or pull request */\n  RenamedTitleEvent = \"RENAMED_TITLE_EVENT\",\n  /** Represents a 'reopened' event on any `Closable`. */\n  ReopenedEvent = \"REOPENED_EVENT\",\n  /** Represents a 'subscribed' event on a given `Subscribable`. */\n  SubscribedEvent = \"SUBSCRIBED_EVENT\",\n  /** Represents a 'transferred' event on a given issue or pull request. */\n  TransferredEvent = \"TRANSFERRED_EVENT\",\n  /** Represents an 'unassigned' event on any assignable object. */\n  UnassignedEvent = \"UNASSIGNED_EVENT\",\n  /** Represents an 'unlabeled' event on a given issue or pull request. */\n  UnlabeledEvent = \"UNLABELED_EVENT\",\n  /** Represents an 'unlocked' event on a given issue or pull request. */\n  UnlockedEvent = \"UNLOCKED_EVENT\",\n  /** Represents an 'unmarked_as_duplicate' event on a given issue or pull request. */\n  UnmarkedAsDuplicateEvent = \"UNMARKED_AS_DUPLICATE_EVENT\",\n  /** Represents an 'unpinned' event on a given issue or pull request. */\n  UnpinnedEvent = \"UNPINNED_EVENT\",\n  /** Represents an 'unsubscribed' event on a given `Subscribable`. */\n  UnsubscribedEvent = \"UNSUBSCRIBED_EVENT\",\n  /** Represents a 'user_blocked' event on a given user. */\n  UserBlockedEvent = \"USER_BLOCKED_EVENT\",\n}\n\n/** Represents a user signing up for a GitHub account. */\nexport type JoinedGitHubContribution = Contribution & {\n  __typename?: \"JoinedGitHubContribution\";\n  /**\n   * Whether this contribution is associated with a record you do not have access to. For\n   * example, your own 'first issue' contribution may have been made on a repository you can no\n   * longer access.\n   */\n  isRestricted: Scalars[\"Boolean\"];\n  /** When this contribution was made. */\n  occurredAt: Scalars[\"DateTime\"];\n  /** The HTTP path for this contribution. */\n  resourcePath: Scalars[\"URI\"];\n  /** The HTTP URL for this contribution. */\n  url: Scalars[\"URI\"];\n  /** The user who made this contribution. */\n  user: User;\n};\n\n/** A label for categorizing Issues, Pull Requests, Milestones, or Discussions with a given Repository. */\nexport type Label = Node & {\n  __typename?: \"Label\";\n  /** Identifies the label color. */\n  color: Scalars[\"String\"];\n  /** Identifies the date and time when the label was created. */\n  createdAt?: Maybe<Scalars[\"DateTime\"]>;\n  /** A brief description of this label. */\n  description?: Maybe<Scalars[\"String\"]>;\n  id: Scalars[\"ID\"];\n  /** Indicates whether or not this is a default label. */\n  isDefault: Scalars[\"Boolean\"];\n  /** A list of issues associated with this label. */\n  issues: IssueConnection;\n  /** Identifies the label name. */\n  name: Scalars[\"String\"];\n  /** A list of pull requests associated with this label. */\n  pullRequests: PullRequestConnection;\n  /** The repository associated with this label. */\n  repository: Repository;\n  /** The HTTP path for this label. */\n  resourcePath: Scalars[\"URI\"];\n  /** Identifies the date and time when the label was last updated. */\n  updatedAt?: Maybe<Scalars[\"DateTime\"]>;\n  /** The HTTP URL for this label. */\n  url: Scalars[\"URI\"];\n};\n\n/** A label for categorizing Issues, Pull Requests, Milestones, or Discussions with a given Repository. */\nexport type LabelIssuesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  filterBy?: InputMaybe<IssueFilters>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  labels?: InputMaybe<Array<Scalars[\"String\"]>>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<IssueOrder>;\n  states?: InputMaybe<Array<IssueState>>;\n};\n\n/** A label for categorizing Issues, Pull Requests, Milestones, or Discussions with a given Repository. */\nexport type LabelPullRequestsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  baseRefName?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  headRefName?: InputMaybe<Scalars[\"String\"]>;\n  labels?: InputMaybe<Array<Scalars[\"String\"]>>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<IssueOrder>;\n  states?: InputMaybe<Array<PullRequestState>>;\n};\n\n/** The connection type for Label. */\nexport type LabelConnection = {\n  __typename?: \"LabelConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<LabelEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Label>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type LabelEdge = {\n  __typename?: \"LabelEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<Label>;\n};\n\n/** Ways in which lists of labels can be ordered upon return. */\nexport type LabelOrder = {\n  /** The direction in which to order labels by the specified field. */\n  direction: OrderDirection;\n  /** The field in which to order labels by. */\n  field: LabelOrderField;\n};\n\n/** Properties by which label connections can be ordered. */\nexport enum LabelOrderField {\n  /** Order labels by creation time */\n  CreatedAt = \"CREATED_AT\",\n  /** Order labels by name */\n  Name = \"NAME\",\n}\n\n/** An object that can have labels assigned to it. */\nexport type Labelable = {\n  /** A list of labels associated with the object. */\n  labels?: Maybe<LabelConnection>;\n};\n\n/** An object that can have labels assigned to it. */\nexport type LabelableLabelsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<LabelOrder>;\n};\n\n/** Represents a 'labeled' event on a given issue or pull request. */\nexport type LabeledEvent = Node & {\n  __typename?: \"LabeledEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  id: Scalars[\"ID\"];\n  /** Identifies the label associated with the 'labeled' event. */\n  label: Label;\n  /** Identifies the `Labelable` associated with the event. */\n  labelable: Labelable;\n};\n\n/** Represents a given language found in repositories. */\nexport type Language = Node & {\n  __typename?: \"Language\";\n  /** The color defined for the current language. */\n  color?: Maybe<Scalars[\"String\"]>;\n  id: Scalars[\"ID\"];\n  /** The name of the current language. */\n  name: Scalars[\"String\"];\n};\n\n/** A list of languages associated with the parent. */\nexport type LanguageConnection = {\n  __typename?: \"LanguageConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<LanguageEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Language>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n  /** The total size in bytes of files written in that language. */\n  totalSize: Scalars[\"Int\"];\n};\n\n/** Represents the language of a repository. */\nexport type LanguageEdge = {\n  __typename?: \"LanguageEdge\";\n  cursor: Scalars[\"String\"];\n  node: Language;\n  /** The number of bytes of code written in the language. */\n  size: Scalars[\"Int\"];\n};\n\n/** Ordering options for language connections. */\nexport type LanguageOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order languages by. */\n  field: LanguageOrderField;\n};\n\n/** Properties by which language connections can be ordered. */\nexport enum LanguageOrderField {\n  /** Order languages by the size of all files containing the language */\n  Size = \"SIZE\",\n}\n\n/** A repository's open source license */\nexport type License = Node & {\n  __typename?: \"License\";\n  /** The full text of the license */\n  body: Scalars[\"String\"];\n  /** The conditions set by the license */\n  conditions: Array<Maybe<LicenseRule>>;\n  /** A human-readable description of the license */\n  description?: Maybe<Scalars[\"String\"]>;\n  /** Whether the license should be featured */\n  featured: Scalars[\"Boolean\"];\n  /** Whether the license should be displayed in license pickers */\n  hidden: Scalars[\"Boolean\"];\n  id: Scalars[\"ID\"];\n  /** Instructions on how to implement the license */\n  implementation?: Maybe<Scalars[\"String\"]>;\n  /** The lowercased SPDX ID of the license */\n  key: Scalars[\"String\"];\n  /** The limitations set by the license */\n  limitations: Array<Maybe<LicenseRule>>;\n  /** The license full name specified by <https://spdx.org/licenses> */\n  name: Scalars[\"String\"];\n  /** Customary short name if applicable (e.g, GPLv3) */\n  nickname?: Maybe<Scalars[\"String\"]>;\n  /** The permissions set by the license */\n  permissions: Array<Maybe<LicenseRule>>;\n  /** Whether the license is a pseudo-license placeholder (e.g., other, no-license) */\n  pseudoLicense: Scalars[\"Boolean\"];\n  /** Short identifier specified by <https://spdx.org/licenses> */\n  spdxId?: Maybe<Scalars[\"String\"]>;\n  /** URL to the license on <https://choosealicense.com> */\n  url?: Maybe<Scalars[\"URI\"]>;\n};\n\n/** Describes a License's conditions, permissions, and limitations */\nexport type LicenseRule = {\n  __typename?: \"LicenseRule\";\n  /** A description of the rule */\n  description: Scalars[\"String\"];\n  /** The machine-readable rule key */\n  key: Scalars[\"String\"];\n  /** The human-readable rule label */\n  label: Scalars[\"String\"];\n};\n\n/** Autogenerated input type of LinkRepositoryToProject */\nexport type LinkRepositoryToProjectInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the Project to link to a Repository */\n  projectId: Scalars[\"ID\"];\n  /** The ID of the Repository to link to a Project. */\n  repositoryId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of LinkRepositoryToProject */\nexport type LinkRepositoryToProjectPayload = {\n  __typename?: \"LinkRepositoryToProjectPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The linked Project. */\n  project?: Maybe<Project>;\n  /** The linked Repository. */\n  repository?: Maybe<Repository>;\n};\n\n/** Autogenerated input type of LockLockable */\nexport type LockLockableInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** A reason for why the item will be locked. */\n  lockReason?: InputMaybe<LockReason>;\n  /** ID of the item to be locked. */\n  lockableId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of LockLockable */\nexport type LockLockablePayload = {\n  __typename?: \"LockLockablePayload\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The item that was locked. */\n  lockedRecord?: Maybe<Lockable>;\n};\n\n/** The possible reasons that an issue or pull request was locked. */\nexport enum LockReason {\n  /** The issue or pull request was locked because the conversation was off-topic. */\n  OffTopic = \"OFF_TOPIC\",\n  /** The issue or pull request was locked because the conversation was resolved. */\n  Resolved = \"RESOLVED\",\n  /** The issue or pull request was locked because the conversation was spam. */\n  Spam = \"SPAM\",\n  /** The issue or pull request was locked because the conversation was too heated. */\n  TooHeated = \"TOO_HEATED\",\n}\n\n/** An object that can be locked. */\nexport type Lockable = {\n  /** Reason that the conversation was locked. */\n  activeLockReason?: Maybe<LockReason>;\n  /** `true` if the object is locked */\n  locked: Scalars[\"Boolean\"];\n};\n\n/** Represents a 'locked' event on a given issue or pull request. */\nexport type LockedEvent = Node & {\n  __typename?: \"LockedEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  id: Scalars[\"ID\"];\n  /** Reason that the conversation was locked (optional). */\n  lockReason?: Maybe<LockReason>;\n  /** Object that was locked. */\n  lockable: Lockable;\n};\n\n/** A placeholder user for attribution of imported data on GitHub. */\nexport type Mannequin = Actor &\n  Node &\n  UniformResourceLocatable & {\n    __typename?: \"Mannequin\";\n    /** A URL pointing to the GitHub App's public avatar. */\n    avatarUrl: Scalars[\"URI\"];\n    /** The user that has claimed the data attributed to this mannequin. */\n    claimant?: Maybe<User>;\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars[\"DateTime\"];\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars[\"Int\"]>;\n    /** The mannequin's email on the source instance. */\n    email?: Maybe<Scalars[\"String\"]>;\n    id: Scalars[\"ID\"];\n    /** The username of the actor. */\n    login: Scalars[\"String\"];\n    /** The HTML path to this resource. */\n    resourcePath: Scalars[\"URI\"];\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars[\"DateTime\"];\n    /** The URL to this resource. */\n    url: Scalars[\"URI\"];\n  };\n\n/** A placeholder user for attribution of imported data on GitHub. */\nexport type MannequinAvatarUrlArgs = {\n  size?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** Autogenerated input type of MarkDiscussionCommentAsAnswer */\nexport type MarkDiscussionCommentAsAnswerInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The Node ID of the discussion comment to mark as an answer. */\n  id: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of MarkDiscussionCommentAsAnswer */\nexport type MarkDiscussionCommentAsAnswerPayload = {\n  __typename?: \"MarkDiscussionCommentAsAnswerPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The discussion that includes the chosen comment. */\n  discussion?: Maybe<Discussion>;\n};\n\n/** Autogenerated input type of MarkFileAsViewed */\nexport type MarkFileAsViewedInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The path of the file to mark as viewed */\n  path: Scalars[\"String\"];\n  /** The Node ID of the pull request. */\n  pullRequestId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of MarkFileAsViewed */\nexport type MarkFileAsViewedPayload = {\n  __typename?: \"MarkFileAsViewedPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The updated pull request. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Autogenerated input type of MarkPullRequestReadyForReview */\nexport type MarkPullRequestReadyForReviewInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** ID of the pull request to be marked as ready for review. */\n  pullRequestId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of MarkPullRequestReadyForReview */\nexport type MarkPullRequestReadyForReviewPayload = {\n  __typename?: \"MarkPullRequestReadyForReviewPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The pull request that is ready for review. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Represents a 'marked_as_duplicate' event on a given issue or pull request. */\nexport type MarkedAsDuplicateEvent = Node & {\n  __typename?: \"MarkedAsDuplicateEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** The authoritative issue or pull request which has been duplicated by another. */\n  canonical?: Maybe<IssueOrPullRequest>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** The issue or pull request which has been marked as a duplicate of another. */\n  duplicate?: Maybe<IssueOrPullRequest>;\n  id: Scalars[\"ID\"];\n  /** Canonical and duplicate belong to different repositories. */\n  isCrossRepository: Scalars[\"Boolean\"];\n};\n\n/** A public description of a Marketplace category. */\nexport type MarketplaceCategory = Node & {\n  __typename?: \"MarketplaceCategory\";\n  /** The category's description. */\n  description?: Maybe<Scalars[\"String\"]>;\n  /** The technical description of how apps listed in this category work with GitHub. */\n  howItWorks?: Maybe<Scalars[\"String\"]>;\n  id: Scalars[\"ID\"];\n  /** The category's name. */\n  name: Scalars[\"String\"];\n  /** How many Marketplace listings have this as their primary category. */\n  primaryListingCount: Scalars[\"Int\"];\n  /** The HTTP path for this Marketplace category. */\n  resourcePath: Scalars[\"URI\"];\n  /** How many Marketplace listings have this as their secondary category. */\n  secondaryListingCount: Scalars[\"Int\"];\n  /** The short name of the category used in its URL. */\n  slug: Scalars[\"String\"];\n  /** The HTTP URL for this Marketplace category. */\n  url: Scalars[\"URI\"];\n};\n\n/** A listing in the GitHub integration marketplace. */\nexport type MarketplaceListing = Node & {\n  __typename?: \"MarketplaceListing\";\n  /** The GitHub App this listing represents. */\n  app?: Maybe<App>;\n  /** URL to the listing owner's company site. */\n  companyUrl?: Maybe<Scalars[\"URI\"]>;\n  /** The HTTP path for configuring access to the listing's integration or OAuth app */\n  configurationResourcePath: Scalars[\"URI\"];\n  /** The HTTP URL for configuring access to the listing's integration or OAuth app */\n  configurationUrl: Scalars[\"URI\"];\n  /** URL to the listing's documentation. */\n  documentationUrl?: Maybe<Scalars[\"URI\"]>;\n  /** The listing's detailed description. */\n  extendedDescription?: Maybe<Scalars[\"String\"]>;\n  /** The listing's detailed description rendered to HTML. */\n  extendedDescriptionHTML: Scalars[\"HTML\"];\n  /** The listing's introductory description. */\n  fullDescription: Scalars[\"String\"];\n  /** The listing's introductory description rendered to HTML. */\n  fullDescriptionHTML: Scalars[\"HTML\"];\n  /** Does this listing have any plans with a free trial? */\n  hasPublishedFreeTrialPlans: Scalars[\"Boolean\"];\n  /** Does this listing have a terms of service link? */\n  hasTermsOfService: Scalars[\"Boolean\"];\n  /** Whether the creator of the app is a verified org */\n  hasVerifiedOwner: Scalars[\"Boolean\"];\n  /** A technical description of how this app works with GitHub. */\n  howItWorks?: Maybe<Scalars[\"String\"]>;\n  /** The listing's technical description rendered to HTML. */\n  howItWorksHTML: Scalars[\"HTML\"];\n  id: Scalars[\"ID\"];\n  /** URL to install the product to the viewer's account or organization. */\n  installationUrl?: Maybe<Scalars[\"URI\"]>;\n  /** Whether this listing's app has been installed for the current viewer */\n  installedForViewer: Scalars[\"Boolean\"];\n  /** Whether this listing has been removed from the Marketplace. */\n  isArchived: Scalars[\"Boolean\"];\n  /**\n   * Whether this listing is still an editable draft that has not been submitted\n   * for review and is not publicly visible in the Marketplace.\n   */\n  isDraft: Scalars[\"Boolean\"];\n  /** Whether the product this listing represents is available as part of a paid plan. */\n  isPaid: Scalars[\"Boolean\"];\n  /** Whether this listing has been approved for display in the Marketplace. */\n  isPublic: Scalars[\"Boolean\"];\n  /** Whether this listing has been rejected by GitHub for display in the Marketplace. */\n  isRejected: Scalars[\"Boolean\"];\n  /** Whether this listing has been approved for unverified display in the Marketplace. */\n  isUnverified: Scalars[\"Boolean\"];\n  /** Whether this draft listing has been submitted for review for approval to be unverified in the Marketplace. */\n  isUnverifiedPending: Scalars[\"Boolean\"];\n  /** Whether this draft listing has been submitted for review from GitHub for approval to be verified in the Marketplace. */\n  isVerificationPendingFromDraft: Scalars[\"Boolean\"];\n  /** Whether this unverified listing has been submitted for review from GitHub for approval to be verified in the Marketplace. */\n  isVerificationPendingFromUnverified: Scalars[\"Boolean\"];\n  /** Whether this listing has been approved for verified display in the Marketplace. */\n  isVerified: Scalars[\"Boolean\"];\n  /** The hex color code, without the leading '#', for the logo background. */\n  logoBackgroundColor: Scalars[\"String\"];\n  /** URL for the listing's logo image. */\n  logoUrl?: Maybe<Scalars[\"URI\"]>;\n  /** The listing's full name. */\n  name: Scalars[\"String\"];\n  /** The listing's very short description without a trailing period or ampersands. */\n  normalizedShortDescription: Scalars[\"String\"];\n  /** URL to the listing's detailed pricing. */\n  pricingUrl?: Maybe<Scalars[\"URI\"]>;\n  /** The category that best describes the listing. */\n  primaryCategory: MarketplaceCategory;\n  /** URL to the listing's privacy policy, may return an empty string for listings that do not require a privacy policy URL. */\n  privacyPolicyUrl: Scalars[\"URI\"];\n  /** The HTTP path for the Marketplace listing. */\n  resourcePath: Scalars[\"URI\"];\n  /** The URLs for the listing's screenshots. */\n  screenshotUrls: Array<Maybe<Scalars[\"String\"]>>;\n  /** An alternate category that describes the listing. */\n  secondaryCategory?: Maybe<MarketplaceCategory>;\n  /** The listing's very short description. */\n  shortDescription: Scalars[\"String\"];\n  /** The short name of the listing used in its URL. */\n  slug: Scalars[\"String\"];\n  /** URL to the listing's status page. */\n  statusUrl?: Maybe<Scalars[\"URI\"]>;\n  /** An email address for support for this listing's app. */\n  supportEmail?: Maybe<Scalars[\"String\"]>;\n  /**\n   * Either a URL or an email address for support for this listing's app, may\n   * return an empty string for listings that do not require a support URL.\n   */\n  supportUrl: Scalars[\"URI\"];\n  /** URL to the listing's terms of service. */\n  termsOfServiceUrl?: Maybe<Scalars[\"URI\"]>;\n  /** The HTTP URL for the Marketplace listing. */\n  url: Scalars[\"URI\"];\n  /** Can the current viewer add plans for this Marketplace listing. */\n  viewerCanAddPlans: Scalars[\"Boolean\"];\n  /** Can the current viewer approve this Marketplace listing. */\n  viewerCanApprove: Scalars[\"Boolean\"];\n  /** Can the current viewer delist this Marketplace listing. */\n  viewerCanDelist: Scalars[\"Boolean\"];\n  /** Can the current viewer edit this Marketplace listing. */\n  viewerCanEdit: Scalars[\"Boolean\"];\n  /**\n   * Can the current viewer edit the primary and secondary category of this\n   * Marketplace listing.\n   */\n  viewerCanEditCategories: Scalars[\"Boolean\"];\n  /** Can the current viewer edit the plans for this Marketplace listing. */\n  viewerCanEditPlans: Scalars[\"Boolean\"];\n  /**\n   * Can the current viewer return this Marketplace listing to draft state\n   * so it becomes editable again.\n   */\n  viewerCanRedraft: Scalars[\"Boolean\"];\n  /**\n   * Can the current viewer reject this Marketplace listing by returning it to\n   * an editable draft state or rejecting it entirely.\n   */\n  viewerCanReject: Scalars[\"Boolean\"];\n  /**\n   * Can the current viewer request this listing be reviewed for display in\n   * the Marketplace as verified.\n   */\n  viewerCanRequestApproval: Scalars[\"Boolean\"];\n  /** Indicates whether the current user has an active subscription to this Marketplace listing. */\n  viewerHasPurchased: Scalars[\"Boolean\"];\n  /**\n   * Indicates if the current user has purchased a subscription to this Marketplace listing\n   * for all of the organizations the user owns.\n   */\n  viewerHasPurchasedForAllOrganizations: Scalars[\"Boolean\"];\n  /** Does the current viewer role allow them to administer this Marketplace listing. */\n  viewerIsListingAdmin: Scalars[\"Boolean\"];\n};\n\n/** A listing in the GitHub integration marketplace. */\nexport type MarketplaceListingLogoUrlArgs = {\n  size?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** Look up Marketplace Listings */\nexport type MarketplaceListingConnection = {\n  __typename?: \"MarketplaceListingConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<MarketplaceListingEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<MarketplaceListing>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type MarketplaceListingEdge = {\n  __typename?: \"MarketplaceListingEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<MarketplaceListing>;\n};\n\n/** Entities that have members who can set status messages. */\nexport type MemberStatusable = {\n  /** Get the status messages members of this entity have set that are either public or visible only to the organization. */\n  memberStatuses: UserStatusConnection;\n};\n\n/** Entities that have members who can set status messages. */\nexport type MemberStatusableMemberStatusesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<UserStatusOrder>;\n};\n\n/** Audit log entry for a members_can_delete_repos.clear event. */\nexport type MembersCanDeleteReposClearAuditEntry = AuditEntry &\n  EnterpriseAuditEntryData &\n  Node &\n  OrganizationAuditEntryData & {\n    __typename?: \"MembersCanDeleteReposClearAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    /** The HTTP path for this enterprise. */\n    enterpriseResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The slug of the enterprise. */\n    enterpriseSlug?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP URL for this enterprise. */\n    enterpriseUrl?: Maybe<Scalars[\"URI\"]>;\n    id: Scalars[\"ID\"];\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** Audit log entry for a members_can_delete_repos.disable event. */\nexport type MembersCanDeleteReposDisableAuditEntry = AuditEntry &\n  EnterpriseAuditEntryData &\n  Node &\n  OrganizationAuditEntryData & {\n    __typename?: \"MembersCanDeleteReposDisableAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    /** The HTTP path for this enterprise. */\n    enterpriseResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The slug of the enterprise. */\n    enterpriseSlug?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP URL for this enterprise. */\n    enterpriseUrl?: Maybe<Scalars[\"URI\"]>;\n    id: Scalars[\"ID\"];\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** Audit log entry for a members_can_delete_repos.enable event. */\nexport type MembersCanDeleteReposEnableAuditEntry = AuditEntry &\n  EnterpriseAuditEntryData &\n  Node &\n  OrganizationAuditEntryData & {\n    __typename?: \"MembersCanDeleteReposEnableAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    /** The HTTP path for this enterprise. */\n    enterpriseResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The slug of the enterprise. */\n    enterpriseSlug?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP URL for this enterprise. */\n    enterpriseUrl?: Maybe<Scalars[\"URI\"]>;\n    id: Scalars[\"ID\"];\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** Represents a 'mentioned' event on a given issue or pull request. */\nexport type MentionedEvent = Node & {\n  __typename?: \"MentionedEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars[\"Int\"]>;\n  id: Scalars[\"ID\"];\n};\n\n/** Autogenerated input type of MergeBranch */\nexport type MergeBranchInput = {\n  /** The email address to associate with this commit. */\n  authorEmail?: InputMaybe<Scalars[\"String\"]>;\n  /** The name of the base branch that the provided head will be merged into. */\n  base: Scalars[\"String\"];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** Message to use for the merge commit. If omitted, a default will be used. */\n  commitMessage?: InputMaybe<Scalars[\"String\"]>;\n  /** The head to merge into the base branch. This can be a branch name or a commit GitObjectID. */\n  head: Scalars[\"String\"];\n  /** The Node ID of the Repository containing the base branch that will be modified. */\n  repositoryId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of MergeBranch */\nexport type MergeBranchPayload = {\n  __typename?: \"MergeBranchPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The resulting merge Commit. */\n  mergeCommit?: Maybe<Commit>;\n};\n\n/** Autogenerated input type of MergePullRequest */\nexport type MergePullRequestInput = {\n  /** The email address to associate with this merge. */\n  authorEmail?: InputMaybe<Scalars[\"String\"]>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** Commit body to use for the merge commit; if omitted, a default message will be used */\n  commitBody?: InputMaybe<Scalars[\"String\"]>;\n  /** Commit headline to use for the merge commit; if omitted, a default message will be used. */\n  commitHeadline?: InputMaybe<Scalars[\"String\"]>;\n  /** OID that the pull request head ref must match to allow merge; if omitted, no check is performed. */\n  expectedHeadOid?: InputMaybe<Scalars[\"GitObjectID\"]>;\n  /** The merge method to use. If omitted, defaults to 'MERGE' */\n  mergeMethod?: InputMaybe<PullRequestMergeMethod>;\n  /** ID of the pull request to be merged. */\n  pullRequestId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of MergePullRequest */\nexport type MergePullRequestPayload = {\n  __typename?: \"MergePullRequestPayload\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The pull request that was merged. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Detailed status information about a pull request merge. */\nexport enum MergeStateStatus {\n  /** The head ref is out of date. */\n  Behind = \"BEHIND\",\n  /** The merge is blocked. */\n  Blocked = \"BLOCKED\",\n  /** Mergeable and passing commit status. */\n  Clean = \"CLEAN\",\n  /** The merge commit cannot be cleanly created. */\n  Dirty = \"DIRTY\",\n  /**\n   * The merge is blocked due to the pull request being a draft.\n   * @deprecated DRAFT state will be removed from this enum and `isDraft` should be used instead Use PullRequest.isDraft instead. Removal on 2021-01-01 UTC.\n   */\n  Draft = \"DRAFT\",\n  /** Mergeable with passing commit status and pre-receive hooks. */\n  HasHooks = \"HAS_HOOKS\",\n  /** The state cannot currently be determined. */\n  Unknown = \"UNKNOWN\",\n  /** Mergeable with non-passing commit status. */\n  Unstable = \"UNSTABLE\",\n}\n\n/** Whether or not a PullRequest can be merged. */\nexport enum MergeableState {\n  /** The pull request cannot be merged due to merge conflicts. */\n  Conflicting = \"CONFLICTING\",\n  /** The pull request can be merged. */\n  Mergeable = \"MERGEABLE\",\n  /** The mergeability of the pull request is still being calculated. */\n  Unknown = \"UNKNOWN\",\n}\n\n/** Represents a 'merged' event on a given pull request. */\nexport type MergedEvent = Node &\n  UniformResourceLocatable & {\n    __typename?: \"MergedEvent\";\n    /** Identifies the actor who performed the event. */\n    actor?: Maybe<Actor>;\n    /** Identifies the commit associated with the `merge` event. */\n    commit?: Maybe<Commit>;\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars[\"DateTime\"];\n    id: Scalars[\"ID\"];\n    /** Identifies the Ref associated with the `merge` event. */\n    mergeRef?: Maybe<Ref>;\n    /** Identifies the name of the Ref associated with the `merge` event. */\n    mergeRefName: Scalars[\"String\"];\n    /** PullRequest referenced by event. */\n    pullRequest: PullRequest;\n    /** The HTTP path for this merged event. */\n    resourcePath: Scalars[\"URI\"];\n    /** The HTTP URL for this merged event. */\n    url: Scalars[\"URI\"];\n  };\n\n/** Represents an Octoshift migration. */\nexport type Migration = {\n  /** The Octoshift migration flag to continue on error. */\n  continueOnError: Scalars[\"Boolean\"];\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** The reason the migration failed. */\n  failureReason?: Maybe<Scalars[\"String\"]>;\n  id: Scalars[\"ID\"];\n  /** The URL for the migration log (expires 1 day after migration completes). */\n  migrationLogUrl?: Maybe<Scalars[\"URI\"]>;\n  /** The Octoshift migration source. */\n  migrationSource: MigrationSource;\n  /** The target repository name. */\n  repositoryName: Scalars[\"String\"];\n  /** The Octoshift migration source URL. */\n  sourceUrl: Scalars[\"URI\"];\n  /** The Octoshift migration state. */\n  state: MigrationState;\n};\n\n/** An Octoshift migration source. */\nexport type MigrationSource = Node & {\n  __typename?: \"MigrationSource\";\n  id: Scalars[\"ID\"];\n  /** The Octoshift migration source name. */\n  name: Scalars[\"String\"];\n  /** The Octoshift migration source type. */\n  type: MigrationSourceType;\n  /** The Octoshift migration source URL. */\n  url: Scalars[\"URI\"];\n};\n\n/** Represents the different Octoshift migration sources. */\nexport enum MigrationSourceType {\n  /** An Azure DevOps migration source. */\n  AzureDevops = \"AZURE_DEVOPS\",\n  /** A Bitbucket Server migration source. */\n  BitbucketServer = \"BITBUCKET_SERVER\",\n  /** A GitHub migration source. */\n  Github = \"GITHUB\",\n  /** A GitHub Migration API source. */\n  GithubArchive = \"GITHUB_ARCHIVE\",\n  /** A GitLab migration source. */\n  Gitlab = \"GITLAB\",\n}\n\n/** The Octoshift migration state. */\nexport enum MigrationState {\n  /** The Octoshift migration has failed. */\n  Failed = \"FAILED\",\n  /** The Octoshift migration is in progress. */\n  InProgress = \"IN_PROGRESS\",\n  /** The Octoshift migration has not started. */\n  NotStarted = \"NOT_STARTED\",\n  /** The Octoshift migration has been queued. */\n  Queued = \"QUEUED\",\n  /** The Octoshift migration has succeeded. */\n  Succeeded = \"SUCCEEDED\",\n}\n\n/** Represents a Milestone object on a given repository. */\nexport type Milestone = Closable &\n  Node &\n  UniformResourceLocatable & {\n    __typename?: \"Milestone\";\n    /** `true` if the object is closed (definition of closed may depend on type) */\n    closed: Scalars[\"Boolean\"];\n    /** Identifies the date and time when the object was closed. */\n    closedAt?: Maybe<Scalars[\"DateTime\"]>;\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars[\"DateTime\"];\n    /** Identifies the actor who created the milestone. */\n    creator?: Maybe<Actor>;\n    /** Identifies the description of the milestone. */\n    description?: Maybe<Scalars[\"String\"]>;\n    /** Identifies the due date of the milestone. */\n    dueOn?: Maybe<Scalars[\"DateTime\"]>;\n    id: Scalars[\"ID\"];\n    /** A list of issues associated with the milestone. */\n    issues: IssueConnection;\n    /** Identifies the number of the milestone. */\n    number: Scalars[\"Int\"];\n    /** Identifies the percentage complete for the milestone */\n    progressPercentage: Scalars[\"Float\"];\n    /** A list of pull requests associated with the milestone. */\n    pullRequests: PullRequestConnection;\n    /** The repository associated with this milestone. */\n    repository: Repository;\n    /** The HTTP path for this milestone */\n    resourcePath: Scalars[\"URI\"];\n    /** Identifies the state of the milestone. */\n    state: MilestoneState;\n    /** Identifies the title of the milestone. */\n    title: Scalars[\"String\"];\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars[\"DateTime\"];\n    /** The HTTP URL for this milestone */\n    url: Scalars[\"URI\"];\n  };\n\n/** Represents a Milestone object on a given repository. */\nexport type MilestoneIssuesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  filterBy?: InputMaybe<IssueFilters>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  labels?: InputMaybe<Array<Scalars[\"String\"]>>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<IssueOrder>;\n  states?: InputMaybe<Array<IssueState>>;\n};\n\n/** Represents a Milestone object on a given repository. */\nexport type MilestonePullRequestsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  baseRefName?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  headRefName?: InputMaybe<Scalars[\"String\"]>;\n  labels?: InputMaybe<Array<Scalars[\"String\"]>>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<IssueOrder>;\n  states?: InputMaybe<Array<PullRequestState>>;\n};\n\n/** The connection type for Milestone. */\nexport type MilestoneConnection = {\n  __typename?: \"MilestoneConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<MilestoneEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Milestone>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type MilestoneEdge = {\n  __typename?: \"MilestoneEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<Milestone>;\n};\n\n/** Types that can be inside a Milestone. */\nexport type MilestoneItem = Issue | PullRequest;\n\n/** Ordering options for milestone connections. */\nexport type MilestoneOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order milestones by. */\n  field: MilestoneOrderField;\n};\n\n/** Properties by which milestone connections can be ordered. */\nexport enum MilestoneOrderField {\n  /** Order milestones by when they were created. */\n  CreatedAt = \"CREATED_AT\",\n  /** Order milestones by when they are due. */\n  DueDate = \"DUE_DATE\",\n  /** Order milestones by their number. */\n  Number = \"NUMBER\",\n  /** Order milestones by when they were last updated. */\n  UpdatedAt = \"UPDATED_AT\",\n}\n\n/** The possible states of a milestone. */\nexport enum MilestoneState {\n  /** A milestone that has been closed. */\n  Closed = \"CLOSED\",\n  /** A milestone that is still open. */\n  Open = \"OPEN\",\n}\n\n/** Represents a 'milestoned' event on a given issue or pull request. */\nexport type MilestonedEvent = Node & {\n  __typename?: \"MilestonedEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  id: Scalars[\"ID\"];\n  /** Identifies the milestone title associated with the 'milestoned' event. */\n  milestoneTitle: Scalars[\"String\"];\n  /** Object referenced by event. */\n  subject: MilestoneItem;\n};\n\n/** Entities that can be minimized. */\nexport type Minimizable = {\n  /** Returns whether or not a comment has been minimized. */\n  isMinimized: Scalars[\"Boolean\"];\n  /** Returns why the comment was minimized. */\n  minimizedReason?: Maybe<Scalars[\"String\"]>;\n  /** Check if the current viewer can minimize this object. */\n  viewerCanMinimize: Scalars[\"Boolean\"];\n};\n\n/** Autogenerated input type of MinimizeComment */\nexport type MinimizeCommentInput = {\n  /** The classification of comment */\n  classifier: ReportedContentClassifiers;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The Node ID of the subject to modify. */\n  subjectId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of MinimizeComment */\nexport type MinimizeCommentPayload = {\n  __typename?: \"MinimizeCommentPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The comment that was minimized. */\n  minimizedComment?: Maybe<Minimizable>;\n};\n\n/** Autogenerated input type of MoveProjectCard */\nexport type MoveProjectCardInput = {\n  /** Place the new card after the card with this id. Pass null to place it at the top. */\n  afterCardId?: InputMaybe<Scalars[\"ID\"]>;\n  /** The id of the card to move. */\n  cardId: Scalars[\"ID\"];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The id of the column to move it into. */\n  columnId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of MoveProjectCard */\nexport type MoveProjectCardPayload = {\n  __typename?: \"MoveProjectCardPayload\";\n  /** The new edge of the moved card. */\n  cardEdge?: Maybe<ProjectCardEdge>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated input type of MoveProjectColumn */\nexport type MoveProjectColumnInput = {\n  /** Place the new column after the column with this id. Pass null to place it at the front. */\n  afterColumnId?: InputMaybe<Scalars[\"ID\"]>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The id of the column to move. */\n  columnId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of MoveProjectColumn */\nexport type MoveProjectColumnPayload = {\n  __typename?: \"MoveProjectColumnPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The new edge of the moved column. */\n  columnEdge?: Maybe<ProjectColumnEdge>;\n};\n\n/** Represents a 'moved_columns_in_project' event on a given issue or pull request. */\nexport type MovedColumnsInProjectEvent = Node & {\n  __typename?: \"MovedColumnsInProjectEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars[\"Int\"]>;\n  id: Scalars[\"ID\"];\n  /** Column name the issue or pull request was moved from. */\n  previousProjectColumnName: Scalars[\"String\"];\n  /** Project referenced by event. */\n  project?: Maybe<Project>;\n  /** Project card referenced by this project event. */\n  projectCard?: Maybe<ProjectCard>;\n  /** Column name the issue or pull request was moved to. */\n  projectColumnName: Scalars[\"String\"];\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type Mutation = {\n  __typename?: \"Mutation\";\n  /** Clear all of a customer's queued migrations */\n  abortQueuedMigrations?: Maybe<AbortQueuedMigrationsPayload>;\n  /** Accepts a pending invitation for a user to become an administrator of an enterprise. */\n  acceptEnterpriseAdministratorInvitation?: Maybe<AcceptEnterpriseAdministratorInvitationPayload>;\n  /** Applies a suggested topic to the repository. */\n  acceptTopicSuggestion?: Maybe<AcceptTopicSuggestionPayload>;\n  /** Adds assignees to an assignable object. */\n  addAssigneesToAssignable?: Maybe<AddAssigneesToAssignablePayload>;\n  /** Adds a comment to an Issue or Pull Request. */\n  addComment?: Maybe<AddCommentPayload>;\n  /** Adds a comment to a Discussion, possibly as a reply to another comment. */\n  addDiscussionComment?: Maybe<AddDiscussionCommentPayload>;\n  /** Adds a support entitlement to an enterprise member. */\n  addEnterpriseSupportEntitlement?: Maybe<AddEnterpriseSupportEntitlementPayload>;\n  /** Adds labels to a labelable object. */\n  addLabelsToLabelable?: Maybe<AddLabelsToLabelablePayload>;\n  /** Adds a card to a ProjectColumn. Either `contentId` or `note` must be provided but **not** both. */\n  addProjectCard?: Maybe<AddProjectCardPayload>;\n  /** Adds a column to a Project. */\n  addProjectColumn?: Maybe<AddProjectColumnPayload>;\n  /** Creates a new draft issue and add it to a Project. */\n  addProjectDraftIssue?: Maybe<AddProjectDraftIssuePayload>;\n  /** Adds an existing item (Issue or PullRequest) to a Project. */\n  addProjectNextItem?: Maybe<AddProjectNextItemPayload>;\n  /** Adds a review to a Pull Request. */\n  addPullRequestReview?: Maybe<AddPullRequestReviewPayload>;\n  /** Adds a comment to a review. */\n  addPullRequestReviewComment?: Maybe<AddPullRequestReviewCommentPayload>;\n  /** Adds a new thread to a pending Pull Request Review. */\n  addPullRequestReviewThread?: Maybe<AddPullRequestReviewThreadPayload>;\n  /** Adds a reaction to a subject. */\n  addReaction?: Maybe<AddReactionPayload>;\n  /** Adds a star to a Starrable. */\n  addStar?: Maybe<AddStarPayload>;\n  /** Add an upvote to a discussion or discussion comment. */\n  addUpvote?: Maybe<AddUpvotePayload>;\n  /** Adds a verifiable domain to an owning account. */\n  addVerifiableDomain?: Maybe<AddVerifiableDomainPayload>;\n  /** Approve all pending deployments under one or more environments */\n  approveDeployments?: Maybe<ApproveDeploymentsPayload>;\n  /** Approve a verifiable domain for notification delivery. */\n  approveVerifiableDomain?: Maybe<ApproveVerifiableDomainPayload>;\n  /** Marks a repository as archived. */\n  archiveRepository?: Maybe<ArchiveRepositoryPayload>;\n  /** Cancels a pending invitation for an administrator to join an enterprise. */\n  cancelEnterpriseAdminInvitation?: Maybe<CancelEnterpriseAdminInvitationPayload>;\n  /** Cancel an active sponsorship. */\n  cancelSponsorship?: Maybe<CancelSponsorshipPayload>;\n  /** Update your status on GitHub. */\n  changeUserStatus?: Maybe<ChangeUserStatusPayload>;\n  /** Clears all labels from a labelable object. */\n  clearLabelsFromLabelable?: Maybe<ClearLabelsFromLabelablePayload>;\n  /** Creates a new project by cloning configuration from an existing project. */\n  cloneProject?: Maybe<CloneProjectPayload>;\n  /** Create a new repository with the same files and directory structure as a template repository. */\n  cloneTemplateRepository?: Maybe<CloneTemplateRepositoryPayload>;\n  /** Close an issue. */\n  closeIssue?: Maybe<CloseIssuePayload>;\n  /** Close a pull request. */\n  closePullRequest?: Maybe<ClosePullRequestPayload>;\n  /** Convert a project note card to one associated with a newly created issue. */\n  convertProjectCardNoteToIssue?: Maybe<ConvertProjectCardNoteToIssuePayload>;\n  /** Converts a pull request to draft */\n  convertPullRequestToDraft?: Maybe<ConvertPullRequestToDraftPayload>;\n  /** Create a new branch protection rule */\n  createBranchProtectionRule?: Maybe<CreateBranchProtectionRulePayload>;\n  /** Create a check run. */\n  createCheckRun?: Maybe<CreateCheckRunPayload>;\n  /** Create a check suite */\n  createCheckSuite?: Maybe<CreateCheckSuitePayload>;\n  /**\n   * Appends a commit to the given branch as the authenticated user.\n   *\n   * This mutation creates a commit whose parent is the HEAD of the provided\n   * branch and also updates that branch to point to the new commit.\n   * It can be thought of as similar to `git commit`.\n   *\n   * ### Locating a Branch\n   *\n   * Commits are appended to a `branch` of type `Ref`.\n   * This must refer to a git branch (i.e.  the fully qualified path must\n   * begin with `refs/heads/`, although including this prefix is optional.\n   *\n   * Callers may specify the `branch` to commit to either by its global node\n   * ID or by passing both of `repositoryNameWithOwner` and `refName`.  For\n   * more details see the documentation for `CommittableBranch`.\n   *\n   * ### Describing Changes\n   *\n   * `fileChanges` are specified as a `FilesChanges` object describing\n   * `FileAdditions` and `FileDeletions`.\n   *\n   * Please see the documentation for `FileChanges` for more information on\n   * how to use this argument to describe any set of file changes.\n   *\n   * ### Authorship\n   *\n   * Similar to the web commit interface, this mutation does not support\n   * specifying the author or committer of the commit and will not add\n   * support for this in the future.\n   *\n   * A commit created by a successful execution of this mutation will be\n   * authored by the owner of the credential which authenticates the API\n   * request.  The committer will be identical to that of commits authored\n   * using the web interface.\n   *\n   * If you need full control over author and committer information, please\n   * use the Git Database REST API instead.\n   *\n   * ### Commit Signing\n   *\n   * Commits made using this mutation are automatically signed by GitHub if\n   * supported and will be marked as verified in the user interface.\n   */\n  createCommitOnBranch?: Maybe<CreateCommitOnBranchPayload>;\n  /** Creates a new deployment event. */\n  createDeployment?: Maybe<CreateDeploymentPayload>;\n  /** Create a deployment status. */\n  createDeploymentStatus?: Maybe<CreateDeploymentStatusPayload>;\n  /** Create a discussion. */\n  createDiscussion?: Maybe<CreateDiscussionPayload>;\n  /** Creates an organization as part of an enterprise account. */\n  createEnterpriseOrganization?: Maybe<CreateEnterpriseOrganizationPayload>;\n  /** Creates an environment or simply returns it if already exists. */\n  createEnvironment?: Maybe<CreateEnvironmentPayload>;\n  /** Creates a new IP allow list entry. */\n  createIpAllowListEntry?: Maybe<CreateIpAllowListEntryPayload>;\n  /** Creates a new issue. */\n  createIssue?: Maybe<CreateIssuePayload>;\n  /** Creates a new label. */\n  createLabel?: Maybe<CreateLabelPayload>;\n  /** Creates an Octoshift migration source. */\n  createMigrationSource?: Maybe<CreateMigrationSourcePayload>;\n  /** Creates a new project. */\n  createProject?: Maybe<CreateProjectPayload>;\n  /** Create a new pull request */\n  createPullRequest?: Maybe<CreatePullRequestPayload>;\n  /** Create a new Git Ref. */\n  createRef?: Maybe<CreateRefPayload>;\n  /** Create a new repository. */\n  createRepository?: Maybe<CreateRepositoryPayload>;\n  /** Create a new payment tier for your GitHub Sponsors profile. */\n  createSponsorsTier?: Maybe<CreateSponsorsTierPayload>;\n  /** Start a new sponsorship of a maintainer in GitHub Sponsors, or reactivate a past sponsorship. */\n  createSponsorship?: Maybe<CreateSponsorshipPayload>;\n  /** Creates a new team discussion. */\n  createTeamDiscussion?: Maybe<CreateTeamDiscussionPayload>;\n  /** Creates a new team discussion comment. */\n  createTeamDiscussionComment?: Maybe<CreateTeamDiscussionCommentPayload>;\n  /** Rejects a suggested topic for the repository. */\n  declineTopicSuggestion?: Maybe<DeclineTopicSuggestionPayload>;\n  /** Delete a branch protection rule */\n  deleteBranchProtectionRule?: Maybe<DeleteBranchProtectionRulePayload>;\n  /** Deletes a deployment. */\n  deleteDeployment?: Maybe<DeleteDeploymentPayload>;\n  /** Delete a discussion and all of its replies. */\n  deleteDiscussion?: Maybe<DeleteDiscussionPayload>;\n  /** Delete a discussion comment. If it has replies, wipe it instead. */\n  deleteDiscussionComment?: Maybe<DeleteDiscussionCommentPayload>;\n  /** Deletes an environment */\n  deleteEnvironment?: Maybe<DeleteEnvironmentPayload>;\n  /** Deletes an IP allow list entry. */\n  deleteIpAllowListEntry?: Maybe<DeleteIpAllowListEntryPayload>;\n  /** Deletes an Issue object. */\n  deleteIssue?: Maybe<DeleteIssuePayload>;\n  /** Deletes an IssueComment object. */\n  deleteIssueComment?: Maybe<DeleteIssueCommentPayload>;\n  /** Deletes a label. */\n  deleteLabel?: Maybe<DeleteLabelPayload>;\n  /** Delete a package version. */\n  deletePackageVersion?: Maybe<DeletePackageVersionPayload>;\n  /** Deletes a project. */\n  deleteProject?: Maybe<DeleteProjectPayload>;\n  /** Deletes a project card. */\n  deleteProjectCard?: Maybe<DeleteProjectCardPayload>;\n  /** Deletes a project column. */\n  deleteProjectColumn?: Maybe<DeleteProjectColumnPayload>;\n  /** Deletes an item from a Project. */\n  deleteProjectNextItem?: Maybe<DeleteProjectNextItemPayload>;\n  /** Deletes a pull request review. */\n  deletePullRequestReview?: Maybe<DeletePullRequestReviewPayload>;\n  /** Deletes a pull request review comment. */\n  deletePullRequestReviewComment?: Maybe<DeletePullRequestReviewCommentPayload>;\n  /** Delete a Git Ref. */\n  deleteRef?: Maybe<DeleteRefPayload>;\n  /** Deletes a team discussion. */\n  deleteTeamDiscussion?: Maybe<DeleteTeamDiscussionPayload>;\n  /** Deletes a team discussion comment. */\n  deleteTeamDiscussionComment?: Maybe<DeleteTeamDiscussionCommentPayload>;\n  /** Deletes a verifiable domain. */\n  deleteVerifiableDomain?: Maybe<DeleteVerifiableDomainPayload>;\n  /** Disable auto merge on the given pull request */\n  disablePullRequestAutoMerge?: Maybe<DisablePullRequestAutoMergePayload>;\n  /** Dismisses an approved or rejected pull request review. */\n  dismissPullRequestReview?: Maybe<DismissPullRequestReviewPayload>;\n  /** Dismisses the Dependabot alert. */\n  dismissRepositoryVulnerabilityAlert?: Maybe<DismissRepositoryVulnerabilityAlertPayload>;\n  /** Enable the default auto-merge on a pull request. */\n  enablePullRequestAutoMerge?: Maybe<EnablePullRequestAutoMergePayload>;\n  /** Follow an organization. */\n  followOrganization?: Maybe<FollowOrganizationPayload>;\n  /** Follow a user. */\n  followUser?: Maybe<FollowUserPayload>;\n  /** Grant the migrator role to a user for all organizations under an enterprise account. */\n  grantEnterpriseOrganizationsMigratorRole?: Maybe<GrantEnterpriseOrganizationsMigratorRolePayload>;\n  /** Grant the migrator role to a user or a team. */\n  grantMigratorRole?: Maybe<GrantMigratorRolePayload>;\n  /** Creates a new project by importing columns and a list of issues/PRs. */\n  importProject?: Maybe<ImportProjectPayload>;\n  /** Invite someone to become an administrator of the enterprise. */\n  inviteEnterpriseAdmin?: Maybe<InviteEnterpriseAdminPayload>;\n  /** Creates a repository link for a project. */\n  linkRepositoryToProject?: Maybe<LinkRepositoryToProjectPayload>;\n  /** Lock a lockable object */\n  lockLockable?: Maybe<LockLockablePayload>;\n  /** Mark a discussion comment as the chosen answer for discussions in an answerable category. */\n  markDiscussionCommentAsAnswer?: Maybe<MarkDiscussionCommentAsAnswerPayload>;\n  /** Mark a pull request file as viewed */\n  markFileAsViewed?: Maybe<MarkFileAsViewedPayload>;\n  /** Marks a pull request ready for review. */\n  markPullRequestReadyForReview?: Maybe<MarkPullRequestReadyForReviewPayload>;\n  /** Merge a head into a branch. */\n  mergeBranch?: Maybe<MergeBranchPayload>;\n  /** Merge a pull request. */\n  mergePullRequest?: Maybe<MergePullRequestPayload>;\n  /** Minimizes a comment on an Issue, Commit, Pull Request, or Gist */\n  minimizeComment?: Maybe<MinimizeCommentPayload>;\n  /** Moves a project card to another place. */\n  moveProjectCard?: Maybe<MoveProjectCardPayload>;\n  /** Moves a project column to another place. */\n  moveProjectColumn?: Maybe<MoveProjectColumnPayload>;\n  /** Pin an issue to a repository */\n  pinIssue?: Maybe<PinIssuePayload>;\n  /** Regenerates the identity provider recovery codes for an enterprise */\n  regenerateEnterpriseIdentityProviderRecoveryCodes?: Maybe<RegenerateEnterpriseIdentityProviderRecoveryCodesPayload>;\n  /** Regenerates a verifiable domain's verification token. */\n  regenerateVerifiableDomainToken?: Maybe<RegenerateVerifiableDomainTokenPayload>;\n  /** Reject all pending deployments under one or more environments */\n  rejectDeployments?: Maybe<RejectDeploymentsPayload>;\n  /** Removes assignees from an assignable object. */\n  removeAssigneesFromAssignable?: Maybe<RemoveAssigneesFromAssignablePayload>;\n  /** Removes an administrator from the enterprise. */\n  removeEnterpriseAdmin?: Maybe<RemoveEnterpriseAdminPayload>;\n  /** Removes the identity provider from an enterprise */\n  removeEnterpriseIdentityProvider?: Maybe<RemoveEnterpriseIdentityProviderPayload>;\n  /** Removes an organization from the enterprise */\n  removeEnterpriseOrganization?: Maybe<RemoveEnterpriseOrganizationPayload>;\n  /** Removes a support entitlement from an enterprise member. */\n  removeEnterpriseSupportEntitlement?: Maybe<RemoveEnterpriseSupportEntitlementPayload>;\n  /** Removes labels from a Labelable object. */\n  removeLabelsFromLabelable?: Maybe<RemoveLabelsFromLabelablePayload>;\n  /** Removes outside collaborator from all repositories in an organization. */\n  removeOutsideCollaborator?: Maybe<RemoveOutsideCollaboratorPayload>;\n  /** Removes a reaction from a subject. */\n  removeReaction?: Maybe<RemoveReactionPayload>;\n  /** Removes a star from a Starrable. */\n  removeStar?: Maybe<RemoveStarPayload>;\n  /** Remove an upvote to a discussion or discussion comment. */\n  removeUpvote?: Maybe<RemoveUpvotePayload>;\n  /** Reopen a issue. */\n  reopenIssue?: Maybe<ReopenIssuePayload>;\n  /** Reopen a pull request. */\n  reopenPullRequest?: Maybe<ReopenPullRequestPayload>;\n  /** Set review requests on a pull request. */\n  requestReviews?: Maybe<RequestReviewsPayload>;\n  /** Rerequests an existing check suite. */\n  rerequestCheckSuite?: Maybe<RerequestCheckSuitePayload>;\n  /** Marks a review thread as resolved. */\n  resolveReviewThread?: Maybe<ResolveReviewThreadPayload>;\n  /** Revoke the migrator role to a user for all organizations under an enterprise account. */\n  revokeEnterpriseOrganizationsMigratorRole?: Maybe<RevokeEnterpriseOrganizationsMigratorRolePayload>;\n  /** Revoke the migrator role from a user or a team. */\n  revokeMigratorRole?: Maybe<RevokeMigratorRolePayload>;\n  /** Creates or updates the identity provider for an enterprise. */\n  setEnterpriseIdentityProvider?: Maybe<SetEnterpriseIdentityProviderPayload>;\n  /** Set an organization level interaction limit for an organization's public repositories. */\n  setOrganizationInteractionLimit?: Maybe<SetOrganizationInteractionLimitPayload>;\n  /** Sets an interaction limit setting for a repository. */\n  setRepositoryInteractionLimit?: Maybe<SetRepositoryInteractionLimitPayload>;\n  /** Set a user level interaction limit for an user's public repositories. */\n  setUserInteractionLimit?: Maybe<SetUserInteractionLimitPayload>;\n  /** Start a repository migration. */\n  startRepositoryMigration?: Maybe<StartRepositoryMigrationPayload>;\n  /** Submits a pending pull request review. */\n  submitPullRequestReview?: Maybe<SubmitPullRequestReviewPayload>;\n  /** Transfer an issue to a different repository */\n  transferIssue?: Maybe<TransferIssuePayload>;\n  /** Unarchives a repository. */\n  unarchiveRepository?: Maybe<UnarchiveRepositoryPayload>;\n  /** Unfollow an organization. */\n  unfollowOrganization?: Maybe<UnfollowOrganizationPayload>;\n  /** Unfollow a user. */\n  unfollowUser?: Maybe<UnfollowUserPayload>;\n  /** Deletes a repository link from a project. */\n  unlinkRepositoryFromProject?: Maybe<UnlinkRepositoryFromProjectPayload>;\n  /** Unlock a lockable object */\n  unlockLockable?: Maybe<UnlockLockablePayload>;\n  /** Unmark a discussion comment as the chosen answer for discussions in an answerable category. */\n  unmarkDiscussionCommentAsAnswer?: Maybe<UnmarkDiscussionCommentAsAnswerPayload>;\n  /** Unmark a pull request file as viewed */\n  unmarkFileAsViewed?: Maybe<UnmarkFileAsViewedPayload>;\n  /** Unmark an issue as a duplicate of another issue. */\n  unmarkIssueAsDuplicate?: Maybe<UnmarkIssueAsDuplicatePayload>;\n  /** Unminimizes a comment on an Issue, Commit, Pull Request, or Gist */\n  unminimizeComment?: Maybe<UnminimizeCommentPayload>;\n  /** Unpin a pinned issue from a repository */\n  unpinIssue?: Maybe<UnpinIssuePayload>;\n  /** Marks a review thread as unresolved. */\n  unresolveReviewThread?: Maybe<UnresolveReviewThreadPayload>;\n  /** Create a new branch protection rule */\n  updateBranchProtectionRule?: Maybe<UpdateBranchProtectionRulePayload>;\n  /** Update a check run */\n  updateCheckRun?: Maybe<UpdateCheckRunPayload>;\n  /** Modifies the settings of an existing check suite */\n  updateCheckSuitePreferences?: Maybe<UpdateCheckSuitePreferencesPayload>;\n  /** Update a discussion */\n  updateDiscussion?: Maybe<UpdateDiscussionPayload>;\n  /** Update the contents of a comment on a Discussion */\n  updateDiscussionComment?: Maybe<UpdateDiscussionCommentPayload>;\n  /** Updates the role of an enterprise administrator. */\n  updateEnterpriseAdministratorRole?: Maybe<UpdateEnterpriseAdministratorRolePayload>;\n  /** Sets whether private repository forks are enabled for an enterprise. */\n  updateEnterpriseAllowPrivateRepositoryForkingSetting?: Maybe<UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload>;\n  /** Sets the base repository permission for organizations in an enterprise. */\n  updateEnterpriseDefaultRepositoryPermissionSetting?: Maybe<UpdateEnterpriseDefaultRepositoryPermissionSettingPayload>;\n  /** Sets whether organization members with admin permissions on a repository can change repository visibility. */\n  updateEnterpriseMembersCanChangeRepositoryVisibilitySetting?: Maybe<UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload>;\n  /** Sets the members can create repositories setting for an enterprise. */\n  updateEnterpriseMembersCanCreateRepositoriesSetting?: Maybe<UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload>;\n  /** Sets the members can delete issues setting for an enterprise. */\n  updateEnterpriseMembersCanDeleteIssuesSetting?: Maybe<UpdateEnterpriseMembersCanDeleteIssuesSettingPayload>;\n  /** Sets the members can delete repositories setting for an enterprise. */\n  updateEnterpriseMembersCanDeleteRepositoriesSetting?: Maybe<UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload>;\n  /** Sets whether members can invite collaborators are enabled for an enterprise. */\n  updateEnterpriseMembersCanInviteCollaboratorsSetting?: Maybe<UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload>;\n  /** Sets whether or not an organization admin can make purchases. */\n  updateEnterpriseMembersCanMakePurchasesSetting?: Maybe<UpdateEnterpriseMembersCanMakePurchasesSettingPayload>;\n  /** Sets the members can update protected branches setting for an enterprise. */\n  updateEnterpriseMembersCanUpdateProtectedBranchesSetting?: Maybe<UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload>;\n  /** Sets the members can view dependency insights for an enterprise. */\n  updateEnterpriseMembersCanViewDependencyInsightsSetting?: Maybe<UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload>;\n  /** Sets whether organization projects are enabled for an enterprise. */\n  updateEnterpriseOrganizationProjectsSetting?: Maybe<UpdateEnterpriseOrganizationProjectsSettingPayload>;\n  /** Updates the role of an enterprise owner with an organization. */\n  updateEnterpriseOwnerOrganizationRole?: Maybe<UpdateEnterpriseOwnerOrganizationRolePayload>;\n  /** Updates an enterprise's profile. */\n  updateEnterpriseProfile?: Maybe<UpdateEnterpriseProfilePayload>;\n  /** Sets whether repository projects are enabled for a enterprise. */\n  updateEnterpriseRepositoryProjectsSetting?: Maybe<UpdateEnterpriseRepositoryProjectsSettingPayload>;\n  /** Sets whether team discussions are enabled for an enterprise. */\n  updateEnterpriseTeamDiscussionsSetting?: Maybe<UpdateEnterpriseTeamDiscussionsSettingPayload>;\n  /** Sets whether two factor authentication is required for all users in an enterprise. */\n  updateEnterpriseTwoFactorAuthenticationRequiredSetting?: Maybe<UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload>;\n  /** Updates an environment. */\n  updateEnvironment?: Maybe<UpdateEnvironmentPayload>;\n  /** Sets whether an IP allow list is enabled on an owner. */\n  updateIpAllowListEnabledSetting?: Maybe<UpdateIpAllowListEnabledSettingPayload>;\n  /** Updates an IP allow list entry. */\n  updateIpAllowListEntry?: Maybe<UpdateIpAllowListEntryPayload>;\n  /** Sets whether IP allow list configuration for installed GitHub Apps is enabled on an owner. */\n  updateIpAllowListForInstalledAppsEnabledSetting?: Maybe<UpdateIpAllowListForInstalledAppsEnabledSettingPayload>;\n  /** Updates an Issue. */\n  updateIssue?: Maybe<UpdateIssuePayload>;\n  /** Updates an IssueComment object. */\n  updateIssueComment?: Maybe<UpdateIssueCommentPayload>;\n  /** Updates an existing label. */\n  updateLabel?: Maybe<UpdateLabelPayload>;\n  /** Update the setting to restrict notifications to only verified or approved domains available to an owner. */\n  updateNotificationRestrictionSetting?: Maybe<UpdateNotificationRestrictionSettingPayload>;\n  /** Sets whether private repository forks are enabled for an organization. */\n  updateOrganizationAllowPrivateRepositoryForkingSetting?: Maybe<UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload>;\n  /** Updates an existing project. */\n  updateProject?: Maybe<UpdateProjectPayload>;\n  /** Updates an existing project card. */\n  updateProjectCard?: Maybe<UpdateProjectCardPayload>;\n  /** Updates an existing project column. */\n  updateProjectColumn?: Maybe<UpdateProjectColumnPayload>;\n  /** Updates a draft issue within a Project. */\n  updateProjectDraftIssue?: Maybe<UpdateProjectDraftIssuePayload>;\n  /** Updates an existing project (beta). */\n  updateProjectNext?: Maybe<UpdateProjectNextPayload>;\n  /** Updates a field of an item from a Project. */\n  updateProjectNextItemField?: Maybe<UpdateProjectNextItemFieldPayload>;\n  /** Update a pull request */\n  updatePullRequest?: Maybe<UpdatePullRequestPayload>;\n  /** Merge HEAD from upstream branch into pull request branch */\n  updatePullRequestBranch?: Maybe<UpdatePullRequestBranchPayload>;\n  /** Updates the body of a pull request review. */\n  updatePullRequestReview?: Maybe<UpdatePullRequestReviewPayload>;\n  /** Updates a pull request review comment. */\n  updatePullRequestReviewComment?: Maybe<UpdatePullRequestReviewCommentPayload>;\n  /** Update a Git Ref. */\n  updateRef?: Maybe<UpdateRefPayload>;\n  /**\n   * Creates, updates and/or deletes multiple refs in a repository.\n   *\n   * This mutation takes a list of `RefUpdate`s and performs these updates\n   * on the repository. All updates are performed atomically, meaning that\n   * if one of them is rejected, no other ref will be modified.\n   *\n   * `RefUpdate.beforeOid` specifies that the given reference needs to point\n   * to the given value before performing any updates. A value of\n   * `0000000000000000000000000000000000000000` can be used to verify that\n   * the references should not exist.\n   *\n   * `RefUpdate.afterOid` specifies the value that the given reference\n   * will point to after performing all updates. A value of\n   * `0000000000000000000000000000000000000000` can be used to delete a\n   * reference.\n   *\n   * If `RefUpdate.force` is set to `true`, a non-fast-forward updates\n   * for the given reference will be allowed.\n   */\n  updateRefs?: Maybe<UpdateRefsPayload>;\n  /** Update information about a repository. */\n  updateRepository?: Maybe<UpdateRepositoryPayload>;\n  /** Change visibility of your sponsorship and opt in or out of email updates from the maintainer. */\n  updateSponsorshipPreferences?: Maybe<UpdateSponsorshipPreferencesPayload>;\n  /** Updates the state for subscribable subjects. */\n  updateSubscription?: Maybe<UpdateSubscriptionPayload>;\n  /** Updates a team discussion. */\n  updateTeamDiscussion?: Maybe<UpdateTeamDiscussionPayload>;\n  /** Updates a discussion comment. */\n  updateTeamDiscussionComment?: Maybe<UpdateTeamDiscussionCommentPayload>;\n  /** Updates team review assignment. */\n  updateTeamReviewAssignment?: Maybe<UpdateTeamReviewAssignmentPayload>;\n  /** Update team repository. */\n  updateTeamsRepository?: Maybe<UpdateTeamsRepositoryPayload>;\n  /** Replaces the repository's topics with the given topics. */\n  updateTopics?: Maybe<UpdateTopicsPayload>;\n  /** Verify that a verifiable domain has the expected DNS record. */\n  verifyVerifiableDomain?: Maybe<VerifyVerifiableDomainPayload>;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAbortQueuedMigrationsArgs = {\n  input: AbortQueuedMigrationsInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAcceptEnterpriseAdministratorInvitationArgs = {\n  input: AcceptEnterpriseAdministratorInvitationInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAcceptTopicSuggestionArgs = {\n  input: AcceptTopicSuggestionInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddAssigneesToAssignableArgs = {\n  input: AddAssigneesToAssignableInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddCommentArgs = {\n  input: AddCommentInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddDiscussionCommentArgs = {\n  input: AddDiscussionCommentInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddEnterpriseSupportEntitlementArgs = {\n  input: AddEnterpriseSupportEntitlementInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddLabelsToLabelableArgs = {\n  input: AddLabelsToLabelableInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddProjectCardArgs = {\n  input: AddProjectCardInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddProjectColumnArgs = {\n  input: AddProjectColumnInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddProjectDraftIssueArgs = {\n  input: AddProjectDraftIssueInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddProjectNextItemArgs = {\n  input: AddProjectNextItemInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddPullRequestReviewArgs = {\n  input: AddPullRequestReviewInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddPullRequestReviewCommentArgs = {\n  input: AddPullRequestReviewCommentInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddPullRequestReviewThreadArgs = {\n  input: AddPullRequestReviewThreadInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddReactionArgs = {\n  input: AddReactionInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddStarArgs = {\n  input: AddStarInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddUpvoteArgs = {\n  input: AddUpvoteInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddVerifiableDomainArgs = {\n  input: AddVerifiableDomainInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationApproveDeploymentsArgs = {\n  input: ApproveDeploymentsInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationApproveVerifiableDomainArgs = {\n  input: ApproveVerifiableDomainInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationArchiveRepositoryArgs = {\n  input: ArchiveRepositoryInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCancelEnterpriseAdminInvitationArgs = {\n  input: CancelEnterpriseAdminInvitationInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCancelSponsorshipArgs = {\n  input: CancelSponsorshipInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationChangeUserStatusArgs = {\n  input: ChangeUserStatusInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationClearLabelsFromLabelableArgs = {\n  input: ClearLabelsFromLabelableInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCloneProjectArgs = {\n  input: CloneProjectInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCloneTemplateRepositoryArgs = {\n  input: CloneTemplateRepositoryInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCloseIssueArgs = {\n  input: CloseIssueInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationClosePullRequestArgs = {\n  input: ClosePullRequestInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationConvertProjectCardNoteToIssueArgs = {\n  input: ConvertProjectCardNoteToIssueInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationConvertPullRequestToDraftArgs = {\n  input: ConvertPullRequestToDraftInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateBranchProtectionRuleArgs = {\n  input: CreateBranchProtectionRuleInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateCheckRunArgs = {\n  input: CreateCheckRunInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateCheckSuiteArgs = {\n  input: CreateCheckSuiteInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateCommitOnBranchArgs = {\n  input: CreateCommitOnBranchInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateDeploymentArgs = {\n  input: CreateDeploymentInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateDeploymentStatusArgs = {\n  input: CreateDeploymentStatusInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateDiscussionArgs = {\n  input: CreateDiscussionInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateEnterpriseOrganizationArgs = {\n  input: CreateEnterpriseOrganizationInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateEnvironmentArgs = {\n  input: CreateEnvironmentInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateIpAllowListEntryArgs = {\n  input: CreateIpAllowListEntryInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateIssueArgs = {\n  input: CreateIssueInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateLabelArgs = {\n  input: CreateLabelInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateMigrationSourceArgs = {\n  input: CreateMigrationSourceInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateProjectArgs = {\n  input: CreateProjectInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreatePullRequestArgs = {\n  input: CreatePullRequestInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateRefArgs = {\n  input: CreateRefInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateRepositoryArgs = {\n  input: CreateRepositoryInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateSponsorsTierArgs = {\n  input: CreateSponsorsTierInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateSponsorshipArgs = {\n  input: CreateSponsorshipInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateTeamDiscussionArgs = {\n  input: CreateTeamDiscussionInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateTeamDiscussionCommentArgs = {\n  input: CreateTeamDiscussionCommentInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeclineTopicSuggestionArgs = {\n  input: DeclineTopicSuggestionInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteBranchProtectionRuleArgs = {\n  input: DeleteBranchProtectionRuleInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteDeploymentArgs = {\n  input: DeleteDeploymentInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteDiscussionArgs = {\n  input: DeleteDiscussionInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteDiscussionCommentArgs = {\n  input: DeleteDiscussionCommentInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteEnvironmentArgs = {\n  input: DeleteEnvironmentInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteIpAllowListEntryArgs = {\n  input: DeleteIpAllowListEntryInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteIssueArgs = {\n  input: DeleteIssueInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteIssueCommentArgs = {\n  input: DeleteIssueCommentInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteLabelArgs = {\n  input: DeleteLabelInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeletePackageVersionArgs = {\n  input: DeletePackageVersionInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteProjectArgs = {\n  input: DeleteProjectInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteProjectCardArgs = {\n  input: DeleteProjectCardInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteProjectColumnArgs = {\n  input: DeleteProjectColumnInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteProjectNextItemArgs = {\n  input: DeleteProjectNextItemInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeletePullRequestReviewArgs = {\n  input: DeletePullRequestReviewInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeletePullRequestReviewCommentArgs = {\n  input: DeletePullRequestReviewCommentInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteRefArgs = {\n  input: DeleteRefInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteTeamDiscussionArgs = {\n  input: DeleteTeamDiscussionInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteTeamDiscussionCommentArgs = {\n  input: DeleteTeamDiscussionCommentInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteVerifiableDomainArgs = {\n  input: DeleteVerifiableDomainInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDisablePullRequestAutoMergeArgs = {\n  input: DisablePullRequestAutoMergeInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDismissPullRequestReviewArgs = {\n  input: DismissPullRequestReviewInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDismissRepositoryVulnerabilityAlertArgs = {\n  input: DismissRepositoryVulnerabilityAlertInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationEnablePullRequestAutoMergeArgs = {\n  input: EnablePullRequestAutoMergeInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationFollowOrganizationArgs = {\n  input: FollowOrganizationInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationFollowUserArgs = {\n  input: FollowUserInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationGrantEnterpriseOrganizationsMigratorRoleArgs = {\n  input: GrantEnterpriseOrganizationsMigratorRoleInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationGrantMigratorRoleArgs = {\n  input: GrantMigratorRoleInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationImportProjectArgs = {\n  input: ImportProjectInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationInviteEnterpriseAdminArgs = {\n  input: InviteEnterpriseAdminInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationLinkRepositoryToProjectArgs = {\n  input: LinkRepositoryToProjectInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationLockLockableArgs = {\n  input: LockLockableInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationMarkDiscussionCommentAsAnswerArgs = {\n  input: MarkDiscussionCommentAsAnswerInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationMarkFileAsViewedArgs = {\n  input: MarkFileAsViewedInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationMarkPullRequestReadyForReviewArgs = {\n  input: MarkPullRequestReadyForReviewInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationMergeBranchArgs = {\n  input: MergeBranchInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationMergePullRequestArgs = {\n  input: MergePullRequestInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationMinimizeCommentArgs = {\n  input: MinimizeCommentInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationMoveProjectCardArgs = {\n  input: MoveProjectCardInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationMoveProjectColumnArgs = {\n  input: MoveProjectColumnInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationPinIssueArgs = {\n  input: PinIssueInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRegenerateEnterpriseIdentityProviderRecoveryCodesArgs = {\n  input: RegenerateEnterpriseIdentityProviderRecoveryCodesInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRegenerateVerifiableDomainTokenArgs = {\n  input: RegenerateVerifiableDomainTokenInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRejectDeploymentsArgs = {\n  input: RejectDeploymentsInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRemoveAssigneesFromAssignableArgs = {\n  input: RemoveAssigneesFromAssignableInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRemoveEnterpriseAdminArgs = {\n  input: RemoveEnterpriseAdminInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRemoveEnterpriseIdentityProviderArgs = {\n  input: RemoveEnterpriseIdentityProviderInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRemoveEnterpriseOrganizationArgs = {\n  input: RemoveEnterpriseOrganizationInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRemoveEnterpriseSupportEntitlementArgs = {\n  input: RemoveEnterpriseSupportEntitlementInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRemoveLabelsFromLabelableArgs = {\n  input: RemoveLabelsFromLabelableInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRemoveOutsideCollaboratorArgs = {\n  input: RemoveOutsideCollaboratorInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRemoveReactionArgs = {\n  input: RemoveReactionInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRemoveStarArgs = {\n  input: RemoveStarInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRemoveUpvoteArgs = {\n  input: RemoveUpvoteInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationReopenIssueArgs = {\n  input: ReopenIssueInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationReopenPullRequestArgs = {\n  input: ReopenPullRequestInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRequestReviewsArgs = {\n  input: RequestReviewsInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRerequestCheckSuiteArgs = {\n  input: RerequestCheckSuiteInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationResolveReviewThreadArgs = {\n  input: ResolveReviewThreadInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRevokeEnterpriseOrganizationsMigratorRoleArgs = {\n  input: RevokeEnterpriseOrganizationsMigratorRoleInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRevokeMigratorRoleArgs = {\n  input: RevokeMigratorRoleInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationSetEnterpriseIdentityProviderArgs = {\n  input: SetEnterpriseIdentityProviderInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationSetOrganizationInteractionLimitArgs = {\n  input: SetOrganizationInteractionLimitInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationSetRepositoryInteractionLimitArgs = {\n  input: SetRepositoryInteractionLimitInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationSetUserInteractionLimitArgs = {\n  input: SetUserInteractionLimitInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationStartRepositoryMigrationArgs = {\n  input: StartRepositoryMigrationInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationSubmitPullRequestReviewArgs = {\n  input: SubmitPullRequestReviewInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationTransferIssueArgs = {\n  input: TransferIssueInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnarchiveRepositoryArgs = {\n  input: UnarchiveRepositoryInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnfollowOrganizationArgs = {\n  input: UnfollowOrganizationInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnfollowUserArgs = {\n  input: UnfollowUserInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnlinkRepositoryFromProjectArgs = {\n  input: UnlinkRepositoryFromProjectInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnlockLockableArgs = {\n  input: UnlockLockableInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnmarkDiscussionCommentAsAnswerArgs = {\n  input: UnmarkDiscussionCommentAsAnswerInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnmarkFileAsViewedArgs = {\n  input: UnmarkFileAsViewedInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnmarkIssueAsDuplicateArgs = {\n  input: UnmarkIssueAsDuplicateInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnminimizeCommentArgs = {\n  input: UnminimizeCommentInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnpinIssueArgs = {\n  input: UnpinIssueInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnresolveReviewThreadArgs = {\n  input: UnresolveReviewThreadInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateBranchProtectionRuleArgs = {\n  input: UpdateBranchProtectionRuleInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateCheckRunArgs = {\n  input: UpdateCheckRunInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateCheckSuitePreferencesArgs = {\n  input: UpdateCheckSuitePreferencesInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateDiscussionArgs = {\n  input: UpdateDiscussionInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateDiscussionCommentArgs = {\n  input: UpdateDiscussionCommentInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseAdministratorRoleArgs = {\n  input: UpdateEnterpriseAdministratorRoleInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseAllowPrivateRepositoryForkingSettingArgs = {\n  input: UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseDefaultRepositoryPermissionSettingArgs = {\n  input: UpdateEnterpriseDefaultRepositoryPermissionSettingInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingArgs = {\n  input: UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseMembersCanCreateRepositoriesSettingArgs = {\n  input: UpdateEnterpriseMembersCanCreateRepositoriesSettingInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseMembersCanDeleteIssuesSettingArgs = {\n  input: UpdateEnterpriseMembersCanDeleteIssuesSettingInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseMembersCanDeleteRepositoriesSettingArgs = {\n  input: UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseMembersCanInviteCollaboratorsSettingArgs = {\n  input: UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseMembersCanMakePurchasesSettingArgs = {\n  input: UpdateEnterpriseMembersCanMakePurchasesSettingInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseMembersCanUpdateProtectedBranchesSettingArgs = {\n  input: UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseMembersCanViewDependencyInsightsSettingArgs = {\n  input: UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseOrganizationProjectsSettingArgs = {\n  input: UpdateEnterpriseOrganizationProjectsSettingInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseOwnerOrganizationRoleArgs = {\n  input: UpdateEnterpriseOwnerOrganizationRoleInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseProfileArgs = {\n  input: UpdateEnterpriseProfileInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseRepositoryProjectsSettingArgs = {\n  input: UpdateEnterpriseRepositoryProjectsSettingInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseTeamDiscussionsSettingArgs = {\n  input: UpdateEnterpriseTeamDiscussionsSettingInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseTwoFactorAuthenticationRequiredSettingArgs = {\n  input: UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnvironmentArgs = {\n  input: UpdateEnvironmentInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateIpAllowListEnabledSettingArgs = {\n  input: UpdateIpAllowListEnabledSettingInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateIpAllowListEntryArgs = {\n  input: UpdateIpAllowListEntryInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateIpAllowListForInstalledAppsEnabledSettingArgs = {\n  input: UpdateIpAllowListForInstalledAppsEnabledSettingInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateIssueArgs = {\n  input: UpdateIssueInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateIssueCommentArgs = {\n  input: UpdateIssueCommentInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateLabelArgs = {\n  input: UpdateLabelInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateNotificationRestrictionSettingArgs = {\n  input: UpdateNotificationRestrictionSettingInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateOrganizationAllowPrivateRepositoryForkingSettingArgs = {\n  input: UpdateOrganizationAllowPrivateRepositoryForkingSettingInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateProjectArgs = {\n  input: UpdateProjectInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateProjectCardArgs = {\n  input: UpdateProjectCardInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateProjectColumnArgs = {\n  input: UpdateProjectColumnInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateProjectDraftIssueArgs = {\n  input: UpdateProjectDraftIssueInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateProjectNextArgs = {\n  input: UpdateProjectNextInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateProjectNextItemFieldArgs = {\n  input: UpdateProjectNextItemFieldInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdatePullRequestArgs = {\n  input: UpdatePullRequestInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdatePullRequestBranchArgs = {\n  input: UpdatePullRequestBranchInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdatePullRequestReviewArgs = {\n  input: UpdatePullRequestReviewInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdatePullRequestReviewCommentArgs = {\n  input: UpdatePullRequestReviewCommentInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateRefArgs = {\n  input: UpdateRefInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateRefsArgs = {\n  input: UpdateRefsInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateRepositoryArgs = {\n  input: UpdateRepositoryInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateSponsorshipPreferencesArgs = {\n  input: UpdateSponsorshipPreferencesInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateSubscriptionArgs = {\n  input: UpdateSubscriptionInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateTeamDiscussionArgs = {\n  input: UpdateTeamDiscussionInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateTeamDiscussionCommentArgs = {\n  input: UpdateTeamDiscussionCommentInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateTeamReviewAssignmentArgs = {\n  input: UpdateTeamReviewAssignmentInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateTeamsRepositoryArgs = {\n  input: UpdateTeamsRepositoryInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateTopicsArgs = {\n  input: UpdateTopicsInput;\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationVerifyVerifiableDomainArgs = {\n  input: VerifyVerifiableDomainInput;\n};\n\n/** An object with an ID. */\nexport type Node = {\n  /** ID of the object. */\n  id: Scalars[\"ID\"];\n};\n\n/** The possible values for the notification restriction setting. */\nexport enum NotificationRestrictionSettingValue {\n  /** The setting is disabled for the owner. */\n  Disabled = \"DISABLED\",\n  /** The setting is enabled for the owner. */\n  Enabled = \"ENABLED\",\n}\n\n/** An OIDC identity provider configured to provision identities for an enterprise. */\nexport type OidcProvider = Node & {\n  __typename?: \"OIDCProvider\";\n  /** The enterprise this identity provider belongs to. */\n  enterprise?: Maybe<Enterprise>;\n  /** ExternalIdentities provisioned by this identity provider. */\n  externalIdentities: ExternalIdentityConnection;\n  id: Scalars[\"ID\"];\n  /** The OIDC identity provider type */\n  providerType: OidcProviderType;\n  /** The id of the tenant this provider is attached to */\n  tenantId: Scalars[\"String\"];\n};\n\n/** An OIDC identity provider configured to provision identities for an enterprise. */\nexport type OidcProviderExternalIdentitiesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  login?: InputMaybe<Scalars[\"String\"]>;\n  membersOnly?: InputMaybe<Scalars[\"Boolean\"]>;\n  userName?: InputMaybe<Scalars[\"String\"]>;\n};\n\n/** The OIDC identity provider type */\nexport enum OidcProviderType {\n  /** Azure Active Directory */\n  Aad = \"AAD\",\n}\n\n/** Metadata for an audit entry with action oauth_application.* */\nexport type OauthApplicationAuditEntryData = {\n  /** The name of the OAuth Application. */\n  oauthApplicationName?: Maybe<Scalars[\"String\"]>;\n  /** The HTTP path for the OAuth Application */\n  oauthApplicationResourcePath?: Maybe<Scalars[\"URI\"]>;\n  /** The HTTP URL for the OAuth Application */\n  oauthApplicationUrl?: Maybe<Scalars[\"URI\"]>;\n};\n\n/** Audit log entry for a oauth_application.create event. */\nexport type OauthApplicationCreateAuditEntry = AuditEntry &\n  Node &\n  OauthApplicationAuditEntryData &\n  OrganizationAuditEntryData & {\n    __typename?: \"OauthApplicationCreateAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The application URL of the OAuth Application. */\n    applicationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The callback URL of the OAuth Application. */\n    callbackUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** The name of the OAuth Application. */\n    oauthApplicationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the OAuth Application */\n    oauthApplicationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the OAuth Application */\n    oauthApplicationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The rate limit of the OAuth Application. */\n    rateLimit?: Maybe<Scalars[\"Int\"]>;\n    /** The state of the OAuth Application. */\n    state?: Maybe<OauthApplicationCreateAuditEntryState>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** The state of an OAuth Application when it was created. */\nexport enum OauthApplicationCreateAuditEntryState {\n  /** The OAuth Application was active and allowed to have OAuth Accesses. */\n  Active = \"ACTIVE\",\n  /** The OAuth Application was in the process of being deleted. */\n  PendingDeletion = \"PENDING_DELETION\",\n  /** The OAuth Application was suspended from generating OAuth Accesses due to abuse or security concerns. */\n  Suspended = \"SUSPENDED\",\n}\n\n/** The corresponding operation type for the action */\nexport enum OperationType {\n  /** An existing resource was accessed */\n  Access = \"ACCESS\",\n  /** A resource performed an authentication event */\n  Authentication = \"AUTHENTICATION\",\n  /** A new resource was created */\n  Create = \"CREATE\",\n  /** An existing resource was modified */\n  Modify = \"MODIFY\",\n  /** An existing resource was removed */\n  Remove = \"REMOVE\",\n  /** An existing resource was restored */\n  Restore = \"RESTORE\",\n  /** An existing resource was transferred between multiple resources */\n  Transfer = \"TRANSFER\",\n}\n\n/** Possible directions in which to order a list of items when provided an `orderBy` argument. */\nexport enum OrderDirection {\n  /** Specifies an ascending order for a given `orderBy` argument. */\n  Asc = \"ASC\",\n  /** Specifies a descending order for a given `orderBy` argument. */\n  Desc = \"DESC\",\n}\n\n/** Audit log entry for a org.add_billing_manager */\nexport type OrgAddBillingManagerAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    __typename?: \"OrgAddBillingManagerAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** The email address used to invite a billing manager for the organization. */\n    invitationEmail?: Maybe<Scalars[\"String\"]>;\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** Audit log entry for a org.add_member */\nexport type OrgAddMemberAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    __typename?: \"OrgAddMemberAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The permission level of the member added to the organization. */\n    permission?: Maybe<OrgAddMemberAuditEntryPermission>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** The permissions available to members on an Organization. */\nexport enum OrgAddMemberAuditEntryPermission {\n  /** Can read, clone, push, and add collaborators to repositories. */\n  Admin = \"ADMIN\",\n  /** Can read and clone repositories. */\n  Read = \"READ\",\n}\n\n/** Audit log entry for a org.block_user */\nexport type OrgBlockUserAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    __typename?: \"OrgBlockUserAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The blocked user. */\n    blockedUser?: Maybe<User>;\n    /** The username of the blocked user. */\n    blockedUserName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the blocked user. */\n    blockedUserResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the blocked user. */\n    blockedUserUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** Audit log entry for a org.config.disable_collaborators_only event. */\nexport type OrgConfigDisableCollaboratorsOnlyAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    __typename?: \"OrgConfigDisableCollaboratorsOnlyAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** Audit log entry for a org.config.enable_collaborators_only event. */\nexport type OrgConfigEnableCollaboratorsOnlyAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    __typename?: \"OrgConfigEnableCollaboratorsOnlyAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** Audit log entry for a org.create event. */\nexport type OrgCreateAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    __typename?: \"OrgCreateAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The billing plan for the Organization. */\n    billingPlan?: Maybe<OrgCreateAuditEntryBillingPlan>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** The billing plans available for organizations. */\nexport enum OrgCreateAuditEntryBillingPlan {\n  /** Team Plan */\n  Business = \"BUSINESS\",\n  /** Enterprise Cloud Plan */\n  BusinessPlus = \"BUSINESS_PLUS\",\n  /** Free Plan */\n  Free = \"FREE\",\n  /** Tiered Per Seat Plan */\n  TieredPerSeat = \"TIERED_PER_SEAT\",\n  /** Legacy Unlimited Plan */\n  Unlimited = \"UNLIMITED\",\n}\n\n/** Audit log entry for a org.disable_oauth_app_restrictions event. */\nexport type OrgDisableOauthAppRestrictionsAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    __typename?: \"OrgDisableOauthAppRestrictionsAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** Audit log entry for a org.disable_saml event. */\nexport type OrgDisableSamlAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    __typename?: \"OrgDisableSamlAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    /** The SAML provider's digest algorithm URL. */\n    digestMethodUrl?: Maybe<Scalars[\"URI\"]>;\n    id: Scalars[\"ID\"];\n    /** The SAML provider's issuer URL. */\n    issuerUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The SAML provider's signature algorithm URL. */\n    signatureMethodUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The SAML provider's single sign-on URL. */\n    singleSignOnUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** Audit log entry for a org.disable_two_factor_requirement event. */\nexport type OrgDisableTwoFactorRequirementAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    __typename?: \"OrgDisableTwoFactorRequirementAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** Audit log entry for a org.enable_oauth_app_restrictions event. */\nexport type OrgEnableOauthAppRestrictionsAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    __typename?: \"OrgEnableOauthAppRestrictionsAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** Audit log entry for a org.enable_saml event. */\nexport type OrgEnableSamlAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    __typename?: \"OrgEnableSamlAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    /** The SAML provider's digest algorithm URL. */\n    digestMethodUrl?: Maybe<Scalars[\"URI\"]>;\n    id: Scalars[\"ID\"];\n    /** The SAML provider's issuer URL. */\n    issuerUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The SAML provider's signature algorithm URL. */\n    signatureMethodUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The SAML provider's single sign-on URL. */\n    singleSignOnUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** Audit log entry for a org.enable_two_factor_requirement event. */\nexport type OrgEnableTwoFactorRequirementAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    __typename?: \"OrgEnableTwoFactorRequirementAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** Ordering options for an organization's enterprise owner connections. */\nexport type OrgEnterpriseOwnerOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order enterprise owners by. */\n  field: OrgEnterpriseOwnerOrderField;\n};\n\n/** Properties by which enterprise owners can be ordered. */\nexport enum OrgEnterpriseOwnerOrderField {\n  /** Order enterprise owners by login. */\n  Login = \"LOGIN\",\n}\n\n/** Audit log entry for a org.invite_member event. */\nexport type OrgInviteMemberAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    __typename?: \"OrgInviteMemberAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    /** The email address of the organization invitation. */\n    email?: Maybe<Scalars[\"String\"]>;\n    id: Scalars[\"ID\"];\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The organization invitation. */\n    organizationInvitation?: Maybe<OrganizationInvitation>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** Audit log entry for a org.invite_to_business event. */\nexport type OrgInviteToBusinessAuditEntry = AuditEntry &\n  EnterpriseAuditEntryData &\n  Node &\n  OrganizationAuditEntryData & {\n    __typename?: \"OrgInviteToBusinessAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    /** The HTTP path for this enterprise. */\n    enterpriseResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The slug of the enterprise. */\n    enterpriseSlug?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP URL for this enterprise. */\n    enterpriseUrl?: Maybe<Scalars[\"URI\"]>;\n    id: Scalars[\"ID\"];\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** Audit log entry for a org.oauth_app_access_approved event. */\nexport type OrgOauthAppAccessApprovedAuditEntry = AuditEntry &\n  Node &\n  OauthApplicationAuditEntryData &\n  OrganizationAuditEntryData & {\n    __typename?: \"OrgOauthAppAccessApprovedAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** The name of the OAuth Application. */\n    oauthApplicationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the OAuth Application */\n    oauthApplicationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the OAuth Application */\n    oauthApplicationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** Audit log entry for a org.oauth_app_access_denied event. */\nexport type OrgOauthAppAccessDeniedAuditEntry = AuditEntry &\n  Node &\n  OauthApplicationAuditEntryData &\n  OrganizationAuditEntryData & {\n    __typename?: \"OrgOauthAppAccessDeniedAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** The name of the OAuth Application. */\n    oauthApplicationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the OAuth Application */\n    oauthApplicationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the OAuth Application */\n    oauthApplicationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** Audit log entry for a org.oauth_app_access_requested event. */\nexport type OrgOauthAppAccessRequestedAuditEntry = AuditEntry &\n  Node &\n  OauthApplicationAuditEntryData &\n  OrganizationAuditEntryData & {\n    __typename?: \"OrgOauthAppAccessRequestedAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** The name of the OAuth Application. */\n    oauthApplicationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the OAuth Application */\n    oauthApplicationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the OAuth Application */\n    oauthApplicationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** Audit log entry for a org.remove_billing_manager event. */\nexport type OrgRemoveBillingManagerAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    __typename?: \"OrgRemoveBillingManagerAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The reason for the billing manager being removed. */\n    reason?: Maybe<OrgRemoveBillingManagerAuditEntryReason>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** The reason a billing manager was removed from an Organization. */\nexport enum OrgRemoveBillingManagerAuditEntryReason {\n  /** SAML external identity missing */\n  SamlExternalIdentityMissing = \"SAML_EXTERNAL_IDENTITY_MISSING\",\n  /** SAML SSO enforcement requires an external identity */\n  SamlSsoEnforcementRequiresExternalIdentity = \"SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY\",\n  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */\n  TwoFactorRequirementNonCompliance = \"TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE\",\n}\n\n/** Audit log entry for a org.remove_member event. */\nexport type OrgRemoveMemberAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    __typename?: \"OrgRemoveMemberAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** The types of membership the member has with the organization. */\n    membershipTypes?: Maybe<Array<OrgRemoveMemberAuditEntryMembershipType>>;\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The reason for the member being removed. */\n    reason?: Maybe<OrgRemoveMemberAuditEntryReason>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** The type of membership a user has with an Organization. */\nexport enum OrgRemoveMemberAuditEntryMembershipType {\n  /**\n   * Organization administrators have full access and can change several settings,\n   * including the names of repositories that belong to the Organization and Owners\n   * team membership. In addition, organization admins can delete the organization\n   * and all of its repositories.\n   */\n  Admin = \"ADMIN\",\n  /** A billing manager is a user who manages the billing settings for the Organization, such as updating payment information. */\n  BillingManager = \"BILLING_MANAGER\",\n  /** A direct member is a user that is a member of the Organization. */\n  DirectMember = \"DIRECT_MEMBER\",\n  /**\n   * An outside collaborator is a person who isn't explicitly a member of the\n   * Organization, but who has Read, Write, or Admin permissions to one or more\n   * repositories in the organization.\n   */\n  OutsideCollaborator = \"OUTSIDE_COLLABORATOR\",\n  /**\n   * An unaffiliated collaborator is a person who is not a member of the\n   * Organization and does not have access to any repositories in the Organization.\n   */\n  Unaffiliated = \"UNAFFILIATED\",\n}\n\n/** The reason a member was removed from an Organization. */\nexport enum OrgRemoveMemberAuditEntryReason {\n  /** SAML external identity missing */\n  SamlExternalIdentityMissing = \"SAML_EXTERNAL_IDENTITY_MISSING\",\n  /** SAML SSO enforcement requires an external identity */\n  SamlSsoEnforcementRequiresExternalIdentity = \"SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY\",\n  /** User was removed from organization during account recovery */\n  TwoFactorAccountRecovery = \"TWO_FACTOR_ACCOUNT_RECOVERY\",\n  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */\n  TwoFactorRequirementNonCompliance = \"TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE\",\n  /** User account has been deleted */\n  UserAccountDeleted = \"USER_ACCOUNT_DELETED\",\n}\n\n/** Audit log entry for a org.remove_outside_collaborator event. */\nexport type OrgRemoveOutsideCollaboratorAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    __typename?: \"OrgRemoveOutsideCollaboratorAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** The types of membership the outside collaborator has with the organization. */\n    membershipTypes?: Maybe<Array<OrgRemoveOutsideCollaboratorAuditEntryMembershipType>>;\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The reason for the outside collaborator being removed from the Organization. */\n    reason?: Maybe<OrgRemoveOutsideCollaboratorAuditEntryReason>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** The type of membership a user has with an Organization. */\nexport enum OrgRemoveOutsideCollaboratorAuditEntryMembershipType {\n  /** A billing manager is a user who manages the billing settings for the Organization, such as updating payment information. */\n  BillingManager = \"BILLING_MANAGER\",\n  /**\n   * An outside collaborator is a person who isn't explicitly a member of the\n   * Organization, but who has Read, Write, or Admin permissions to one or more\n   * repositories in the organization.\n   */\n  OutsideCollaborator = \"OUTSIDE_COLLABORATOR\",\n  /**\n   * An unaffiliated collaborator is a person who is not a member of the\n   * Organization and does not have access to any repositories in the organization.\n   */\n  Unaffiliated = \"UNAFFILIATED\",\n}\n\n/** The reason an outside collaborator was removed from an Organization. */\nexport enum OrgRemoveOutsideCollaboratorAuditEntryReason {\n  /** SAML external identity missing */\n  SamlExternalIdentityMissing = \"SAML_EXTERNAL_IDENTITY_MISSING\",\n  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */\n  TwoFactorRequirementNonCompliance = \"TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE\",\n}\n\n/** Audit log entry for a org.restore_member event. */\nexport type OrgRestoreMemberAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    __typename?: \"OrgRestoreMemberAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The number of custom email routings for the restored member. */\n    restoredCustomEmailRoutingsCount?: Maybe<Scalars[\"Int\"]>;\n    /** The number of issue assignments for the restored member. */\n    restoredIssueAssignmentsCount?: Maybe<Scalars[\"Int\"]>;\n    /** Restored organization membership objects. */\n    restoredMemberships?: Maybe<Array<OrgRestoreMemberAuditEntryMembership>>;\n    /** The number of restored memberships. */\n    restoredMembershipsCount?: Maybe<Scalars[\"Int\"]>;\n    /** The number of repositories of the restored member. */\n    restoredRepositoriesCount?: Maybe<Scalars[\"Int\"]>;\n    /** The number of starred repositories for the restored member. */\n    restoredRepositoryStarsCount?: Maybe<Scalars[\"Int\"]>;\n    /** The number of watched repositories for the restored member. */\n    restoredRepositoryWatchesCount?: Maybe<Scalars[\"Int\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** Types of memberships that can be restored for an Organization member. */\nexport type OrgRestoreMemberAuditEntryMembership =\n  | OrgRestoreMemberMembershipOrganizationAuditEntryData\n  | OrgRestoreMemberMembershipRepositoryAuditEntryData\n  | OrgRestoreMemberMembershipTeamAuditEntryData;\n\n/** Metadata for an organization membership for org.restore_member actions */\nexport type OrgRestoreMemberMembershipOrganizationAuditEntryData = OrganizationAuditEntryData & {\n  __typename?: \"OrgRestoreMemberMembershipOrganizationAuditEntryData\";\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars[\"String\"]>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars[\"URI\"]>;\n};\n\n/** Metadata for a repository membership for org.restore_member actions */\nexport type OrgRestoreMemberMembershipRepositoryAuditEntryData = RepositoryAuditEntryData & {\n  __typename?: \"OrgRestoreMemberMembershipRepositoryAuditEntryData\";\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars[\"String\"]>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars[\"URI\"]>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars[\"URI\"]>;\n};\n\n/** Metadata for a team membership for org.restore_member actions */\nexport type OrgRestoreMemberMembershipTeamAuditEntryData = TeamAuditEntryData & {\n  __typename?: \"OrgRestoreMemberMembershipTeamAuditEntryData\";\n  /** The team associated with the action */\n  team?: Maybe<Team>;\n  /** The name of the team */\n  teamName?: Maybe<Scalars[\"String\"]>;\n  /** The HTTP path for this team */\n  teamResourcePath?: Maybe<Scalars[\"URI\"]>;\n  /** The HTTP URL for this team */\n  teamUrl?: Maybe<Scalars[\"URI\"]>;\n};\n\n/** Audit log entry for a org.unblock_user */\nexport type OrgUnblockUserAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    __typename?: \"OrgUnblockUserAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user being unblocked by the organization. */\n    blockedUser?: Maybe<User>;\n    /** The username of the blocked user. */\n    blockedUserName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the blocked user. */\n    blockedUserResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the blocked user. */\n    blockedUserUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** Audit log entry for a org.update_default_repository_permission */\nexport type OrgUpdateDefaultRepositoryPermissionAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    __typename?: \"OrgUpdateDefaultRepositoryPermissionAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The new base repository permission level for the organization. */\n    permission?: Maybe<OrgUpdateDefaultRepositoryPermissionAuditEntryPermission>;\n    /** The former base repository permission level for the organization. */\n    permissionWas?: Maybe<OrgUpdateDefaultRepositoryPermissionAuditEntryPermission>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** The default permission a repository can have in an Organization. */\nexport enum OrgUpdateDefaultRepositoryPermissionAuditEntryPermission {\n  /** Can read, clone, push, and add collaborators to repositories. */\n  Admin = \"ADMIN\",\n  /** No default permission value. */\n  None = \"NONE\",\n  /** Can read and clone repositories. */\n  Read = \"READ\",\n  /** Can read, clone and push to repositories. */\n  Write = \"WRITE\",\n}\n\n/** Audit log entry for a org.update_member event. */\nexport type OrgUpdateMemberAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    __typename?: \"OrgUpdateMemberAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The new member permission level for the organization. */\n    permission?: Maybe<OrgUpdateMemberAuditEntryPermission>;\n    /** The former member permission level for the organization. */\n    permissionWas?: Maybe<OrgUpdateMemberAuditEntryPermission>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** The permissions available to members on an Organization. */\nexport enum OrgUpdateMemberAuditEntryPermission {\n  /** Can read, clone, push, and add collaborators to repositories. */\n  Admin = \"ADMIN\",\n  /** Can read and clone repositories. */\n  Read = \"READ\",\n}\n\n/** Audit log entry for a org.update_member_repository_creation_permission event. */\nexport type OrgUpdateMemberRepositoryCreationPermissionAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    __typename?: \"OrgUpdateMemberRepositoryCreationPermissionAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** Can members create repositories in the organization. */\n    canCreateRepositories?: Maybe<Scalars[\"Boolean\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The permission for visibility level of repositories for this organization. */\n    visibility?: Maybe<OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility>;\n  };\n\n/** The permissions available for repository creation on an Organization. */\nexport enum OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility {\n  /** All organization members are restricted from creating any repositories. */\n  All = \"ALL\",\n  /** All organization members are restricted from creating internal repositories. */\n  Internal = \"INTERNAL\",\n  /** All organization members are allowed to create any repositories. */\n  None = \"NONE\",\n  /** All organization members are restricted from creating private repositories. */\n  Private = \"PRIVATE\",\n  /** All organization members are restricted from creating private or internal repositories. */\n  PrivateInternal = \"PRIVATE_INTERNAL\",\n  /** All organization members are restricted from creating public repositories. */\n  Public = \"PUBLIC\",\n  /** All organization members are restricted from creating public or internal repositories. */\n  PublicInternal = \"PUBLIC_INTERNAL\",\n  /** All organization members are restricted from creating public or private repositories. */\n  PublicPrivate = \"PUBLIC_PRIVATE\",\n}\n\n/** Audit log entry for a org.update_member_repository_invitation_permission event. */\nexport type OrgUpdateMemberRepositoryInvitationPermissionAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    __typename?: \"OrgUpdateMemberRepositoryInvitationPermissionAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** Can outside collaborators be invited to repositories in the organization. */\n    canInviteOutsideCollaboratorsToRepositories?: Maybe<Scalars[\"Boolean\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type Organization = Actor &\n  MemberStatusable &\n  Node &\n  PackageOwner &\n  ProfileOwner &\n  ProjectNextOwner &\n  ProjectOwner &\n  ProjectV2Owner &\n  RepositoryDiscussionAuthor &\n  RepositoryDiscussionCommentAuthor &\n  RepositoryOwner &\n  Sponsorable &\n  UniformResourceLocatable & {\n    __typename?: \"Organization\";\n    /** Determine if this repository owner has any items that can be pinned to their profile. */\n    anyPinnableItems: Scalars[\"Boolean\"];\n    /** Audit log entries of the organization */\n    auditLog: OrganizationAuditEntryConnection;\n    /** A URL pointing to the organization's public avatar. */\n    avatarUrl: Scalars[\"URI\"];\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars[\"DateTime\"];\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars[\"Int\"]>;\n    /** The organization's public profile description. */\n    description?: Maybe<Scalars[\"String\"]>;\n    /** The organization's public profile description rendered to HTML. */\n    descriptionHTML?: Maybe<Scalars[\"String\"]>;\n    /** A list of domains owned by the organization. */\n    domains?: Maybe<VerifiableDomainConnection>;\n    /** The organization's public email. */\n    email?: Maybe<Scalars[\"String\"]>;\n    /** A list of owners of the organization's enterprise account. */\n    enterpriseOwners: OrganizationEnterpriseOwnerConnection;\n    /** The estimated next GitHub Sponsors payout for this user/organization in cents (USD). */\n    estimatedNextSponsorsPayoutInCents: Scalars[\"Int\"];\n    /** True if this user/organization has a GitHub Sponsors listing. */\n    hasSponsorsListing: Scalars[\"Boolean\"];\n    id: Scalars[\"ID\"];\n    /** The interaction ability settings for this organization. */\n    interactionAbility?: Maybe<RepositoryInteractionAbility>;\n    /** The setting value for whether the organization has an IP allow list enabled. */\n    ipAllowListEnabledSetting: IpAllowListEnabledSettingValue;\n    /** The IP addresses that are allowed to access resources owned by the organization. */\n    ipAllowListEntries: IpAllowListEntryConnection;\n    /** The setting value for whether the organization has IP allow list configuration for installed GitHub Apps enabled. */\n    ipAllowListForInstalledAppsEnabledSetting: IpAllowListForInstalledAppsEnabledSettingValue;\n    /** Check if the given account is sponsoring this user/organization. */\n    isSponsoredBy: Scalars[\"Boolean\"];\n    /** True if the viewer is sponsored by this user/organization. */\n    isSponsoringViewer: Scalars[\"Boolean\"];\n    /** Whether the organization has verified its profile email and website. */\n    isVerified: Scalars[\"Boolean\"];\n    /**\n     * Showcases a selection of repositories and gists that the profile owner has\n     * either curated or that have been selected automatically based on popularity.\n     */\n    itemShowcase: ProfileItemShowcase;\n    /** The organization's public profile location. */\n    location?: Maybe<Scalars[\"String\"]>;\n    /** The organization's login name. */\n    login: Scalars[\"String\"];\n    /** Get the status messages members of this entity have set that are either public or visible only to the organization. */\n    memberStatuses: UserStatusConnection;\n    /** Members can fork private repositories in this organization */\n    membersCanForkPrivateRepositories: Scalars[\"Boolean\"];\n    /** A list of users who are members of this organization. */\n    membersWithRole: OrganizationMemberConnection;\n    /** The estimated monthly GitHub Sponsors income for this user/organization in cents (USD). */\n    monthlyEstimatedSponsorsIncomeInCents: Scalars[\"Int\"];\n    /** The organization's public profile name. */\n    name?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path creating a new team */\n    newTeamResourcePath: Scalars[\"URI\"];\n    /** The HTTP URL creating a new team */\n    newTeamUrl: Scalars[\"URI\"];\n    /** Indicates if email notification delivery for this organization is restricted to verified or approved domains. */\n    notificationDeliveryRestrictionEnabledSetting: NotificationRestrictionSettingValue;\n    /** The billing email for the organization. */\n    organizationBillingEmail?: Maybe<Scalars[\"String\"]>;\n    /** A list of packages under the owner. */\n    packages: PackageConnection;\n    /** A list of users who have been invited to join this organization. */\n    pendingMembers: UserConnection;\n    /** A list of repositories and gists this profile owner can pin to their profile. */\n    pinnableItems: PinnableItemConnection;\n    /** A list of repositories and gists this profile owner has pinned to their profile */\n    pinnedItems: PinnableItemConnection;\n    /** Returns how many more items this profile owner can pin to their profile. */\n    pinnedItemsRemaining: Scalars[\"Int\"];\n    /** Find project by number. */\n    project?: Maybe<Project>;\n    /** Find a project by project (beta) number. */\n    projectNext?: Maybe<ProjectNext>;\n    /** A list of projects under the owner. */\n    projects: ProjectConnection;\n    /** A list of projects (beta) under the owner. */\n    projectsNext: ProjectNextConnection;\n    /** The HTTP path listing organization's projects */\n    projectsResourcePath: Scalars[\"URI\"];\n    /** The HTTP URL listing organization's projects */\n    projectsUrl: Scalars[\"URI\"];\n    /** A list of repositories that the user owns. */\n    repositories: RepositoryConnection;\n    /** Find Repository. */\n    repository?: Maybe<Repository>;\n    /** Discussion comments this user has authored. */\n    repositoryDiscussionComments: DiscussionCommentConnection;\n    /** Discussions this user has started. */\n    repositoryDiscussions: DiscussionConnection;\n    /** A list of all repository migrations for this organization. */\n    repositoryMigrations: RepositoryMigrationConnection;\n    /**\n     * When true the organization requires all members, billing managers, and outside\n     * collaborators to enable two-factor authentication.\n     */\n    requiresTwoFactorAuthentication?: Maybe<Scalars[\"Boolean\"]>;\n    /** The HTTP path for this organization. */\n    resourcePath: Scalars[\"URI\"];\n    /** The Organization's SAML identity providers */\n    samlIdentityProvider?: Maybe<OrganizationIdentityProvider>;\n    /** List of users and organizations this entity is sponsoring. */\n    sponsoring: SponsorConnection;\n    /** List of sponsors for this user or organization. */\n    sponsors: SponsorConnection;\n    /** Events involving this sponsorable, such as new sponsorships. */\n    sponsorsActivities: SponsorsActivityConnection;\n    /** The GitHub Sponsors listing for this user or organization. */\n    sponsorsListing?: Maybe<SponsorsListing>;\n    /**\n     * The sponsorship from the viewer to this user/organization; that is, the\n     * sponsorship where you're the sponsor. Only returns a sponsorship if it is active.\n     */\n    sponsorshipForViewerAsSponsor?: Maybe<Sponsorship>;\n    /**\n     * The sponsorship from this user/organization to the viewer; that is, the\n     * sponsorship you're receiving. Only returns a sponsorship if it is active.\n     */\n    sponsorshipForViewerAsSponsorable?: Maybe<Sponsorship>;\n    /** List of sponsorship updates sent from this sponsorable to sponsors. */\n    sponsorshipNewsletters: SponsorshipNewsletterConnection;\n    /** This object's sponsorships as the maintainer. */\n    sponsorshipsAsMaintainer: SponsorshipConnection;\n    /** This object's sponsorships as the sponsor. */\n    sponsorshipsAsSponsor: SponsorshipConnection;\n    /** Find an organization's team by its slug. */\n    team?: Maybe<Team>;\n    /** A list of teams in this organization. */\n    teams: TeamConnection;\n    /** The HTTP path listing organization's teams */\n    teamsResourcePath: Scalars[\"URI\"];\n    /** The HTTP URL listing organization's teams */\n    teamsUrl: Scalars[\"URI\"];\n    /** The organization's Twitter username. */\n    twitterUsername?: Maybe<Scalars[\"String\"]>;\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars[\"DateTime\"];\n    /** The HTTP URL for this organization. */\n    url: Scalars[\"URI\"];\n    /** Organization is adminable by the viewer. */\n    viewerCanAdminister: Scalars[\"Boolean\"];\n    /** Can the viewer pin repositories and gists to the profile? */\n    viewerCanChangePinnedItems: Scalars[\"Boolean\"];\n    /** Can the current viewer create new projects on this owner. */\n    viewerCanCreateProjects: Scalars[\"Boolean\"];\n    /** Viewer can create repositories on this organization */\n    viewerCanCreateRepositories: Scalars[\"Boolean\"];\n    /** Viewer can create teams on this organization. */\n    viewerCanCreateTeams: Scalars[\"Boolean\"];\n    /** Whether or not the viewer is able to sponsor this user/organization. */\n    viewerCanSponsor: Scalars[\"Boolean\"];\n    /** Viewer is an active member of this organization. */\n    viewerIsAMember: Scalars[\"Boolean\"];\n    /** True if the viewer is sponsoring this user/organization. */\n    viewerIsSponsoring: Scalars[\"Boolean\"];\n    /** The organization's public profile URL. */\n    websiteUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationAnyPinnableItemsArgs = {\n  type?: InputMaybe<PinnableItemType>;\n};\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationAuditLogArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<AuditLogOrder>;\n  query?: InputMaybe<Scalars[\"String\"]>;\n};\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationAvatarUrlArgs = {\n  size?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationDomainsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  isApproved?: InputMaybe<Scalars[\"Boolean\"]>;\n  isVerified?: InputMaybe<Scalars[\"Boolean\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<VerifiableDomainOrder>;\n};\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationEnterpriseOwnersArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<OrgEnterpriseOwnerOrder>;\n  organizationRole?: InputMaybe<RoleInOrganization>;\n  query?: InputMaybe<Scalars[\"String\"]>;\n};\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationIpAllowListEntriesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<IpAllowListEntryOrder>;\n};\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationIsSponsoredByArgs = {\n  accountLogin: Scalars[\"String\"];\n};\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationMemberStatusesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<UserStatusOrder>;\n};\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationMembersWithRoleArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationPackagesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  names?: InputMaybe<Array<InputMaybe<Scalars[\"String\"]>>>;\n  orderBy?: InputMaybe<PackageOrder>;\n  packageType?: InputMaybe<PackageType>;\n  repositoryId?: InputMaybe<Scalars[\"ID\"]>;\n};\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationPendingMembersArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationPinnableItemsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  types?: InputMaybe<Array<PinnableItemType>>;\n};\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationPinnedItemsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  types?: InputMaybe<Array<PinnableItemType>>;\n};\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationProjectArgs = {\n  number: Scalars[\"Int\"];\n};\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationProjectNextArgs = {\n  number: Scalars[\"Int\"];\n};\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationProjectsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<ProjectOrder>;\n  search?: InputMaybe<Scalars[\"String\"]>;\n  states?: InputMaybe<Array<ProjectState>>;\n};\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationProjectsNextArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  query?: InputMaybe<Scalars[\"String\"]>;\n  sortBy?: InputMaybe<ProjectNextOrderField>;\n};\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationRepositoriesArgs = {\n  affiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  isFork?: InputMaybe<Scalars[\"Boolean\"]>;\n  isLocked?: InputMaybe<Scalars[\"Boolean\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<RepositoryOrder>;\n  ownerAffiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;\n  privacy?: InputMaybe<RepositoryPrivacy>;\n};\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationRepositoryArgs = {\n  followRenames?: InputMaybe<Scalars[\"Boolean\"]>;\n  name: Scalars[\"String\"];\n};\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationRepositoryDiscussionCommentsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  onlyAnswers?: InputMaybe<Scalars[\"Boolean\"]>;\n  repositoryId?: InputMaybe<Scalars[\"ID\"]>;\n};\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationRepositoryDiscussionsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  answered?: InputMaybe<Scalars[\"Boolean\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<DiscussionOrder>;\n  repositoryId?: InputMaybe<Scalars[\"ID\"]>;\n};\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationRepositoryMigrationsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<RepositoryMigrationOrder>;\n  repositoryName?: InputMaybe<Scalars[\"String\"]>;\n  state?: InputMaybe<MigrationState>;\n};\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationSponsoringArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<SponsorOrder>;\n};\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationSponsorsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<SponsorOrder>;\n  tierId?: InputMaybe<Scalars[\"ID\"]>;\n};\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationSponsorsActivitiesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<SponsorsActivityOrder>;\n  period?: InputMaybe<SponsorsActivityPeriod>;\n};\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationSponsorshipNewslettersArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<SponsorshipNewsletterOrder>;\n};\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationSponsorshipsAsMaintainerArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  includePrivate?: InputMaybe<Scalars[\"Boolean\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<SponsorshipOrder>;\n};\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationSponsorshipsAsSponsorArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<SponsorshipOrder>;\n};\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationTeamArgs = {\n  slug: Scalars[\"String\"];\n};\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationTeamsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  ldapMapped?: InputMaybe<Scalars[\"Boolean\"]>;\n  orderBy?: InputMaybe<TeamOrder>;\n  privacy?: InputMaybe<TeamPrivacy>;\n  query?: InputMaybe<Scalars[\"String\"]>;\n  role?: InputMaybe<TeamRole>;\n  rootTeamsOnly?: InputMaybe<Scalars[\"Boolean\"]>;\n  userLogins?: InputMaybe<Array<Scalars[\"String\"]>>;\n};\n\n/** An audit entry in an organization audit log. */\nexport type OrganizationAuditEntry =\n  | MembersCanDeleteReposClearAuditEntry\n  | MembersCanDeleteReposDisableAuditEntry\n  | MembersCanDeleteReposEnableAuditEntry\n  | OauthApplicationCreateAuditEntry\n  | OrgAddBillingManagerAuditEntry\n  | OrgAddMemberAuditEntry\n  | OrgBlockUserAuditEntry\n  | OrgConfigDisableCollaboratorsOnlyAuditEntry\n  | OrgConfigEnableCollaboratorsOnlyAuditEntry\n  | OrgCreateAuditEntry\n  | OrgDisableOauthAppRestrictionsAuditEntry\n  | OrgDisableSamlAuditEntry\n  | OrgDisableTwoFactorRequirementAuditEntry\n  | OrgEnableOauthAppRestrictionsAuditEntry\n  | OrgEnableSamlAuditEntry\n  | OrgEnableTwoFactorRequirementAuditEntry\n  | OrgInviteMemberAuditEntry\n  | OrgInviteToBusinessAuditEntry\n  | OrgOauthAppAccessApprovedAuditEntry\n  | OrgOauthAppAccessDeniedAuditEntry\n  | OrgOauthAppAccessRequestedAuditEntry\n  | OrgRemoveBillingManagerAuditEntry\n  | OrgRemoveMemberAuditEntry\n  | OrgRemoveOutsideCollaboratorAuditEntry\n  | OrgRestoreMemberAuditEntry\n  | OrgUnblockUserAuditEntry\n  | OrgUpdateDefaultRepositoryPermissionAuditEntry\n  | OrgUpdateMemberAuditEntry\n  | OrgUpdateMemberRepositoryCreationPermissionAuditEntry\n  | OrgUpdateMemberRepositoryInvitationPermissionAuditEntry\n  | PrivateRepositoryForkingDisableAuditEntry\n  | PrivateRepositoryForkingEnableAuditEntry\n  | RepoAccessAuditEntry\n  | RepoAddMemberAuditEntry\n  | RepoAddTopicAuditEntry\n  | RepoArchivedAuditEntry\n  | RepoChangeMergeSettingAuditEntry\n  | RepoConfigDisableAnonymousGitAccessAuditEntry\n  | RepoConfigDisableCollaboratorsOnlyAuditEntry\n  | RepoConfigDisableContributorsOnlyAuditEntry\n  | RepoConfigDisableSockpuppetDisallowedAuditEntry\n  | RepoConfigEnableAnonymousGitAccessAuditEntry\n  | RepoConfigEnableCollaboratorsOnlyAuditEntry\n  | RepoConfigEnableContributorsOnlyAuditEntry\n  | RepoConfigEnableSockpuppetDisallowedAuditEntry\n  | RepoConfigLockAnonymousGitAccessAuditEntry\n  | RepoConfigUnlockAnonymousGitAccessAuditEntry\n  | RepoCreateAuditEntry\n  | RepoDestroyAuditEntry\n  | RepoRemoveMemberAuditEntry\n  | RepoRemoveTopicAuditEntry\n  | RepositoryVisibilityChangeDisableAuditEntry\n  | RepositoryVisibilityChangeEnableAuditEntry\n  | TeamAddMemberAuditEntry\n  | TeamAddRepositoryAuditEntry\n  | TeamChangeParentTeamAuditEntry\n  | TeamRemoveMemberAuditEntry\n  | TeamRemoveRepositoryAuditEntry;\n\n/** The connection type for OrganizationAuditEntry. */\nexport type OrganizationAuditEntryConnection = {\n  __typename?: \"OrganizationAuditEntryConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<OrganizationAuditEntryEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<OrganizationAuditEntry>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** Metadata for an audit entry with action org.* */\nexport type OrganizationAuditEntryData = {\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars[\"String\"]>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars[\"URI\"]>;\n};\n\n/** An edge in a connection. */\nexport type OrganizationAuditEntryEdge = {\n  __typename?: \"OrganizationAuditEntryEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<OrganizationAuditEntry>;\n};\n\n/** A list of organizations managed by an enterprise. */\nexport type OrganizationConnection = {\n  __typename?: \"OrganizationConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<OrganizationEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Organization>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type OrganizationEdge = {\n  __typename?: \"OrganizationEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<Organization>;\n};\n\n/** The connection type for User. */\nexport type OrganizationEnterpriseOwnerConnection = {\n  __typename?: \"OrganizationEnterpriseOwnerConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<OrganizationEnterpriseOwnerEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An enterprise owner in the context of an organization that is part of the enterprise. */\nexport type OrganizationEnterpriseOwnerEdge = {\n  __typename?: \"OrganizationEnterpriseOwnerEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<User>;\n  /** The role of the owner with respect to the organization. */\n  organizationRole: RoleInOrganization;\n};\n\n/** An Identity Provider configured to provision SAML and SCIM identities for Organizations */\nexport type OrganizationIdentityProvider = Node & {\n  __typename?: \"OrganizationIdentityProvider\";\n  /** The digest algorithm used to sign SAML requests for the Identity Provider. */\n  digestMethod?: Maybe<Scalars[\"URI\"]>;\n  /** External Identities provisioned by this Identity Provider */\n  externalIdentities: ExternalIdentityConnection;\n  id: Scalars[\"ID\"];\n  /** The x509 certificate used by the Identity Provider to sign assertions and responses. */\n  idpCertificate?: Maybe<Scalars[\"X509Certificate\"]>;\n  /** The Issuer Entity ID for the SAML Identity Provider */\n  issuer?: Maybe<Scalars[\"String\"]>;\n  /** Organization this Identity Provider belongs to */\n  organization?: Maybe<Organization>;\n  /** The signature algorithm used to sign SAML requests for the Identity Provider. */\n  signatureMethod?: Maybe<Scalars[\"URI\"]>;\n  /** The URL endpoint for the Identity Provider's SAML SSO. */\n  ssoUrl?: Maybe<Scalars[\"URI\"]>;\n};\n\n/** An Identity Provider configured to provision SAML and SCIM identities for Organizations */\nexport type OrganizationIdentityProviderExternalIdentitiesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  login?: InputMaybe<Scalars[\"String\"]>;\n  membersOnly?: InputMaybe<Scalars[\"Boolean\"]>;\n  userName?: InputMaybe<Scalars[\"String\"]>;\n};\n\n/** An Invitation for a user to an organization. */\nexport type OrganizationInvitation = Node & {\n  __typename?: \"OrganizationInvitation\";\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** The email address of the user invited to the organization. */\n  email?: Maybe<Scalars[\"String\"]>;\n  id: Scalars[\"ID\"];\n  /** The type of invitation that was sent (e.g. email, user). */\n  invitationType: OrganizationInvitationType;\n  /** The user who was invited to the organization. */\n  invitee?: Maybe<User>;\n  /** The user who created the invitation. */\n  inviter: User;\n  /** The organization the invite is for */\n  organization: Organization;\n  /** The user's pending role in the organization (e.g. member, owner). */\n  role: OrganizationInvitationRole;\n};\n\n/** The connection type for OrganizationInvitation. */\nexport type OrganizationInvitationConnection = {\n  __typename?: \"OrganizationInvitationConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<OrganizationInvitationEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<OrganizationInvitation>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type OrganizationInvitationEdge = {\n  __typename?: \"OrganizationInvitationEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<OrganizationInvitation>;\n};\n\n/** The possible organization invitation roles. */\nexport enum OrganizationInvitationRole {\n  /** The user is invited to be an admin of the organization. */\n  Admin = \"ADMIN\",\n  /** The user is invited to be a billing manager of the organization. */\n  BillingManager = \"BILLING_MANAGER\",\n  /** The user is invited to be a direct member of the organization. */\n  DirectMember = \"DIRECT_MEMBER\",\n  /** The user's previous role will be reinstated. */\n  Reinstate = \"REINSTATE\",\n}\n\n/** The possible organization invitation types. */\nexport enum OrganizationInvitationType {\n  /** The invitation was to an email address. */\n  Email = \"EMAIL\",\n  /** The invitation was to an existing user. */\n  User = \"USER\",\n}\n\n/** The connection type for User. */\nexport type OrganizationMemberConnection = {\n  __typename?: \"OrganizationMemberConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<OrganizationMemberEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** Represents a user within an organization. */\nexport type OrganizationMemberEdge = {\n  __typename?: \"OrganizationMemberEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** Whether the organization member has two factor enabled or not. Returns null if information is not available to viewer. */\n  hasTwoFactorEnabled?: Maybe<Scalars[\"Boolean\"]>;\n  /** The item at the end of the edge. */\n  node?: Maybe<User>;\n  /** The role this user has in the organization. */\n  role?: Maybe<OrganizationMemberRole>;\n};\n\n/** The possible roles within an organization for its members. */\nexport enum OrganizationMemberRole {\n  /** The user is an administrator of the organization. */\n  Admin = \"ADMIN\",\n  /** The user is a member of the organization. */\n  Member = \"MEMBER\",\n}\n\n/** The possible values for the members can create repositories setting on an organization. */\nexport enum OrganizationMembersCanCreateRepositoriesSettingValue {\n  /** Members will be able to create public and private repositories. */\n  All = \"ALL\",\n  /** Members will not be able to create public or private repositories. */\n  Disabled = \"DISABLED\",\n  /** Members will be able to create only internal repositories. */\n  Internal = \"INTERNAL\",\n  /** Members will be able to create only private repositories. */\n  Private = \"PRIVATE\",\n}\n\n/** Ordering options for organization connections. */\nexport type OrganizationOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order organizations by. */\n  field: OrganizationOrderField;\n};\n\n/** Properties by which organization connections can be ordered. */\nexport enum OrganizationOrderField {\n  /** Order organizations by creation time */\n  CreatedAt = \"CREATED_AT\",\n  /** Order organizations by login */\n  Login = \"LOGIN\",\n}\n\n/** An organization teams hovercard context */\nexport type OrganizationTeamsHovercardContext = HovercardContext & {\n  __typename?: \"OrganizationTeamsHovercardContext\";\n  /** A string describing this context */\n  message: Scalars[\"String\"];\n  /** An octicon to accompany this context */\n  octicon: Scalars[\"String\"];\n  /** Teams in this organization the user is a member of that are relevant */\n  relevantTeams: TeamConnection;\n  /** The path for the full team list for this user */\n  teamsResourcePath: Scalars[\"URI\"];\n  /** The URL for the full team list for this user */\n  teamsUrl: Scalars[\"URI\"];\n  /** The total number of teams the user is on in the organization */\n  totalTeamCount: Scalars[\"Int\"];\n};\n\n/** An organization teams hovercard context */\nexport type OrganizationTeamsHovercardContextRelevantTeamsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** An organization list hovercard context */\nexport type OrganizationsHovercardContext = HovercardContext & {\n  __typename?: \"OrganizationsHovercardContext\";\n  /** A string describing this context */\n  message: Scalars[\"String\"];\n  /** An octicon to accompany this context */\n  octicon: Scalars[\"String\"];\n  /** Organizations this user is a member of that are relevant */\n  relevantOrganizations: OrganizationConnection;\n  /** The total number of organizations this user is in */\n  totalOrganizationCount: Scalars[\"Int\"];\n};\n\n/** An organization list hovercard context */\nexport type OrganizationsHovercardContextRelevantOrganizationsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** Information for an uploaded package. */\nexport type Package = Node & {\n  __typename?: \"Package\";\n  id: Scalars[\"ID\"];\n  /** Find the latest version for the package. */\n  latestVersion?: Maybe<PackageVersion>;\n  /** Identifies the name of the package. */\n  name: Scalars[\"String\"];\n  /** Identifies the type of the package. */\n  packageType: PackageType;\n  /** The repository this package belongs to. */\n  repository?: Maybe<Repository>;\n  /** Statistics about package activity. */\n  statistics?: Maybe<PackageStatistics>;\n  /** Find package version by version string. */\n  version?: Maybe<PackageVersion>;\n  /** list of versions for this package */\n  versions: PackageVersionConnection;\n};\n\n/** Information for an uploaded package. */\nexport type PackageVersionArgs = {\n  version: Scalars[\"String\"];\n};\n\n/** Information for an uploaded package. */\nexport type PackageVersionsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<PackageVersionOrder>;\n};\n\n/** The connection type for Package. */\nexport type PackageConnection = {\n  __typename?: \"PackageConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PackageEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Package>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type PackageEdge = {\n  __typename?: \"PackageEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<Package>;\n};\n\n/** A file in a package version. */\nexport type PackageFile = Node & {\n  __typename?: \"PackageFile\";\n  id: Scalars[\"ID\"];\n  /** MD5 hash of the file. */\n  md5?: Maybe<Scalars[\"String\"]>;\n  /** Name of the file. */\n  name: Scalars[\"String\"];\n  /** The package version this file belongs to. */\n  packageVersion?: Maybe<PackageVersion>;\n  /** SHA1 hash of the file. */\n  sha1?: Maybe<Scalars[\"String\"]>;\n  /** SHA256 hash of the file. */\n  sha256?: Maybe<Scalars[\"String\"]>;\n  /** Size of the file in bytes. */\n  size?: Maybe<Scalars[\"Int\"]>;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars[\"DateTime\"];\n  /** URL to download the asset. */\n  url?: Maybe<Scalars[\"URI\"]>;\n};\n\n/** The connection type for PackageFile. */\nexport type PackageFileConnection = {\n  __typename?: \"PackageFileConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PackageFileEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PackageFile>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type PackageFileEdge = {\n  __typename?: \"PackageFileEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<PackageFile>;\n};\n\n/** Ways in which lists of package files can be ordered upon return. */\nexport type PackageFileOrder = {\n  /** The direction in which to order package files by the specified field. */\n  direction?: InputMaybe<OrderDirection>;\n  /** The field in which to order package files by. */\n  field?: InputMaybe<PackageFileOrderField>;\n};\n\n/** Properties by which package file connections can be ordered. */\nexport enum PackageFileOrderField {\n  /** Order package files by creation time */\n  CreatedAt = \"CREATED_AT\",\n}\n\n/** Ways in which lists of packages can be ordered upon return. */\nexport type PackageOrder = {\n  /** The direction in which to order packages by the specified field. */\n  direction?: InputMaybe<OrderDirection>;\n  /** The field in which to order packages by. */\n  field?: InputMaybe<PackageOrderField>;\n};\n\n/** Properties by which package connections can be ordered. */\nexport enum PackageOrderField {\n  /** Order packages by creation time */\n  CreatedAt = \"CREATED_AT\",\n}\n\n/** Represents an owner of a package. */\nexport type PackageOwner = {\n  id: Scalars[\"ID\"];\n  /** A list of packages under the owner. */\n  packages: PackageConnection;\n};\n\n/** Represents an owner of a package. */\nexport type PackageOwnerPackagesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  names?: InputMaybe<Array<InputMaybe<Scalars[\"String\"]>>>;\n  orderBy?: InputMaybe<PackageOrder>;\n  packageType?: InputMaybe<PackageType>;\n  repositoryId?: InputMaybe<Scalars[\"ID\"]>;\n};\n\n/** Represents a object that contains package activity statistics such as downloads. */\nexport type PackageStatistics = {\n  __typename?: \"PackageStatistics\";\n  /** Number of times the package was downloaded since it was created. */\n  downloadsTotalCount: Scalars[\"Int\"];\n};\n\n/** A version tag contains the mapping between a tag name and a version. */\nexport type PackageTag = Node & {\n  __typename?: \"PackageTag\";\n  id: Scalars[\"ID\"];\n  /** Identifies the tag name of the version. */\n  name: Scalars[\"String\"];\n  /** Version that the tag is associated with. */\n  version?: Maybe<PackageVersion>;\n};\n\n/** The possible types of a package. */\nexport enum PackageType {\n  /** A debian package. */\n  Debian = \"DEBIAN\",\n  /**\n   * A docker image.\n   * @deprecated DOCKER will be removed from this enum as this type will be migrated to only be used by the Packages REST API. Removal on 2021-06-21 UTC.\n   */\n  Docker = \"DOCKER\",\n  /** A maven package. */\n  Maven = \"MAVEN\",\n  /** An npm package. */\n  Npm = \"NPM\",\n  /** A nuget package. */\n  Nuget = \"NUGET\",\n  /** A python package. */\n  Pypi = \"PYPI\",\n  /** A rubygems package. */\n  Rubygems = \"RUBYGEMS\",\n}\n\n/** Information about a specific package version. */\nexport type PackageVersion = Node & {\n  __typename?: \"PackageVersion\";\n  /** List of files associated with this package version */\n  files: PackageFileConnection;\n  id: Scalars[\"ID\"];\n  /** The package associated with this version. */\n  package?: Maybe<Package>;\n  /** The platform this version was built for. */\n  platform?: Maybe<Scalars[\"String\"]>;\n  /** Whether or not this version is a pre-release. */\n  preRelease: Scalars[\"Boolean\"];\n  /** The README of this package version. */\n  readme?: Maybe<Scalars[\"String\"]>;\n  /** The release associated with this package version. */\n  release?: Maybe<Release>;\n  /** Statistics about package activity. */\n  statistics?: Maybe<PackageVersionStatistics>;\n  /** The package version summary. */\n  summary?: Maybe<Scalars[\"String\"]>;\n  /** The version string. */\n  version: Scalars[\"String\"];\n};\n\n/** Information about a specific package version. */\nexport type PackageVersionFilesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<PackageFileOrder>;\n};\n\n/** The connection type for PackageVersion. */\nexport type PackageVersionConnection = {\n  __typename?: \"PackageVersionConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PackageVersionEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PackageVersion>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type PackageVersionEdge = {\n  __typename?: \"PackageVersionEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<PackageVersion>;\n};\n\n/** Ways in which lists of package versions can be ordered upon return. */\nexport type PackageVersionOrder = {\n  /** The direction in which to order package versions by the specified field. */\n  direction?: InputMaybe<OrderDirection>;\n  /** The field in which to order package versions by. */\n  field?: InputMaybe<PackageVersionOrderField>;\n};\n\n/** Properties by which package version connections can be ordered. */\nexport enum PackageVersionOrderField {\n  /** Order package versions by creation time */\n  CreatedAt = \"CREATED_AT\",\n}\n\n/** Represents a object that contains package version activity statistics such as downloads. */\nexport type PackageVersionStatistics = {\n  __typename?: \"PackageVersionStatistics\";\n  /** Number of times the package was downloaded since it was created. */\n  downloadsTotalCount: Scalars[\"Int\"];\n};\n\n/** Information about pagination in a connection. */\nexport type PageInfo = {\n  __typename?: \"PageInfo\";\n  /** When paginating forwards, the cursor to continue. */\n  endCursor?: Maybe<Scalars[\"String\"]>;\n  /** When paginating forwards, are there more items? */\n  hasNextPage: Scalars[\"Boolean\"];\n  /** When paginating backwards, are there more items? */\n  hasPreviousPage: Scalars[\"Boolean\"];\n  /** When paginating backwards, the cursor to continue. */\n  startCursor?: Maybe<Scalars[\"String\"]>;\n};\n\n/** The possible types of patch statuses. */\nexport enum PatchStatus {\n  /** The file was added. Git status 'A'. */\n  Added = \"ADDED\",\n  /** The file's type was changed. Git status 'T'. */\n  Changed = \"CHANGED\",\n  /** The file was copied. Git status 'C'. */\n  Copied = \"COPIED\",\n  /** The file was deleted. Git status 'D'. */\n  Deleted = \"DELETED\",\n  /** The file's contents were changed. Git status 'M'. */\n  Modified = \"MODIFIED\",\n  /** The file was renamed. Git status 'R'. */\n  Renamed = \"RENAMED\",\n}\n\n/** Types that can grant permissions on a repository to a user */\nexport type PermissionGranter = Organization | Repository | Team;\n\n/** A level of permission and source for a user's access to a repository. */\nexport type PermissionSource = {\n  __typename?: \"PermissionSource\";\n  /** The organization the repository belongs to. */\n  organization: Organization;\n  /** The level of access this source has granted to the user. */\n  permission: DefaultRepositoryPermissionField;\n  /** The source of this permission. */\n  source: PermissionGranter;\n};\n\n/** Autogenerated input type of PinIssue */\nexport type PinIssueInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the issue to be pinned */\n  issueId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of PinIssue */\nexport type PinIssuePayload = {\n  __typename?: \"PinIssuePayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The issue that was pinned */\n  issue?: Maybe<Issue>;\n};\n\n/** Types that can be pinned to a profile page. */\nexport type PinnableItem = Gist | Repository;\n\n/** The connection type for PinnableItem. */\nexport type PinnableItemConnection = {\n  __typename?: \"PinnableItemConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PinnableItemEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PinnableItem>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type PinnableItemEdge = {\n  __typename?: \"PinnableItemEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<PinnableItem>;\n};\n\n/** Represents items that can be pinned to a profile page or dashboard. */\nexport enum PinnableItemType {\n  /** A gist. */\n  Gist = \"GIST\",\n  /** An issue. */\n  Issue = \"ISSUE\",\n  /** An organization. */\n  Organization = \"ORGANIZATION\",\n  /** A project. */\n  Project = \"PROJECT\",\n  /** A pull request. */\n  PullRequest = \"PULL_REQUEST\",\n  /** A repository. */\n  Repository = \"REPOSITORY\",\n  /** A team. */\n  Team = \"TEAM\",\n  /** A user. */\n  User = \"USER\",\n}\n\n/** A Pinned Discussion is a discussion pinned to a repository's index page. */\nexport type PinnedDiscussion = Node &\n  RepositoryNode & {\n    __typename?: \"PinnedDiscussion\";\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars[\"DateTime\"];\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars[\"Int\"]>;\n    /** The discussion that was pinned. */\n    discussion: Discussion;\n    /** Color stops of the chosen gradient */\n    gradientStopColors: Array<Scalars[\"String\"]>;\n    id: Scalars[\"ID\"];\n    /** Background texture pattern */\n    pattern: PinnedDiscussionPattern;\n    /** The actor that pinned this discussion. */\n    pinnedBy: Actor;\n    /** Preconfigured background gradient option */\n    preconfiguredGradient?: Maybe<PinnedDiscussionGradient>;\n    /** The repository associated with this node. */\n    repository: Repository;\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars[\"DateTime\"];\n  };\n\n/** The connection type for PinnedDiscussion. */\nexport type PinnedDiscussionConnection = {\n  __typename?: \"PinnedDiscussionConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PinnedDiscussionEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PinnedDiscussion>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type PinnedDiscussionEdge = {\n  __typename?: \"PinnedDiscussionEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<PinnedDiscussion>;\n};\n\n/** Preconfigured gradients that may be used to style discussions pinned within a repository. */\nexport enum PinnedDiscussionGradient {\n  /** A gradient of blue to mint */\n  BlueMint = \"BLUE_MINT\",\n  /** A gradient of blue to purple */\n  BluePurple = \"BLUE_PURPLE\",\n  /** A gradient of pink to blue */\n  PinkBlue = \"PINK_BLUE\",\n  /** A gradient of purple to coral */\n  PurpleCoral = \"PURPLE_CORAL\",\n  /** A gradient of red to orange */\n  RedOrange = \"RED_ORANGE\",\n}\n\n/** Preconfigured background patterns that may be used to style discussions pinned within a repository. */\nexport enum PinnedDiscussionPattern {\n  /** An upward-facing chevron pattern */\n  ChevronUp = \"CHEVRON_UP\",\n  /** A hollow dot pattern */\n  Dot = \"DOT\",\n  /** A solid dot pattern */\n  DotFill = \"DOT_FILL\",\n  /** A heart pattern */\n  HeartFill = \"HEART_FILL\",\n  /** A plus sign pattern */\n  Plus = \"PLUS\",\n  /** A lightning bolt pattern */\n  Zap = \"ZAP\",\n}\n\n/** Represents a 'pinned' event on a given issue or pull request. */\nexport type PinnedEvent = Node & {\n  __typename?: \"PinnedEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  id: Scalars[\"ID\"];\n  /** Identifies the issue associated with the event. */\n  issue: Issue;\n};\n\n/** A Pinned Issue is a issue pinned to a repository's index page. */\nexport type PinnedIssue = Node & {\n  __typename?: \"PinnedIssue\";\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars[\"Int\"]>;\n  id: Scalars[\"ID\"];\n  /** The issue that was pinned. */\n  issue: Issue;\n  /** The actor that pinned this issue. */\n  pinnedBy: Actor;\n  /** The repository that this issue was pinned to. */\n  repository: Repository;\n};\n\n/** The connection type for PinnedIssue. */\nexport type PinnedIssueConnection = {\n  __typename?: \"PinnedIssueConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PinnedIssueEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PinnedIssue>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type PinnedIssueEdge = {\n  __typename?: \"PinnedIssueEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<PinnedIssue>;\n};\n\n/** Audit log entry for a private_repository_forking.disable event. */\nexport type PrivateRepositoryForkingDisableAuditEntry = AuditEntry &\n  EnterpriseAuditEntryData &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData & {\n    __typename?: \"PrivateRepositoryForkingDisableAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    /** The HTTP path for this enterprise. */\n    enterpriseResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The slug of the enterprise. */\n    enterpriseSlug?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP URL for this enterprise. */\n    enterpriseUrl?: Maybe<Scalars[\"URI\"]>;\n    id: Scalars[\"ID\"];\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>;\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** Audit log entry for a private_repository_forking.enable event. */\nexport type PrivateRepositoryForkingEnableAuditEntry = AuditEntry &\n  EnterpriseAuditEntryData &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData & {\n    __typename?: \"PrivateRepositoryForkingEnableAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    /** The HTTP path for this enterprise. */\n    enterpriseResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The slug of the enterprise. */\n    enterpriseSlug?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP URL for this enterprise. */\n    enterpriseUrl?: Maybe<Scalars[\"URI\"]>;\n    id: Scalars[\"ID\"];\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>;\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/**\n * A curatable list of repositories relating to a repository owner, which defaults\n * to showing the most popular repositories they own.\n */\nexport type ProfileItemShowcase = {\n  __typename?: \"ProfileItemShowcase\";\n  /** Whether or not the owner has pinned any repositories or gists. */\n  hasPinnedItems: Scalars[\"Boolean\"];\n  /**\n   * The repositories and gists in the showcase. If the profile owner has any\n   * pinned items, those will be returned. Otherwise, the profile owner's popular\n   * repositories will be returned.\n   */\n  items: PinnableItemConnection;\n};\n\n/**\n * A curatable list of repositories relating to a repository owner, which defaults\n * to showing the most popular repositories they own.\n */\nexport type ProfileItemShowcaseItemsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** Represents any entity on GitHub that has a profile page. */\nexport type ProfileOwner = {\n  /** Determine if this repository owner has any items that can be pinned to their profile. */\n  anyPinnableItems: Scalars[\"Boolean\"];\n  /** The public profile email. */\n  email?: Maybe<Scalars[\"String\"]>;\n  id: Scalars[\"ID\"];\n  /**\n   * Showcases a selection of repositories and gists that the profile owner has\n   * either curated or that have been selected automatically based on popularity.\n   */\n  itemShowcase: ProfileItemShowcase;\n  /** The public profile location. */\n  location?: Maybe<Scalars[\"String\"]>;\n  /** The username used to login. */\n  login: Scalars[\"String\"];\n  /** The public profile name. */\n  name?: Maybe<Scalars[\"String\"]>;\n  /** A list of repositories and gists this profile owner can pin to their profile. */\n  pinnableItems: PinnableItemConnection;\n  /** A list of repositories and gists this profile owner has pinned to their profile */\n  pinnedItems: PinnableItemConnection;\n  /** Returns how many more items this profile owner can pin to their profile. */\n  pinnedItemsRemaining: Scalars[\"Int\"];\n  /** Can the viewer pin repositories and gists to the profile? */\n  viewerCanChangePinnedItems: Scalars[\"Boolean\"];\n  /** The public profile website URL. */\n  websiteUrl?: Maybe<Scalars[\"URI\"]>;\n};\n\n/** Represents any entity on GitHub that has a profile page. */\nexport type ProfileOwnerAnyPinnableItemsArgs = {\n  type?: InputMaybe<PinnableItemType>;\n};\n\n/** Represents any entity on GitHub that has a profile page. */\nexport type ProfileOwnerPinnableItemsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  types?: InputMaybe<Array<PinnableItemType>>;\n};\n\n/** Represents any entity on GitHub that has a profile page. */\nexport type ProfileOwnerPinnedItemsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  types?: InputMaybe<Array<PinnableItemType>>;\n};\n\n/** Projects manage issues, pull requests and notes within a project owner. */\nexport type Project = Closable &\n  Node &\n  Updatable & {\n    __typename?: \"Project\";\n    /** The project's description body. */\n    body?: Maybe<Scalars[\"String\"]>;\n    /** The projects description body rendered to HTML. */\n    bodyHTML: Scalars[\"HTML\"];\n    /** `true` if the object is closed (definition of closed may depend on type) */\n    closed: Scalars[\"Boolean\"];\n    /** Identifies the date and time when the object was closed. */\n    closedAt?: Maybe<Scalars[\"DateTime\"]>;\n    /** List of columns in the project */\n    columns: ProjectColumnConnection;\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars[\"DateTime\"];\n    /** The actor who originally created the project. */\n    creator?: Maybe<Actor>;\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars[\"Int\"]>;\n    id: Scalars[\"ID\"];\n    /** The project's name. */\n    name: Scalars[\"String\"];\n    /** The project's number. */\n    number: Scalars[\"Int\"];\n    /** The project's owner. Currently limited to repositories, organizations, and users. */\n    owner: ProjectOwner;\n    /** List of pending cards in this project */\n    pendingCards: ProjectCardConnection;\n    /** Project progress details. */\n    progress: ProjectProgress;\n    /** The HTTP path for this project */\n    resourcePath: Scalars[\"URI\"];\n    /** Whether the project is open or closed. */\n    state: ProjectState;\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars[\"DateTime\"];\n    /** The HTTP URL for this project */\n    url: Scalars[\"URI\"];\n    /** Check if the current viewer can update this object. */\n    viewerCanUpdate: Scalars[\"Boolean\"];\n  };\n\n/** Projects manage issues, pull requests and notes within a project owner. */\nexport type ProjectColumnsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** Projects manage issues, pull requests and notes within a project owner. */\nexport type ProjectPendingCardsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  archivedStates?: InputMaybe<Array<InputMaybe<ProjectCardArchivedState>>>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A card in a project. */\nexport type ProjectCard = Node & {\n  __typename?: \"ProjectCard\";\n  /**\n   * The project column this card is associated under. A card may only belong to one\n   * project column at a time. The column field will be null if the card is created\n   * in a pending state and has yet to be associated with a column. Once cards are\n   * associated with a column, they will not become pending in the future.\n   */\n  column?: Maybe<ProjectColumn>;\n  /** The card content item */\n  content?: Maybe<ProjectCardItem>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** The actor who created this card */\n  creator?: Maybe<Actor>;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars[\"Int\"]>;\n  id: Scalars[\"ID\"];\n  /** Whether the card is archived */\n  isArchived: Scalars[\"Boolean\"];\n  /** The card note */\n  note?: Maybe<Scalars[\"String\"]>;\n  /** The project that contains this card. */\n  project: Project;\n  /** The HTTP path for this card */\n  resourcePath: Scalars[\"URI\"];\n  /** The state of ProjectCard */\n  state?: Maybe<ProjectCardState>;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars[\"DateTime\"];\n  /** The HTTP URL for this card */\n  url: Scalars[\"URI\"];\n};\n\n/** The possible archived states of a project card. */\nexport enum ProjectCardArchivedState {\n  /** A project card that is archived */\n  Archived = \"ARCHIVED\",\n  /** A project card that is not archived */\n  NotArchived = \"NOT_ARCHIVED\",\n}\n\n/** The connection type for ProjectCard. */\nexport type ProjectCardConnection = {\n  __typename?: \"ProjectCardConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ProjectCardEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ProjectCard>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type ProjectCardEdge = {\n  __typename?: \"ProjectCardEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<ProjectCard>;\n};\n\n/** An issue or PR and its owning repository to be used in a project card. */\nexport type ProjectCardImport = {\n  /** The issue or pull request number. */\n  number: Scalars[\"Int\"];\n  /** Repository name with owner (owner/repository). */\n  repository: Scalars[\"String\"];\n};\n\n/** Types that can be inside Project Cards. */\nexport type ProjectCardItem = Issue | PullRequest;\n\n/** Various content states of a ProjectCard */\nexport enum ProjectCardState {\n  /** The card has content only. */\n  ContentOnly = \"CONTENT_ONLY\",\n  /** The card has a note only. */\n  NoteOnly = \"NOTE_ONLY\",\n  /** The card is redacted. */\n  Redacted = \"REDACTED\",\n}\n\n/** A column inside a project. */\nexport type ProjectColumn = Node & {\n  __typename?: \"ProjectColumn\";\n  /** List of cards in the column */\n  cards: ProjectCardConnection;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars[\"Int\"]>;\n  id: Scalars[\"ID\"];\n  /** The project column's name. */\n  name: Scalars[\"String\"];\n  /** The project that contains this column. */\n  project: Project;\n  /** The semantic purpose of the column */\n  purpose?: Maybe<ProjectColumnPurpose>;\n  /** The HTTP path for this project column */\n  resourcePath: Scalars[\"URI\"];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars[\"DateTime\"];\n  /** The HTTP URL for this project column */\n  url: Scalars[\"URI\"];\n};\n\n/** A column inside a project. */\nexport type ProjectColumnCardsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  archivedStates?: InputMaybe<Array<InputMaybe<ProjectCardArchivedState>>>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** The connection type for ProjectColumn. */\nexport type ProjectColumnConnection = {\n  __typename?: \"ProjectColumnConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ProjectColumnEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ProjectColumn>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type ProjectColumnEdge = {\n  __typename?: \"ProjectColumnEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<ProjectColumn>;\n};\n\n/** A project column and a list of its issues and PRs. */\nexport type ProjectColumnImport = {\n  /** The name of the column. */\n  columnName: Scalars[\"String\"];\n  /** A list of issues and pull requests in the column. */\n  issues?: InputMaybe<Array<ProjectCardImport>>;\n  /** The position of the column, starting from 0. */\n  position: Scalars[\"Int\"];\n};\n\n/** The semantic purpose of the column - todo, in progress, or done. */\nexport enum ProjectColumnPurpose {\n  /** The column contains cards which are complete */\n  Done = \"DONE\",\n  /** The column contains cards which are currently being worked on */\n  InProgress = \"IN_PROGRESS\",\n  /** The column contains cards still to be worked on */\n  Todo = \"TODO\",\n}\n\n/** A list of projects associated with the owner. */\nexport type ProjectConnection = {\n  __typename?: \"ProjectConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ProjectEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Project>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type ProjectEdge = {\n  __typename?: \"ProjectEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<Project>;\n};\n\n/** The type of a project item. */\nexport enum ProjectItemType {\n  /** Draft Issue */\n  DraftIssue = \"DRAFT_ISSUE\",\n  /** Issue */\n  Issue = \"ISSUE\",\n  /** Pull Request */\n  PullRequest = \"PULL_REQUEST\",\n  /** Redacted Item */\n  Redacted = \"REDACTED\",\n}\n\n/** New projects that manage issues, pull requests and drafts using tables and boards. */\nexport type ProjectNext = Closable &\n  Node &\n  Updatable & {\n    __typename?: \"ProjectNext\";\n    /** Returns true if the project is closed. */\n    closed: Scalars[\"Boolean\"];\n    /** Identifies the date and time when the object was closed. */\n    closedAt?: Maybe<Scalars[\"DateTime\"]>;\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars[\"DateTime\"];\n    /** The actor who originally created the project. */\n    creator?: Maybe<Actor>;\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars[\"Int\"]>;\n    /** The project's description. */\n    description?: Maybe<Scalars[\"String\"]>;\n    /** List of fields in the project */\n    fields: ProjectNextFieldConnection;\n    id: Scalars[\"ID\"];\n    /** List of items in the project */\n    items: ProjectNextItemConnection;\n    /** The project's number. */\n    number: Scalars[\"Int\"];\n    /** The project's owner. Currently limited to organizations and users. */\n    owner: ProjectNextOwner;\n    /** Returns true if the project is public. */\n    public: Scalars[\"Boolean\"];\n    /** The repositories the project is linked to. */\n    repositories: RepositoryConnection;\n    /** The HTTP path for this project */\n    resourcePath: Scalars[\"URI\"];\n    /** The project's short description. */\n    shortDescription?: Maybe<Scalars[\"String\"]>;\n    /** The project's name. */\n    title?: Maybe<Scalars[\"String\"]>;\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars[\"DateTime\"];\n    /** The HTTP URL for this project */\n    url: Scalars[\"URI\"];\n    /** Check if the current viewer can update this object. */\n    viewerCanUpdate: Scalars[\"Boolean\"];\n    /** List of views in the project */\n    views: ProjectViewConnection;\n  };\n\n/** New projects that manage issues, pull requests and drafts using tables and boards. */\nexport type ProjectNextFieldsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** New projects that manage issues, pull requests and drafts using tables and boards. */\nexport type ProjectNextItemsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** New projects that manage issues, pull requests and drafts using tables and boards. */\nexport type ProjectNextRepositoriesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** New projects that manage issues, pull requests and drafts using tables and boards. */\nexport type ProjectNextViewsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** The connection type for ProjectNext. */\nexport type ProjectNextConnection = {\n  __typename?: \"ProjectNextConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ProjectNextEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ProjectNext>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type ProjectNextEdge = {\n  __typename?: \"ProjectNextEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<ProjectNext>;\n};\n\n/** A field inside a project. */\nexport type ProjectNextField = Node &\n  ProjectNextFieldCommon & {\n    __typename?: \"ProjectNextField\";\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars[\"DateTime\"];\n    /** The field's type. */\n    dataType: ProjectNextFieldType;\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars[\"Int\"]>;\n    id: Scalars[\"ID\"];\n    /** The project field's name. */\n    name: Scalars[\"String\"];\n    /** The project that contains this field. */\n    project: ProjectNext;\n    /** The field's settings. */\n    settings?: Maybe<Scalars[\"String\"]>;\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars[\"DateTime\"];\n  };\n\n/** Common fields across different field types */\nexport type ProjectNextFieldCommon = {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** The field's type. */\n  dataType: ProjectNextFieldType;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars[\"Int\"]>;\n  id: Scalars[\"ID\"];\n  /** The project field's name. */\n  name: Scalars[\"String\"];\n  /** The project that contains this field. */\n  project: ProjectNext;\n  /** The field's settings. */\n  settings?: Maybe<Scalars[\"String\"]>;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars[\"DateTime\"];\n};\n\n/** The connection type for ProjectNextField. */\nexport type ProjectNextFieldConnection = {\n  __typename?: \"ProjectNextFieldConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ProjectNextFieldEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ProjectNextField>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type ProjectNextFieldEdge = {\n  __typename?: \"ProjectNextFieldEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<ProjectNextField>;\n};\n\n/** The type of a project next field. */\nexport enum ProjectNextFieldType {\n  /** Assignees */\n  Assignees = \"ASSIGNEES\",\n  /** Date */\n  Date = \"DATE\",\n  /** Iteration */\n  Iteration = \"ITERATION\",\n  /** Labels */\n  Labels = \"LABELS\",\n  /** Linked Pull Requests */\n  LinkedPullRequests = \"LINKED_PULL_REQUESTS\",\n  /** Milestone */\n  Milestone = \"MILESTONE\",\n  /** Number */\n  Number = \"NUMBER\",\n  /** Repository */\n  Repository = \"REPOSITORY\",\n  /** Reviewers */\n  Reviewers = \"REVIEWERS\",\n  /** Single Select */\n  SingleSelect = \"SINGLE_SELECT\",\n  /** Text */\n  Text = \"TEXT\",\n  /** Title */\n  Title = \"TITLE\",\n  /** Tracks */\n  Tracks = \"TRACKS\",\n}\n\n/** An item within a new Project. */\nexport type ProjectNextItem = Node & {\n  __typename?: \"ProjectNextItem\";\n  /** The content of the referenced draft issue, issue, or pull request */\n  content?: Maybe<ProjectNextItemContent>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** The actor who created the item. */\n  creator?: Maybe<Actor>;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars[\"Int\"]>;\n  /** List of field values */\n  fieldValues: ProjectNextItemFieldValueConnection;\n  id: Scalars[\"ID\"];\n  /** Whether the item is archived. */\n  isArchived: Scalars[\"Boolean\"];\n  /** The project that contains this item. */\n  project: ProjectNext;\n  /** The title of the item */\n  title?: Maybe<Scalars[\"String\"]>;\n  /** The type of the item. */\n  type: ProjectItemType;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars[\"DateTime\"];\n};\n\n/** An item within a new Project. */\nexport type ProjectNextItemFieldValuesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** The connection type for ProjectNextItem. */\nexport type ProjectNextItemConnection = {\n  __typename?: \"ProjectNextItemConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ProjectNextItemEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ProjectNextItem>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** Types that can be inside Project Items. */\nexport type ProjectNextItemContent = DraftIssue | Issue | PullRequest;\n\n/** An edge in a connection. */\nexport type ProjectNextItemEdge = {\n  __typename?: \"ProjectNextItemEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<ProjectNextItem>;\n};\n\n/** An value of a field in an item of a new Project. */\nexport type ProjectNextItemFieldValue = Node & {\n  __typename?: \"ProjectNextItemFieldValue\";\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** The actor who created the item. */\n  creator?: Maybe<Actor>;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars[\"Int\"]>;\n  id: Scalars[\"ID\"];\n  /** The project field that contains this value. */\n  projectField: ProjectNextField;\n  /** The project item that contains this value. */\n  projectItem: ProjectNextItem;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars[\"DateTime\"];\n  /** The value of a field */\n  value?: Maybe<Scalars[\"String\"]>;\n};\n\n/** The connection type for ProjectNextItemFieldValue. */\nexport type ProjectNextItemFieldValueConnection = {\n  __typename?: \"ProjectNextItemFieldValueConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ProjectNextItemFieldValueEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ProjectNextItemFieldValue>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type ProjectNextItemFieldValueEdge = {\n  __typename?: \"ProjectNextItemFieldValueEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<ProjectNextItemFieldValue>;\n};\n\n/** Properties by which the return project can be ordered. */\nexport enum ProjectNextOrderField {\n  /** The project's date and time of creation */\n  CreatedAt = \"CREATED_AT\",\n  /** The project's number */\n  Number = \"NUMBER\",\n  /** The project's title */\n  Title = \"TITLE\",\n  /** The project's date and time of update */\n  UpdatedAt = \"UPDATED_AT\",\n}\n\n/** Represents an owner of a project (beta). */\nexport type ProjectNextOwner = {\n  id: Scalars[\"ID\"];\n  /** Find a project by project (beta) number. */\n  projectNext?: Maybe<ProjectNext>;\n  /** A list of projects (beta) under the owner. */\n  projectsNext: ProjectNextConnection;\n};\n\n/** Represents an owner of a project (beta). */\nexport type ProjectNextOwnerProjectNextArgs = {\n  number: Scalars[\"Int\"];\n};\n\n/** Represents an owner of a project (beta). */\nexport type ProjectNextOwnerProjectsNextArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  query?: InputMaybe<Scalars[\"String\"]>;\n  sortBy?: InputMaybe<ProjectNextOrderField>;\n};\n\n/** Ways in which lists of projects can be ordered upon return. */\nexport type ProjectOrder = {\n  /** The direction in which to order projects by the specified field. */\n  direction: OrderDirection;\n  /** The field in which to order projects by. */\n  field: ProjectOrderField;\n};\n\n/** Properties by which project connections can be ordered. */\nexport enum ProjectOrderField {\n  /** Order projects by creation time */\n  CreatedAt = \"CREATED_AT\",\n  /** Order projects by name */\n  Name = \"NAME\",\n  /** Order projects by update time */\n  UpdatedAt = \"UPDATED_AT\",\n}\n\n/** Represents an owner of a Project. */\nexport type ProjectOwner = {\n  id: Scalars[\"ID\"];\n  /** Find project by number. */\n  project?: Maybe<Project>;\n  /** A list of projects under the owner. */\n  projects: ProjectConnection;\n  /** The HTTP path listing owners projects */\n  projectsResourcePath: Scalars[\"URI\"];\n  /** The HTTP URL listing owners projects */\n  projectsUrl: Scalars[\"URI\"];\n  /** Can the current viewer create new projects on this owner. */\n  viewerCanCreateProjects: Scalars[\"Boolean\"];\n};\n\n/** Represents an owner of a Project. */\nexport type ProjectOwnerProjectArgs = {\n  number: Scalars[\"Int\"];\n};\n\n/** Represents an owner of a Project. */\nexport type ProjectOwnerProjectsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<ProjectOrder>;\n  search?: InputMaybe<Scalars[\"String\"]>;\n  states?: InputMaybe<Array<ProjectState>>;\n};\n\n/** Project progress stats. */\nexport type ProjectProgress = {\n  __typename?: \"ProjectProgress\";\n  /** The number of done cards. */\n  doneCount: Scalars[\"Int\"];\n  /** The percentage of done cards. */\n  donePercentage: Scalars[\"Float\"];\n  /** Whether progress tracking is enabled and cards with purpose exist for this project */\n  enabled: Scalars[\"Boolean\"];\n  /** The number of in-progress cards. */\n  inProgressCount: Scalars[\"Int\"];\n  /** The percentage of in-progress cards. */\n  inProgressPercentage: Scalars[\"Float\"];\n  /** The number of to do cards. */\n  todoCount: Scalars[\"Int\"];\n  /** The percentage of to do cards. */\n  todoPercentage: Scalars[\"Float\"];\n};\n\n/** State of the project; either 'open' or 'closed' */\nexport enum ProjectState {\n  /** The project is closed. */\n  Closed = \"CLOSED\",\n  /** The project is open. */\n  Open = \"OPEN\",\n}\n\n/** GitHub-provided templates for Projects */\nexport enum ProjectTemplate {\n  /** Create a board with v2 triggers to automatically move cards across To do, In progress and Done columns. */\n  AutomatedKanbanV2 = \"AUTOMATED_KANBAN_V2\",\n  /** Create a board with triggers to automatically move cards across columns with review automation. */\n  AutomatedReviewsKanban = \"AUTOMATED_REVIEWS_KANBAN\",\n  /** Create a board with columns for To do, In progress and Done. */\n  BasicKanban = \"BASIC_KANBAN\",\n  /** Create a board to triage and prioritize bugs with To do, priority, and Done columns. */\n  BugTriage = \"BUG_TRIAGE\",\n}\n\n/** Represents an owner of a project (beta). */\nexport type ProjectV2Owner = {\n  id: Scalars[\"ID\"];\n};\n\n/** A view within a Project. */\nexport type ProjectView = Node & {\n  __typename?: \"ProjectView\";\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars[\"Int\"]>;\n  /** The project view's filter. */\n  filter?: Maybe<Scalars[\"String\"]>;\n  /** The view's group-by field. */\n  groupBy?: Maybe<Array<Scalars[\"Int\"]>>;\n  id: Scalars[\"ID\"];\n  /** The view's filtered items. */\n  items: ProjectNextItemConnection;\n  /** The project view's layout. */\n  layout: ProjectViewLayout;\n  /** The project view's name. */\n  name: Scalars[\"String\"];\n  /** The project view's number. */\n  number: Scalars[\"Int\"];\n  /** The project that contains this view. */\n  project: ProjectNext;\n  /** The view's sort-by config. */\n  sortBy?: Maybe<Array<SortBy>>;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars[\"DateTime\"];\n  /** The view's vertical-group-by field. */\n  verticalGroupBy?: Maybe<Array<Scalars[\"Int\"]>>;\n  /** The view's visible fields. */\n  visibleFields?: Maybe<Array<Scalars[\"Int\"]>>;\n};\n\n/** A view within a Project. */\nexport type ProjectViewItemsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** The connection type for ProjectView. */\nexport type ProjectViewConnection = {\n  __typename?: \"ProjectViewConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ProjectViewEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ProjectView>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type ProjectViewEdge = {\n  __typename?: \"ProjectViewEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<ProjectView>;\n};\n\n/** The layout of a project view. */\nexport enum ProjectViewLayout {\n  /** Board layout */\n  BoardLayout = \"BOARD_LAYOUT\",\n  /** Table layout */\n  TableLayout = \"TABLE_LAYOUT\",\n}\n\n/** A user's public key. */\nexport type PublicKey = Node & {\n  __typename?: \"PublicKey\";\n  /** The last time this authorization was used to perform an action. Values will be null for keys not owned by the user. */\n  accessedAt?: Maybe<Scalars[\"DateTime\"]>;\n  /**\n   * Identifies the date and time when the key was created. Keys created before\n   * March 5th, 2014 have inaccurate values. Values will be null for keys not owned by the user.\n   */\n  createdAt?: Maybe<Scalars[\"DateTime\"]>;\n  /** The fingerprint for this PublicKey. */\n  fingerprint: Scalars[\"String\"];\n  id: Scalars[\"ID\"];\n  /** Whether this PublicKey is read-only or not. Values will be null for keys not owned by the user. */\n  isReadOnly?: Maybe<Scalars[\"Boolean\"]>;\n  /** The public key string. */\n  key: Scalars[\"String\"];\n  /**\n   * Identifies the date and time when the key was updated. Keys created before\n   * March 5th, 2014 may have inaccurate values. Values will be null for keys not\n   * owned by the user.\n   */\n  updatedAt?: Maybe<Scalars[\"DateTime\"]>;\n};\n\n/** The connection type for PublicKey. */\nexport type PublicKeyConnection = {\n  __typename?: \"PublicKeyConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PublicKeyEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PublicKey>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type PublicKeyEdge = {\n  __typename?: \"PublicKeyEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<PublicKey>;\n};\n\n/** A repository pull request. */\nexport type PullRequest = Assignable &\n  Closable &\n  Comment &\n  Labelable &\n  Lockable &\n  Node &\n  ProjectNextOwner &\n  ProjectV2Owner &\n  Reactable &\n  RepositoryNode &\n  Subscribable &\n  UniformResourceLocatable &\n  Updatable &\n  UpdatableComment & {\n    __typename?: \"PullRequest\";\n    /** Reason that the conversation was locked. */\n    activeLockReason?: Maybe<LockReason>;\n    /** The number of additions in this pull request. */\n    additions: Scalars[\"Int\"];\n    /** A list of Users assigned to this object. */\n    assignees: UserConnection;\n    /** The actor who authored the comment. */\n    author?: Maybe<Actor>;\n    /** Author's association with the subject of the comment. */\n    authorAssociation: CommentAuthorAssociation;\n    /** Returns the auto-merge request object if one exists for this pull request. */\n    autoMergeRequest?: Maybe<AutoMergeRequest>;\n    /** Identifies the base Ref associated with the pull request. */\n    baseRef?: Maybe<Ref>;\n    /** Identifies the name of the base Ref associated with the pull request, even if the ref has been deleted. */\n    baseRefName: Scalars[\"String\"];\n    /** Identifies the oid of the base ref associated with the pull request, even if the ref has been deleted. */\n    baseRefOid: Scalars[\"GitObjectID\"];\n    /** The repository associated with this pull request's base Ref. */\n    baseRepository?: Maybe<Repository>;\n    /** The body as Markdown. */\n    body: Scalars[\"String\"];\n    /** The body rendered to HTML. */\n    bodyHTML: Scalars[\"HTML\"];\n    /** The body rendered to text. */\n    bodyText: Scalars[\"String\"];\n    /** Whether or not the pull request is rebaseable. */\n    canBeRebased: Scalars[\"Boolean\"];\n    /** The number of changed files in this pull request. */\n    changedFiles: Scalars[\"Int\"];\n    /** The HTTP path for the checks of this pull request. */\n    checksResourcePath: Scalars[\"URI\"];\n    /** The HTTP URL for the checks of this pull request. */\n    checksUrl: Scalars[\"URI\"];\n    /** `true` if the pull request is closed */\n    closed: Scalars[\"Boolean\"];\n    /** Identifies the date and time when the object was closed. */\n    closedAt?: Maybe<Scalars[\"DateTime\"]>;\n    /** List of issues that were may be closed by this pull request */\n    closingIssuesReferences?: Maybe<IssueConnection>;\n    /** A list of comments associated with the pull request. */\n    comments: IssueCommentConnection;\n    /** A list of commits present in this pull request's head branch not present in the base branch. */\n    commits: PullRequestCommitConnection;\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars[\"DateTime\"];\n    /** Check if this comment was created via an email reply. */\n    createdViaEmail: Scalars[\"Boolean\"];\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars[\"Int\"]>;\n    /** The number of deletions in this pull request. */\n    deletions: Scalars[\"Int\"];\n    /** The actor who edited this pull request's body. */\n    editor?: Maybe<Actor>;\n    /** Lists the files changed within this pull request. */\n    files?: Maybe<PullRequestChangedFileConnection>;\n    /** Identifies the head Ref associated with the pull request. */\n    headRef?: Maybe<Ref>;\n    /** Identifies the name of the head Ref associated with the pull request, even if the ref has been deleted. */\n    headRefName: Scalars[\"String\"];\n    /** Identifies the oid of the head ref associated with the pull request, even if the ref has been deleted. */\n    headRefOid: Scalars[\"GitObjectID\"];\n    /** The repository associated with this pull request's head Ref. */\n    headRepository?: Maybe<Repository>;\n    /** The owner of the repository associated with this pull request's head Ref. */\n    headRepositoryOwner?: Maybe<RepositoryOwner>;\n    /** The hovercard information for this issue */\n    hovercard: Hovercard;\n    id: Scalars[\"ID\"];\n    /** Check if this comment was edited and includes an edit with the creation data */\n    includesCreatedEdit: Scalars[\"Boolean\"];\n    /** The head and base repositories are different. */\n    isCrossRepository: Scalars[\"Boolean\"];\n    /** Identifies if the pull request is a draft. */\n    isDraft: Scalars[\"Boolean\"];\n    /** Is this pull request read by the viewer */\n    isReadByViewer?: Maybe<Scalars[\"Boolean\"]>;\n    /** A list of labels associated with the object. */\n    labels?: Maybe<LabelConnection>;\n    /** The moment the editor made the last edit */\n    lastEditedAt?: Maybe<Scalars[\"DateTime\"]>;\n    /** A list of latest reviews per user associated with the pull request. */\n    latestOpinionatedReviews?: Maybe<PullRequestReviewConnection>;\n    /** A list of latest reviews per user associated with the pull request that are not also pending review. */\n    latestReviews?: Maybe<PullRequestReviewConnection>;\n    /** `true` if the pull request is locked */\n    locked: Scalars[\"Boolean\"];\n    /** Indicates whether maintainers can modify the pull request. */\n    maintainerCanModify: Scalars[\"Boolean\"];\n    /** The commit that was created when this pull request was merged. */\n    mergeCommit?: Maybe<Commit>;\n    /** Detailed information about the current pull request merge state status. */\n    mergeStateStatus: MergeStateStatus;\n    /** Whether or not the pull request can be merged based on the existence of merge conflicts. */\n    mergeable: MergeableState;\n    /** Whether or not the pull request was merged. */\n    merged: Scalars[\"Boolean\"];\n    /** The date and time that the pull request was merged. */\n    mergedAt?: Maybe<Scalars[\"DateTime\"]>;\n    /** The actor who merged the pull request. */\n    mergedBy?: Maybe<Actor>;\n    /** Identifies the milestone associated with the pull request. */\n    milestone?: Maybe<Milestone>;\n    /** Identifies the pull request number. */\n    number: Scalars[\"Int\"];\n    /** A list of Users that are participating in the Pull Request conversation. */\n    participants: UserConnection;\n    /** The permalink to the pull request. */\n    permalink: Scalars[\"URI\"];\n    /**\n     * The commit that GitHub automatically generated to test if this pull request\n     * could be merged. This field will not return a value if the pull request is\n     * merged, or if the test merge commit is still being generated. See the\n     * `mergeable` field for more details on the mergeability of the pull request.\n     */\n    potentialMergeCommit?: Maybe<Commit>;\n    /** List of project cards associated with this pull request. */\n    projectCards: ProjectCardConnection;\n    /** Find a project by project (beta) number. */\n    projectNext?: Maybe<ProjectNext>;\n    /** List of project (beta) items associated with this pull request. */\n    projectNextItems: ProjectNextItemConnection;\n    /** A list of projects (beta) under the owner. */\n    projectsNext: ProjectNextConnection;\n    /** Identifies when the comment was published at. */\n    publishedAt?: Maybe<Scalars[\"DateTime\"]>;\n    /** A list of reactions grouped by content left on the subject. */\n    reactionGroups?: Maybe<Array<ReactionGroup>>;\n    /** A list of Reactions left on the Issue. */\n    reactions: ReactionConnection;\n    /** The repository associated with this node. */\n    repository: Repository;\n    /** The HTTP path for this pull request. */\n    resourcePath: Scalars[\"URI\"];\n    /** The HTTP path for reverting this pull request. */\n    revertResourcePath: Scalars[\"URI\"];\n    /** The HTTP URL for reverting this pull request. */\n    revertUrl: Scalars[\"URI\"];\n    /** The current status of this pull request with respect to code review. */\n    reviewDecision?: Maybe<PullRequestReviewDecision>;\n    /** A list of review requests associated with the pull request. */\n    reviewRequests?: Maybe<ReviewRequestConnection>;\n    /** The list of all review threads for this pull request. */\n    reviewThreads: PullRequestReviewThreadConnection;\n    /** A list of reviews associated with the pull request. */\n    reviews?: Maybe<PullRequestReviewConnection>;\n    /** Identifies the state of the pull request. */\n    state: PullRequestState;\n    /** A list of reviewer suggestions based on commit history and past review comments. */\n    suggestedReviewers: Array<Maybe<SuggestedReviewer>>;\n    /**\n     * A list of events, comments, commits, etc. associated with the pull request.\n     * @deprecated `timeline` will be removed Use PullRequest.timelineItems instead. Removal on 2020-10-01 UTC.\n     */\n    timeline: PullRequestTimelineConnection;\n    /** A list of events, comments, commits, etc. associated with the pull request. */\n    timelineItems: PullRequestTimelineItemsConnection;\n    /** Identifies the pull request title. */\n    title: Scalars[\"String\"];\n    /** Identifies the pull request title rendered to HTML. */\n    titleHTML: Scalars[\"HTML\"];\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars[\"DateTime\"];\n    /** The HTTP URL for this pull request. */\n    url: Scalars[\"URI\"];\n    /** A list of edits to this content. */\n    userContentEdits?: Maybe<UserContentEditConnection>;\n    /** Whether or not the viewer can apply suggestion. */\n    viewerCanApplySuggestion: Scalars[\"Boolean\"];\n    /** Check if the viewer can restore the deleted head ref. */\n    viewerCanDeleteHeadRef: Scalars[\"Boolean\"];\n    /** Whether or not the viewer can disable auto-merge */\n    viewerCanDisableAutoMerge: Scalars[\"Boolean\"];\n    /** Whether or not the viewer can enable auto-merge */\n    viewerCanEnableAutoMerge: Scalars[\"Boolean\"];\n    /** Indicates whether the viewer can bypass branch protections and merge the pull request immediately */\n    viewerCanMergeAsAdmin: Scalars[\"Boolean\"];\n    /** Can user react to this subject */\n    viewerCanReact: Scalars[\"Boolean\"];\n    /** Check if the viewer is able to change their subscription status for the repository. */\n    viewerCanSubscribe: Scalars[\"Boolean\"];\n    /** Check if the current viewer can update this object. */\n    viewerCanUpdate: Scalars[\"Boolean\"];\n    /** Reasons why the current viewer can not update this comment. */\n    viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;\n    /** Did the viewer author this comment. */\n    viewerDidAuthor: Scalars[\"Boolean\"];\n    /** The latest review given from the viewer. */\n    viewerLatestReview?: Maybe<PullRequestReview>;\n    /** The person who has requested the viewer for review on this pull request. */\n    viewerLatestReviewRequest?: Maybe<ReviewRequest>;\n    /** The merge body text for the viewer and method. */\n    viewerMergeBodyText: Scalars[\"String\"];\n    /** The merge headline text for the viewer and method. */\n    viewerMergeHeadlineText: Scalars[\"String\"];\n    /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */\n    viewerSubscription?: Maybe<SubscriptionState>;\n  };\n\n/** A repository pull request. */\nexport type PullRequestAssigneesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A repository pull request. */\nexport type PullRequestClosingIssuesReferencesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<IssueOrder>;\n  userLinkedOnly?: InputMaybe<Scalars[\"Boolean\"]>;\n};\n\n/** A repository pull request. */\nexport type PullRequestCommentsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<IssueCommentOrder>;\n};\n\n/** A repository pull request. */\nexport type PullRequestCommitsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A repository pull request. */\nexport type PullRequestFilesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A repository pull request. */\nexport type PullRequestHovercardArgs = {\n  includeNotificationContexts?: InputMaybe<Scalars[\"Boolean\"]>;\n};\n\n/** A repository pull request. */\nexport type PullRequestLabelsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<LabelOrder>;\n};\n\n/** A repository pull request. */\nexport type PullRequestLatestOpinionatedReviewsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  writersOnly?: InputMaybe<Scalars[\"Boolean\"]>;\n};\n\n/** A repository pull request. */\nexport type PullRequestLatestReviewsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A repository pull request. */\nexport type PullRequestParticipantsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A repository pull request. */\nexport type PullRequestProjectCardsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  archivedStates?: InputMaybe<Array<InputMaybe<ProjectCardArchivedState>>>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A repository pull request. */\nexport type PullRequestProjectNextArgs = {\n  number: Scalars[\"Int\"];\n};\n\n/** A repository pull request. */\nexport type PullRequestProjectNextItemsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  includeArchived?: InputMaybe<Scalars[\"Boolean\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A repository pull request. */\nexport type PullRequestProjectsNextArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  query?: InputMaybe<Scalars[\"String\"]>;\n  sortBy?: InputMaybe<ProjectNextOrderField>;\n};\n\n/** A repository pull request. */\nexport type PullRequestReactionsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  content?: InputMaybe<ReactionContent>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<ReactionOrder>;\n};\n\n/** A repository pull request. */\nexport type PullRequestReviewRequestsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A repository pull request. */\nexport type PullRequestReviewThreadsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A repository pull request. */\nexport type PullRequestReviewsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  author?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  states?: InputMaybe<Array<PullRequestReviewState>>;\n};\n\n/** A repository pull request. */\nexport type PullRequestTimelineArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  since?: InputMaybe<Scalars[\"DateTime\"]>;\n};\n\n/** A repository pull request. */\nexport type PullRequestTimelineItemsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  itemTypes?: InputMaybe<Array<PullRequestTimelineItemsItemType>>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  since?: InputMaybe<Scalars[\"DateTime\"]>;\n  skip?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A repository pull request. */\nexport type PullRequestUserContentEditsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A repository pull request. */\nexport type PullRequestViewerMergeBodyTextArgs = {\n  mergeType?: InputMaybe<PullRequestMergeMethod>;\n};\n\n/** A repository pull request. */\nexport type PullRequestViewerMergeHeadlineTextArgs = {\n  mergeType?: InputMaybe<PullRequestMergeMethod>;\n};\n\n/** A file changed in a pull request. */\nexport type PullRequestChangedFile = {\n  __typename?: \"PullRequestChangedFile\";\n  /** The number of additions to the file. */\n  additions: Scalars[\"Int\"];\n  /** How the file was changed in this PullRequest */\n  changeType: PatchStatus;\n  /** The number of deletions to the file. */\n  deletions: Scalars[\"Int\"];\n  /** The path of the file. */\n  path: Scalars[\"String\"];\n  /** The state of the file for the viewer. */\n  viewerViewedState: FileViewedState;\n};\n\n/** The connection type for PullRequestChangedFile. */\nexport type PullRequestChangedFileConnection = {\n  __typename?: \"PullRequestChangedFileConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PullRequestChangedFileEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PullRequestChangedFile>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type PullRequestChangedFileEdge = {\n  __typename?: \"PullRequestChangedFileEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<PullRequestChangedFile>;\n};\n\n/** Represents a Git commit part of a pull request. */\nexport type PullRequestCommit = Node &\n  UniformResourceLocatable & {\n    __typename?: \"PullRequestCommit\";\n    /** The Git commit object */\n    commit: Commit;\n    id: Scalars[\"ID\"];\n    /** The pull request this commit belongs to */\n    pullRequest: PullRequest;\n    /** The HTTP path for this pull request commit */\n    resourcePath: Scalars[\"URI\"];\n    /** The HTTP URL for this pull request commit */\n    url: Scalars[\"URI\"];\n  };\n\n/** Represents a commit comment thread part of a pull request. */\nexport type PullRequestCommitCommentThread = Node &\n  RepositoryNode & {\n    __typename?: \"PullRequestCommitCommentThread\";\n    /** The comments that exist in this thread. */\n    comments: CommitCommentConnection;\n    /** The commit the comments were made on. */\n    commit: Commit;\n    id: Scalars[\"ID\"];\n    /** The file the comments were made on. */\n    path?: Maybe<Scalars[\"String\"]>;\n    /** The position in the diff for the commit that the comment was made on. */\n    position?: Maybe<Scalars[\"Int\"]>;\n    /** The pull request this commit comment thread belongs to */\n    pullRequest: PullRequest;\n    /** The repository associated with this node. */\n    repository: Repository;\n  };\n\n/** Represents a commit comment thread part of a pull request. */\nexport type PullRequestCommitCommentThreadCommentsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** The connection type for PullRequestCommit. */\nexport type PullRequestCommitConnection = {\n  __typename?: \"PullRequestCommitConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PullRequestCommitEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PullRequestCommit>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type PullRequestCommitEdge = {\n  __typename?: \"PullRequestCommitEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<PullRequestCommit>;\n};\n\n/** The connection type for PullRequest. */\nexport type PullRequestConnection = {\n  __typename?: \"PullRequestConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PullRequestEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PullRequest>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** This aggregates pull requests opened by a user within one repository. */\nexport type PullRequestContributionsByRepository = {\n  __typename?: \"PullRequestContributionsByRepository\";\n  /** The pull request contributions. */\n  contributions: CreatedPullRequestContributionConnection;\n  /** The repository in which the pull requests were opened. */\n  repository: Repository;\n};\n\n/** This aggregates pull requests opened by a user within one repository. */\nexport type PullRequestContributionsByRepositoryContributionsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<ContributionOrder>;\n};\n\n/** An edge in a connection. */\nexport type PullRequestEdge = {\n  __typename?: \"PullRequestEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<PullRequest>;\n};\n\n/** Represents available types of methods to use when merging a pull request. */\nexport enum PullRequestMergeMethod {\n  /** Add all commits from the head branch to the base branch with a merge commit. */\n  Merge = \"MERGE\",\n  /** Add all commits from the head branch onto the base branch individually. */\n  Rebase = \"REBASE\",\n  /** Combine all commits from the head branch into a single commit in the base branch. */\n  Squash = \"SQUASH\",\n}\n\n/** Ways in which lists of issues can be ordered upon return. */\nexport type PullRequestOrder = {\n  /** The direction in which to order pull requests by the specified field. */\n  direction: OrderDirection;\n  /** The field in which to order pull requests by. */\n  field: PullRequestOrderField;\n};\n\n/** Properties by which pull_requests connections can be ordered. */\nexport enum PullRequestOrderField {\n  /** Order pull_requests by creation time */\n  CreatedAt = \"CREATED_AT\",\n  /** Order pull_requests by update time */\n  UpdatedAt = \"UPDATED_AT\",\n}\n\n/** A review object for a given pull request. */\nexport type PullRequestReview = Comment &\n  Deletable &\n  Node &\n  Reactable &\n  RepositoryNode &\n  Updatable &\n  UpdatableComment & {\n    __typename?: \"PullRequestReview\";\n    /** The actor who authored the comment. */\n    author?: Maybe<Actor>;\n    /** Author's association with the subject of the comment. */\n    authorAssociation: CommentAuthorAssociation;\n    /** Indicates whether the author of this review has push access to the repository. */\n    authorCanPushToRepository: Scalars[\"Boolean\"];\n    /** Identifies the pull request review body. */\n    body: Scalars[\"String\"];\n    /** The body rendered to HTML. */\n    bodyHTML: Scalars[\"HTML\"];\n    /** The body of this review rendered as plain text. */\n    bodyText: Scalars[\"String\"];\n    /** A list of review comments for the current pull request review. */\n    comments: PullRequestReviewCommentConnection;\n    /** Identifies the commit associated with this pull request review. */\n    commit?: Maybe<Commit>;\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars[\"DateTime\"];\n    /** Check if this comment was created via an email reply. */\n    createdViaEmail: Scalars[\"Boolean\"];\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars[\"Int\"]>;\n    /** The actor who edited the comment. */\n    editor?: Maybe<Actor>;\n    id: Scalars[\"ID\"];\n    /** Check if this comment was edited and includes an edit with the creation data */\n    includesCreatedEdit: Scalars[\"Boolean\"];\n    /** The moment the editor made the last edit */\n    lastEditedAt?: Maybe<Scalars[\"DateTime\"]>;\n    /** A list of teams that this review was made on behalf of. */\n    onBehalfOf: TeamConnection;\n    /** Identifies when the comment was published at. */\n    publishedAt?: Maybe<Scalars[\"DateTime\"]>;\n    /** Identifies the pull request associated with this pull request review. */\n    pullRequest: PullRequest;\n    /** A list of reactions grouped by content left on the subject. */\n    reactionGroups?: Maybe<Array<ReactionGroup>>;\n    /** A list of Reactions left on the Issue. */\n    reactions: ReactionConnection;\n    /** The repository associated with this node. */\n    repository: Repository;\n    /** The HTTP path permalink for this PullRequestReview. */\n    resourcePath: Scalars[\"URI\"];\n    /** Identifies the current state of the pull request review. */\n    state: PullRequestReviewState;\n    /** Identifies when the Pull Request Review was submitted */\n    submittedAt?: Maybe<Scalars[\"DateTime\"]>;\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars[\"DateTime\"];\n    /** The HTTP URL permalink for this PullRequestReview. */\n    url: Scalars[\"URI\"];\n    /** A list of edits to this content. */\n    userContentEdits?: Maybe<UserContentEditConnection>;\n    /** Check if the current viewer can delete this object. */\n    viewerCanDelete: Scalars[\"Boolean\"];\n    /** Can user react to this subject */\n    viewerCanReact: Scalars[\"Boolean\"];\n    /** Check if the current viewer can update this object. */\n    viewerCanUpdate: Scalars[\"Boolean\"];\n    /** Reasons why the current viewer can not update this comment. */\n    viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;\n    /** Did the viewer author this comment. */\n    viewerDidAuthor: Scalars[\"Boolean\"];\n  };\n\n/** A review object for a given pull request. */\nexport type PullRequestReviewCommentsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A review object for a given pull request. */\nexport type PullRequestReviewOnBehalfOfArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A review object for a given pull request. */\nexport type PullRequestReviewReactionsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  content?: InputMaybe<ReactionContent>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<ReactionOrder>;\n};\n\n/** A review object for a given pull request. */\nexport type PullRequestReviewUserContentEditsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A review comment associated with a given repository pull request. */\nexport type PullRequestReviewComment = Comment &\n  Deletable &\n  Minimizable &\n  Node &\n  Reactable &\n  RepositoryNode &\n  Updatable &\n  UpdatableComment & {\n    __typename?: \"PullRequestReviewComment\";\n    /** The actor who authored the comment. */\n    author?: Maybe<Actor>;\n    /** Author's association with the subject of the comment. */\n    authorAssociation: CommentAuthorAssociation;\n    /** The comment body of this review comment. */\n    body: Scalars[\"String\"];\n    /** The body rendered to HTML. */\n    bodyHTML: Scalars[\"HTML\"];\n    /** The comment body of this review comment rendered as plain text. */\n    bodyText: Scalars[\"String\"];\n    /** Identifies the commit associated with the comment. */\n    commit?: Maybe<Commit>;\n    /** Identifies when the comment was created. */\n    createdAt: Scalars[\"DateTime\"];\n    /** Check if this comment was created via an email reply. */\n    createdViaEmail: Scalars[\"Boolean\"];\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars[\"Int\"]>;\n    /** The diff hunk to which the comment applies. */\n    diffHunk: Scalars[\"String\"];\n    /** Identifies when the comment was created in a draft state. */\n    draftedAt: Scalars[\"DateTime\"];\n    /** The actor who edited the comment. */\n    editor?: Maybe<Actor>;\n    id: Scalars[\"ID\"];\n    /** Check if this comment was edited and includes an edit with the creation data */\n    includesCreatedEdit: Scalars[\"Boolean\"];\n    /** Returns whether or not a comment has been minimized. */\n    isMinimized: Scalars[\"Boolean\"];\n    /** The moment the editor made the last edit */\n    lastEditedAt?: Maybe<Scalars[\"DateTime\"]>;\n    /** Returns why the comment was minimized. */\n    minimizedReason?: Maybe<Scalars[\"String\"]>;\n    /** Identifies the original commit associated with the comment. */\n    originalCommit?: Maybe<Commit>;\n    /** The original line index in the diff to which the comment applies. */\n    originalPosition: Scalars[\"Int\"];\n    /** Identifies when the comment body is outdated */\n    outdated: Scalars[\"Boolean\"];\n    /** The path to which the comment applies. */\n    path: Scalars[\"String\"];\n    /** The line index in the diff to which the comment applies. */\n    position?: Maybe<Scalars[\"Int\"]>;\n    /** Identifies when the comment was published at. */\n    publishedAt?: Maybe<Scalars[\"DateTime\"]>;\n    /** The pull request associated with this review comment. */\n    pullRequest: PullRequest;\n    /** The pull request review associated with this review comment. */\n    pullRequestReview?: Maybe<PullRequestReview>;\n    /** A list of reactions grouped by content left on the subject. */\n    reactionGroups?: Maybe<Array<ReactionGroup>>;\n    /** A list of Reactions left on the Issue. */\n    reactions: ReactionConnection;\n    /** The comment this is a reply to. */\n    replyTo?: Maybe<PullRequestReviewComment>;\n    /** The repository associated with this node. */\n    repository: Repository;\n    /** The HTTP path permalink for this review comment. */\n    resourcePath: Scalars[\"URI\"];\n    /** Identifies the state of the comment. */\n    state: PullRequestReviewCommentState;\n    /** Identifies when the comment was last updated. */\n    updatedAt: Scalars[\"DateTime\"];\n    /** The HTTP URL permalink for this review comment. */\n    url: Scalars[\"URI\"];\n    /** A list of edits to this content. */\n    userContentEdits?: Maybe<UserContentEditConnection>;\n    /** Check if the current viewer can delete this object. */\n    viewerCanDelete: Scalars[\"Boolean\"];\n    /** Check if the current viewer can minimize this object. */\n    viewerCanMinimize: Scalars[\"Boolean\"];\n    /** Can user react to this subject */\n    viewerCanReact: Scalars[\"Boolean\"];\n    /** Check if the current viewer can update this object. */\n    viewerCanUpdate: Scalars[\"Boolean\"];\n    /** Reasons why the current viewer can not update this comment. */\n    viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;\n    /** Did the viewer author this comment. */\n    viewerDidAuthor: Scalars[\"Boolean\"];\n  };\n\n/** A review comment associated with a given repository pull request. */\nexport type PullRequestReviewCommentReactionsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  content?: InputMaybe<ReactionContent>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<ReactionOrder>;\n};\n\n/** A review comment associated with a given repository pull request. */\nexport type PullRequestReviewCommentUserContentEditsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** The connection type for PullRequestReviewComment. */\nexport type PullRequestReviewCommentConnection = {\n  __typename?: \"PullRequestReviewCommentConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PullRequestReviewCommentEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PullRequestReviewComment>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type PullRequestReviewCommentEdge = {\n  __typename?: \"PullRequestReviewCommentEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<PullRequestReviewComment>;\n};\n\n/** The possible states of a pull request review comment. */\nexport enum PullRequestReviewCommentState {\n  /** A comment that is part of a pending review */\n  Pending = \"PENDING\",\n  /** A comment that is part of a submitted review */\n  Submitted = \"SUBMITTED\",\n}\n\n/** The connection type for PullRequestReview. */\nexport type PullRequestReviewConnection = {\n  __typename?: \"PullRequestReviewConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PullRequestReviewEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PullRequestReview>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** This aggregates pull request reviews made by a user within one repository. */\nexport type PullRequestReviewContributionsByRepository = {\n  __typename?: \"PullRequestReviewContributionsByRepository\";\n  /** The pull request review contributions. */\n  contributions: CreatedPullRequestReviewContributionConnection;\n  /** The repository in which the pull request reviews were made. */\n  repository: Repository;\n};\n\n/** This aggregates pull request reviews made by a user within one repository. */\nexport type PullRequestReviewContributionsByRepositoryContributionsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<ContributionOrder>;\n};\n\n/** The review status of a pull request. */\nexport enum PullRequestReviewDecision {\n  /** The pull request has received an approving review. */\n  Approved = \"APPROVED\",\n  /** Changes have been requested on the pull request. */\n  ChangesRequested = \"CHANGES_REQUESTED\",\n  /** A review is required before the pull request can be merged. */\n  ReviewRequired = \"REVIEW_REQUIRED\",\n}\n\n/** An edge in a connection. */\nexport type PullRequestReviewEdge = {\n  __typename?: \"PullRequestReviewEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<PullRequestReview>;\n};\n\n/** The possible events to perform on a pull request review. */\nexport enum PullRequestReviewEvent {\n  /** Submit feedback and approve merging these changes. */\n  Approve = \"APPROVE\",\n  /** Submit general feedback without explicit approval. */\n  Comment = \"COMMENT\",\n  /** Dismiss review so it now longer effects merging. */\n  Dismiss = \"DISMISS\",\n  /** Submit feedback that must be addressed before merging. */\n  RequestChanges = \"REQUEST_CHANGES\",\n}\n\n/** The possible states of a pull request review. */\nexport enum PullRequestReviewState {\n  /** A review allowing the pull request to merge. */\n  Approved = \"APPROVED\",\n  /** A review blocking the pull request from merging. */\n  ChangesRequested = \"CHANGES_REQUESTED\",\n  /** An informational review. */\n  Commented = \"COMMENTED\",\n  /** A review that has been dismissed. */\n  Dismissed = \"DISMISSED\",\n  /** A review that has not yet been submitted. */\n  Pending = \"PENDING\",\n}\n\n/** A threaded list of comments for a given pull request. */\nexport type PullRequestReviewThread = Node & {\n  __typename?: \"PullRequestReviewThread\";\n  /** A list of pull request comments associated with the thread. */\n  comments: PullRequestReviewCommentConnection;\n  /** The side of the diff on which this thread was placed. */\n  diffSide: DiffSide;\n  id: Scalars[\"ID\"];\n  /** Whether or not the thread has been collapsed (resolved) */\n  isCollapsed: Scalars[\"Boolean\"];\n  /** Indicates whether this thread was outdated by newer changes. */\n  isOutdated: Scalars[\"Boolean\"];\n  /** Whether this thread has been resolved */\n  isResolved: Scalars[\"Boolean\"];\n  /** The line in the file to which this thread refers */\n  line?: Maybe<Scalars[\"Int\"]>;\n  /** The original line in the file to which this thread refers. */\n  originalLine?: Maybe<Scalars[\"Int\"]>;\n  /** The original start line in the file to which this thread refers (multi-line only). */\n  originalStartLine?: Maybe<Scalars[\"Int\"]>;\n  /** Identifies the file path of this thread. */\n  path: Scalars[\"String\"];\n  /** Identifies the pull request associated with this thread. */\n  pullRequest: PullRequest;\n  /** Identifies the repository associated with this thread. */\n  repository: Repository;\n  /** The user who resolved this thread */\n  resolvedBy?: Maybe<User>;\n  /** The side of the diff that the first line of the thread starts on (multi-line only) */\n  startDiffSide?: Maybe<DiffSide>;\n  /** The start line in the file to which this thread refers (multi-line only) */\n  startLine?: Maybe<Scalars[\"Int\"]>;\n  /** Indicates whether the current viewer can reply to this thread. */\n  viewerCanReply: Scalars[\"Boolean\"];\n  /** Whether or not the viewer can resolve this thread */\n  viewerCanResolve: Scalars[\"Boolean\"];\n  /** Whether or not the viewer can unresolve this thread */\n  viewerCanUnresolve: Scalars[\"Boolean\"];\n};\n\n/** A threaded list of comments for a given pull request. */\nexport type PullRequestReviewThreadCommentsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  skip?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** Review comment threads for a pull request review. */\nexport type PullRequestReviewThreadConnection = {\n  __typename?: \"PullRequestReviewThreadConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PullRequestReviewThreadEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PullRequestReviewThread>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type PullRequestReviewThreadEdge = {\n  __typename?: \"PullRequestReviewThreadEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<PullRequestReviewThread>;\n};\n\n/** Represents the latest point in the pull request timeline for which the viewer has seen the pull request's commits. */\nexport type PullRequestRevisionMarker = {\n  __typename?: \"PullRequestRevisionMarker\";\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** The last commit the viewer has seen. */\n  lastSeenCommit: Commit;\n  /** The pull request to which the marker belongs. */\n  pullRequest: PullRequest;\n};\n\n/** The possible states of a pull request. */\nexport enum PullRequestState {\n  /** A pull request that has been closed without being merged. */\n  Closed = \"CLOSED\",\n  /** A pull request that has been closed by being merged. */\n  Merged = \"MERGED\",\n  /** A pull request that is still open. */\n  Open = \"OPEN\",\n}\n\n/** A repository pull request template. */\nexport type PullRequestTemplate = {\n  __typename?: \"PullRequestTemplate\";\n  /** The body of the template */\n  body?: Maybe<Scalars[\"String\"]>;\n  /** The filename of the template */\n  filename?: Maybe<Scalars[\"String\"]>;\n  /** The repository the template belongs to */\n  repository: Repository;\n};\n\n/** The connection type for PullRequestTimelineItem. */\nexport type PullRequestTimelineConnection = {\n  __typename?: \"PullRequestTimelineConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PullRequestTimelineItemEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PullRequestTimelineItem>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An item in a pull request timeline */\nexport type PullRequestTimelineItem =\n  | AssignedEvent\n  | BaseRefDeletedEvent\n  | BaseRefForcePushedEvent\n  | ClosedEvent\n  | Commit\n  | CommitCommentThread\n  | CrossReferencedEvent\n  | DemilestonedEvent\n  | DeployedEvent\n  | DeploymentEnvironmentChangedEvent\n  | HeadRefDeletedEvent\n  | HeadRefForcePushedEvent\n  | HeadRefRestoredEvent\n  | IssueComment\n  | LabeledEvent\n  | LockedEvent\n  | MergedEvent\n  | MilestonedEvent\n  | PullRequestReview\n  | PullRequestReviewComment\n  | PullRequestReviewThread\n  | ReferencedEvent\n  | RenamedTitleEvent\n  | ReopenedEvent\n  | ReviewDismissedEvent\n  | ReviewRequestRemovedEvent\n  | ReviewRequestedEvent\n  | SubscribedEvent\n  | UnassignedEvent\n  | UnlabeledEvent\n  | UnlockedEvent\n  | UnsubscribedEvent\n  | UserBlockedEvent;\n\n/** An edge in a connection. */\nexport type PullRequestTimelineItemEdge = {\n  __typename?: \"PullRequestTimelineItemEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<PullRequestTimelineItem>;\n};\n\n/** An item in a pull request timeline */\nexport type PullRequestTimelineItems =\n  | AddedToProjectEvent\n  | AssignedEvent\n  | AutoMergeDisabledEvent\n  | AutoMergeEnabledEvent\n  | AutoRebaseEnabledEvent\n  | AutoSquashEnabledEvent\n  | AutomaticBaseChangeFailedEvent\n  | AutomaticBaseChangeSucceededEvent\n  | BaseRefChangedEvent\n  | BaseRefDeletedEvent\n  | BaseRefForcePushedEvent\n  | ClosedEvent\n  | CommentDeletedEvent\n  | ConnectedEvent\n  | ConvertToDraftEvent\n  | ConvertedNoteToIssueEvent\n  | ConvertedToDiscussionEvent\n  | CrossReferencedEvent\n  | DemilestonedEvent\n  | DeployedEvent\n  | DeploymentEnvironmentChangedEvent\n  | DisconnectedEvent\n  | HeadRefDeletedEvent\n  | HeadRefForcePushedEvent\n  | HeadRefRestoredEvent\n  | IssueComment\n  | LabeledEvent\n  | LockedEvent\n  | MarkedAsDuplicateEvent\n  | MentionedEvent\n  | MergedEvent\n  | MilestonedEvent\n  | MovedColumnsInProjectEvent\n  | PinnedEvent\n  | PullRequestCommit\n  | PullRequestCommitCommentThread\n  | PullRequestReview\n  | PullRequestReviewThread\n  | PullRequestRevisionMarker\n  | ReadyForReviewEvent\n  | ReferencedEvent\n  | RemovedFromProjectEvent\n  | RenamedTitleEvent\n  | ReopenedEvent\n  | ReviewDismissedEvent\n  | ReviewRequestRemovedEvent\n  | ReviewRequestedEvent\n  | SubscribedEvent\n  | TransferredEvent\n  | UnassignedEvent\n  | UnlabeledEvent\n  | UnlockedEvent\n  | UnmarkedAsDuplicateEvent\n  | UnpinnedEvent\n  | UnsubscribedEvent\n  | UserBlockedEvent;\n\n/** The connection type for PullRequestTimelineItems. */\nexport type PullRequestTimelineItemsConnection = {\n  __typename?: \"PullRequestTimelineItemsConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PullRequestTimelineItemsEdge>>>;\n  /** Identifies the count of items after applying `before` and `after` filters. */\n  filteredCount: Scalars[\"Int\"];\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PullRequestTimelineItems>>>;\n  /** Identifies the count of items after applying `before`/`after` filters and `first`/`last`/`skip` slicing. */\n  pageCount: Scalars[\"Int\"];\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n  /** Identifies the date and time when the timeline was last updated. */\n  updatedAt: Scalars[\"DateTime\"];\n};\n\n/** An edge in a connection. */\nexport type PullRequestTimelineItemsEdge = {\n  __typename?: \"PullRequestTimelineItemsEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<PullRequestTimelineItems>;\n};\n\n/** The possible item types found in a timeline. */\nexport enum PullRequestTimelineItemsItemType {\n  /** Represents an 'added_to_merge_queue' event on a given pull request. */\n  AddedToMergeQueueEvent = \"ADDED_TO_MERGE_QUEUE_EVENT\",\n  /** Represents a 'added_to_project' event on a given issue or pull request. */\n  AddedToProjectEvent = \"ADDED_TO_PROJECT_EVENT\",\n  /** Represents an 'assigned' event on any assignable object. */\n  AssignedEvent = \"ASSIGNED_EVENT\",\n  /** Represents a 'automatic_base_change_failed' event on a given pull request. */\n  AutomaticBaseChangeFailedEvent = \"AUTOMATIC_BASE_CHANGE_FAILED_EVENT\",\n  /** Represents a 'automatic_base_change_succeeded' event on a given pull request. */\n  AutomaticBaseChangeSucceededEvent = \"AUTOMATIC_BASE_CHANGE_SUCCEEDED_EVENT\",\n  /** Represents a 'auto_merge_disabled' event on a given pull request. */\n  AutoMergeDisabledEvent = \"AUTO_MERGE_DISABLED_EVENT\",\n  /** Represents a 'auto_merge_enabled' event on a given pull request. */\n  AutoMergeEnabledEvent = \"AUTO_MERGE_ENABLED_EVENT\",\n  /** Represents a 'auto_rebase_enabled' event on a given pull request. */\n  AutoRebaseEnabledEvent = \"AUTO_REBASE_ENABLED_EVENT\",\n  /** Represents a 'auto_squash_enabled' event on a given pull request. */\n  AutoSquashEnabledEvent = \"AUTO_SQUASH_ENABLED_EVENT\",\n  /** Represents a 'base_ref_changed' event on a given issue or pull request. */\n  BaseRefChangedEvent = \"BASE_REF_CHANGED_EVENT\",\n  /** Represents a 'base_ref_deleted' event on a given pull request. */\n  BaseRefDeletedEvent = \"BASE_REF_DELETED_EVENT\",\n  /** Represents a 'base_ref_force_pushed' event on a given pull request. */\n  BaseRefForcePushedEvent = \"BASE_REF_FORCE_PUSHED_EVENT\",\n  /** Represents a 'closed' event on any `Closable`. */\n  ClosedEvent = \"CLOSED_EVENT\",\n  /** Represents a 'comment_deleted' event on a given issue or pull request. */\n  CommentDeletedEvent = \"COMMENT_DELETED_EVENT\",\n  /** Represents a 'connected' event on a given issue or pull request. */\n  ConnectedEvent = \"CONNECTED_EVENT\",\n  /** Represents a 'converted_note_to_issue' event on a given issue or pull request. */\n  ConvertedNoteToIssueEvent = \"CONVERTED_NOTE_TO_ISSUE_EVENT\",\n  /** Represents a 'converted_to_discussion' event on a given issue. */\n  ConvertedToDiscussionEvent = \"CONVERTED_TO_DISCUSSION_EVENT\",\n  /** Represents a 'convert_to_draft' event on a given pull request. */\n  ConvertToDraftEvent = \"CONVERT_TO_DRAFT_EVENT\",\n  /** Represents a mention made by one issue or pull request to another. */\n  CrossReferencedEvent = \"CROSS_REFERENCED_EVENT\",\n  /** Represents a 'demilestoned' event on a given issue or pull request. */\n  DemilestonedEvent = \"DEMILESTONED_EVENT\",\n  /** Represents a 'deployed' event on a given pull request. */\n  DeployedEvent = \"DEPLOYED_EVENT\",\n  /** Represents a 'deployment_environment_changed' event on a given pull request. */\n  DeploymentEnvironmentChangedEvent = \"DEPLOYMENT_ENVIRONMENT_CHANGED_EVENT\",\n  /** Represents a 'disconnected' event on a given issue or pull request. */\n  DisconnectedEvent = \"DISCONNECTED_EVENT\",\n  /** Represents a 'head_ref_deleted' event on a given pull request. */\n  HeadRefDeletedEvent = \"HEAD_REF_DELETED_EVENT\",\n  /** Represents a 'head_ref_force_pushed' event on a given pull request. */\n  HeadRefForcePushedEvent = \"HEAD_REF_FORCE_PUSHED_EVENT\",\n  /** Represents a 'head_ref_restored' event on a given pull request. */\n  HeadRefRestoredEvent = \"HEAD_REF_RESTORED_EVENT\",\n  /** Represents a comment on an Issue. */\n  IssueComment = \"ISSUE_COMMENT\",\n  /** Represents a 'labeled' event on a given issue or pull request. */\n  LabeledEvent = \"LABELED_EVENT\",\n  /** Represents a 'locked' event on a given issue or pull request. */\n  LockedEvent = \"LOCKED_EVENT\",\n  /** Represents a 'marked_as_duplicate' event on a given issue or pull request. */\n  MarkedAsDuplicateEvent = \"MARKED_AS_DUPLICATE_EVENT\",\n  /** Represents a 'mentioned' event on a given issue or pull request. */\n  MentionedEvent = \"MENTIONED_EVENT\",\n  /** Represents a 'merged' event on a given pull request. */\n  MergedEvent = \"MERGED_EVENT\",\n  /** Represents a 'milestoned' event on a given issue or pull request. */\n  MilestonedEvent = \"MILESTONED_EVENT\",\n  /** Represents a 'moved_columns_in_project' event on a given issue or pull request. */\n  MovedColumnsInProjectEvent = \"MOVED_COLUMNS_IN_PROJECT_EVENT\",\n  /** Represents a 'pinned' event on a given issue or pull request. */\n  PinnedEvent = \"PINNED_EVENT\",\n  /** Represents a Git commit part of a pull request. */\n  PullRequestCommit = \"PULL_REQUEST_COMMIT\",\n  /** Represents a commit comment thread part of a pull request. */\n  PullRequestCommitCommentThread = \"PULL_REQUEST_COMMIT_COMMENT_THREAD\",\n  /** A review object for a given pull request. */\n  PullRequestReview = \"PULL_REQUEST_REVIEW\",\n  /** A threaded list of comments for a given pull request. */\n  PullRequestReviewThread = \"PULL_REQUEST_REVIEW_THREAD\",\n  /** Represents the latest point in the pull request timeline for which the viewer has seen the pull request's commits. */\n  PullRequestRevisionMarker = \"PULL_REQUEST_REVISION_MARKER\",\n  /** Represents a 'ready_for_review' event on a given pull request. */\n  ReadyForReviewEvent = \"READY_FOR_REVIEW_EVENT\",\n  /** Represents a 'referenced' event on a given `ReferencedSubject`. */\n  ReferencedEvent = \"REFERENCED_EVENT\",\n  /** Represents a 'removed_from_merge_queue' event on a given pull request. */\n  RemovedFromMergeQueueEvent = \"REMOVED_FROM_MERGE_QUEUE_EVENT\",\n  /** Represents a 'removed_from_project' event on a given issue or pull request. */\n  RemovedFromProjectEvent = \"REMOVED_FROM_PROJECT_EVENT\",\n  /** Represents a 'renamed' event on a given issue or pull request */\n  RenamedTitleEvent = \"RENAMED_TITLE_EVENT\",\n  /** Represents a 'reopened' event on any `Closable`. */\n  ReopenedEvent = \"REOPENED_EVENT\",\n  /** Represents a 'review_dismissed' event on a given issue or pull request. */\n  ReviewDismissedEvent = \"REVIEW_DISMISSED_EVENT\",\n  /** Represents an 'review_requested' event on a given pull request. */\n  ReviewRequestedEvent = \"REVIEW_REQUESTED_EVENT\",\n  /** Represents an 'review_request_removed' event on a given pull request. */\n  ReviewRequestRemovedEvent = \"REVIEW_REQUEST_REMOVED_EVENT\",\n  /** Represents a 'subscribed' event on a given `Subscribable`. */\n  SubscribedEvent = \"SUBSCRIBED_EVENT\",\n  /** Represents a 'transferred' event on a given issue or pull request. */\n  TransferredEvent = \"TRANSFERRED_EVENT\",\n  /** Represents an 'unassigned' event on any assignable object. */\n  UnassignedEvent = \"UNASSIGNED_EVENT\",\n  /** Represents an 'unlabeled' event on a given issue or pull request. */\n  UnlabeledEvent = \"UNLABELED_EVENT\",\n  /** Represents an 'unlocked' event on a given issue or pull request. */\n  UnlockedEvent = \"UNLOCKED_EVENT\",\n  /** Represents an 'unmarked_as_duplicate' event on a given issue or pull request. */\n  UnmarkedAsDuplicateEvent = \"UNMARKED_AS_DUPLICATE_EVENT\",\n  /** Represents an 'unpinned' event on a given issue or pull request. */\n  UnpinnedEvent = \"UNPINNED_EVENT\",\n  /** Represents an 'unsubscribed' event on a given `Subscribable`. */\n  UnsubscribedEvent = \"UNSUBSCRIBED_EVENT\",\n  /** Represents a 'user_blocked' event on a given user. */\n  UserBlockedEvent = \"USER_BLOCKED_EVENT\",\n}\n\n/** The possible target states when updating a pull request. */\nexport enum PullRequestUpdateState {\n  /** A pull request that has been closed without being merged. */\n  Closed = \"CLOSED\",\n  /** A pull request that is still open. */\n  Open = \"OPEN\",\n}\n\n/** A Git push. */\nexport type Push = Node & {\n  __typename?: \"Push\";\n  id: Scalars[\"ID\"];\n  /** The SHA after the push */\n  nextSha?: Maybe<Scalars[\"GitObjectID\"]>;\n  /** The permalink for this push. */\n  permalink: Scalars[\"URI\"];\n  /** The SHA before the push */\n  previousSha?: Maybe<Scalars[\"GitObjectID\"]>;\n  /** The actor who pushed */\n  pusher: Actor;\n  /** The repository that was pushed to */\n  repository: Repository;\n};\n\n/** A team, user or app who has the ability to push to a protected branch. */\nexport type PushAllowance = Node & {\n  __typename?: \"PushAllowance\";\n  /** The actor that can push. */\n  actor?: Maybe<PushAllowanceActor>;\n  /** Identifies the branch protection rule associated with the allowed user or team. */\n  branchProtectionRule?: Maybe<BranchProtectionRule>;\n  id: Scalars[\"ID\"];\n};\n\n/** Types that can be an actor. */\nexport type PushAllowanceActor = App | Team | User;\n\n/** The connection type for PushAllowance. */\nexport type PushAllowanceConnection = {\n  __typename?: \"PushAllowanceConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PushAllowanceEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PushAllowance>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type PushAllowanceEdge = {\n  __typename?: \"PushAllowanceEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<PushAllowance>;\n};\n\n/** The query root of GitHub's GraphQL interface. */\nexport type Query = {\n  __typename?: \"Query\";\n  /** Look up a code of conduct by its key */\n  codeOfConduct?: Maybe<CodeOfConduct>;\n  /** Look up a code of conduct by its key */\n  codesOfConduct?: Maybe<Array<Maybe<CodeOfConduct>>>;\n  /** Look up an enterprise by URL slug. */\n  enterprise?: Maybe<Enterprise>;\n  /** Look up a pending enterprise administrator invitation by invitee, enterprise and role. */\n  enterpriseAdministratorInvitation?: Maybe<EnterpriseAdministratorInvitation>;\n  /** Look up a pending enterprise administrator invitation by invitation token. */\n  enterpriseAdministratorInvitationByToken?: Maybe<EnterpriseAdministratorInvitation>;\n  /** Look up an open source license by its key */\n  license?: Maybe<License>;\n  /** Return a list of known open source licenses */\n  licenses: Array<Maybe<License>>;\n  /** Get alphabetically sorted list of Marketplace categories */\n  marketplaceCategories: Array<MarketplaceCategory>;\n  /** Look up a Marketplace category by its slug. */\n  marketplaceCategory?: Maybe<MarketplaceCategory>;\n  /** Look up a single Marketplace listing */\n  marketplaceListing?: Maybe<MarketplaceListing>;\n  /** Look up Marketplace listings */\n  marketplaceListings: MarketplaceListingConnection;\n  /** Return information about the GitHub instance */\n  meta: GitHubMetadata;\n  /** Fetches an object given its ID. */\n  node?: Maybe<Node>;\n  /** Lookup nodes by a list of IDs. */\n  nodes: Array<Maybe<Node>>;\n  /** Lookup a organization by login. */\n  organization?: Maybe<Organization>;\n  /** The client's rate limit information. */\n  rateLimit?: Maybe<RateLimit>;\n  /** Hack to workaround https://github.com/facebook/relay/issues/112 re-exposing the root query object */\n  relay: Query;\n  /** Lookup a given repository by the owner and repository name. */\n  repository?: Maybe<Repository>;\n  /** Lookup a repository owner (ie. either a User or an Organization) by login. */\n  repositoryOwner?: Maybe<RepositoryOwner>;\n  /** Lookup resource by a URL. */\n  resource?: Maybe<UniformResourceLocatable>;\n  /** Perform a search across resources. */\n  search: SearchResultItemConnection;\n  /** GitHub Security Advisories */\n  securityAdvisories: SecurityAdvisoryConnection;\n  /** Fetch a Security Advisory by its GHSA ID */\n  securityAdvisory?: Maybe<SecurityAdvisory>;\n  /** Software Vulnerabilities documented by GitHub Security Advisories */\n  securityVulnerabilities: SecurityVulnerabilityConnection;\n  /** Users and organizations who can be sponsored via GitHub Sponsors. */\n  sponsorables: SponsorableItemConnection;\n  /** Look up a topic by name. */\n  topic?: Maybe<Topic>;\n  /** Lookup a user by login. */\n  user?: Maybe<User>;\n  /** The currently authenticated user. */\n  viewer: User;\n};\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryCodeOfConductArgs = {\n  key: Scalars[\"String\"];\n};\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryEnterpriseArgs = {\n  invitationToken?: InputMaybe<Scalars[\"String\"]>;\n  slug: Scalars[\"String\"];\n};\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryEnterpriseAdministratorInvitationArgs = {\n  enterpriseSlug: Scalars[\"String\"];\n  role: EnterpriseAdministratorRole;\n  userLogin: Scalars[\"String\"];\n};\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryEnterpriseAdministratorInvitationByTokenArgs = {\n  invitationToken: Scalars[\"String\"];\n};\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryLicenseArgs = {\n  key: Scalars[\"String\"];\n};\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryMarketplaceCategoriesArgs = {\n  excludeEmpty?: InputMaybe<Scalars[\"Boolean\"]>;\n  excludeSubcategories?: InputMaybe<Scalars[\"Boolean\"]>;\n  includeCategories?: InputMaybe<Array<Scalars[\"String\"]>>;\n};\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryMarketplaceCategoryArgs = {\n  slug: Scalars[\"String\"];\n  useTopicAliases?: InputMaybe<Scalars[\"Boolean\"]>;\n};\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryMarketplaceListingArgs = {\n  slug: Scalars[\"String\"];\n};\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryMarketplaceListingsArgs = {\n  adminId?: InputMaybe<Scalars[\"ID\"]>;\n  after?: InputMaybe<Scalars[\"String\"]>;\n  allStates?: InputMaybe<Scalars[\"Boolean\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  categorySlug?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  organizationId?: InputMaybe<Scalars[\"ID\"]>;\n  primaryCategoryOnly?: InputMaybe<Scalars[\"Boolean\"]>;\n  slugs?: InputMaybe<Array<InputMaybe<Scalars[\"String\"]>>>;\n  useTopicAliases?: InputMaybe<Scalars[\"Boolean\"]>;\n  viewerCanAdmin?: InputMaybe<Scalars[\"Boolean\"]>;\n  withFreeTrialsOnly?: InputMaybe<Scalars[\"Boolean\"]>;\n};\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryNodeArgs = {\n  id: Scalars[\"ID\"];\n};\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryNodesArgs = {\n  ids: Array<Scalars[\"ID\"]>;\n};\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryOrganizationArgs = {\n  login: Scalars[\"String\"];\n};\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryRateLimitArgs = {\n  dryRun?: InputMaybe<Scalars[\"Boolean\"]>;\n};\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryRepositoryArgs = {\n  followRenames?: InputMaybe<Scalars[\"Boolean\"]>;\n  name: Scalars[\"String\"];\n  owner: Scalars[\"String\"];\n};\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryRepositoryOwnerArgs = {\n  login: Scalars[\"String\"];\n};\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryResourceArgs = {\n  url: Scalars[\"URI\"];\n};\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QuerySearchArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  query: Scalars[\"String\"];\n  type: SearchType;\n};\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QuerySecurityAdvisoriesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  identifier?: InputMaybe<SecurityAdvisoryIdentifierFilter>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<SecurityAdvisoryOrder>;\n  publishedSince?: InputMaybe<Scalars[\"DateTime\"]>;\n  updatedSince?: InputMaybe<Scalars[\"DateTime\"]>;\n};\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QuerySecurityAdvisoryArgs = {\n  ghsaId: Scalars[\"String\"];\n};\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QuerySecurityVulnerabilitiesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  ecosystem?: InputMaybe<SecurityAdvisoryEcosystem>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<SecurityVulnerabilityOrder>;\n  package?: InputMaybe<Scalars[\"String\"]>;\n  severities?: InputMaybe<Array<SecurityAdvisorySeverity>>;\n};\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QuerySponsorablesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  dependencyEcosystem?: InputMaybe<SecurityAdvisoryEcosystem>;\n  ecosystem?: InputMaybe<DependencyGraphEcosystem>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  onlyDependencies?: InputMaybe<Scalars[\"Boolean\"]>;\n  orderBy?: InputMaybe<SponsorableOrder>;\n  orgLoginForDependencies?: InputMaybe<Scalars[\"String\"]>;\n};\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryTopicArgs = {\n  name: Scalars[\"String\"];\n};\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryUserArgs = {\n  login: Scalars[\"String\"];\n};\n\n/** Represents the client's rate limit. */\nexport type RateLimit = {\n  __typename?: \"RateLimit\";\n  /** The point cost for the current query counting against the rate limit. */\n  cost: Scalars[\"Int\"];\n  /** The maximum number of points the client is permitted to consume in a 60 minute window. */\n  limit: Scalars[\"Int\"];\n  /** The maximum number of nodes this query may return */\n  nodeCount: Scalars[\"Int\"];\n  /** The number of points remaining in the current rate limit window. */\n  remaining: Scalars[\"Int\"];\n  /** The time at which the current rate limit window resets in UTC epoch seconds. */\n  resetAt: Scalars[\"DateTime\"];\n  /** The number of points used in the current rate limit window. */\n  used: Scalars[\"Int\"];\n};\n\n/** Represents a subject that can be reacted on. */\nexport type Reactable = {\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars[\"Int\"]>;\n  id: Scalars[\"ID\"];\n  /** A list of reactions grouped by content left on the subject. */\n  reactionGroups?: Maybe<Array<ReactionGroup>>;\n  /** A list of Reactions left on the Issue. */\n  reactions: ReactionConnection;\n  /** Can user react to this subject */\n  viewerCanReact: Scalars[\"Boolean\"];\n};\n\n/** Represents a subject that can be reacted on. */\nexport type ReactableReactionsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  content?: InputMaybe<ReactionContent>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<ReactionOrder>;\n};\n\n/** The connection type for User. */\nexport type ReactingUserConnection = {\n  __typename?: \"ReactingUserConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ReactingUserEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** Represents a user that's made a reaction. */\nexport type ReactingUserEdge = {\n  __typename?: \"ReactingUserEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  node: User;\n  /** The moment when the user made the reaction. */\n  reactedAt: Scalars[\"DateTime\"];\n};\n\n/** An emoji reaction to a particular piece of content. */\nexport type Reaction = Node & {\n  __typename?: \"Reaction\";\n  /** Identifies the emoji reaction. */\n  content: ReactionContent;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars[\"Int\"]>;\n  id: Scalars[\"ID\"];\n  /** The reactable piece of content */\n  reactable: Reactable;\n  /** Identifies the user who created this reaction. */\n  user?: Maybe<User>;\n};\n\n/** A list of reactions that have been left on the subject. */\nexport type ReactionConnection = {\n  __typename?: \"ReactionConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ReactionEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Reaction>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n  /** Whether or not the authenticated user has left a reaction on the subject. */\n  viewerHasReacted: Scalars[\"Boolean\"];\n};\n\n/** Emojis that can be attached to Issues, Pull Requests and Comments. */\nexport enum ReactionContent {\n  /** Represents the `:confused:` emoji. */\n  Confused = \"CONFUSED\",\n  /** Represents the `:eyes:` emoji. */\n  Eyes = \"EYES\",\n  /** Represents the `:heart:` emoji. */\n  Heart = \"HEART\",\n  /** Represents the `:hooray:` emoji. */\n  Hooray = \"HOORAY\",\n  /** Represents the `:laugh:` emoji. */\n  Laugh = \"LAUGH\",\n  /** Represents the `:rocket:` emoji. */\n  Rocket = \"ROCKET\",\n  /** Represents the `:-1:` emoji. */\n  ThumbsDown = \"THUMBS_DOWN\",\n  /** Represents the `:+1:` emoji. */\n  ThumbsUp = \"THUMBS_UP\",\n}\n\n/** An edge in a connection. */\nexport type ReactionEdge = {\n  __typename?: \"ReactionEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<Reaction>;\n};\n\n/** A group of emoji reactions to a particular piece of content. */\nexport type ReactionGroup = {\n  __typename?: \"ReactionGroup\";\n  /** Identifies the emoji reaction. */\n  content: ReactionContent;\n  /** Identifies when the reaction was created. */\n  createdAt?: Maybe<Scalars[\"DateTime\"]>;\n  /** Reactors to the reaction subject with the emotion represented by this reaction group. */\n  reactors: ReactorConnection;\n  /** The subject that was reacted to. */\n  subject: Reactable;\n  /**\n   * Users who have reacted to the reaction subject with the emotion represented by this reaction group\n   * @deprecated Reactors can now be mannequins, bots, and organizations. Use the `reactors` field instead. Removal on 2021-10-01 UTC.\n   */\n  users: ReactingUserConnection;\n  /** Whether or not the authenticated user has left a reaction on the subject. */\n  viewerHasReacted: Scalars[\"Boolean\"];\n};\n\n/** A group of emoji reactions to a particular piece of content. */\nexport type ReactionGroupReactorsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A group of emoji reactions to a particular piece of content. */\nexport type ReactionGroupUsersArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** Ways in which lists of reactions can be ordered upon return. */\nexport type ReactionOrder = {\n  /** The direction in which to order reactions by the specified field. */\n  direction: OrderDirection;\n  /** The field in which to order reactions by. */\n  field: ReactionOrderField;\n};\n\n/** A list of fields that reactions can be ordered by. */\nexport enum ReactionOrderField {\n  /** Allows ordering a list of reactions by when they were created. */\n  CreatedAt = \"CREATED_AT\",\n}\n\n/** Types that can be assigned to reactions. */\nexport type Reactor = Bot | Mannequin | Organization | User;\n\n/** The connection type for Reactor. */\nexport type ReactorConnection = {\n  __typename?: \"ReactorConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ReactorEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Reactor>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** Represents an author of a reaction. */\nexport type ReactorEdge = {\n  __typename?: \"ReactorEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The author of the reaction. */\n  node: Reactor;\n  /** The moment when the user made the reaction. */\n  reactedAt: Scalars[\"DateTime\"];\n};\n\n/** Represents a 'ready_for_review' event on a given pull request. */\nexport type ReadyForReviewEvent = Node &\n  UniformResourceLocatable & {\n    __typename?: \"ReadyForReviewEvent\";\n    /** Identifies the actor who performed the event. */\n    actor?: Maybe<Actor>;\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars[\"DateTime\"];\n    id: Scalars[\"ID\"];\n    /** PullRequest referenced by event. */\n    pullRequest: PullRequest;\n    /** The HTTP path for this ready for review event. */\n    resourcePath: Scalars[\"URI\"];\n    /** The HTTP URL for this ready for review event. */\n    url: Scalars[\"URI\"];\n  };\n\n/** Represents a Git reference. */\nexport type Ref = Node & {\n  __typename?: \"Ref\";\n  /** A list of pull requests with this ref as the head ref. */\n  associatedPullRequests: PullRequestConnection;\n  /** Branch protection rules for this ref */\n  branchProtectionRule?: Maybe<BranchProtectionRule>;\n  id: Scalars[\"ID\"];\n  /** The ref name. */\n  name: Scalars[\"String\"];\n  /** The ref's prefix, such as `refs/heads/` or `refs/tags/`. */\n  prefix: Scalars[\"String\"];\n  /** Branch protection rules that are viewable by non-admins */\n  refUpdateRule?: Maybe<RefUpdateRule>;\n  /** The repository the ref belongs to. */\n  repository: Repository;\n  /** The object the ref points to. Returns null when object does not exist. */\n  target?: Maybe<GitObject>;\n};\n\n/** Represents a Git reference. */\nexport type RefAssociatedPullRequestsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  baseRefName?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  headRefName?: InputMaybe<Scalars[\"String\"]>;\n  labels?: InputMaybe<Array<Scalars[\"String\"]>>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<IssueOrder>;\n  states?: InputMaybe<Array<PullRequestState>>;\n};\n\n/** The connection type for Ref. */\nexport type RefConnection = {\n  __typename?: \"RefConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<RefEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Ref>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type RefEdge = {\n  __typename?: \"RefEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<Ref>;\n};\n\n/** Ways in which lists of git refs can be ordered upon return. */\nexport type RefOrder = {\n  /** The direction in which to order refs by the specified field. */\n  direction: OrderDirection;\n  /** The field in which to order refs by. */\n  field: RefOrderField;\n};\n\n/** Properties by which ref connections can be ordered. */\nexport enum RefOrderField {\n  /** Order refs by their alphanumeric name */\n  Alphabetical = \"ALPHABETICAL\",\n  /** Order refs by underlying commit date if the ref prefix is refs/tags/ */\n  TagCommitDate = \"TAG_COMMIT_DATE\",\n}\n\n/** A ref update */\nexport type RefUpdate = {\n  /** The value this ref should be updated to. */\n  afterOid: Scalars[\"GitObjectID\"];\n  /** The value this ref needs to point to before the update. */\n  beforeOid?: InputMaybe<Scalars[\"GitObjectID\"]>;\n  /** Force a non fast-forward update. */\n  force?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** The fully qualified name of the ref to be update. For example `refs/heads/branch-name` */\n  name: Scalars[\"GitRefname\"];\n};\n\n/** A ref update rules for a viewer. */\nexport type RefUpdateRule = {\n  __typename?: \"RefUpdateRule\";\n  /** Can this branch be deleted. */\n  allowsDeletions: Scalars[\"Boolean\"];\n  /** Are force pushes allowed on this branch. */\n  allowsForcePushes: Scalars[\"Boolean\"];\n  /** Can matching branches be created. */\n  blocksCreations: Scalars[\"Boolean\"];\n  /** Identifies the protection rule pattern. */\n  pattern: Scalars[\"String\"];\n  /** Number of approving reviews required to update matching branches. */\n  requiredApprovingReviewCount?: Maybe<Scalars[\"Int\"]>;\n  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */\n  requiredStatusCheckContexts?: Maybe<Array<Maybe<Scalars[\"String\"]>>>;\n  /** Are reviews from code owners required to update matching branches. */\n  requiresCodeOwnerReviews: Scalars[\"Boolean\"];\n  /** Are conversations required to be resolved before merging. */\n  requiresConversationResolution: Scalars[\"Boolean\"];\n  /** Are merge commits prohibited from being pushed to this branch. */\n  requiresLinearHistory: Scalars[\"Boolean\"];\n  /** Are commits required to be signed. */\n  requiresSignatures: Scalars[\"Boolean\"];\n  /** Is the viewer allowed to dismiss reviews. */\n  viewerAllowedToDismissReviews: Scalars[\"Boolean\"];\n  /** Can the viewer push to the branch */\n  viewerCanPush: Scalars[\"Boolean\"];\n};\n\n/** Represents a 'referenced' event on a given `ReferencedSubject`. */\nexport type ReferencedEvent = Node & {\n  __typename?: \"ReferencedEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the commit associated with the 'referenced' event. */\n  commit?: Maybe<Commit>;\n  /** Identifies the repository associated with the 'referenced' event. */\n  commitRepository: Repository;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  id: Scalars[\"ID\"];\n  /** Reference originated in a different repository. */\n  isCrossRepository: Scalars[\"Boolean\"];\n  /** Checks if the commit message itself references the subject. Can be false in the case of a commit comment reference. */\n  isDirectReference: Scalars[\"Boolean\"];\n  /** Object referenced by event. */\n  subject: ReferencedSubject;\n};\n\n/** Any referencable object */\nexport type ReferencedSubject = Issue | PullRequest;\n\n/** Autogenerated input type of RegenerateEnterpriseIdentityProviderRecoveryCodes */\nexport type RegenerateEnterpriseIdentityProviderRecoveryCodesInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the enterprise on which to set an identity provider. */\n  enterpriseId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of RegenerateEnterpriseIdentityProviderRecoveryCodes */\nexport type RegenerateEnterpriseIdentityProviderRecoveryCodesPayload = {\n  __typename?: \"RegenerateEnterpriseIdentityProviderRecoveryCodesPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The identity provider for the enterprise. */\n  identityProvider?: Maybe<EnterpriseIdentityProvider>;\n};\n\n/** Autogenerated input type of RegenerateVerifiableDomainToken */\nexport type RegenerateVerifiableDomainTokenInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the verifiable domain to regenerate the verification token of. */\n  id: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of RegenerateVerifiableDomainToken */\nexport type RegenerateVerifiableDomainTokenPayload = {\n  __typename?: \"RegenerateVerifiableDomainTokenPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The verification token that was generated. */\n  verificationToken?: Maybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated input type of RejectDeployments */\nexport type RejectDeploymentsInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** Optional comment for rejecting deployments */\n  comment?: InputMaybe<Scalars[\"String\"]>;\n  /** The ids of environments to reject deployments */\n  environmentIds: Array<Scalars[\"ID\"]>;\n  /** The node ID of the workflow run containing the pending deployments. */\n  workflowRunId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of RejectDeployments */\nexport type RejectDeploymentsPayload = {\n  __typename?: \"RejectDeploymentsPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The affected deployments. */\n  deployments?: Maybe<Array<Deployment>>;\n};\n\n/** A release contains the content for a release. */\nexport type Release = Node &\n  Reactable &\n  UniformResourceLocatable & {\n    __typename?: \"Release\";\n    /** The author of the release */\n    author?: Maybe<User>;\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars[\"DateTime\"];\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars[\"Int\"]>;\n    /** The description of the release. */\n    description?: Maybe<Scalars[\"String\"]>;\n    /** The description of this release rendered to HTML. */\n    descriptionHTML?: Maybe<Scalars[\"HTML\"]>;\n    id: Scalars[\"ID\"];\n    /** Whether or not the release is a draft */\n    isDraft: Scalars[\"Boolean\"];\n    /** Whether or not the release is the latest releast */\n    isLatest: Scalars[\"Boolean\"];\n    /** Whether or not the release is a prerelease */\n    isPrerelease: Scalars[\"Boolean\"];\n    /** A list of users mentioned in the release description */\n    mentions?: Maybe<UserConnection>;\n    /** The title of the release. */\n    name?: Maybe<Scalars[\"String\"]>;\n    /** Identifies the date and time when the release was created. */\n    publishedAt?: Maybe<Scalars[\"DateTime\"]>;\n    /** A list of reactions grouped by content left on the subject. */\n    reactionGroups?: Maybe<Array<ReactionGroup>>;\n    /** A list of Reactions left on the Issue. */\n    reactions: ReactionConnection;\n    /** List of releases assets which are dependent on this release. */\n    releaseAssets: ReleaseAssetConnection;\n    /** The repository that the release belongs to. */\n    repository: Repository;\n    /** The HTTP path for this issue */\n    resourcePath: Scalars[\"URI\"];\n    /** A description of the release, rendered to HTML without any links in it. */\n    shortDescriptionHTML?: Maybe<Scalars[\"HTML\"]>;\n    /** The Git tag the release points to */\n    tag?: Maybe<Ref>;\n    /** The tag commit for this release. */\n    tagCommit?: Maybe<Commit>;\n    /** The name of the release's Git tag */\n    tagName: Scalars[\"String\"];\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars[\"DateTime\"];\n    /** The HTTP URL for this issue */\n    url: Scalars[\"URI\"];\n    /** Can user react to this subject */\n    viewerCanReact: Scalars[\"Boolean\"];\n  };\n\n/** A release contains the content for a release. */\nexport type ReleaseMentionsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A release contains the content for a release. */\nexport type ReleaseReactionsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  content?: InputMaybe<ReactionContent>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<ReactionOrder>;\n};\n\n/** A release contains the content for a release. */\nexport type ReleaseReleaseAssetsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  name?: InputMaybe<Scalars[\"String\"]>;\n};\n\n/** A release contains the content for a release. */\nexport type ReleaseShortDescriptionHtmlArgs = {\n  limit?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A release asset contains the content for a release asset. */\nexport type ReleaseAsset = Node & {\n  __typename?: \"ReleaseAsset\";\n  /** The asset's content-type */\n  contentType: Scalars[\"String\"];\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** The number of times this asset was downloaded */\n  downloadCount: Scalars[\"Int\"];\n  /** Identifies the URL where you can download the release asset via the browser. */\n  downloadUrl: Scalars[\"URI\"];\n  id: Scalars[\"ID\"];\n  /** Identifies the title of the release asset. */\n  name: Scalars[\"String\"];\n  /** Release that the asset is associated with */\n  release?: Maybe<Release>;\n  /** The size (in bytes) of the asset */\n  size: Scalars[\"Int\"];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars[\"DateTime\"];\n  /** The user that performed the upload */\n  uploadedBy: User;\n  /** Identifies the URL of the release asset. */\n  url: Scalars[\"URI\"];\n};\n\n/** The connection type for ReleaseAsset. */\nexport type ReleaseAssetConnection = {\n  __typename?: \"ReleaseAssetConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ReleaseAssetEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ReleaseAsset>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type ReleaseAssetEdge = {\n  __typename?: \"ReleaseAssetEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<ReleaseAsset>;\n};\n\n/** The connection type for Release. */\nexport type ReleaseConnection = {\n  __typename?: \"ReleaseConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ReleaseEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Release>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type ReleaseEdge = {\n  __typename?: \"ReleaseEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<Release>;\n};\n\n/** Ways in which lists of releases can be ordered upon return. */\nexport type ReleaseOrder = {\n  /** The direction in which to order releases by the specified field. */\n  direction: OrderDirection;\n  /** The field in which to order releases by. */\n  field: ReleaseOrderField;\n};\n\n/** Properties by which release connections can be ordered. */\nexport enum ReleaseOrderField {\n  /** Order releases by creation time */\n  CreatedAt = \"CREATED_AT\",\n  /** Order releases alphabetically by name */\n  Name = \"NAME\",\n}\n\n/** Autogenerated input type of RemoveAssigneesFromAssignable */\nexport type RemoveAssigneesFromAssignableInput = {\n  /** The id of the assignable object to remove assignees from. */\n  assignableId: Scalars[\"ID\"];\n  /** The id of users to remove as assignees. */\n  assigneeIds: Array<Scalars[\"ID\"]>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated return type of RemoveAssigneesFromAssignable */\nexport type RemoveAssigneesFromAssignablePayload = {\n  __typename?: \"RemoveAssigneesFromAssignablePayload\";\n  /** The item that was unassigned. */\n  assignable?: Maybe<Assignable>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated input type of RemoveEnterpriseAdmin */\nexport type RemoveEnterpriseAdminInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The Enterprise ID from which to remove the administrator. */\n  enterpriseId: Scalars[\"ID\"];\n  /** The login of the user to remove as an administrator. */\n  login: Scalars[\"String\"];\n};\n\n/** Autogenerated return type of RemoveEnterpriseAdmin */\nexport type RemoveEnterpriseAdminPayload = {\n  __typename?: \"RemoveEnterpriseAdminPayload\";\n  /** The user who was removed as an administrator. */\n  admin?: Maybe<User>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The updated enterprise. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of removing an administrator. */\n  message?: Maybe<Scalars[\"String\"]>;\n  /** The viewer performing the mutation. */\n  viewer?: Maybe<User>;\n};\n\n/** Autogenerated input type of RemoveEnterpriseIdentityProvider */\nexport type RemoveEnterpriseIdentityProviderInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the enterprise from which to remove the identity provider. */\n  enterpriseId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of RemoveEnterpriseIdentityProvider */\nexport type RemoveEnterpriseIdentityProviderPayload = {\n  __typename?: \"RemoveEnterpriseIdentityProviderPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The identity provider that was removed from the enterprise. */\n  identityProvider?: Maybe<EnterpriseIdentityProvider>;\n};\n\n/** Autogenerated input type of RemoveEnterpriseOrganization */\nexport type RemoveEnterpriseOrganizationInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the enterprise from which the organization should be removed. */\n  enterpriseId: Scalars[\"ID\"];\n  /** The ID of the organization to remove from the enterprise. */\n  organizationId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of RemoveEnterpriseOrganization */\nexport type RemoveEnterpriseOrganizationPayload = {\n  __typename?: \"RemoveEnterpriseOrganizationPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The updated enterprise. */\n  enterprise?: Maybe<Enterprise>;\n  /** The organization that was removed from the enterprise. */\n  organization?: Maybe<Organization>;\n  /** The viewer performing the mutation. */\n  viewer?: Maybe<User>;\n};\n\n/** Autogenerated input type of RemoveEnterpriseSupportEntitlement */\nexport type RemoveEnterpriseSupportEntitlementInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the Enterprise which the admin belongs to. */\n  enterpriseId: Scalars[\"ID\"];\n  /** The login of a member who will lose the support entitlement. */\n  login: Scalars[\"String\"];\n};\n\n/** Autogenerated return type of RemoveEnterpriseSupportEntitlement */\nexport type RemoveEnterpriseSupportEntitlementPayload = {\n  __typename?: \"RemoveEnterpriseSupportEntitlementPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** A message confirming the result of removing the support entitlement. */\n  message?: Maybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated input type of RemoveLabelsFromLabelable */\nexport type RemoveLabelsFromLabelableInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ids of labels to remove. */\n  labelIds: Array<Scalars[\"ID\"]>;\n  /** The id of the Labelable to remove labels from. */\n  labelableId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of RemoveLabelsFromLabelable */\nexport type RemoveLabelsFromLabelablePayload = {\n  __typename?: \"RemoveLabelsFromLabelablePayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The Labelable the labels were removed from. */\n  labelable?: Maybe<Labelable>;\n};\n\n/** Autogenerated input type of RemoveOutsideCollaborator */\nexport type RemoveOutsideCollaboratorInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the organization to remove the outside collaborator from. */\n  organizationId: Scalars[\"ID\"];\n  /** The ID of the outside collaborator to remove. */\n  userId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of RemoveOutsideCollaborator */\nexport type RemoveOutsideCollaboratorPayload = {\n  __typename?: \"RemoveOutsideCollaboratorPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The user that was removed as an outside collaborator. */\n  removedUser?: Maybe<User>;\n};\n\n/** Autogenerated input type of RemoveReaction */\nexport type RemoveReactionInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The name of the emoji reaction to remove. */\n  content: ReactionContent;\n  /** The Node ID of the subject to modify. */\n  subjectId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of RemoveReaction */\nexport type RemoveReactionPayload = {\n  __typename?: \"RemoveReactionPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The reaction object. */\n  reaction?: Maybe<Reaction>;\n  /** The reactable subject. */\n  subject?: Maybe<Reactable>;\n};\n\n/** Autogenerated input type of RemoveStar */\nexport type RemoveStarInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The Starrable ID to unstar. */\n  starrableId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of RemoveStar */\nexport type RemoveStarPayload = {\n  __typename?: \"RemoveStarPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The starrable. */\n  starrable?: Maybe<Starrable>;\n};\n\n/** Autogenerated input type of RemoveUpvote */\nexport type RemoveUpvoteInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The Node ID of the discussion or comment to remove upvote. */\n  subjectId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of RemoveUpvote */\nexport type RemoveUpvotePayload = {\n  __typename?: \"RemoveUpvotePayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The votable subject. */\n  subject?: Maybe<Votable>;\n};\n\n/** Represents a 'removed_from_project' event on a given issue or pull request. */\nexport type RemovedFromProjectEvent = Node & {\n  __typename?: \"RemovedFromProjectEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars[\"Int\"]>;\n  id: Scalars[\"ID\"];\n  /** Project referenced by event. */\n  project?: Maybe<Project>;\n  /** Column name referenced by this project event. */\n  projectColumnName: Scalars[\"String\"];\n};\n\n/** Represents a 'renamed' event on a given issue or pull request */\nexport type RenamedTitleEvent = Node & {\n  __typename?: \"RenamedTitleEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** Identifies the current title of the issue or pull request. */\n  currentTitle: Scalars[\"String\"];\n  id: Scalars[\"ID\"];\n  /** Identifies the previous title of the issue or pull request. */\n  previousTitle: Scalars[\"String\"];\n  /** Subject that was renamed. */\n  subject: RenamedTitleSubject;\n};\n\n/** An object which has a renamable title */\nexport type RenamedTitleSubject = Issue | PullRequest;\n\n/** Autogenerated input type of ReopenIssue */\nexport type ReopenIssueInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** ID of the issue to be opened. */\n  issueId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of ReopenIssue */\nexport type ReopenIssuePayload = {\n  __typename?: \"ReopenIssuePayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The issue that was opened. */\n  issue?: Maybe<Issue>;\n};\n\n/** Autogenerated input type of ReopenPullRequest */\nexport type ReopenPullRequestInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** ID of the pull request to be reopened. */\n  pullRequestId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of ReopenPullRequest */\nexport type ReopenPullRequestPayload = {\n  __typename?: \"ReopenPullRequestPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The pull request that was reopened. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Represents a 'reopened' event on any `Closable`. */\nexport type ReopenedEvent = Node & {\n  __typename?: \"ReopenedEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Object that was reopened. */\n  closable: Closable;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  id: Scalars[\"ID\"];\n};\n\n/** Audit log entry for a repo.access event. */\nexport type RepoAccessAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData & {\n    __typename?: \"RepoAccessAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>;\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The visibility of the repository */\n    visibility?: Maybe<RepoAccessAuditEntryVisibility>;\n  };\n\n/** The privacy of a repository */\nexport enum RepoAccessAuditEntryVisibility {\n  /** The repository is visible only to users in the same business. */\n  Internal = \"INTERNAL\",\n  /** The repository is visible only to those with explicit access. */\n  Private = \"PRIVATE\",\n  /** The repository is visible to everyone. */\n  Public = \"PUBLIC\",\n}\n\n/** Audit log entry for a repo.add_member event. */\nexport type RepoAddMemberAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData & {\n    __typename?: \"RepoAddMemberAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>;\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The visibility of the repository */\n    visibility?: Maybe<RepoAddMemberAuditEntryVisibility>;\n  };\n\n/** The privacy of a repository */\nexport enum RepoAddMemberAuditEntryVisibility {\n  /** The repository is visible only to users in the same business. */\n  Internal = \"INTERNAL\",\n  /** The repository is visible only to those with explicit access. */\n  Private = \"PRIVATE\",\n  /** The repository is visible to everyone. */\n  Public = \"PUBLIC\",\n}\n\n/** Audit log entry for a repo.add_topic event. */\nexport type RepoAddTopicAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData &\n  TopicAuditEntryData & {\n    __typename?: \"RepoAddTopicAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>;\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The name of the topic added to the repository */\n    topic?: Maybe<Topic>;\n    /** The name of the topic added to the repository */\n    topicName?: Maybe<Scalars[\"String\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** Audit log entry for a repo.archived event. */\nexport type RepoArchivedAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData & {\n    __typename?: \"RepoArchivedAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>;\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The visibility of the repository */\n    visibility?: Maybe<RepoArchivedAuditEntryVisibility>;\n  };\n\n/** The privacy of a repository */\nexport enum RepoArchivedAuditEntryVisibility {\n  /** The repository is visible only to users in the same business. */\n  Internal = \"INTERNAL\",\n  /** The repository is visible only to those with explicit access. */\n  Private = \"PRIVATE\",\n  /** The repository is visible to everyone. */\n  Public = \"PUBLIC\",\n}\n\n/** Audit log entry for a repo.change_merge_setting event. */\nexport type RepoChangeMergeSettingAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData & {\n    __typename?: \"RepoChangeMergeSettingAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** Whether the change was to enable (true) or disable (false) the merge type */\n    isEnabled?: Maybe<Scalars[\"Boolean\"]>;\n    /** The merge method affected by the change */\n    mergeType?: Maybe<RepoChangeMergeSettingAuditEntryMergeType>;\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>;\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** The merge options available for pull requests to this repository. */\nexport enum RepoChangeMergeSettingAuditEntryMergeType {\n  /** The pull request is added to the base branch in a merge commit. */\n  Merge = \"MERGE\",\n  /** Commits from the pull request are added onto the base branch individually without a merge commit. */\n  Rebase = \"REBASE\",\n  /** The pull request's commits are squashed into a single commit before they are merged to the base branch. */\n  Squash = \"SQUASH\",\n}\n\n/** Audit log entry for a repo.config.disable_anonymous_git_access event. */\nexport type RepoConfigDisableAnonymousGitAccessAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData & {\n    __typename?: \"RepoConfigDisableAnonymousGitAccessAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>;\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** Audit log entry for a repo.config.disable_collaborators_only event. */\nexport type RepoConfigDisableCollaboratorsOnlyAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData & {\n    __typename?: \"RepoConfigDisableCollaboratorsOnlyAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>;\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** Audit log entry for a repo.config.disable_contributors_only event. */\nexport type RepoConfigDisableContributorsOnlyAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData & {\n    __typename?: \"RepoConfigDisableContributorsOnlyAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>;\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** Audit log entry for a repo.config.disable_sockpuppet_disallowed event. */\nexport type RepoConfigDisableSockpuppetDisallowedAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData & {\n    __typename?: \"RepoConfigDisableSockpuppetDisallowedAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>;\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** Audit log entry for a repo.config.enable_anonymous_git_access event. */\nexport type RepoConfigEnableAnonymousGitAccessAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData & {\n    __typename?: \"RepoConfigEnableAnonymousGitAccessAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>;\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** Audit log entry for a repo.config.enable_collaborators_only event. */\nexport type RepoConfigEnableCollaboratorsOnlyAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData & {\n    __typename?: \"RepoConfigEnableCollaboratorsOnlyAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>;\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** Audit log entry for a repo.config.enable_contributors_only event. */\nexport type RepoConfigEnableContributorsOnlyAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData & {\n    __typename?: \"RepoConfigEnableContributorsOnlyAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>;\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** Audit log entry for a repo.config.enable_sockpuppet_disallowed event. */\nexport type RepoConfigEnableSockpuppetDisallowedAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData & {\n    __typename?: \"RepoConfigEnableSockpuppetDisallowedAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>;\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** Audit log entry for a repo.config.lock_anonymous_git_access event. */\nexport type RepoConfigLockAnonymousGitAccessAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData & {\n    __typename?: \"RepoConfigLockAnonymousGitAccessAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>;\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** Audit log entry for a repo.config.unlock_anonymous_git_access event. */\nexport type RepoConfigUnlockAnonymousGitAccessAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData & {\n    __typename?: \"RepoConfigUnlockAnonymousGitAccessAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>;\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** Audit log entry for a repo.create event. */\nexport type RepoCreateAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData & {\n    __typename?: \"RepoCreateAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    /** The name of the parent repository for this forked repository. */\n    forkParentName?: Maybe<Scalars[\"String\"]>;\n    /** The name of the root repository for this network. */\n    forkSourceName?: Maybe<Scalars[\"String\"]>;\n    id: Scalars[\"ID\"];\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>;\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The visibility of the repository */\n    visibility?: Maybe<RepoCreateAuditEntryVisibility>;\n  };\n\n/** The privacy of a repository */\nexport enum RepoCreateAuditEntryVisibility {\n  /** The repository is visible only to users in the same business. */\n  Internal = \"INTERNAL\",\n  /** The repository is visible only to those with explicit access. */\n  Private = \"PRIVATE\",\n  /** The repository is visible to everyone. */\n  Public = \"PUBLIC\",\n}\n\n/** Audit log entry for a repo.destroy event. */\nexport type RepoDestroyAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData & {\n    __typename?: \"RepoDestroyAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>;\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The visibility of the repository */\n    visibility?: Maybe<RepoDestroyAuditEntryVisibility>;\n  };\n\n/** The privacy of a repository */\nexport enum RepoDestroyAuditEntryVisibility {\n  /** The repository is visible only to users in the same business. */\n  Internal = \"INTERNAL\",\n  /** The repository is visible only to those with explicit access. */\n  Private = \"PRIVATE\",\n  /** The repository is visible to everyone. */\n  Public = \"PUBLIC\",\n}\n\n/** Audit log entry for a repo.remove_member event. */\nexport type RepoRemoveMemberAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData & {\n    __typename?: \"RepoRemoveMemberAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>;\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The visibility of the repository */\n    visibility?: Maybe<RepoRemoveMemberAuditEntryVisibility>;\n  };\n\n/** The privacy of a repository */\nexport enum RepoRemoveMemberAuditEntryVisibility {\n  /** The repository is visible only to users in the same business. */\n  Internal = \"INTERNAL\",\n  /** The repository is visible only to those with explicit access. */\n  Private = \"PRIVATE\",\n  /** The repository is visible to everyone. */\n  Public = \"PUBLIC\",\n}\n\n/** Audit log entry for a repo.remove_topic event. */\nexport type RepoRemoveTopicAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData &\n  TopicAuditEntryData & {\n    __typename?: \"RepoRemoveTopicAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>;\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The name of the topic added to the repository */\n    topic?: Maybe<Topic>;\n    /** The name of the topic added to the repository */\n    topicName?: Maybe<Scalars[\"String\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** The reasons a piece of content can be reported or minimized. */\nexport enum ReportedContentClassifiers {\n  /** An abusive or harassing piece of content */\n  Abuse = \"ABUSE\",\n  /** A duplicated piece of content */\n  Duplicate = \"DUPLICATE\",\n  /** An irrelevant piece of content */\n  OffTopic = \"OFF_TOPIC\",\n  /** An outdated piece of content */\n  Outdated = \"OUTDATED\",\n  /** The content has been resolved */\n  Resolved = \"RESOLVED\",\n  /** A spammy piece of content */\n  Spam = \"SPAM\",\n}\n\n/** A repository contains the content for a project. */\nexport type Repository = Node &\n  PackageOwner &\n  ProjectOwner &\n  RepositoryInfo &\n  Starrable &\n  Subscribable &\n  UniformResourceLocatable & {\n    __typename?: \"Repository\";\n    /** A list of users that can be assigned to issues in this repository. */\n    assignableUsers: UserConnection;\n    /** Whether or not Auto-merge can be enabled on pull requests in this repository. */\n    autoMergeAllowed: Scalars[\"Boolean\"];\n    /** A list of branch protection rules for this repository. */\n    branchProtectionRules: BranchProtectionRuleConnection;\n    /** Returns the code of conduct for this repository */\n    codeOfConduct?: Maybe<CodeOfConduct>;\n    /** Information extracted from the repository's `CODEOWNERS` file. */\n    codeowners?: Maybe<RepositoryCodeowners>;\n    /** A list of collaborators associated with the repository. */\n    collaborators?: Maybe<RepositoryCollaboratorConnection>;\n    /** A list of commit comments associated with the repository. */\n    commitComments: CommitCommentConnection;\n    /** Returns a list of contact links associated to the repository */\n    contactLinks?: Maybe<Array<RepositoryContactLink>>;\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars[\"DateTime\"];\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars[\"Int\"]>;\n    /** The Ref associated with the repository's default branch. */\n    defaultBranchRef?: Maybe<Ref>;\n    /** Whether or not branches are automatically deleted when merged in this repository. */\n    deleteBranchOnMerge: Scalars[\"Boolean\"];\n    /** A list of dependency manifests contained in the repository */\n    dependencyGraphManifests?: Maybe<DependencyGraphManifestConnection>;\n    /** A list of deploy keys that are on this repository. */\n    deployKeys: DeployKeyConnection;\n    /** Deployments associated with the repository */\n    deployments: DeploymentConnection;\n    /** The description of the repository. */\n    description?: Maybe<Scalars[\"String\"]>;\n    /** The description of the repository rendered to HTML. */\n    descriptionHTML: Scalars[\"HTML\"];\n    /** Returns a single discussion from the current repository by number. */\n    discussion?: Maybe<Discussion>;\n    /** A list of discussion categories that are available in the repository. */\n    discussionCategories: DiscussionCategoryConnection;\n    /** A list of discussions that have been opened in the repository. */\n    discussions: DiscussionConnection;\n    /** The number of kilobytes this repository occupies on disk. */\n    diskUsage?: Maybe<Scalars[\"Int\"]>;\n    /** Returns a single active environment from the current repository by name. */\n    environment?: Maybe<Environment>;\n    /** A list of environments that are in this repository. */\n    environments: EnvironmentConnection;\n    /** Returns how many forks there are of this repository in the whole network. */\n    forkCount: Scalars[\"Int\"];\n    /** Whether this repository allows forks. */\n    forkingAllowed: Scalars[\"Boolean\"];\n    /** A list of direct forked repositories. */\n    forks: RepositoryConnection;\n    /** The funding links for this repository */\n    fundingLinks: Array<FundingLink>;\n    /** Indicates if the repository has issues feature enabled. */\n    hasIssuesEnabled: Scalars[\"Boolean\"];\n    /** Indicates if the repository has the Projects feature enabled. */\n    hasProjectsEnabled: Scalars[\"Boolean\"];\n    /** Indicates if the repository has wiki feature enabled. */\n    hasWikiEnabled: Scalars[\"Boolean\"];\n    /** The repository's URL. */\n    homepageUrl?: Maybe<Scalars[\"URI\"]>;\n    id: Scalars[\"ID\"];\n    /** The interaction ability settings for this repository. */\n    interactionAbility?: Maybe<RepositoryInteractionAbility>;\n    /** Indicates if the repository is unmaintained. */\n    isArchived: Scalars[\"Boolean\"];\n    /** Returns true if blank issue creation is allowed */\n    isBlankIssuesEnabled: Scalars[\"Boolean\"];\n    /** Returns whether or not this repository disabled. */\n    isDisabled: Scalars[\"Boolean\"];\n    /** Returns whether or not this repository is empty. */\n    isEmpty: Scalars[\"Boolean\"];\n    /** Identifies if the repository is a fork. */\n    isFork: Scalars[\"Boolean\"];\n    /** Indicates if a repository is either owned by an organization, or is a private fork of an organization repository. */\n    isInOrganization: Scalars[\"Boolean\"];\n    /** Indicates if the repository has been locked or not. */\n    isLocked: Scalars[\"Boolean\"];\n    /** Identifies if the repository is a mirror. */\n    isMirror: Scalars[\"Boolean\"];\n    /** Identifies if the repository is private or internal. */\n    isPrivate: Scalars[\"Boolean\"];\n    /** Returns true if this repository has a security policy */\n    isSecurityPolicyEnabled?: Maybe<Scalars[\"Boolean\"]>;\n    /** Identifies if the repository is a template that can be used to generate new repositories. */\n    isTemplate: Scalars[\"Boolean\"];\n    /** Is this repository a user configuration repository? */\n    isUserConfigurationRepository: Scalars[\"Boolean\"];\n    /** Returns a single issue from the current repository by number. */\n    issue?: Maybe<Issue>;\n    /** Returns a single issue-like object from the current repository by number. */\n    issueOrPullRequest?: Maybe<IssueOrPullRequest>;\n    /** Returns a list of issue templates associated to the repository */\n    issueTemplates?: Maybe<Array<IssueTemplate>>;\n    /** A list of issues that have been opened in the repository. */\n    issues: IssueConnection;\n    /** Returns a single label by name */\n    label?: Maybe<Label>;\n    /** A list of labels associated with the repository. */\n    labels?: Maybe<LabelConnection>;\n    /** A list containing a breakdown of the language composition of the repository. */\n    languages?: Maybe<LanguageConnection>;\n    /** Get the latest release for the repository if one exists. */\n    latestRelease?: Maybe<Release>;\n    /** The license associated with the repository */\n    licenseInfo?: Maybe<License>;\n    /** The reason the repository has been locked. */\n    lockReason?: Maybe<RepositoryLockReason>;\n    /** A list of Users that can be mentioned in the context of the repository. */\n    mentionableUsers: UserConnection;\n    /** Whether or not PRs are merged with a merge commit on this repository. */\n    mergeCommitAllowed: Scalars[\"Boolean\"];\n    /** Returns a single milestone from the current repository by number. */\n    milestone?: Maybe<Milestone>;\n    /** A list of milestones associated with the repository. */\n    milestones?: Maybe<MilestoneConnection>;\n    /** The repository's original mirror URL. */\n    mirrorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The name of the repository. */\n    name: Scalars[\"String\"];\n    /** The repository's name with owner. */\n    nameWithOwner: Scalars[\"String\"];\n    /** A Git object in the repository */\n    object?: Maybe<GitObject>;\n    /** The image used to represent this repository in Open Graph data. */\n    openGraphImageUrl: Scalars[\"URI\"];\n    /** The User owner of the repository. */\n    owner: RepositoryOwner;\n    /** A list of packages under the owner. */\n    packages: PackageConnection;\n    /** The repository parent, if this is a fork. */\n    parent?: Maybe<Repository>;\n    /** A list of discussions that have been pinned in this repository. */\n    pinnedDiscussions: PinnedDiscussionConnection;\n    /** A list of pinned issues for this repository. */\n    pinnedIssues?: Maybe<PinnedIssueConnection>;\n    /** The primary language of the repository's code. */\n    primaryLanguage?: Maybe<Language>;\n    /** Find project by number. */\n    project?: Maybe<Project>;\n    /** Finds and returns the Project (beta) according to the provided Project (beta) number. */\n    projectNext?: Maybe<ProjectNext>;\n    /** A list of projects under the owner. */\n    projects: ProjectConnection;\n    /** List of projects (beta) linked to this repository. */\n    projectsNext: ProjectNextConnection;\n    /** The HTTP path listing the repository's projects */\n    projectsResourcePath: Scalars[\"URI\"];\n    /** The HTTP URL listing the repository's projects */\n    projectsUrl: Scalars[\"URI\"];\n    /** Returns a single pull request from the current repository by number. */\n    pullRequest?: Maybe<PullRequest>;\n    /** Returns a list of pull request templates associated to the repository */\n    pullRequestTemplates?: Maybe<Array<PullRequestTemplate>>;\n    /** A list of pull requests that have been opened in the repository. */\n    pullRequests: PullRequestConnection;\n    /** Identifies when the repository was last pushed to. */\n    pushedAt?: Maybe<Scalars[\"DateTime\"]>;\n    /** Whether or not rebase-merging is enabled on this repository. */\n    rebaseMergeAllowed: Scalars[\"Boolean\"];\n    /** Fetch a given ref from the repository */\n    ref?: Maybe<Ref>;\n    /** Fetch a list of refs from the repository */\n    refs?: Maybe<RefConnection>;\n    /** Lookup a single release given various criteria. */\n    release?: Maybe<Release>;\n    /** List of releases which are dependent on this repository. */\n    releases: ReleaseConnection;\n    /** A list of applied repository-topic associations for this repository. */\n    repositoryTopics: RepositoryTopicConnection;\n    /** The HTTP path for this repository */\n    resourcePath: Scalars[\"URI\"];\n    /** The security policy URL. */\n    securityPolicyUrl?: Maybe<Scalars[\"URI\"]>;\n    /** A description of the repository, rendered to HTML without any links in it. */\n    shortDescriptionHTML: Scalars[\"HTML\"];\n    /** Whether or not squash-merging is enabled on this repository. */\n    squashMergeAllowed: Scalars[\"Boolean\"];\n    /** The SSH URL to clone this repository */\n    sshUrl: Scalars[\"GitSSHRemote\"];\n    /** Returns a count of how many stargazers there are on this object */\n    stargazerCount: Scalars[\"Int\"];\n    /** A list of users who have starred this starrable. */\n    stargazers: StargazerConnection;\n    /**\n     * Returns a list of all submodules in this repository parsed from the\n     * .gitmodules file as of the default branch's HEAD commit.\n     */\n    submodules: SubmoduleConnection;\n    /** Temporary authentication token for cloning this repository. */\n    tempCloneToken?: Maybe<Scalars[\"String\"]>;\n    /** The repository from which this repository was generated, if any. */\n    templateRepository?: Maybe<Repository>;\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars[\"DateTime\"];\n    /** The HTTP URL for this repository */\n    url: Scalars[\"URI\"];\n    /** Whether this repository has a custom image to use with Open Graph as opposed to being represented by the owner's avatar. */\n    usesCustomOpenGraphImage: Scalars[\"Boolean\"];\n    /** Indicates whether the viewer has admin permissions on this repository. */\n    viewerCanAdminister: Scalars[\"Boolean\"];\n    /** Can the current viewer create new projects on this owner. */\n    viewerCanCreateProjects: Scalars[\"Boolean\"];\n    /** Check if the viewer is able to change their subscription status for the repository. */\n    viewerCanSubscribe: Scalars[\"Boolean\"];\n    /** Indicates whether the viewer can update the topics of this repository. */\n    viewerCanUpdateTopics: Scalars[\"Boolean\"];\n    /** The last commit email for the viewer. */\n    viewerDefaultCommitEmail?: Maybe<Scalars[\"String\"]>;\n    /** The last used merge method by the viewer or the default for the repository. */\n    viewerDefaultMergeMethod: PullRequestMergeMethod;\n    /** Returns a boolean indicating whether the viewing user has starred this starrable. */\n    viewerHasStarred: Scalars[\"Boolean\"];\n    /** The users permission level on the repository. Will return null if authenticated as an GitHub App. */\n    viewerPermission?: Maybe<RepositoryPermission>;\n    /** A list of emails this viewer can commit with. */\n    viewerPossibleCommitEmails?: Maybe<Array<Scalars[\"String\"]>>;\n    /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */\n    viewerSubscription?: Maybe<SubscriptionState>;\n    /** Indicates the repository's visibility level. */\n    visibility: RepositoryVisibility;\n    /** A list of vulnerability alerts that are on this repository. */\n    vulnerabilityAlerts?: Maybe<RepositoryVulnerabilityAlertConnection>;\n    /** A list of users watching the repository. */\n    watchers: UserConnection;\n  };\n\n/** A repository contains the content for a project. */\nexport type RepositoryAssignableUsersArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  query?: InputMaybe<Scalars[\"String\"]>;\n};\n\n/** A repository contains the content for a project. */\nexport type RepositoryBranchProtectionRulesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A repository contains the content for a project. */\nexport type RepositoryCodeownersArgs = {\n  refName?: InputMaybe<Scalars[\"String\"]>;\n};\n\n/** A repository contains the content for a project. */\nexport type RepositoryCollaboratorsArgs = {\n  affiliation?: InputMaybe<CollaboratorAffiliation>;\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  query?: InputMaybe<Scalars[\"String\"]>;\n};\n\n/** A repository contains the content for a project. */\nexport type RepositoryCommitCommentsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A repository contains the content for a project. */\nexport type RepositoryDependencyGraphManifestsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  dependenciesAfter?: InputMaybe<Scalars[\"String\"]>;\n  dependenciesFirst?: InputMaybe<Scalars[\"Int\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  withDependencies?: InputMaybe<Scalars[\"Boolean\"]>;\n};\n\n/** A repository contains the content for a project. */\nexport type RepositoryDeployKeysArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A repository contains the content for a project. */\nexport type RepositoryDeploymentsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  environments?: InputMaybe<Array<Scalars[\"String\"]>>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<DeploymentOrder>;\n};\n\n/** A repository contains the content for a project. */\nexport type RepositoryDiscussionArgs = {\n  number: Scalars[\"Int\"];\n};\n\n/** A repository contains the content for a project. */\nexport type RepositoryDiscussionCategoriesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  filterByAssignable?: InputMaybe<Scalars[\"Boolean\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A repository contains the content for a project. */\nexport type RepositoryDiscussionsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  categoryId?: InputMaybe<Scalars[\"ID\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<DiscussionOrder>;\n};\n\n/** A repository contains the content for a project. */\nexport type RepositoryEnvironmentArgs = {\n  name: Scalars[\"String\"];\n};\n\n/** A repository contains the content for a project. */\nexport type RepositoryEnvironmentsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A repository contains the content for a project. */\nexport type RepositoryForksArgs = {\n  affiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  isLocked?: InputMaybe<Scalars[\"Boolean\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<RepositoryOrder>;\n  ownerAffiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;\n  privacy?: InputMaybe<RepositoryPrivacy>;\n};\n\n/** A repository contains the content for a project. */\nexport type RepositoryIssueArgs = {\n  number: Scalars[\"Int\"];\n};\n\n/** A repository contains the content for a project. */\nexport type RepositoryIssueOrPullRequestArgs = {\n  number: Scalars[\"Int\"];\n};\n\n/** A repository contains the content for a project. */\nexport type RepositoryIssuesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  filterBy?: InputMaybe<IssueFilters>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  labels?: InputMaybe<Array<Scalars[\"String\"]>>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<IssueOrder>;\n  states?: InputMaybe<Array<IssueState>>;\n};\n\n/** A repository contains the content for a project. */\nexport type RepositoryLabelArgs = {\n  name: Scalars[\"String\"];\n};\n\n/** A repository contains the content for a project. */\nexport type RepositoryLabelsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<LabelOrder>;\n  query?: InputMaybe<Scalars[\"String\"]>;\n};\n\n/** A repository contains the content for a project. */\nexport type RepositoryLanguagesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<LanguageOrder>;\n};\n\n/** A repository contains the content for a project. */\nexport type RepositoryMentionableUsersArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  query?: InputMaybe<Scalars[\"String\"]>;\n};\n\n/** A repository contains the content for a project. */\nexport type RepositoryMilestoneArgs = {\n  number: Scalars[\"Int\"];\n};\n\n/** A repository contains the content for a project. */\nexport type RepositoryMilestonesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<MilestoneOrder>;\n  query?: InputMaybe<Scalars[\"String\"]>;\n  states?: InputMaybe<Array<MilestoneState>>;\n};\n\n/** A repository contains the content for a project. */\nexport type RepositoryObjectArgs = {\n  expression?: InputMaybe<Scalars[\"String\"]>;\n  oid?: InputMaybe<Scalars[\"GitObjectID\"]>;\n};\n\n/** A repository contains the content for a project. */\nexport type RepositoryPackagesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  names?: InputMaybe<Array<InputMaybe<Scalars[\"String\"]>>>;\n  orderBy?: InputMaybe<PackageOrder>;\n  packageType?: InputMaybe<PackageType>;\n  repositoryId?: InputMaybe<Scalars[\"ID\"]>;\n};\n\n/** A repository contains the content for a project. */\nexport type RepositoryPinnedDiscussionsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A repository contains the content for a project. */\nexport type RepositoryPinnedIssuesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A repository contains the content for a project. */\nexport type RepositoryProjectArgs = {\n  number: Scalars[\"Int\"];\n};\n\n/** A repository contains the content for a project. */\nexport type RepositoryProjectNextArgs = {\n  number: Scalars[\"Int\"];\n};\n\n/** A repository contains the content for a project. */\nexport type RepositoryProjectsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<ProjectOrder>;\n  search?: InputMaybe<Scalars[\"String\"]>;\n  states?: InputMaybe<Array<ProjectState>>;\n};\n\n/** A repository contains the content for a project. */\nexport type RepositoryProjectsNextArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  query?: InputMaybe<Scalars[\"String\"]>;\n  sortBy?: InputMaybe<ProjectNextOrderField>;\n};\n\n/** A repository contains the content for a project. */\nexport type RepositoryPullRequestArgs = {\n  number: Scalars[\"Int\"];\n};\n\n/** A repository contains the content for a project. */\nexport type RepositoryPullRequestsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  baseRefName?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  headRefName?: InputMaybe<Scalars[\"String\"]>;\n  labels?: InputMaybe<Array<Scalars[\"String\"]>>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<IssueOrder>;\n  states?: InputMaybe<Array<PullRequestState>>;\n};\n\n/** A repository contains the content for a project. */\nexport type RepositoryRefArgs = {\n  qualifiedName: Scalars[\"String\"];\n};\n\n/** A repository contains the content for a project. */\nexport type RepositoryRefsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  direction?: InputMaybe<OrderDirection>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<RefOrder>;\n  query?: InputMaybe<Scalars[\"String\"]>;\n  refPrefix: Scalars[\"String\"];\n};\n\n/** A repository contains the content for a project. */\nexport type RepositoryReleaseArgs = {\n  tagName: Scalars[\"String\"];\n};\n\n/** A repository contains the content for a project. */\nexport type RepositoryReleasesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<ReleaseOrder>;\n};\n\n/** A repository contains the content for a project. */\nexport type RepositoryRepositoryTopicsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A repository contains the content for a project. */\nexport type RepositoryShortDescriptionHtmlArgs = {\n  limit?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A repository contains the content for a project. */\nexport type RepositoryStargazersArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<StarOrder>;\n};\n\n/** A repository contains the content for a project. */\nexport type RepositorySubmodulesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A repository contains the content for a project. */\nexport type RepositoryVulnerabilityAlertsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  states?: InputMaybe<Array<RepositoryVulnerabilityAlertState>>;\n};\n\n/** A repository contains the content for a project. */\nexport type RepositoryWatchersArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** The affiliation of a user to a repository */\nexport enum RepositoryAffiliation {\n  /** Repositories that the user has been added to as a collaborator. */\n  Collaborator = \"COLLABORATOR\",\n  /**\n   * Repositories that the user has access to through being a member of an\n   * organization. This includes every repository on every team that the user is on.\n   */\n  OrganizationMember = \"ORGANIZATION_MEMBER\",\n  /** Repositories that are owned by the authenticated user. */\n  Owner = \"OWNER\",\n}\n\n/** Metadata for an audit entry with action repo.* */\nexport type RepositoryAuditEntryData = {\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars[\"String\"]>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars[\"URI\"]>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars[\"URI\"]>;\n};\n\n/** Information extracted from a repository's `CODEOWNERS` file. */\nexport type RepositoryCodeowners = {\n  __typename?: \"RepositoryCodeowners\";\n  /** Any problems that were encountered while parsing the `CODEOWNERS` file. */\n  errors: Array<RepositoryCodeownersError>;\n};\n\n/** An error in a `CODEOWNERS` file. */\nexport type RepositoryCodeownersError = {\n  __typename?: \"RepositoryCodeownersError\";\n  /** The column number where the error occurs. */\n  column: Scalars[\"Int\"];\n  /** A short string describing the type of error. */\n  kind: Scalars[\"String\"];\n  /** The line number where the error occurs. */\n  line: Scalars[\"Int\"];\n  /** A complete description of the error, combining information from other fields. */\n  message: Scalars[\"String\"];\n  /** The path to the file when the error occurs. */\n  path: Scalars[\"String\"];\n  /** The content of the line where the error occurs. */\n  source: Scalars[\"String\"];\n  /** A suggestion of how to fix the error. */\n  suggestion?: Maybe<Scalars[\"String\"]>;\n};\n\n/** The connection type for User. */\nexport type RepositoryCollaboratorConnection = {\n  __typename?: \"RepositoryCollaboratorConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<RepositoryCollaboratorEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** Represents a user who is a collaborator of a repository. */\nexport type RepositoryCollaboratorEdge = {\n  __typename?: \"RepositoryCollaboratorEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  node: User;\n  /** The permission the user has on the repository. */\n  permission: RepositoryPermission;\n  /** A list of sources for the user's access to the repository. */\n  permissionSources?: Maybe<Array<PermissionSource>>;\n};\n\n/** A list of repositories owned by the subject. */\nexport type RepositoryConnection = {\n  __typename?: \"RepositoryConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<RepositoryEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Repository>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n  /** The total size in kilobytes of all repositories in the connection. */\n  totalDiskUsage: Scalars[\"Int\"];\n};\n\n/** A repository contact link. */\nexport type RepositoryContactLink = {\n  __typename?: \"RepositoryContactLink\";\n  /** The contact link purpose. */\n  about: Scalars[\"String\"];\n  /** The contact link name. */\n  name: Scalars[\"String\"];\n  /** The contact link URL. */\n  url: Scalars[\"URI\"];\n};\n\n/** The reason a repository is listed as 'contributed'. */\nexport enum RepositoryContributionType {\n  /** Created a commit */\n  Commit = \"COMMIT\",\n  /** Created an issue */\n  Issue = \"ISSUE\",\n  /** Created a pull request */\n  PullRequest = \"PULL_REQUEST\",\n  /** Reviewed a pull request */\n  PullRequestReview = \"PULL_REQUEST_REVIEW\",\n  /** Created the repository */\n  Repository = \"REPOSITORY\",\n}\n\n/** Represents an author of discussions in repositories. */\nexport type RepositoryDiscussionAuthor = {\n  /** Discussions this user has started. */\n  repositoryDiscussions: DiscussionConnection;\n};\n\n/** Represents an author of discussions in repositories. */\nexport type RepositoryDiscussionAuthorRepositoryDiscussionsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  answered?: InputMaybe<Scalars[\"Boolean\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<DiscussionOrder>;\n  repositoryId?: InputMaybe<Scalars[\"ID\"]>;\n};\n\n/** Represents an author of discussion comments in repositories. */\nexport type RepositoryDiscussionCommentAuthor = {\n  /** Discussion comments this user has authored. */\n  repositoryDiscussionComments: DiscussionCommentConnection;\n};\n\n/** Represents an author of discussion comments in repositories. */\nexport type RepositoryDiscussionCommentAuthorRepositoryDiscussionCommentsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  onlyAnswers?: InputMaybe<Scalars[\"Boolean\"]>;\n  repositoryId?: InputMaybe<Scalars[\"ID\"]>;\n};\n\n/** An edge in a connection. */\nexport type RepositoryEdge = {\n  __typename?: \"RepositoryEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<Repository>;\n};\n\n/** A subset of repository info. */\nexport type RepositoryInfo = {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** The description of the repository. */\n  description?: Maybe<Scalars[\"String\"]>;\n  /** The description of the repository rendered to HTML. */\n  descriptionHTML: Scalars[\"HTML\"];\n  /** Returns how many forks there are of this repository in the whole network. */\n  forkCount: Scalars[\"Int\"];\n  /** Indicates if the repository has issues feature enabled. */\n  hasIssuesEnabled: Scalars[\"Boolean\"];\n  /** Indicates if the repository has the Projects feature enabled. */\n  hasProjectsEnabled: Scalars[\"Boolean\"];\n  /** Indicates if the repository has wiki feature enabled. */\n  hasWikiEnabled: Scalars[\"Boolean\"];\n  /** The repository's URL. */\n  homepageUrl?: Maybe<Scalars[\"URI\"]>;\n  /** Indicates if the repository is unmaintained. */\n  isArchived: Scalars[\"Boolean\"];\n  /** Identifies if the repository is a fork. */\n  isFork: Scalars[\"Boolean\"];\n  /** Indicates if a repository is either owned by an organization, or is a private fork of an organization repository. */\n  isInOrganization: Scalars[\"Boolean\"];\n  /** Indicates if the repository has been locked or not. */\n  isLocked: Scalars[\"Boolean\"];\n  /** Identifies if the repository is a mirror. */\n  isMirror: Scalars[\"Boolean\"];\n  /** Identifies if the repository is private or internal. */\n  isPrivate: Scalars[\"Boolean\"];\n  /** Identifies if the repository is a template that can be used to generate new repositories. */\n  isTemplate: Scalars[\"Boolean\"];\n  /** The license associated with the repository */\n  licenseInfo?: Maybe<License>;\n  /** The reason the repository has been locked. */\n  lockReason?: Maybe<RepositoryLockReason>;\n  /** The repository's original mirror URL. */\n  mirrorUrl?: Maybe<Scalars[\"URI\"]>;\n  /** The name of the repository. */\n  name: Scalars[\"String\"];\n  /** The repository's name with owner. */\n  nameWithOwner: Scalars[\"String\"];\n  /** The image used to represent this repository in Open Graph data. */\n  openGraphImageUrl: Scalars[\"URI\"];\n  /** The User owner of the repository. */\n  owner: RepositoryOwner;\n  /** Identifies when the repository was last pushed to. */\n  pushedAt?: Maybe<Scalars[\"DateTime\"]>;\n  /** The HTTP path for this repository */\n  resourcePath: Scalars[\"URI\"];\n  /** A description of the repository, rendered to HTML without any links in it. */\n  shortDescriptionHTML: Scalars[\"HTML\"];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars[\"DateTime\"];\n  /** The HTTP URL for this repository */\n  url: Scalars[\"URI\"];\n  /** Whether this repository has a custom image to use with Open Graph as opposed to being represented by the owner's avatar. */\n  usesCustomOpenGraphImage: Scalars[\"Boolean\"];\n  /** Indicates the repository's visibility level. */\n  visibility: RepositoryVisibility;\n};\n\n/** A subset of repository info. */\nexport type RepositoryInfoShortDescriptionHtmlArgs = {\n  limit?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** Repository interaction limit that applies to this object. */\nexport type RepositoryInteractionAbility = {\n  __typename?: \"RepositoryInteractionAbility\";\n  /** The time the currently active limit expires. */\n  expiresAt?: Maybe<Scalars[\"DateTime\"]>;\n  /** The current limit that is enabled on this object. */\n  limit: RepositoryInteractionLimit;\n  /** The origin of the currently active interaction limit. */\n  origin: RepositoryInteractionLimitOrigin;\n};\n\n/** A repository interaction limit. */\nexport enum RepositoryInteractionLimit {\n  /** Users that are not collaborators will not be able to interact with the repository. */\n  CollaboratorsOnly = \"COLLABORATORS_ONLY\",\n  /** Users that have not previously committed to a repository’s default branch will be unable to interact with the repository. */\n  ContributorsOnly = \"CONTRIBUTORS_ONLY\",\n  /** Users that have recently created their account will be unable to interact with the repository. */\n  ExistingUsers = \"EXISTING_USERS\",\n  /** No interaction limits are enabled. */\n  NoLimit = \"NO_LIMIT\",\n}\n\n/** The length for a repository interaction limit to be enabled for. */\nexport enum RepositoryInteractionLimitExpiry {\n  /** The interaction limit will expire after 1 day. */\n  OneDay = \"ONE_DAY\",\n  /** The interaction limit will expire after 1 month. */\n  OneMonth = \"ONE_MONTH\",\n  /** The interaction limit will expire after 1 week. */\n  OneWeek = \"ONE_WEEK\",\n  /** The interaction limit will expire after 6 months. */\n  SixMonths = \"SIX_MONTHS\",\n  /** The interaction limit will expire after 3 days. */\n  ThreeDays = \"THREE_DAYS\",\n}\n\n/** Indicates where an interaction limit is configured. */\nexport enum RepositoryInteractionLimitOrigin {\n  /** A limit that is configured at the organization level. */\n  Organization = \"ORGANIZATION\",\n  /** A limit that is configured at the repository level. */\n  Repository = \"REPOSITORY\",\n  /** A limit that is configured at the user-wide level. */\n  User = \"USER\",\n}\n\n/** An invitation for a user to be added to a repository. */\nexport type RepositoryInvitation = Node & {\n  __typename?: \"RepositoryInvitation\";\n  /** The email address that received the invitation. */\n  email?: Maybe<Scalars[\"String\"]>;\n  id: Scalars[\"ID\"];\n  /** The user who received the invitation. */\n  invitee?: Maybe<User>;\n  /** The user who created the invitation. */\n  inviter: User;\n  /** The permalink for this repository invitation. */\n  permalink: Scalars[\"URI\"];\n  /** The permission granted on this repository by this invitation. */\n  permission: RepositoryPermission;\n  /** The Repository the user is invited to. */\n  repository?: Maybe<RepositoryInfo>;\n};\n\n/** A list of repository invitations. */\nexport type RepositoryInvitationConnection = {\n  __typename?: \"RepositoryInvitationConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<RepositoryInvitationEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<RepositoryInvitation>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type RepositoryInvitationEdge = {\n  __typename?: \"RepositoryInvitationEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<RepositoryInvitation>;\n};\n\n/** Ordering options for repository invitation connections. */\nexport type RepositoryInvitationOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order repository invitations by. */\n  field: RepositoryInvitationOrderField;\n};\n\n/** Properties by which repository invitation connections can be ordered. */\nexport enum RepositoryInvitationOrderField {\n  /** Order repository invitations by creation time */\n  CreatedAt = \"CREATED_AT\",\n}\n\n/** The possible reasons a given repository could be in a locked state. */\nexport enum RepositoryLockReason {\n  /** The repository is locked due to a billing related reason. */\n  Billing = \"BILLING\",\n  /** The repository is locked due to a migration. */\n  Migrating = \"MIGRATING\",\n  /** The repository is locked due to a move. */\n  Moving = \"MOVING\",\n  /** The repository is locked due to a rename. */\n  Rename = \"RENAME\",\n}\n\n/** An Octoshift repository migration. */\nexport type RepositoryMigration = Migration &\n  Node & {\n    __typename?: \"RepositoryMigration\";\n    /** The Octoshift migration flag to continue on error. */\n    continueOnError: Scalars[\"Boolean\"];\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars[\"DateTime\"];\n    /** The reason the migration failed. */\n    failureReason?: Maybe<Scalars[\"String\"]>;\n    id: Scalars[\"ID\"];\n    /** The URL for the migration log (expires 1 day after migration completes). */\n    migrationLogUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The Octoshift migration source. */\n    migrationSource: MigrationSource;\n    /** The target repository name. */\n    repositoryName: Scalars[\"String\"];\n    /** The Octoshift migration source URL. */\n    sourceUrl: Scalars[\"URI\"];\n    /** The Octoshift migration state. */\n    state: MigrationState;\n  };\n\n/** The connection type for RepositoryMigration. */\nexport type RepositoryMigrationConnection = {\n  __typename?: \"RepositoryMigrationConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<RepositoryMigrationEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<RepositoryMigration>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** Represents a repository migration. */\nexport type RepositoryMigrationEdge = {\n  __typename?: \"RepositoryMigrationEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<RepositoryMigration>;\n};\n\n/** Ordering options for repository migrations. */\nexport type RepositoryMigrationOrder = {\n  /** The ordering direction. */\n  direction: RepositoryMigrationOrderDirection;\n  /** The field to order repository migrations by. */\n  field: RepositoryMigrationOrderField;\n};\n\n/** Possible directions in which to order a list of repository migrations when provided an `orderBy` argument. */\nexport enum RepositoryMigrationOrderDirection {\n  /** Specifies an ascending order for a given `orderBy` argument. */\n  Asc = \"ASC\",\n  /** Specifies a descending order for a given `orderBy` argument. */\n  Desc = \"DESC\",\n}\n\n/** Properties by which repository migrations can be ordered. */\nexport enum RepositoryMigrationOrderField {\n  /** Order mannequins why when they were created. */\n  CreatedAt = \"CREATED_AT\",\n}\n\n/** Represents a object that belongs to a repository. */\nexport type RepositoryNode = {\n  /** The repository associated with this node. */\n  repository: Repository;\n};\n\n/** Ordering options for repository connections */\nexport type RepositoryOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order repositories by. */\n  field: RepositoryOrderField;\n};\n\n/** Properties by which repository connections can be ordered. */\nexport enum RepositoryOrderField {\n  /** Order repositories by creation time */\n  CreatedAt = \"CREATED_AT\",\n  /** Order repositories by name */\n  Name = \"NAME\",\n  /** Order repositories by push time */\n  PushedAt = \"PUSHED_AT\",\n  /** Order repositories by number of stargazers */\n  Stargazers = \"STARGAZERS\",\n  /** Order repositories by update time */\n  UpdatedAt = \"UPDATED_AT\",\n}\n\n/** Represents an owner of a Repository. */\nexport type RepositoryOwner = {\n  /** A URL pointing to the owner's public avatar. */\n  avatarUrl: Scalars[\"URI\"];\n  id: Scalars[\"ID\"];\n  /** The username used to login. */\n  login: Scalars[\"String\"];\n  /** A list of repositories that the user owns. */\n  repositories: RepositoryConnection;\n  /** Find Repository. */\n  repository?: Maybe<Repository>;\n  /** The HTTP URL for the owner. */\n  resourcePath: Scalars[\"URI\"];\n  /** The HTTP URL for the owner. */\n  url: Scalars[\"URI\"];\n};\n\n/** Represents an owner of a Repository. */\nexport type RepositoryOwnerAvatarUrlArgs = {\n  size?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** Represents an owner of a Repository. */\nexport type RepositoryOwnerRepositoriesArgs = {\n  affiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  isFork?: InputMaybe<Scalars[\"Boolean\"]>;\n  isLocked?: InputMaybe<Scalars[\"Boolean\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<RepositoryOrder>;\n  ownerAffiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;\n  privacy?: InputMaybe<RepositoryPrivacy>;\n};\n\n/** Represents an owner of a Repository. */\nexport type RepositoryOwnerRepositoryArgs = {\n  followRenames?: InputMaybe<Scalars[\"Boolean\"]>;\n  name: Scalars[\"String\"];\n};\n\n/** The access level to a repository */\nexport enum RepositoryPermission {\n  /**\n   * Can read, clone, and push to this repository. Can also manage issues, pull\n   * requests, and repository settings, including adding collaborators\n   */\n  Admin = \"ADMIN\",\n  /** Can read, clone, and push to this repository. They can also manage issues, pull requests, and some repository settings */\n  Maintain = \"MAINTAIN\",\n  /** Can read and clone this repository. Can also open and comment on issues and pull requests */\n  Read = \"READ\",\n  /** Can read and clone this repository. Can also manage issues and pull requests */\n  Triage = \"TRIAGE\",\n  /** Can read, clone, and push to this repository. Can also manage issues and pull requests */\n  Write = \"WRITE\",\n}\n\n/** The privacy of a repository */\nexport enum RepositoryPrivacy {\n  /** Private */\n  Private = \"PRIVATE\",\n  /** Public */\n  Public = \"PUBLIC\",\n}\n\n/** A repository-topic connects a repository to a topic. */\nexport type RepositoryTopic = Node &\n  UniformResourceLocatable & {\n    __typename?: \"RepositoryTopic\";\n    id: Scalars[\"ID\"];\n    /** The HTTP path for this repository-topic. */\n    resourcePath: Scalars[\"URI\"];\n    /** The topic. */\n    topic: Topic;\n    /** The HTTP URL for this repository-topic. */\n    url: Scalars[\"URI\"];\n  };\n\n/** The connection type for RepositoryTopic. */\nexport type RepositoryTopicConnection = {\n  __typename?: \"RepositoryTopicConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<RepositoryTopicEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<RepositoryTopic>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type RepositoryTopicEdge = {\n  __typename?: \"RepositoryTopicEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<RepositoryTopic>;\n};\n\n/** The repository's visibility level. */\nexport enum RepositoryVisibility {\n  /** The repository is visible only to users in the same business. */\n  Internal = \"INTERNAL\",\n  /** The repository is visible only to those with explicit access. */\n  Private = \"PRIVATE\",\n  /** The repository is visible to everyone. */\n  Public = \"PUBLIC\",\n}\n\n/** Audit log entry for a repository_visibility_change.disable event. */\nexport type RepositoryVisibilityChangeDisableAuditEntry = AuditEntry &\n  EnterpriseAuditEntryData &\n  Node &\n  OrganizationAuditEntryData & {\n    __typename?: \"RepositoryVisibilityChangeDisableAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    /** The HTTP path for this enterprise. */\n    enterpriseResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The slug of the enterprise. */\n    enterpriseSlug?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP URL for this enterprise. */\n    enterpriseUrl?: Maybe<Scalars[\"URI\"]>;\n    id: Scalars[\"ID\"];\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** Audit log entry for a repository_visibility_change.enable event. */\nexport type RepositoryVisibilityChangeEnableAuditEntry = AuditEntry &\n  EnterpriseAuditEntryData &\n  Node &\n  OrganizationAuditEntryData & {\n    __typename?: \"RepositoryVisibilityChangeEnableAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    /** The HTTP path for this enterprise. */\n    enterpriseResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The slug of the enterprise. */\n    enterpriseSlug?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP URL for this enterprise. */\n    enterpriseUrl?: Maybe<Scalars[\"URI\"]>;\n    id: Scalars[\"ID\"];\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** A Dependabot alert for a repository with a dependency affected by a security vulnerability. */\nexport type RepositoryVulnerabilityAlert = Node &\n  RepositoryNode & {\n    __typename?: \"RepositoryVulnerabilityAlert\";\n    /** When was the alert created? */\n    createdAt: Scalars[\"DateTime\"];\n    /** The associated Dependabot update */\n    dependabotUpdate?: Maybe<DependabotUpdate>;\n    /** The reason the alert was dismissed */\n    dismissReason?: Maybe<Scalars[\"String\"]>;\n    /** When was the alert dismissed? */\n    dismissedAt?: Maybe<Scalars[\"DateTime\"]>;\n    /** The user who dismissed the alert */\n    dismisser?: Maybe<User>;\n    /** The reason the alert was marked as fixed. */\n    fixReason?: Maybe<Scalars[\"String\"]>;\n    /** When was the alert fixed? */\n    fixedAt?: Maybe<Scalars[\"DateTime\"]>;\n    id: Scalars[\"ID\"];\n    /** Identifies the alert number. */\n    number: Scalars[\"Int\"];\n    /** The associated repository */\n    repository: Repository;\n    /** The associated security advisory */\n    securityAdvisory?: Maybe<SecurityAdvisory>;\n    /** The associated security vulnerability */\n    securityVulnerability?: Maybe<SecurityVulnerability>;\n    /** Identifies the state of the alert. */\n    state: RepositoryVulnerabilityAlertState;\n    /** The vulnerable manifest filename */\n    vulnerableManifestFilename: Scalars[\"String\"];\n    /** The vulnerable manifest path */\n    vulnerableManifestPath: Scalars[\"String\"];\n    /** The vulnerable requirements */\n    vulnerableRequirements?: Maybe<Scalars[\"String\"]>;\n  };\n\n/** The connection type for RepositoryVulnerabilityAlert. */\nexport type RepositoryVulnerabilityAlertConnection = {\n  __typename?: \"RepositoryVulnerabilityAlertConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<RepositoryVulnerabilityAlertEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<RepositoryVulnerabilityAlert>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type RepositoryVulnerabilityAlertEdge = {\n  __typename?: \"RepositoryVulnerabilityAlertEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<RepositoryVulnerabilityAlert>;\n};\n\n/** The possible states of an alert */\nexport enum RepositoryVulnerabilityAlertState {\n  /** An alert that has been manually closed by a user. */\n  Dismissed = \"DISMISSED\",\n  /** An alert that has been resolved by a code change. */\n  Fixed = \"FIXED\",\n  /** An alert that is still open. */\n  Open = \"OPEN\",\n}\n\n/** Autogenerated input type of RequestReviews */\nexport type RequestReviewsInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The Node ID of the pull request to modify. */\n  pullRequestId: Scalars[\"ID\"];\n  /** The Node IDs of the team to request. */\n  teamIds?: InputMaybe<Array<Scalars[\"ID\"]>>;\n  /** Add users to the set rather than replace. */\n  union?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** The Node IDs of the user to request. */\n  userIds?: InputMaybe<Array<Scalars[\"ID\"]>>;\n};\n\n/** Autogenerated return type of RequestReviews */\nexport type RequestReviewsPayload = {\n  __typename?: \"RequestReviewsPayload\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The pull request that is getting requests. */\n  pullRequest?: Maybe<PullRequest>;\n  /** The edge from the pull request to the requested reviewers. */\n  requestedReviewersEdge?: Maybe<UserEdge>;\n};\n\n/** The possible states that can be requested when creating a check run. */\nexport enum RequestableCheckStatusState {\n  /** The check suite or run has been completed. */\n  Completed = \"COMPLETED\",\n  /** The check suite or run is in progress. */\n  InProgress = \"IN_PROGRESS\",\n  /** The check suite or run is in pending state. */\n  Pending = \"PENDING\",\n  /** The check suite or run has been queued. */\n  Queued = \"QUEUED\",\n  /** The check suite or run is in waiting state. */\n  Waiting = \"WAITING\",\n}\n\n/** Types that can be requested reviewers. */\nexport type RequestedReviewer = Mannequin | Team | User;\n\n/** Represents a type that can be required by a pull request for merging. */\nexport type RequirableByPullRequest = {\n  /** Whether this is required to pass before merging for a specific pull request. */\n  isRequired: Scalars[\"Boolean\"];\n};\n\n/** Represents a type that can be required by a pull request for merging. */\nexport type RequirableByPullRequestIsRequiredArgs = {\n  pullRequestId?: InputMaybe<Scalars[\"ID\"]>;\n  pullRequestNumber?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** Represents a required status check for a protected branch, but not any specific run of that check. */\nexport type RequiredStatusCheckDescription = {\n  __typename?: \"RequiredStatusCheckDescription\";\n  /** The App that must provide this status in order for it to be accepted. */\n  app?: Maybe<App>;\n  /** The name of this status. */\n  context: Scalars[\"String\"];\n};\n\n/** Specifies the attributes for a new or updated required status check. */\nexport type RequiredStatusCheckInput = {\n  /**\n   * The ID of the App that must set the status in order for it to be accepted.\n   * Omit this value to use whichever app has recently been setting this status, or\n   * use \"any\" to allow any app to set the status.\n   */\n  appId?: InputMaybe<Scalars[\"ID\"]>;\n  /** Status check context that must pass for commits to be accepted to the matching branch. */\n  context: Scalars[\"String\"];\n};\n\n/** Autogenerated input type of RerequestCheckSuite */\nexport type RerequestCheckSuiteInput = {\n  /** The Node ID of the check suite. */\n  checkSuiteId: Scalars[\"ID\"];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The Node ID of the repository. */\n  repositoryId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of RerequestCheckSuite */\nexport type RerequestCheckSuitePayload = {\n  __typename?: \"RerequestCheckSuitePayload\";\n  /** The requested check suite. */\n  checkSuite?: Maybe<CheckSuite>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated input type of ResolveReviewThread */\nexport type ResolveReviewThreadInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the thread to resolve */\n  threadId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of ResolveReviewThread */\nexport type ResolveReviewThreadPayload = {\n  __typename?: \"ResolveReviewThreadPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The thread to resolve. */\n  thread?: Maybe<PullRequestReviewThread>;\n};\n\n/** Represents a private contribution a user made on GitHub. */\nexport type RestrictedContribution = Contribution & {\n  __typename?: \"RestrictedContribution\";\n  /**\n   * Whether this contribution is associated with a record you do not have access to. For\n   * example, your own 'first issue' contribution may have been made on a repository you can no\n   * longer access.\n   */\n  isRestricted: Scalars[\"Boolean\"];\n  /** When this contribution was made. */\n  occurredAt: Scalars[\"DateTime\"];\n  /** The HTTP path for this contribution. */\n  resourcePath: Scalars[\"URI\"];\n  /** The HTTP URL for this contribution. */\n  url: Scalars[\"URI\"];\n  /** The user who made this contribution. */\n  user: User;\n};\n\n/** A team or user who has the ability to dismiss a review on a protected branch. */\nexport type ReviewDismissalAllowance = Node & {\n  __typename?: \"ReviewDismissalAllowance\";\n  /** The actor that can dismiss. */\n  actor?: Maybe<ReviewDismissalAllowanceActor>;\n  /** Identifies the branch protection rule associated with the allowed user or team. */\n  branchProtectionRule?: Maybe<BranchProtectionRule>;\n  id: Scalars[\"ID\"];\n};\n\n/** Types that can be an actor. */\nexport type ReviewDismissalAllowanceActor = Team | User;\n\n/** The connection type for ReviewDismissalAllowance. */\nexport type ReviewDismissalAllowanceConnection = {\n  __typename?: \"ReviewDismissalAllowanceConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ReviewDismissalAllowanceEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ReviewDismissalAllowance>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type ReviewDismissalAllowanceEdge = {\n  __typename?: \"ReviewDismissalAllowanceEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<ReviewDismissalAllowance>;\n};\n\n/** Represents a 'review_dismissed' event on a given issue or pull request. */\nexport type ReviewDismissedEvent = Node &\n  UniformResourceLocatable & {\n    __typename?: \"ReviewDismissedEvent\";\n    /** Identifies the actor who performed the event. */\n    actor?: Maybe<Actor>;\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars[\"DateTime\"];\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars[\"Int\"]>;\n    /** Identifies the optional message associated with the 'review_dismissed' event. */\n    dismissalMessage?: Maybe<Scalars[\"String\"]>;\n    /** Identifies the optional message associated with the event, rendered to HTML. */\n    dismissalMessageHTML?: Maybe<Scalars[\"String\"]>;\n    id: Scalars[\"ID\"];\n    /** Identifies the previous state of the review with the 'review_dismissed' event. */\n    previousReviewState: PullRequestReviewState;\n    /** PullRequest referenced by event. */\n    pullRequest: PullRequest;\n    /** Identifies the commit which caused the review to become stale. */\n    pullRequestCommit?: Maybe<PullRequestCommit>;\n    /** The HTTP path for this review dismissed event. */\n    resourcePath: Scalars[\"URI\"];\n    /** Identifies the review associated with the 'review_dismissed' event. */\n    review?: Maybe<PullRequestReview>;\n    /** The HTTP URL for this review dismissed event. */\n    url: Scalars[\"URI\"];\n  };\n\n/** A request for a user to review a pull request. */\nexport type ReviewRequest = Node & {\n  __typename?: \"ReviewRequest\";\n  /** Whether this request was created for a code owner */\n  asCodeOwner: Scalars[\"Boolean\"];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars[\"Int\"]>;\n  id: Scalars[\"ID\"];\n  /** Identifies the pull request associated with this review request. */\n  pullRequest: PullRequest;\n  /** The reviewer that is requested. */\n  requestedReviewer?: Maybe<RequestedReviewer>;\n};\n\n/** The connection type for ReviewRequest. */\nexport type ReviewRequestConnection = {\n  __typename?: \"ReviewRequestConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ReviewRequestEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ReviewRequest>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type ReviewRequestEdge = {\n  __typename?: \"ReviewRequestEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<ReviewRequest>;\n};\n\n/** Represents an 'review_request_removed' event on a given pull request. */\nexport type ReviewRequestRemovedEvent = Node & {\n  __typename?: \"ReviewRequestRemovedEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  id: Scalars[\"ID\"];\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest;\n  /** Identifies the reviewer whose review request was removed. */\n  requestedReviewer?: Maybe<RequestedReviewer>;\n};\n\n/** Represents an 'review_requested' event on a given pull request. */\nexport type ReviewRequestedEvent = Node & {\n  __typename?: \"ReviewRequestedEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  id: Scalars[\"ID\"];\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest;\n  /** Identifies the reviewer whose review was requested. */\n  requestedReviewer?: Maybe<RequestedReviewer>;\n};\n\n/**\n * A hovercard context with a message describing the current code review state of the pull\n * request.\n */\nexport type ReviewStatusHovercardContext = HovercardContext & {\n  __typename?: \"ReviewStatusHovercardContext\";\n  /** A string describing this context */\n  message: Scalars[\"String\"];\n  /** An octicon to accompany this context */\n  octicon: Scalars[\"String\"];\n  /** The current status of the pull request with respect to code review. */\n  reviewDecision?: Maybe<PullRequestReviewDecision>;\n};\n\n/** Autogenerated input type of RevokeEnterpriseOrganizationsMigratorRole */\nexport type RevokeEnterpriseOrganizationsMigratorRoleInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the enterprise to which all organizations managed by it will be granted the migrator role. */\n  enterpriseId: Scalars[\"ID\"];\n  /** The login of the user to revoke the migrator role */\n  login: Scalars[\"String\"];\n};\n\n/** Autogenerated return type of RevokeEnterpriseOrganizationsMigratorRole */\nexport type RevokeEnterpriseOrganizationsMigratorRolePayload = {\n  __typename?: \"RevokeEnterpriseOrganizationsMigratorRolePayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The organizations that had the migrator role revoked for the given user. */\n  organizations?: Maybe<OrganizationConnection>;\n};\n\n/** Autogenerated return type of RevokeEnterpriseOrganizationsMigratorRole */\nexport type RevokeEnterpriseOrganizationsMigratorRolePayloadOrganizationsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** Autogenerated input type of RevokeMigratorRole */\nexport type RevokeMigratorRoleInput = {\n  /** The user login or Team slug to revoke the migrator role from. */\n  actor: Scalars[\"String\"];\n  /** Specifies the type of the actor, can be either USER or TEAM. */\n  actorType: ActorType;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the organization that the user/team belongs to. */\n  organizationId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of RevokeMigratorRole */\nexport type RevokeMigratorRolePayload = {\n  __typename?: \"RevokeMigratorRolePayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** Did the operation succeed? */\n  success?: Maybe<Scalars[\"Boolean\"]>;\n};\n\n/** Possible roles a user may have in relation to an organization. */\nexport enum RoleInOrganization {\n  /** A user who is a direct member of the organization. */\n  DirectMember = \"DIRECT_MEMBER\",\n  /** A user with full administrative access to the organization. */\n  Owner = \"OWNER\",\n  /** A user who is unaffiliated with the organization. */\n  Unaffiliated = \"UNAFFILIATED\",\n}\n\n/** The possible digest algorithms used to sign SAML requests for an identity provider. */\nexport enum SamlDigestAlgorithm {\n  /** SHA1 */\n  Sha1 = \"SHA1\",\n  /** SHA256 */\n  Sha256 = \"SHA256\",\n  /** SHA384 */\n  Sha384 = \"SHA384\",\n  /** SHA512 */\n  Sha512 = \"SHA512\",\n}\n\n/** The possible signature algorithms used to sign SAML requests for a Identity Provider. */\nexport enum SamlSignatureAlgorithm {\n  /** RSA-SHA1 */\n  RsaSha1 = \"RSA_SHA1\",\n  /** RSA-SHA256 */\n  RsaSha256 = \"RSA_SHA256\",\n  /** RSA-SHA384 */\n  RsaSha384 = \"RSA_SHA384\",\n  /** RSA-SHA512 */\n  RsaSha512 = \"RSA_SHA512\",\n}\n\n/** A Saved Reply is text a user can use to reply quickly. */\nexport type SavedReply = Node & {\n  __typename?: \"SavedReply\";\n  /** The body of the saved reply. */\n  body: Scalars[\"String\"];\n  /** The saved reply body rendered to HTML. */\n  bodyHTML: Scalars[\"HTML\"];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars[\"Int\"]>;\n  id: Scalars[\"ID\"];\n  /** The title of the saved reply. */\n  title: Scalars[\"String\"];\n  /** The user that saved this reply. */\n  user?: Maybe<Actor>;\n};\n\n/** The connection type for SavedReply. */\nexport type SavedReplyConnection = {\n  __typename?: \"SavedReplyConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SavedReplyEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<SavedReply>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type SavedReplyEdge = {\n  __typename?: \"SavedReplyEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<SavedReply>;\n};\n\n/** Ordering options for saved reply connections. */\nexport type SavedReplyOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order saved replies by. */\n  field: SavedReplyOrderField;\n};\n\n/** Properties by which saved reply connections can be ordered. */\nexport enum SavedReplyOrderField {\n  /** Order saved reply by when they were updated. */\n  UpdatedAt = \"UPDATED_AT\",\n}\n\n/** The results of a search. */\nexport type SearchResultItem = App | Discussion | Issue | MarketplaceListing | Organization | PullRequest | Repository | User;\n\n/** A list of results that matched against a search query. */\nexport type SearchResultItemConnection = {\n  __typename?: \"SearchResultItemConnection\";\n  /** The number of pieces of code that matched the search query. */\n  codeCount: Scalars[\"Int\"];\n  /** The number of discussions that matched the search query. */\n  discussionCount: Scalars[\"Int\"];\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SearchResultItemEdge>>>;\n  /** The number of issues that matched the search query. */\n  issueCount: Scalars[\"Int\"];\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<SearchResultItem>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** The number of repositories that matched the search query. */\n  repositoryCount: Scalars[\"Int\"];\n  /** The number of users that matched the search query. */\n  userCount: Scalars[\"Int\"];\n  /** The number of wiki pages that matched the search query. */\n  wikiCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type SearchResultItemEdge = {\n  __typename?: \"SearchResultItemEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<SearchResultItem>;\n  /** Text matches on the result found. */\n  textMatches?: Maybe<Array<Maybe<TextMatch>>>;\n};\n\n/** Represents the individual results of a search. */\nexport enum SearchType {\n  /** Returns matching discussions in repositories. */\n  Discussion = \"DISCUSSION\",\n  /** Returns results matching issues in repositories. */\n  Issue = \"ISSUE\",\n  /** Returns results matching repositories. */\n  Repository = \"REPOSITORY\",\n  /** Returns results matching users and organizations on GitHub. */\n  User = \"USER\",\n}\n\n/** A GitHub Security Advisory */\nexport type SecurityAdvisory = Node & {\n  __typename?: \"SecurityAdvisory\";\n  /** The CVSS associated with this advisory */\n  cvss: Cvss;\n  /** CWEs associated with this Advisory */\n  cwes: CweConnection;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars[\"Int\"]>;\n  /** This is a long plaintext description of the advisory */\n  description: Scalars[\"String\"];\n  /** The GitHub Security Advisory ID */\n  ghsaId: Scalars[\"String\"];\n  id: Scalars[\"ID\"];\n  /** A list of identifiers for this advisory */\n  identifiers: Array<SecurityAdvisoryIdentifier>;\n  /** The permalink for the advisory's dependabot alerts page */\n  notificationsPermalink?: Maybe<Scalars[\"URI\"]>;\n  /** The organization that originated the advisory */\n  origin: Scalars[\"String\"];\n  /** The permalink for the advisory */\n  permalink?: Maybe<Scalars[\"URI\"]>;\n  /** When the advisory was published */\n  publishedAt: Scalars[\"DateTime\"];\n  /** A list of references for this advisory */\n  references: Array<SecurityAdvisoryReference>;\n  /** The severity of the advisory */\n  severity: SecurityAdvisorySeverity;\n  /** A short plaintext summary of the advisory */\n  summary: Scalars[\"String\"];\n  /** When the advisory was last updated */\n  updatedAt: Scalars[\"DateTime\"];\n  /** Vulnerabilities associated with this Advisory */\n  vulnerabilities: SecurityVulnerabilityConnection;\n  /** When the advisory was withdrawn, if it has been withdrawn */\n  withdrawnAt?: Maybe<Scalars[\"DateTime\"]>;\n};\n\n/** A GitHub Security Advisory */\nexport type SecurityAdvisoryCwesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A GitHub Security Advisory */\nexport type SecurityAdvisoryVulnerabilitiesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  ecosystem?: InputMaybe<SecurityAdvisoryEcosystem>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<SecurityVulnerabilityOrder>;\n  package?: InputMaybe<Scalars[\"String\"]>;\n  severities?: InputMaybe<Array<SecurityAdvisorySeverity>>;\n};\n\n/** The connection type for SecurityAdvisory. */\nexport type SecurityAdvisoryConnection = {\n  __typename?: \"SecurityAdvisoryConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SecurityAdvisoryEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<SecurityAdvisory>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** The possible ecosystems of a security vulnerability's package. */\nexport enum SecurityAdvisoryEcosystem {\n  /** PHP packages hosted at packagist.org */\n  Composer = \"COMPOSER\",\n  /** Go modules */\n  Go = \"GO\",\n  /** Java artifacts hosted at the Maven central repository */\n  Maven = \"MAVEN\",\n  /** JavaScript packages hosted at npmjs.com */\n  Npm = \"NPM\",\n  /** .NET packages hosted at the NuGet Gallery */\n  Nuget = \"NUGET\",\n  /** Python packages hosted at PyPI.org */\n  Pip = \"PIP\",\n  /** Ruby gems hosted at RubyGems.org */\n  Rubygems = \"RUBYGEMS\",\n  /** Rust crates */\n  Rust = \"RUST\",\n}\n\n/** An edge in a connection. */\nexport type SecurityAdvisoryEdge = {\n  __typename?: \"SecurityAdvisoryEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<SecurityAdvisory>;\n};\n\n/** A GitHub Security Advisory Identifier */\nexport type SecurityAdvisoryIdentifier = {\n  __typename?: \"SecurityAdvisoryIdentifier\";\n  /** The identifier type, e.g. GHSA, CVE */\n  type: Scalars[\"String\"];\n  /** The identifier */\n  value: Scalars[\"String\"];\n};\n\n/** An advisory identifier to filter results on. */\nexport type SecurityAdvisoryIdentifierFilter = {\n  /** The identifier type. */\n  type: SecurityAdvisoryIdentifierType;\n  /** The identifier string. Supports exact or partial matching. */\n  value: Scalars[\"String\"];\n};\n\n/** Identifier formats available for advisories. */\nexport enum SecurityAdvisoryIdentifierType {\n  /** Common Vulnerabilities and Exposures Identifier. */\n  Cve = \"CVE\",\n  /** GitHub Security Advisory ID. */\n  Ghsa = \"GHSA\",\n}\n\n/** Ordering options for security advisory connections */\nexport type SecurityAdvisoryOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order security advisories by. */\n  field: SecurityAdvisoryOrderField;\n};\n\n/** Properties by which security advisory connections can be ordered. */\nexport enum SecurityAdvisoryOrderField {\n  /** Order advisories by publication time */\n  PublishedAt = \"PUBLISHED_AT\",\n  /** Order advisories by update time */\n  UpdatedAt = \"UPDATED_AT\",\n}\n\n/** An individual package */\nexport type SecurityAdvisoryPackage = {\n  __typename?: \"SecurityAdvisoryPackage\";\n  /** The ecosystem the package belongs to, e.g. RUBYGEMS, NPM */\n  ecosystem: SecurityAdvisoryEcosystem;\n  /** The package name */\n  name: Scalars[\"String\"];\n};\n\n/** An individual package version */\nexport type SecurityAdvisoryPackageVersion = {\n  __typename?: \"SecurityAdvisoryPackageVersion\";\n  /** The package name or version */\n  identifier: Scalars[\"String\"];\n};\n\n/** A GitHub Security Advisory Reference */\nexport type SecurityAdvisoryReference = {\n  __typename?: \"SecurityAdvisoryReference\";\n  /** A publicly accessible reference */\n  url: Scalars[\"URI\"];\n};\n\n/** Severity of the vulnerability. */\nexport enum SecurityAdvisorySeverity {\n  /** Critical. */\n  Critical = \"CRITICAL\",\n  /** High. */\n  High = \"HIGH\",\n  /** Low. */\n  Low = \"LOW\",\n  /** Moderate. */\n  Moderate = \"MODERATE\",\n}\n\n/** An individual vulnerability within an Advisory */\nexport type SecurityVulnerability = {\n  __typename?: \"SecurityVulnerability\";\n  /** The Advisory associated with this Vulnerability */\n  advisory: SecurityAdvisory;\n  /** The first version containing a fix for the vulnerability */\n  firstPatchedVersion?: Maybe<SecurityAdvisoryPackageVersion>;\n  /** A description of the vulnerable package */\n  package: SecurityAdvisoryPackage;\n  /** The severity of the vulnerability within this package */\n  severity: SecurityAdvisorySeverity;\n  /** When the vulnerability was last updated */\n  updatedAt: Scalars[\"DateTime\"];\n  /**\n   * A string that describes the vulnerable package versions.\n   * This string follows a basic syntax with a few forms.\n   * + `= 0.2.0` denotes a single vulnerable version.\n   * + `<= 1.0.8` denotes a version range up to and including the specified version\n   * + `< 0.1.11` denotes a version range up to, but excluding, the specified version\n   * + `>= 4.3.0, < 4.3.5` denotes a version range with a known minimum and maximum version.\n   * + `>= 0.0.1` denotes a version range with a known minimum, but no known maximum\n   */\n  vulnerableVersionRange: Scalars[\"String\"];\n};\n\n/** The connection type for SecurityVulnerability. */\nexport type SecurityVulnerabilityConnection = {\n  __typename?: \"SecurityVulnerabilityConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SecurityVulnerabilityEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<SecurityVulnerability>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type SecurityVulnerabilityEdge = {\n  __typename?: \"SecurityVulnerabilityEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<SecurityVulnerability>;\n};\n\n/** Ordering options for security vulnerability connections */\nexport type SecurityVulnerabilityOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order security vulnerabilities by. */\n  field: SecurityVulnerabilityOrderField;\n};\n\n/** Properties by which security vulnerability connections can be ordered. */\nexport enum SecurityVulnerabilityOrderField {\n  /** Order vulnerability by update time */\n  UpdatedAt = \"UPDATED_AT\",\n}\n\n/** Autogenerated input type of SetEnterpriseIdentityProvider */\nexport type SetEnterpriseIdentityProviderInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The digest algorithm used to sign SAML requests for the identity provider. */\n  digestMethod: SamlDigestAlgorithm;\n  /** The ID of the enterprise on which to set an identity provider. */\n  enterpriseId: Scalars[\"ID\"];\n  /** The x509 certificate used by the identity provider to sign assertions and responses. */\n  idpCertificate: Scalars[\"String\"];\n  /** The Issuer Entity ID for the SAML identity provider */\n  issuer?: InputMaybe<Scalars[\"String\"]>;\n  /** The signature algorithm used to sign SAML requests for the identity provider. */\n  signatureMethod: SamlSignatureAlgorithm;\n  /** The URL endpoint for the identity provider's SAML SSO. */\n  ssoUrl: Scalars[\"URI\"];\n};\n\n/** Autogenerated return type of SetEnterpriseIdentityProvider */\nexport type SetEnterpriseIdentityProviderPayload = {\n  __typename?: \"SetEnterpriseIdentityProviderPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The identity provider for the enterprise. */\n  identityProvider?: Maybe<EnterpriseIdentityProvider>;\n};\n\n/** Autogenerated input type of SetOrganizationInteractionLimit */\nexport type SetOrganizationInteractionLimitInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** When this limit should expire. */\n  expiry?: InputMaybe<RepositoryInteractionLimitExpiry>;\n  /** The limit to set. */\n  limit: RepositoryInteractionLimit;\n  /** The ID of the organization to set a limit for. */\n  organizationId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of SetOrganizationInteractionLimit */\nexport type SetOrganizationInteractionLimitPayload = {\n  __typename?: \"SetOrganizationInteractionLimitPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The organization that the interaction limit was set for. */\n  organization?: Maybe<Organization>;\n};\n\n/** Autogenerated input type of SetRepositoryInteractionLimit */\nexport type SetRepositoryInteractionLimitInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** When this limit should expire. */\n  expiry?: InputMaybe<RepositoryInteractionLimitExpiry>;\n  /** The limit to set. */\n  limit: RepositoryInteractionLimit;\n  /** The ID of the repository to set a limit for. */\n  repositoryId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of SetRepositoryInteractionLimit */\nexport type SetRepositoryInteractionLimitPayload = {\n  __typename?: \"SetRepositoryInteractionLimitPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The repository that the interaction limit was set for. */\n  repository?: Maybe<Repository>;\n};\n\n/** Autogenerated input type of SetUserInteractionLimit */\nexport type SetUserInteractionLimitInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** When this limit should expire. */\n  expiry?: InputMaybe<RepositoryInteractionLimitExpiry>;\n  /** The limit to set. */\n  limit: RepositoryInteractionLimit;\n  /** The ID of the user to set a limit for. */\n  userId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of SetUserInteractionLimit */\nexport type SetUserInteractionLimitPayload = {\n  __typename?: \"SetUserInteractionLimitPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The user that the interaction limit was set for. */\n  user?: Maybe<User>;\n};\n\n/** Represents an S/MIME signature on a Commit or Tag. */\nexport type SmimeSignature = GitSignature & {\n  __typename?: \"SmimeSignature\";\n  /** Email used to sign this object. */\n  email: Scalars[\"String\"];\n  /** True if the signature is valid and verified by GitHub. */\n  isValid: Scalars[\"Boolean\"];\n  /** Payload for GPG signing object. Raw ODB object without the signature header. */\n  payload: Scalars[\"String\"];\n  /** ASCII-armored signature header from object. */\n  signature: Scalars[\"String\"];\n  /** GitHub user corresponding to the email signing this commit. */\n  signer?: Maybe<User>;\n  /**\n   * The state of this signature. `VALID` if signature is valid and verified by\n   * GitHub, otherwise represents reason why signature is considered invalid.\n   */\n  state: GitSignatureState;\n  /** True if the signature was made with GitHub's signing key. */\n  wasSignedByGitHub: Scalars[\"Boolean\"];\n};\n\n/** Represents a sort by field and direction. */\nexport type SortBy = {\n  __typename?: \"SortBy\";\n  /** The direction of the sorting. Possible values are ASC and DESC. */\n  direction: OrderDirection;\n  /** The id of the field by which the column is sorted. */\n  field: Scalars[\"Int\"];\n};\n\n/** Entities that can sponsor others via GitHub Sponsors */\nexport type Sponsor = Organization | User;\n\n/** The connection type for Sponsor. */\nexport type SponsorConnection = {\n  __typename?: \"SponsorConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SponsorEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Sponsor>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** Represents a user or organization who is sponsoring someone in GitHub Sponsors. */\nexport type SponsorEdge = {\n  __typename?: \"SponsorEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<Sponsor>;\n};\n\n/** Ordering options for connections to get sponsor entities for GitHub Sponsors. */\nexport type SponsorOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order sponsor entities by. */\n  field: SponsorOrderField;\n};\n\n/** Properties by which sponsor connections can be ordered. */\nexport enum SponsorOrderField {\n  /** Order sponsorable entities by login (username). */\n  Login = \"LOGIN\",\n  /** Order sponsors by their relevance to the viewer. */\n  Relevance = \"RELEVANCE\",\n}\n\n/** Entities that can be sponsored through GitHub Sponsors */\nexport type Sponsorable = {\n  /** The estimated next GitHub Sponsors payout for this user/organization in cents (USD). */\n  estimatedNextSponsorsPayoutInCents: Scalars[\"Int\"];\n  /** True if this user/organization has a GitHub Sponsors listing. */\n  hasSponsorsListing: Scalars[\"Boolean\"];\n  /** Check if the given account is sponsoring this user/organization. */\n  isSponsoredBy: Scalars[\"Boolean\"];\n  /** True if the viewer is sponsored by this user/organization. */\n  isSponsoringViewer: Scalars[\"Boolean\"];\n  /** The estimated monthly GitHub Sponsors income for this user/organization in cents (USD). */\n  monthlyEstimatedSponsorsIncomeInCents: Scalars[\"Int\"];\n  /** List of users and organizations this entity is sponsoring. */\n  sponsoring: SponsorConnection;\n  /** List of sponsors for this user or organization. */\n  sponsors: SponsorConnection;\n  /** Events involving this sponsorable, such as new sponsorships. */\n  sponsorsActivities: SponsorsActivityConnection;\n  /** The GitHub Sponsors listing for this user or organization. */\n  sponsorsListing?: Maybe<SponsorsListing>;\n  /**\n   * The sponsorship from the viewer to this user/organization; that is, the\n   * sponsorship where you're the sponsor. Only returns a sponsorship if it is active.\n   */\n  sponsorshipForViewerAsSponsor?: Maybe<Sponsorship>;\n  /**\n   * The sponsorship from this user/organization to the viewer; that is, the\n   * sponsorship you're receiving. Only returns a sponsorship if it is active.\n   */\n  sponsorshipForViewerAsSponsorable?: Maybe<Sponsorship>;\n  /** List of sponsorship updates sent from this sponsorable to sponsors. */\n  sponsorshipNewsletters: SponsorshipNewsletterConnection;\n  /** This object's sponsorships as the maintainer. */\n  sponsorshipsAsMaintainer: SponsorshipConnection;\n  /** This object's sponsorships as the sponsor. */\n  sponsorshipsAsSponsor: SponsorshipConnection;\n  /** Whether or not the viewer is able to sponsor this user/organization. */\n  viewerCanSponsor: Scalars[\"Boolean\"];\n  /** True if the viewer is sponsoring this user/organization. */\n  viewerIsSponsoring: Scalars[\"Boolean\"];\n};\n\n/** Entities that can be sponsored through GitHub Sponsors */\nexport type SponsorableIsSponsoredByArgs = {\n  accountLogin: Scalars[\"String\"];\n};\n\n/** Entities that can be sponsored through GitHub Sponsors */\nexport type SponsorableSponsoringArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<SponsorOrder>;\n};\n\n/** Entities that can be sponsored through GitHub Sponsors */\nexport type SponsorableSponsorsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<SponsorOrder>;\n  tierId?: InputMaybe<Scalars[\"ID\"]>;\n};\n\n/** Entities that can be sponsored through GitHub Sponsors */\nexport type SponsorableSponsorsActivitiesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<SponsorsActivityOrder>;\n  period?: InputMaybe<SponsorsActivityPeriod>;\n};\n\n/** Entities that can be sponsored through GitHub Sponsors */\nexport type SponsorableSponsorshipNewslettersArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<SponsorshipNewsletterOrder>;\n};\n\n/** Entities that can be sponsored through GitHub Sponsors */\nexport type SponsorableSponsorshipsAsMaintainerArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  includePrivate?: InputMaybe<Scalars[\"Boolean\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<SponsorshipOrder>;\n};\n\n/** Entities that can be sponsored through GitHub Sponsors */\nexport type SponsorableSponsorshipsAsSponsorArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<SponsorshipOrder>;\n};\n\n/** Entities that can be sponsored via GitHub Sponsors */\nexport type SponsorableItem = Organization | User;\n\n/** The connection type for SponsorableItem. */\nexport type SponsorableItemConnection = {\n  __typename?: \"SponsorableItemConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SponsorableItemEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<SponsorableItem>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type SponsorableItemEdge = {\n  __typename?: \"SponsorableItemEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<SponsorableItem>;\n};\n\n/** Ordering options for connections to get sponsorable entities for GitHub Sponsors. */\nexport type SponsorableOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order sponsorable entities by. */\n  field: SponsorableOrderField;\n};\n\n/** Properties by which sponsorable connections can be ordered. */\nexport enum SponsorableOrderField {\n  /** Order sponsorable entities by login (username). */\n  Login = \"LOGIN\",\n}\n\n/** An event related to sponsorship activity. */\nexport type SponsorsActivity = Node & {\n  __typename?: \"SponsorsActivity\";\n  /** What action this activity indicates took place. */\n  action: SponsorsActivityAction;\n  id: Scalars[\"ID\"];\n  /** The tier that the sponsorship used to use, for tier change events. */\n  previousSponsorsTier?: Maybe<SponsorsTier>;\n  /** The user or organization who triggered this activity and was/is sponsoring the sponsorable. */\n  sponsor?: Maybe<Sponsor>;\n  /** The user or organization that is being sponsored, the maintainer. */\n  sponsorable: Sponsorable;\n  /** The associated sponsorship tier. */\n  sponsorsTier?: Maybe<SponsorsTier>;\n  /** The timestamp of this event. */\n  timestamp?: Maybe<Scalars[\"DateTime\"]>;\n};\n\n/** The possible actions that GitHub Sponsors activities can represent. */\nexport enum SponsorsActivityAction {\n  /** The activity was cancelling a sponsorship. */\n  CancelledSponsorship = \"CANCELLED_SPONSORSHIP\",\n  /** The activity was starting a sponsorship. */\n  NewSponsorship = \"NEW_SPONSORSHIP\",\n  /** The activity was scheduling a downgrade or cancellation. */\n  PendingChange = \"PENDING_CHANGE\",\n  /** The activity was funds being refunded to the sponsor or GitHub. */\n  Refund = \"REFUND\",\n  /** The activity was disabling matching for a previously matched sponsorship. */\n  SponsorMatchDisabled = \"SPONSOR_MATCH_DISABLED\",\n  /** The activity was changing the sponsorship tier, either directly by the sponsor or by a scheduled/pending change. */\n  TierChange = \"TIER_CHANGE\",\n}\n\n/** The connection type for SponsorsActivity. */\nexport type SponsorsActivityConnection = {\n  __typename?: \"SponsorsActivityConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SponsorsActivityEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<SponsorsActivity>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type SponsorsActivityEdge = {\n  __typename?: \"SponsorsActivityEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<SponsorsActivity>;\n};\n\n/** Ordering options for GitHub Sponsors activity connections. */\nexport type SponsorsActivityOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order activity by. */\n  field: SponsorsActivityOrderField;\n};\n\n/** Properties by which GitHub Sponsors activity connections can be ordered. */\nexport enum SponsorsActivityOrderField {\n  /** Order activities by when they happened. */\n  Timestamp = \"TIMESTAMP\",\n}\n\n/** The possible time periods for which Sponsors activities can be requested. */\nexport enum SponsorsActivityPeriod {\n  /** Don't restrict the activity to any date range, include all activity. */\n  All = \"ALL\",\n  /** The previous calendar day. */\n  Day = \"DAY\",\n  /** The previous thirty days. */\n  Month = \"MONTH\",\n  /** The previous seven days. */\n  Week = \"WEEK\",\n}\n\n/** A goal associated with a GitHub Sponsors listing, representing a target the sponsored maintainer would like to attain. */\nexport type SponsorsGoal = {\n  __typename?: \"SponsorsGoal\";\n  /** A description of the goal from the maintainer. */\n  description?: Maybe<Scalars[\"String\"]>;\n  /** What the objective of this goal is. */\n  kind: SponsorsGoalKind;\n  /** The percentage representing how complete this goal is, between 0-100. */\n  percentComplete: Scalars[\"Int\"];\n  /**\n   * What the goal amount is. Represents an amount in USD for monthly sponsorship\n   * amount goals. Represents a count of unique sponsors for total sponsors count goals.\n   */\n  targetValue: Scalars[\"Int\"];\n  /** A brief summary of the kind and target value of this goal. */\n  title: Scalars[\"String\"];\n};\n\n/** The different kinds of goals a GitHub Sponsors member can have. */\nexport enum SponsorsGoalKind {\n  /** The goal is about getting a certain amount in USD from sponsorships each month. */\n  MonthlySponsorshipAmount = \"MONTHLY_SPONSORSHIP_AMOUNT\",\n  /** The goal is about reaching a certain number of sponsors. */\n  TotalSponsorsCount = \"TOTAL_SPONSORS_COUNT\",\n}\n\n/** A GitHub Sponsors listing. */\nexport type SponsorsListing = Node & {\n  __typename?: \"SponsorsListing\";\n  /** The current goal the maintainer is trying to reach with GitHub Sponsors, if any. */\n  activeGoal?: Maybe<SponsorsGoal>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** The full description of the listing. */\n  fullDescription: Scalars[\"String\"];\n  /** The full description of the listing rendered to HTML. */\n  fullDescriptionHTML: Scalars[\"HTML\"];\n  id: Scalars[\"ID\"];\n  /** Whether this listing is publicly visible. */\n  isPublic: Scalars[\"Boolean\"];\n  /** The listing's full name. */\n  name: Scalars[\"String\"];\n  /** A future date on which this listing is eligible to receive a payout. */\n  nextPayoutDate?: Maybe<Scalars[\"Date\"]>;\n  /** The short description of the listing. */\n  shortDescription: Scalars[\"String\"];\n  /** The short name of the listing. */\n  slug: Scalars[\"String\"];\n  /** The entity this listing represents who can be sponsored on GitHub Sponsors. */\n  sponsorable: Sponsorable;\n  /** The published tiers for this GitHub Sponsors listing. */\n  tiers?: Maybe<SponsorsTierConnection>;\n};\n\n/** A GitHub Sponsors listing. */\nexport type SponsorsListingTiersArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<SponsorsTierOrder>;\n};\n\n/** A GitHub Sponsors tier associated with a GitHub Sponsors listing. */\nexport type SponsorsTier = Node & {\n  __typename?: \"SponsorsTier\";\n  /** SponsorsTier information only visible to users that can administer the associated Sponsors listing. */\n  adminInfo?: Maybe<SponsorsTierAdminInfo>;\n  /**\n   * Get a different tier for this tier's maintainer that is at the same frequency\n   * as this tier but with an equal or lesser cost. Returns the published tier with\n   * the monthly price closest to this tier's without going over.\n   */\n  closestLesserValueTier?: Maybe<SponsorsTier>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** The description of the tier. */\n  description: Scalars[\"String\"];\n  /** The tier description rendered to HTML */\n  descriptionHTML: Scalars[\"HTML\"];\n  id: Scalars[\"ID\"];\n  /**\n   * Whether this tier was chosen at checkout time by the sponsor rather than\n   * defined ahead of time by the maintainer who manages the Sponsors listing.\n   */\n  isCustomAmount: Scalars[\"Boolean\"];\n  /** Whether this tier is only for use with one-time sponsorships. */\n  isOneTime: Scalars[\"Boolean\"];\n  /** How much this tier costs per month in cents. */\n  monthlyPriceInCents: Scalars[\"Int\"];\n  /** How much this tier costs per month in USD. */\n  monthlyPriceInDollars: Scalars[\"Int\"];\n  /** The name of the tier. */\n  name: Scalars[\"String\"];\n  /** The sponsors listing that this tier belongs to. */\n  sponsorsListing: SponsorsListing;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars[\"DateTime\"];\n};\n\n/** SponsorsTier information only visible to users that can administer the associated Sponsors listing. */\nexport type SponsorsTierAdminInfo = {\n  __typename?: \"SponsorsTierAdminInfo\";\n  /** The sponsorships associated with this tier. */\n  sponsorships: SponsorshipConnection;\n};\n\n/** SponsorsTier information only visible to users that can administer the associated Sponsors listing. */\nexport type SponsorsTierAdminInfoSponsorshipsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  includePrivate?: InputMaybe<Scalars[\"Boolean\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<SponsorshipOrder>;\n};\n\n/** The connection type for SponsorsTier. */\nexport type SponsorsTierConnection = {\n  __typename?: \"SponsorsTierConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SponsorsTierEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<SponsorsTier>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type SponsorsTierEdge = {\n  __typename?: \"SponsorsTierEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<SponsorsTier>;\n};\n\n/** Ordering options for Sponsors tiers connections. */\nexport type SponsorsTierOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order tiers by. */\n  field: SponsorsTierOrderField;\n};\n\n/** Properties by which Sponsors tiers connections can be ordered. */\nexport enum SponsorsTierOrderField {\n  /** Order tiers by creation time. */\n  CreatedAt = \"CREATED_AT\",\n  /** Order tiers by their monthly price in cents */\n  MonthlyPriceInCents = \"MONTHLY_PRICE_IN_CENTS\",\n}\n\n/** A sponsorship relationship between a sponsor and a maintainer */\nexport type Sponsorship = Node & {\n  __typename?: \"Sponsorship\";\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  id: Scalars[\"ID\"];\n  /** Whether this sponsorship represents a one-time payment versus a recurring sponsorship. */\n  isOneTimePayment: Scalars[\"Boolean\"];\n  /**\n   * Check if the sponsor has chosen to receive sponsorship update emails sent from\n   * the sponsorable. Only returns a non-null value when the viewer has permission to know this.\n   */\n  isSponsorOptedIntoEmail?: Maybe<Scalars[\"Boolean\"]>;\n  /**\n   * The entity that is being sponsored\n   * @deprecated `Sponsorship.maintainer` will be removed. Use `Sponsorship.sponsorable` instead. Removal on 2020-04-01 UTC.\n   */\n  maintainer: User;\n  /** The privacy level for this sponsorship. */\n  privacyLevel: SponsorshipPrivacy;\n  /**\n   * The user that is sponsoring. Returns null if the sponsorship is private or if sponsor is not a user.\n   * @deprecated `Sponsorship.sponsor` will be removed. Use `Sponsorship.sponsorEntity` instead. Removal on 2020-10-01 UTC.\n   */\n  sponsor?: Maybe<User>;\n  /** The user or organization that is sponsoring, if you have permission to view them. */\n  sponsorEntity?: Maybe<Sponsor>;\n  /** The entity that is being sponsored */\n  sponsorable: Sponsorable;\n  /** The associated sponsorship tier */\n  tier?: Maybe<SponsorsTier>;\n  /** Identifies the date and time when the current tier was chosen for this sponsorship. */\n  tierSelectedAt?: Maybe<Scalars[\"DateTime\"]>;\n};\n\n/** The connection type for Sponsorship. */\nexport type SponsorshipConnection = {\n  __typename?: \"SponsorshipConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SponsorshipEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Sponsorship>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n  /**\n   * The total amount in cents of all recurring sponsorships in the connection\n   * whose amount you can view. Does not include one-time sponsorships.\n   */\n  totalRecurringMonthlyPriceInCents: Scalars[\"Int\"];\n  /**\n   * The total amount in USD of all recurring sponsorships in the connection whose\n   * amount you can view. Does not include one-time sponsorships.\n   */\n  totalRecurringMonthlyPriceInDollars: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type SponsorshipEdge = {\n  __typename?: \"SponsorshipEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<Sponsorship>;\n};\n\n/** An update sent to sponsors of a user or organization on GitHub Sponsors. */\nexport type SponsorshipNewsletter = Node & {\n  __typename?: \"SponsorshipNewsletter\";\n  /** The contents of the newsletter, the message the sponsorable wanted to give. */\n  body: Scalars[\"String\"];\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  id: Scalars[\"ID\"];\n  /** Indicates if the newsletter has been made available to sponsors. */\n  isPublished: Scalars[\"Boolean\"];\n  /** The user or organization this newsletter is from. */\n  sponsorable: Sponsorable;\n  /** The subject of the newsletter, what it's about. */\n  subject: Scalars[\"String\"];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars[\"DateTime\"];\n};\n\n/** The connection type for SponsorshipNewsletter. */\nexport type SponsorshipNewsletterConnection = {\n  __typename?: \"SponsorshipNewsletterConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SponsorshipNewsletterEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<SponsorshipNewsletter>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type SponsorshipNewsletterEdge = {\n  __typename?: \"SponsorshipNewsletterEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<SponsorshipNewsletter>;\n};\n\n/** Ordering options for sponsorship newsletter connections. */\nexport type SponsorshipNewsletterOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order sponsorship newsletters by. */\n  field: SponsorshipNewsletterOrderField;\n};\n\n/** Properties by which sponsorship update connections can be ordered. */\nexport enum SponsorshipNewsletterOrderField {\n  /** Order sponsorship newsletters by when they were created. */\n  CreatedAt = \"CREATED_AT\",\n}\n\n/** Ordering options for sponsorship connections. */\nexport type SponsorshipOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order sponsorship by. */\n  field: SponsorshipOrderField;\n};\n\n/** Properties by which sponsorship connections can be ordered. */\nexport enum SponsorshipOrderField {\n  /** Order sponsorship by creation time. */\n  CreatedAt = \"CREATED_AT\",\n}\n\n/** The privacy of a sponsorship */\nexport enum SponsorshipPrivacy {\n  /** Private */\n  Private = \"PRIVATE\",\n  /** Public */\n  Public = \"PUBLIC\",\n}\n\n/** Ways in which star connections can be ordered. */\nexport type StarOrder = {\n  /** The direction in which to order nodes. */\n  direction: OrderDirection;\n  /** The field in which to order nodes by. */\n  field: StarOrderField;\n};\n\n/** Properties by which star connections can be ordered. */\nexport enum StarOrderField {\n  /** Allows ordering a list of stars by when they were created. */\n  StarredAt = \"STARRED_AT\",\n}\n\n/** The connection type for User. */\nexport type StargazerConnection = {\n  __typename?: \"StargazerConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<StargazerEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** Represents a user that's starred a repository. */\nexport type StargazerEdge = {\n  __typename?: \"StargazerEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  node: User;\n  /** Identifies when the item was starred. */\n  starredAt: Scalars[\"DateTime\"];\n};\n\n/** Things that can be starred. */\nexport type Starrable = {\n  id: Scalars[\"ID\"];\n  /** Returns a count of how many stargazers there are on this object */\n  stargazerCount: Scalars[\"Int\"];\n  /** A list of users who have starred this starrable. */\n  stargazers: StargazerConnection;\n  /** Returns a boolean indicating whether the viewing user has starred this starrable. */\n  viewerHasStarred: Scalars[\"Boolean\"];\n};\n\n/** Things that can be starred. */\nexport type StarrableStargazersArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<StarOrder>;\n};\n\n/** The connection type for Repository. */\nexport type StarredRepositoryConnection = {\n  __typename?: \"StarredRepositoryConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<StarredRepositoryEdge>>>;\n  /** Is the list of stars for this user truncated? This is true for users that have many stars. */\n  isOverLimit: Scalars[\"Boolean\"];\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Repository>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** Represents a starred repository. */\nexport type StarredRepositoryEdge = {\n  __typename?: \"StarredRepositoryEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  node: Repository;\n  /** Identifies when the item was starred. */\n  starredAt: Scalars[\"DateTime\"];\n};\n\n/** Autogenerated input type of StartRepositoryMigration */\nexport type StartRepositoryMigrationInput = {\n  /** The Octoshift migration source access token. */\n  accessToken?: InputMaybe<Scalars[\"String\"]>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** Whether to continue the migration on error */\n  continueOnError?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** The signed URL to access the user-uploaded git archive */\n  gitArchiveUrl?: InputMaybe<Scalars[\"String\"]>;\n  /** The GitHub personal access token of the user importing to the target repository. */\n  githubPat?: InputMaybe<Scalars[\"String\"]>;\n  /** The signed URL to access the user-uploaded metadata archive */\n  metadataArchiveUrl?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the organization that will own the imported repository. */\n  ownerId: Scalars[\"ID\"];\n  /** The name of the imported repository. */\n  repositoryName: Scalars[\"String\"];\n  /** Whether to skip migrating releases for the repository. */\n  skipReleases?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** The ID of the Octoshift migration source. */\n  sourceId: Scalars[\"ID\"];\n  /** The Octoshift migration source repository URL. */\n  sourceRepositoryUrl: Scalars[\"URI\"];\n};\n\n/** Autogenerated return type of StartRepositoryMigration */\nexport type StartRepositoryMigrationPayload = {\n  __typename?: \"StartRepositoryMigrationPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The new Octoshift repository migration. */\n  repositoryMigration?: Maybe<RepositoryMigration>;\n};\n\n/** Represents a commit status. */\nexport type Status = Node & {\n  __typename?: \"Status\";\n  /** A list of status contexts and check runs for this commit. */\n  combinedContexts: StatusCheckRollupContextConnection;\n  /** The commit this status is attached to. */\n  commit?: Maybe<Commit>;\n  /** Looks up an individual status context by context name. */\n  context?: Maybe<StatusContext>;\n  /** The individual status contexts for this commit. */\n  contexts: Array<StatusContext>;\n  id: Scalars[\"ID\"];\n  /** The combined commit status. */\n  state: StatusState;\n};\n\n/** Represents a commit status. */\nexport type StatusCombinedContextsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** Represents a commit status. */\nexport type StatusContextArgs = {\n  name: Scalars[\"String\"];\n};\n\n/** Represents the rollup for both the check runs and status for a commit. */\nexport type StatusCheckRollup = Node & {\n  __typename?: \"StatusCheckRollup\";\n  /** The commit the status and check runs are attached to. */\n  commit?: Maybe<Commit>;\n  /** A list of status contexts and check runs for this commit. */\n  contexts: StatusCheckRollupContextConnection;\n  id: Scalars[\"ID\"];\n  /** The combined status for the commit. */\n  state: StatusState;\n};\n\n/** Represents the rollup for both the check runs and status for a commit. */\nexport type StatusCheckRollupContextsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** Types that can be inside a StatusCheckRollup context. */\nexport type StatusCheckRollupContext = CheckRun | StatusContext;\n\n/** The connection type for StatusCheckRollupContext. */\nexport type StatusCheckRollupContextConnection = {\n  __typename?: \"StatusCheckRollupContextConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<StatusCheckRollupContextEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<StatusCheckRollupContext>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type StatusCheckRollupContextEdge = {\n  __typename?: \"StatusCheckRollupContextEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<StatusCheckRollupContext>;\n};\n\n/** Represents an individual commit status context */\nexport type StatusContext = Node &\n  RequirableByPullRequest & {\n    __typename?: \"StatusContext\";\n    /** The avatar of the OAuth application or the user that created the status */\n    avatarUrl?: Maybe<Scalars[\"URI\"]>;\n    /** This commit this status context is attached to. */\n    commit?: Maybe<Commit>;\n    /** The name of this status context. */\n    context: Scalars[\"String\"];\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars[\"DateTime\"];\n    /** The actor who created this status context. */\n    creator?: Maybe<Actor>;\n    /** The description for this status context. */\n    description?: Maybe<Scalars[\"String\"]>;\n    id: Scalars[\"ID\"];\n    /** Whether this is required to pass before merging for a specific pull request. */\n    isRequired: Scalars[\"Boolean\"];\n    /** The state of this status context. */\n    state: StatusState;\n    /** The URL for this status context. */\n    targetUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** Represents an individual commit status context */\nexport type StatusContextAvatarUrlArgs = {\n  size?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** Represents an individual commit status context */\nexport type StatusContextIsRequiredArgs = {\n  pullRequestId?: InputMaybe<Scalars[\"ID\"]>;\n  pullRequestNumber?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** The possible commit status states. */\nexport enum StatusState {\n  /** Status is errored. */\n  Error = \"ERROR\",\n  /** Status is expected. */\n  Expected = \"EXPECTED\",\n  /** Status is failing. */\n  Failure = \"FAILURE\",\n  /** Status is pending. */\n  Pending = \"PENDING\",\n  /** Status is successful. */\n  Success = \"SUCCESS\",\n}\n\n/** Autogenerated input type of SubmitPullRequestReview */\nexport type SubmitPullRequestReviewInput = {\n  /** The text field to set on the Pull Request Review. */\n  body?: InputMaybe<Scalars[\"String\"]>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The event to send to the Pull Request Review. */\n  event: PullRequestReviewEvent;\n  /** The Pull Request ID to submit any pending reviews. */\n  pullRequestId?: InputMaybe<Scalars[\"ID\"]>;\n  /** The Pull Request Review ID to submit. */\n  pullRequestReviewId?: InputMaybe<Scalars[\"ID\"]>;\n};\n\n/** Autogenerated return type of SubmitPullRequestReview */\nexport type SubmitPullRequestReviewPayload = {\n  __typename?: \"SubmitPullRequestReviewPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The submitted pull request review. */\n  pullRequestReview?: Maybe<PullRequestReview>;\n};\n\n/** A pointer to a repository at a specific revision embedded inside another repository. */\nexport type Submodule = {\n  __typename?: \"Submodule\";\n  /** The branch of the upstream submodule for tracking updates */\n  branch?: Maybe<Scalars[\"String\"]>;\n  /** The git URL of the submodule repository */\n  gitUrl: Scalars[\"URI\"];\n  /** The name of the submodule in .gitmodules */\n  name: Scalars[\"String\"];\n  /** The path in the superproject that this submodule is located in */\n  path: Scalars[\"String\"];\n  /** The commit revision of the subproject repository being tracked by the submodule */\n  subprojectCommitOid?: Maybe<Scalars[\"GitObjectID\"]>;\n};\n\n/** The connection type for Submodule. */\nexport type SubmoduleConnection = {\n  __typename?: \"SubmoduleConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SubmoduleEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Submodule>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type SubmoduleEdge = {\n  __typename?: \"SubmoduleEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<Submodule>;\n};\n\n/** Entities that can be subscribed to for web and email notifications. */\nexport type Subscribable = {\n  id: Scalars[\"ID\"];\n  /** Check if the viewer is able to change their subscription status for the repository. */\n  viewerCanSubscribe: Scalars[\"Boolean\"];\n  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */\n  viewerSubscription?: Maybe<SubscriptionState>;\n};\n\n/** Represents a 'subscribed' event on a given `Subscribable`. */\nexport type SubscribedEvent = Node & {\n  __typename?: \"SubscribedEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  id: Scalars[\"ID\"];\n  /** Object referenced by event. */\n  subscribable: Subscribable;\n};\n\n/** The possible states of a subscription. */\nexport enum SubscriptionState {\n  /** The User is never notified. */\n  Ignored = \"IGNORED\",\n  /** The User is notified of all conversations. */\n  Subscribed = \"SUBSCRIBED\",\n  /** The User is only notified when participating or @mentioned. */\n  Unsubscribed = \"UNSUBSCRIBED\",\n}\n\n/** A suggestion to review a pull request based on a user's commit history and review comments. */\nexport type SuggestedReviewer = {\n  __typename?: \"SuggestedReviewer\";\n  /** Is this suggestion based on past commits? */\n  isAuthor: Scalars[\"Boolean\"];\n  /** Is this suggestion based on past review comments? */\n  isCommenter: Scalars[\"Boolean\"];\n  /** Identifies the user suggested to review the pull request. */\n  reviewer: User;\n};\n\n/** Represents a Git tag. */\nexport type Tag = GitObject &\n  Node & {\n    __typename?: \"Tag\";\n    /** An abbreviated version of the Git object ID */\n    abbreviatedOid: Scalars[\"String\"];\n    /** The HTTP path for this Git object */\n    commitResourcePath: Scalars[\"URI\"];\n    /** The HTTP URL for this Git object */\n    commitUrl: Scalars[\"URI\"];\n    id: Scalars[\"ID\"];\n    /** The Git tag message. */\n    message?: Maybe<Scalars[\"String\"]>;\n    /** The Git tag name. */\n    name: Scalars[\"String\"];\n    /** The Git object ID */\n    oid: Scalars[\"GitObjectID\"];\n    /** The Repository the Git object belongs to */\n    repository: Repository;\n    /** Details about the tag author. */\n    tagger?: Maybe<GitActor>;\n    /** The Git object the tag points to. */\n    target: GitObject;\n  };\n\n/** A team of users in an organization. */\nexport type Team = MemberStatusable &\n  Node &\n  Subscribable & {\n    __typename?: \"Team\";\n    /** A list of teams that are ancestors of this team. */\n    ancestors: TeamConnection;\n    /** A URL pointing to the team's avatar. */\n    avatarUrl?: Maybe<Scalars[\"URI\"]>;\n    /** List of child teams belonging to this team */\n    childTeams: TeamConnection;\n    /** The slug corresponding to the organization and team. */\n    combinedSlug: Scalars[\"String\"];\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars[\"DateTime\"];\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars[\"Int\"]>;\n    /** The description of the team. */\n    description?: Maybe<Scalars[\"String\"]>;\n    /** Find a team discussion by its number. */\n    discussion?: Maybe<TeamDiscussion>;\n    /** A list of team discussions. */\n    discussions: TeamDiscussionConnection;\n    /** The HTTP path for team discussions */\n    discussionsResourcePath: Scalars[\"URI\"];\n    /** The HTTP URL for team discussions */\n    discussionsUrl: Scalars[\"URI\"];\n    /** The HTTP path for editing this team */\n    editTeamResourcePath: Scalars[\"URI\"];\n    /** The HTTP URL for editing this team */\n    editTeamUrl: Scalars[\"URI\"];\n    id: Scalars[\"ID\"];\n    /** A list of pending invitations for users to this team */\n    invitations?: Maybe<OrganizationInvitationConnection>;\n    /** Get the status messages members of this entity have set that are either public or visible only to the organization. */\n    memberStatuses: UserStatusConnection;\n    /** A list of users who are members of this team. */\n    members: TeamMemberConnection;\n    /** The HTTP path for the team' members */\n    membersResourcePath: Scalars[\"URI\"];\n    /** The HTTP URL for the team' members */\n    membersUrl: Scalars[\"URI\"];\n    /** The name of the team. */\n    name: Scalars[\"String\"];\n    /** The HTTP path creating a new team */\n    newTeamResourcePath: Scalars[\"URI\"];\n    /** The HTTP URL creating a new team */\n    newTeamUrl: Scalars[\"URI\"];\n    /** The organization that owns this team. */\n    organization: Organization;\n    /** The parent team of the team. */\n    parentTeam?: Maybe<Team>;\n    /** The level of privacy the team has. */\n    privacy: TeamPrivacy;\n    /** A list of repositories this team has access to. */\n    repositories: TeamRepositoryConnection;\n    /** The HTTP path for this team's repositories */\n    repositoriesResourcePath: Scalars[\"URI\"];\n    /** The HTTP URL for this team's repositories */\n    repositoriesUrl: Scalars[\"URI\"];\n    /** The HTTP path for this team */\n    resourcePath: Scalars[\"URI\"];\n    /** What algorithm is used for review assignment for this team */\n    reviewRequestDelegationAlgorithm?: Maybe<TeamReviewAssignmentAlgorithm>;\n    /** True if review assignment is enabled for this team */\n    reviewRequestDelegationEnabled: Scalars[\"Boolean\"];\n    /** How many team members are required for review assignment for this team */\n    reviewRequestDelegationMemberCount?: Maybe<Scalars[\"Int\"]>;\n    /** When assigning team members via delegation, whether the entire team should be notified as well. */\n    reviewRequestDelegationNotifyTeam: Scalars[\"Boolean\"];\n    /** The slug corresponding to the team. */\n    slug: Scalars[\"String\"];\n    /** The HTTP path for this team's teams */\n    teamsResourcePath: Scalars[\"URI\"];\n    /** The HTTP URL for this team's teams */\n    teamsUrl: Scalars[\"URI\"];\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars[\"DateTime\"];\n    /** The HTTP URL for this team */\n    url: Scalars[\"URI\"];\n    /** Team is adminable by the viewer. */\n    viewerCanAdminister: Scalars[\"Boolean\"];\n    /** Check if the viewer is able to change their subscription status for the repository. */\n    viewerCanSubscribe: Scalars[\"Boolean\"];\n    /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */\n    viewerSubscription?: Maybe<SubscriptionState>;\n  };\n\n/** A team of users in an organization. */\nexport type TeamAncestorsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A team of users in an organization. */\nexport type TeamAvatarUrlArgs = {\n  size?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A team of users in an organization. */\nexport type TeamChildTeamsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  immediateOnly?: InputMaybe<Scalars[\"Boolean\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<TeamOrder>;\n  userLogins?: InputMaybe<Array<Scalars[\"String\"]>>;\n};\n\n/** A team of users in an organization. */\nexport type TeamDiscussionArgs = {\n  number: Scalars[\"Int\"];\n};\n\n/** A team of users in an organization. */\nexport type TeamDiscussionsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  isPinned?: InputMaybe<Scalars[\"Boolean\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<TeamDiscussionOrder>;\n};\n\n/** A team of users in an organization. */\nexport type TeamInvitationsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A team of users in an organization. */\nexport type TeamMemberStatusesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<UserStatusOrder>;\n};\n\n/** A team of users in an organization. */\nexport type TeamMembersArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  membership?: InputMaybe<TeamMembershipType>;\n  orderBy?: InputMaybe<TeamMemberOrder>;\n  query?: InputMaybe<Scalars[\"String\"]>;\n  role?: InputMaybe<TeamMemberRole>;\n};\n\n/** A team of users in an organization. */\nexport type TeamRepositoriesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<TeamRepositoryOrder>;\n  query?: InputMaybe<Scalars[\"String\"]>;\n};\n\n/** Audit log entry for a team.add_member event. */\nexport type TeamAddMemberAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  TeamAuditEntryData & {\n    __typename?: \"TeamAddMemberAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** Whether the team was mapped to an LDAP Group. */\n    isLdapMapped?: Maybe<Scalars[\"Boolean\"]>;\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The team associated with the action */\n    team?: Maybe<Team>;\n    /** The name of the team */\n    teamName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for this team */\n    teamResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for this team */\n    teamUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** Audit log entry for a team.add_repository event. */\nexport type TeamAddRepositoryAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData &\n  TeamAuditEntryData & {\n    __typename?: \"TeamAddRepositoryAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** Whether the team was mapped to an LDAP Group. */\n    isLdapMapped?: Maybe<Scalars[\"Boolean\"]>;\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>;\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The team associated with the action */\n    team?: Maybe<Team>;\n    /** The name of the team */\n    teamName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for this team */\n    teamResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for this team */\n    teamUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** Metadata for an audit entry with action team.* */\nexport type TeamAuditEntryData = {\n  /** The team associated with the action */\n  team?: Maybe<Team>;\n  /** The name of the team */\n  teamName?: Maybe<Scalars[\"String\"]>;\n  /** The HTTP path for this team */\n  teamResourcePath?: Maybe<Scalars[\"URI\"]>;\n  /** The HTTP URL for this team */\n  teamUrl?: Maybe<Scalars[\"URI\"]>;\n};\n\n/** Audit log entry for a team.change_parent_team event. */\nexport type TeamChangeParentTeamAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  TeamAuditEntryData & {\n    __typename?: \"TeamChangeParentTeamAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** Whether the team was mapped to an LDAP Group. */\n    isLdapMapped?: Maybe<Scalars[\"Boolean\"]>;\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The new parent team. */\n    parentTeam?: Maybe<Team>;\n    /** The name of the new parent team */\n    parentTeamName?: Maybe<Scalars[\"String\"]>;\n    /** The name of the former parent team */\n    parentTeamNameWas?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the parent team */\n    parentTeamResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the parent team */\n    parentTeamUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The former parent team. */\n    parentTeamWas?: Maybe<Team>;\n    /** The HTTP path for the previous parent team */\n    parentTeamWasResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the previous parent team */\n    parentTeamWasUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The team associated with the action */\n    team?: Maybe<Team>;\n    /** The name of the team */\n    teamName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for this team */\n    teamResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for this team */\n    teamUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** The connection type for Team. */\nexport type TeamConnection = {\n  __typename?: \"TeamConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<TeamEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Team>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** A team discussion. */\nexport type TeamDiscussion = Comment &\n  Deletable &\n  Node &\n  Reactable &\n  Subscribable &\n  UniformResourceLocatable &\n  Updatable &\n  UpdatableComment & {\n    __typename?: \"TeamDiscussion\";\n    /** The actor who authored the comment. */\n    author?: Maybe<Actor>;\n    /** Author's association with the discussion's team. */\n    authorAssociation: CommentAuthorAssociation;\n    /** The body as Markdown. */\n    body: Scalars[\"String\"];\n    /** The body rendered to HTML. */\n    bodyHTML: Scalars[\"HTML\"];\n    /** The body rendered to text. */\n    bodyText: Scalars[\"String\"];\n    /** Identifies the discussion body hash. */\n    bodyVersion: Scalars[\"String\"];\n    /** A list of comments on this discussion. */\n    comments: TeamDiscussionCommentConnection;\n    /** The HTTP path for discussion comments */\n    commentsResourcePath: Scalars[\"URI\"];\n    /** The HTTP URL for discussion comments */\n    commentsUrl: Scalars[\"URI\"];\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars[\"DateTime\"];\n    /** Check if this comment was created via an email reply. */\n    createdViaEmail: Scalars[\"Boolean\"];\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars[\"Int\"]>;\n    /** The actor who edited the comment. */\n    editor?: Maybe<Actor>;\n    id: Scalars[\"ID\"];\n    /** Check if this comment was edited and includes an edit with the creation data */\n    includesCreatedEdit: Scalars[\"Boolean\"];\n    /** Whether or not the discussion is pinned. */\n    isPinned: Scalars[\"Boolean\"];\n    /** Whether or not the discussion is only visible to team members and org admins. */\n    isPrivate: Scalars[\"Boolean\"];\n    /** The moment the editor made the last edit */\n    lastEditedAt?: Maybe<Scalars[\"DateTime\"]>;\n    /** Identifies the discussion within its team. */\n    number: Scalars[\"Int\"];\n    /** Identifies when the comment was published at. */\n    publishedAt?: Maybe<Scalars[\"DateTime\"]>;\n    /** A list of reactions grouped by content left on the subject. */\n    reactionGroups?: Maybe<Array<ReactionGroup>>;\n    /** A list of Reactions left on the Issue. */\n    reactions: ReactionConnection;\n    /** The HTTP path for this discussion */\n    resourcePath: Scalars[\"URI\"];\n    /** The team that defines the context of this discussion. */\n    team: Team;\n    /** The title of the discussion */\n    title: Scalars[\"String\"];\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars[\"DateTime\"];\n    /** The HTTP URL for this discussion */\n    url: Scalars[\"URI\"];\n    /** A list of edits to this content. */\n    userContentEdits?: Maybe<UserContentEditConnection>;\n    /** Check if the current viewer can delete this object. */\n    viewerCanDelete: Scalars[\"Boolean\"];\n    /** Whether or not the current viewer can pin this discussion. */\n    viewerCanPin: Scalars[\"Boolean\"];\n    /** Can user react to this subject */\n    viewerCanReact: Scalars[\"Boolean\"];\n    /** Check if the viewer is able to change their subscription status for the repository. */\n    viewerCanSubscribe: Scalars[\"Boolean\"];\n    /** Check if the current viewer can update this object. */\n    viewerCanUpdate: Scalars[\"Boolean\"];\n    /** Reasons why the current viewer can not update this comment. */\n    viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;\n    /** Did the viewer author this comment. */\n    viewerDidAuthor: Scalars[\"Boolean\"];\n    /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */\n    viewerSubscription?: Maybe<SubscriptionState>;\n  };\n\n/** A team discussion. */\nexport type TeamDiscussionCommentsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  fromComment?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<TeamDiscussionCommentOrder>;\n};\n\n/** A team discussion. */\nexport type TeamDiscussionReactionsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  content?: InputMaybe<ReactionContent>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<ReactionOrder>;\n};\n\n/** A team discussion. */\nexport type TeamDiscussionUserContentEditsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A comment on a team discussion. */\nexport type TeamDiscussionComment = Comment &\n  Deletable &\n  Node &\n  Reactable &\n  UniformResourceLocatable &\n  Updatable &\n  UpdatableComment & {\n    __typename?: \"TeamDiscussionComment\";\n    /** The actor who authored the comment. */\n    author?: Maybe<Actor>;\n    /** Author's association with the comment's team. */\n    authorAssociation: CommentAuthorAssociation;\n    /** The body as Markdown. */\n    body: Scalars[\"String\"];\n    /** The body rendered to HTML. */\n    bodyHTML: Scalars[\"HTML\"];\n    /** The body rendered to text. */\n    bodyText: Scalars[\"String\"];\n    /** The current version of the body content. */\n    bodyVersion: Scalars[\"String\"];\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars[\"DateTime\"];\n    /** Check if this comment was created via an email reply. */\n    createdViaEmail: Scalars[\"Boolean\"];\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars[\"Int\"]>;\n    /** The discussion this comment is about. */\n    discussion: TeamDiscussion;\n    /** The actor who edited the comment. */\n    editor?: Maybe<Actor>;\n    id: Scalars[\"ID\"];\n    /** Check if this comment was edited and includes an edit with the creation data */\n    includesCreatedEdit: Scalars[\"Boolean\"];\n    /** The moment the editor made the last edit */\n    lastEditedAt?: Maybe<Scalars[\"DateTime\"]>;\n    /** Identifies the comment number. */\n    number: Scalars[\"Int\"];\n    /** Identifies when the comment was published at. */\n    publishedAt?: Maybe<Scalars[\"DateTime\"]>;\n    /** A list of reactions grouped by content left on the subject. */\n    reactionGroups?: Maybe<Array<ReactionGroup>>;\n    /** A list of Reactions left on the Issue. */\n    reactions: ReactionConnection;\n    /** The HTTP path for this comment */\n    resourcePath: Scalars[\"URI\"];\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars[\"DateTime\"];\n    /** The HTTP URL for this comment */\n    url: Scalars[\"URI\"];\n    /** A list of edits to this content. */\n    userContentEdits?: Maybe<UserContentEditConnection>;\n    /** Check if the current viewer can delete this object. */\n    viewerCanDelete: Scalars[\"Boolean\"];\n    /** Can user react to this subject */\n    viewerCanReact: Scalars[\"Boolean\"];\n    /** Check if the current viewer can update this object. */\n    viewerCanUpdate: Scalars[\"Boolean\"];\n    /** Reasons why the current viewer can not update this comment. */\n    viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;\n    /** Did the viewer author this comment. */\n    viewerDidAuthor: Scalars[\"Boolean\"];\n  };\n\n/** A comment on a team discussion. */\nexport type TeamDiscussionCommentReactionsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  content?: InputMaybe<ReactionContent>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<ReactionOrder>;\n};\n\n/** A comment on a team discussion. */\nexport type TeamDiscussionCommentUserContentEditsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** The connection type for TeamDiscussionComment. */\nexport type TeamDiscussionCommentConnection = {\n  __typename?: \"TeamDiscussionCommentConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<TeamDiscussionCommentEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<TeamDiscussionComment>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type TeamDiscussionCommentEdge = {\n  __typename?: \"TeamDiscussionCommentEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<TeamDiscussionComment>;\n};\n\n/** Ways in which team discussion comment connections can be ordered. */\nexport type TeamDiscussionCommentOrder = {\n  /** The direction in which to order nodes. */\n  direction: OrderDirection;\n  /** The field by which to order nodes. */\n  field: TeamDiscussionCommentOrderField;\n};\n\n/** Properties by which team discussion comment connections can be ordered. */\nexport enum TeamDiscussionCommentOrderField {\n  /** Allows sequential ordering of team discussion comments (which is equivalent to chronological ordering). */\n  Number = \"NUMBER\",\n}\n\n/** The connection type for TeamDiscussion. */\nexport type TeamDiscussionConnection = {\n  __typename?: \"TeamDiscussionConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<TeamDiscussionEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<TeamDiscussion>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type TeamDiscussionEdge = {\n  __typename?: \"TeamDiscussionEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<TeamDiscussion>;\n};\n\n/** Ways in which team discussion connections can be ordered. */\nexport type TeamDiscussionOrder = {\n  /** The direction in which to order nodes. */\n  direction: OrderDirection;\n  /** The field by which to order nodes. */\n  field: TeamDiscussionOrderField;\n};\n\n/** Properties by which team discussion connections can be ordered. */\nexport enum TeamDiscussionOrderField {\n  /** Allows chronological ordering of team discussions. */\n  CreatedAt = \"CREATED_AT\",\n}\n\n/** An edge in a connection. */\nexport type TeamEdge = {\n  __typename?: \"TeamEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<Team>;\n};\n\n/** The connection type for User. */\nexport type TeamMemberConnection = {\n  __typename?: \"TeamMemberConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<TeamMemberEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** Represents a user who is a member of a team. */\nexport type TeamMemberEdge = {\n  __typename?: \"TeamMemberEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The HTTP path to the organization's member access page. */\n  memberAccessResourcePath: Scalars[\"URI\"];\n  /** The HTTP URL to the organization's member access page. */\n  memberAccessUrl: Scalars[\"URI\"];\n  node: User;\n  /** The role the member has on the team. */\n  role: TeamMemberRole;\n};\n\n/** Ordering options for team member connections */\nexport type TeamMemberOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order team members by. */\n  field: TeamMemberOrderField;\n};\n\n/** Properties by which team member connections can be ordered. */\nexport enum TeamMemberOrderField {\n  /** Order team members by creation time */\n  CreatedAt = \"CREATED_AT\",\n  /** Order team members by login */\n  Login = \"LOGIN\",\n}\n\n/** The possible team member roles; either 'maintainer' or 'member'. */\nexport enum TeamMemberRole {\n  /** A team maintainer has permission to add and remove team members. */\n  Maintainer = \"MAINTAINER\",\n  /** A team member has no administrative permissions on the team. */\n  Member = \"MEMBER\",\n}\n\n/** Defines which types of team members are included in the returned list. Can be one of IMMEDIATE, CHILD_TEAM or ALL. */\nexport enum TeamMembershipType {\n  /** Includes immediate and child team members for the team. */\n  All = \"ALL\",\n  /** Includes only child team members for the team. */\n  ChildTeam = \"CHILD_TEAM\",\n  /** Includes only immediate members of the team. */\n  Immediate = \"IMMEDIATE\",\n}\n\n/** Ways in which team connections can be ordered. */\nexport type TeamOrder = {\n  /** The direction in which to order nodes. */\n  direction: OrderDirection;\n  /** The field in which to order nodes by. */\n  field: TeamOrderField;\n};\n\n/** Properties by which team connections can be ordered. */\nexport enum TeamOrderField {\n  /** Allows ordering a list of teams by name. */\n  Name = \"NAME\",\n}\n\n/** The possible team privacy values. */\nexport enum TeamPrivacy {\n  /** A secret team can only be seen by its members. */\n  Secret = \"SECRET\",\n  /** A visible team can be seen and @mentioned by every member of the organization. */\n  Visible = \"VISIBLE\",\n}\n\n/** Audit log entry for a team.remove_member event. */\nexport type TeamRemoveMemberAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  TeamAuditEntryData & {\n    __typename?: \"TeamRemoveMemberAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** Whether the team was mapped to an LDAP Group. */\n    isLdapMapped?: Maybe<Scalars[\"Boolean\"]>;\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The team associated with the action */\n    team?: Maybe<Team>;\n    /** The name of the team */\n    teamName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for this team */\n    teamResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for this team */\n    teamUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** Audit log entry for a team.remove_repository event. */\nexport type TeamRemoveRepositoryAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData &\n  TeamAuditEntryData & {\n    __typename?: \"TeamRemoveRepositoryAuditEntry\";\n    /** The action name */\n    action: Scalars[\"String\"];\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>;\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars[\"String\"]>;\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>;\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The time the action was initiated */\n    createdAt: Scalars[\"PreciseDateTime\"];\n    id: Scalars[\"ID\"];\n    /** Whether the team was mapped to an LDAP Group. */\n    isLdapMapped?: Maybe<Scalars[\"Boolean\"]>;\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>;\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>;\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>;\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The team associated with the action */\n    team?: Maybe<Team>;\n    /** The name of the team */\n    teamName?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for this team */\n    teamResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for this team */\n    teamUrl?: Maybe<Scalars[\"URI\"]>;\n    /** The user affected by the action */\n    user?: Maybe<User>;\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars[\"String\"]>;\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars[\"URI\"]>;\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** The connection type for Repository. */\nexport type TeamRepositoryConnection = {\n  __typename?: \"TeamRepositoryConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<TeamRepositoryEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Repository>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** Represents a team repository. */\nexport type TeamRepositoryEdge = {\n  __typename?: \"TeamRepositoryEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  node: Repository;\n  /** The permission level the team has on the repository */\n  permission: RepositoryPermission;\n};\n\n/** Ordering options for team repository connections */\nexport type TeamRepositoryOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order repositories by. */\n  field: TeamRepositoryOrderField;\n};\n\n/** Properties by which team repository connections can be ordered. */\nexport enum TeamRepositoryOrderField {\n  /** Order repositories by creation time */\n  CreatedAt = \"CREATED_AT\",\n  /** Order repositories by name */\n  Name = \"NAME\",\n  /** Order repositories by permission */\n  Permission = \"PERMISSION\",\n  /** Order repositories by push time */\n  PushedAt = \"PUSHED_AT\",\n  /** Order repositories by number of stargazers */\n  Stargazers = \"STARGAZERS\",\n  /** Order repositories by update time */\n  UpdatedAt = \"UPDATED_AT\",\n}\n\n/** The possible team review assignment algorithms */\nexport enum TeamReviewAssignmentAlgorithm {\n  /** Balance review load across the entire team */\n  LoadBalance = \"LOAD_BALANCE\",\n  /** Alternate reviews between each team member */\n  RoundRobin = \"ROUND_ROBIN\",\n}\n\n/** The role of a user on a team. */\nexport enum TeamRole {\n  /** User has admin rights on the team. */\n  Admin = \"ADMIN\",\n  /** User is a member of the team. */\n  Member = \"MEMBER\",\n}\n\n/** A text match within a search result. */\nexport type TextMatch = {\n  __typename?: \"TextMatch\";\n  /** The specific text fragment within the property matched on. */\n  fragment: Scalars[\"String\"];\n  /** Highlights within the matched fragment. */\n  highlights: Array<TextMatchHighlight>;\n  /** The property matched on. */\n  property: Scalars[\"String\"];\n};\n\n/** Represents a single highlight in a search result match. */\nexport type TextMatchHighlight = {\n  __typename?: \"TextMatchHighlight\";\n  /** The indice in the fragment where the matched text begins. */\n  beginIndice: Scalars[\"Int\"];\n  /** The indice in the fragment where the matched text ends. */\n  endIndice: Scalars[\"Int\"];\n  /** The text matched. */\n  text: Scalars[\"String\"];\n};\n\n/** A topic aggregates entities that are related to a subject. */\nexport type Topic = Node &\n  Starrable & {\n    __typename?: \"Topic\";\n    id: Scalars[\"ID\"];\n    /** The topic's name. */\n    name: Scalars[\"String\"];\n    /**\n     * A list of related topics, including aliases of this topic, sorted with the most relevant\n     * first. Returns up to 10 Topics.\n     */\n    relatedTopics: Array<Topic>;\n    /** A list of repositories. */\n    repositories: RepositoryConnection;\n    /** Returns a count of how many stargazers there are on this object */\n    stargazerCount: Scalars[\"Int\"];\n    /** A list of users who have starred this starrable. */\n    stargazers: StargazerConnection;\n    /** Returns a boolean indicating whether the viewing user has starred this starrable. */\n    viewerHasStarred: Scalars[\"Boolean\"];\n  };\n\n/** A topic aggregates entities that are related to a subject. */\nexport type TopicRelatedTopicsArgs = {\n  first?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A topic aggregates entities that are related to a subject. */\nexport type TopicRepositoriesArgs = {\n  affiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  isLocked?: InputMaybe<Scalars[\"Boolean\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<RepositoryOrder>;\n  ownerAffiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;\n  privacy?: InputMaybe<RepositoryPrivacy>;\n  sponsorableOnly?: InputMaybe<Scalars[\"Boolean\"]>;\n};\n\n/** A topic aggregates entities that are related to a subject. */\nexport type TopicStargazersArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<StarOrder>;\n};\n\n/** Metadata for an audit entry with a topic. */\nexport type TopicAuditEntryData = {\n  /** The name of the topic added to the repository */\n  topic?: Maybe<Topic>;\n  /** The name of the topic added to the repository */\n  topicName?: Maybe<Scalars[\"String\"]>;\n};\n\n/** Reason that the suggested topic is declined. */\nexport enum TopicSuggestionDeclineReason {\n  /** The suggested topic is not relevant to the repository. */\n  NotRelevant = \"NOT_RELEVANT\",\n  /** The viewer does not like the suggested topic. */\n  PersonalPreference = \"PERSONAL_PREFERENCE\",\n  /** The suggested topic is too general for the repository. */\n  TooGeneral = \"TOO_GENERAL\",\n  /** The suggested topic is too specific for the repository (e.g. #ruby-on-rails-version-4-2-1). */\n  TooSpecific = \"TOO_SPECIFIC\",\n}\n\n/** The possible states of a tracked issue. */\nexport enum TrackedIssueStates {\n  /** The tracked issue is closed */\n  Closed = \"CLOSED\",\n  /** The tracked issue is open */\n  Open = \"OPEN\",\n}\n\n/** Autogenerated input type of TransferIssue */\nexport type TransferIssueInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The Node ID of the issue to be transferred */\n  issueId: Scalars[\"ID\"];\n  /** The Node ID of the repository the issue should be transferred to */\n  repositoryId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of TransferIssue */\nexport type TransferIssuePayload = {\n  __typename?: \"TransferIssuePayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The issue that was transferred */\n  issue?: Maybe<Issue>;\n};\n\n/** Represents a 'transferred' event on a given issue or pull request. */\nexport type TransferredEvent = Node & {\n  __typename?: \"TransferredEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** The repository this came from */\n  fromRepository?: Maybe<Repository>;\n  id: Scalars[\"ID\"];\n  /** Identifies the issue associated with the event. */\n  issue: Issue;\n};\n\n/** Represents a Git tree. */\nexport type Tree = GitObject &\n  Node & {\n    __typename?: \"Tree\";\n    /** An abbreviated version of the Git object ID */\n    abbreviatedOid: Scalars[\"String\"];\n    /** The HTTP path for this Git object */\n    commitResourcePath: Scalars[\"URI\"];\n    /** The HTTP URL for this Git object */\n    commitUrl: Scalars[\"URI\"];\n    /** A list of tree entries. */\n    entries?: Maybe<Array<TreeEntry>>;\n    id: Scalars[\"ID\"];\n    /** The Git object ID */\n    oid: Scalars[\"GitObjectID\"];\n    /** The Repository the Git object belongs to */\n    repository: Repository;\n  };\n\n/** Represents a Git tree entry. */\nexport type TreeEntry = {\n  __typename?: \"TreeEntry\";\n  /** The extension of the file */\n  extension?: Maybe<Scalars[\"String\"]>;\n  /** Whether or not this tree entry is generated */\n  isGenerated: Scalars[\"Boolean\"];\n  /** Number of lines in the file. */\n  lineCount?: Maybe<Scalars[\"Int\"]>;\n  /** Entry file mode. */\n  mode: Scalars[\"Int\"];\n  /** Entry file name. */\n  name: Scalars[\"String\"];\n  /** Entry file object. */\n  object?: Maybe<GitObject>;\n  /** Entry file Git object ID. */\n  oid: Scalars[\"GitObjectID\"];\n  /** The full path of the file. */\n  path?: Maybe<Scalars[\"String\"]>;\n  /** The Repository the tree entry belongs to */\n  repository: Repository;\n  /** If the TreeEntry is for a directory occupied by a submodule project, this returns the corresponding submodule */\n  submodule?: Maybe<Submodule>;\n  /** Entry file type. */\n  type: Scalars[\"String\"];\n};\n\n/** Autogenerated input type of UnarchiveRepository */\nexport type UnarchiveRepositoryInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the repository to unarchive. */\n  repositoryId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of UnarchiveRepository */\nexport type UnarchiveRepositoryPayload = {\n  __typename?: \"UnarchiveRepositoryPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The repository that was unarchived. */\n  repository?: Maybe<Repository>;\n};\n\n/** Represents an 'unassigned' event on any assignable object. */\nexport type UnassignedEvent = Node & {\n  __typename?: \"UnassignedEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the assignable associated with the event. */\n  assignable: Assignable;\n  /** Identifies the user or mannequin that was unassigned. */\n  assignee?: Maybe<Assignee>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  id: Scalars[\"ID\"];\n  /**\n   * Identifies the subject (user) who was unassigned.\n   * @deprecated Assignees can now be mannequins. Use the `assignee` field instead. Removal on 2020-01-01 UTC.\n   */\n  user?: Maybe<User>;\n};\n\n/** Autogenerated input type of UnfollowOrganization */\nexport type UnfollowOrganizationInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** ID of the organization to unfollow. */\n  organizationId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of UnfollowOrganization */\nexport type UnfollowOrganizationPayload = {\n  __typename?: \"UnfollowOrganizationPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The organization that was unfollowed. */\n  organization?: Maybe<Organization>;\n};\n\n/** Autogenerated input type of UnfollowUser */\nexport type UnfollowUserInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** ID of the user to unfollow. */\n  userId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of UnfollowUser */\nexport type UnfollowUserPayload = {\n  __typename?: \"UnfollowUserPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The user that was unfollowed. */\n  user?: Maybe<User>;\n};\n\n/** Represents a type that can be retrieved by a URL. */\nexport type UniformResourceLocatable = {\n  /** The HTML path to this resource. */\n  resourcePath: Scalars[\"URI\"];\n  /** The URL to this resource. */\n  url: Scalars[\"URI\"];\n};\n\n/** Represents an unknown signature on a Commit or Tag. */\nexport type UnknownSignature = GitSignature & {\n  __typename?: \"UnknownSignature\";\n  /** Email used to sign this object. */\n  email: Scalars[\"String\"];\n  /** True if the signature is valid and verified by GitHub. */\n  isValid: Scalars[\"Boolean\"];\n  /** Payload for GPG signing object. Raw ODB object without the signature header. */\n  payload: Scalars[\"String\"];\n  /** ASCII-armored signature header from object. */\n  signature: Scalars[\"String\"];\n  /** GitHub user corresponding to the email signing this commit. */\n  signer?: Maybe<User>;\n  /**\n   * The state of this signature. `VALID` if signature is valid and verified by\n   * GitHub, otherwise represents reason why signature is considered invalid.\n   */\n  state: GitSignatureState;\n  /** True if the signature was made with GitHub's signing key. */\n  wasSignedByGitHub: Scalars[\"Boolean\"];\n};\n\n/** Represents an 'unlabeled' event on a given issue or pull request. */\nexport type UnlabeledEvent = Node & {\n  __typename?: \"UnlabeledEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  id: Scalars[\"ID\"];\n  /** Identifies the label associated with the 'unlabeled' event. */\n  label: Label;\n  /** Identifies the `Labelable` associated with the event. */\n  labelable: Labelable;\n};\n\n/** Autogenerated input type of UnlinkRepositoryFromProject */\nexport type UnlinkRepositoryFromProjectInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the Project linked to the Repository. */\n  projectId: Scalars[\"ID\"];\n  /** The ID of the Repository linked to the Project. */\n  repositoryId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of UnlinkRepositoryFromProject */\nexport type UnlinkRepositoryFromProjectPayload = {\n  __typename?: \"UnlinkRepositoryFromProjectPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The linked Project. */\n  project?: Maybe<Project>;\n  /** The linked Repository. */\n  repository?: Maybe<Repository>;\n};\n\n/** Autogenerated input type of UnlockLockable */\nexport type UnlockLockableInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** ID of the item to be unlocked. */\n  lockableId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of UnlockLockable */\nexport type UnlockLockablePayload = {\n  __typename?: \"UnlockLockablePayload\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The item that was unlocked. */\n  unlockedRecord?: Maybe<Lockable>;\n};\n\n/** Represents an 'unlocked' event on a given issue or pull request. */\nexport type UnlockedEvent = Node & {\n  __typename?: \"UnlockedEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  id: Scalars[\"ID\"];\n  /** Object that was unlocked. */\n  lockable: Lockable;\n};\n\n/** Autogenerated input type of UnmarkDiscussionCommentAsAnswer */\nexport type UnmarkDiscussionCommentAsAnswerInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The Node ID of the discussion comment to unmark as an answer. */\n  id: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of UnmarkDiscussionCommentAsAnswer */\nexport type UnmarkDiscussionCommentAsAnswerPayload = {\n  __typename?: \"UnmarkDiscussionCommentAsAnswerPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The discussion that includes the comment. */\n  discussion?: Maybe<Discussion>;\n};\n\n/** Autogenerated input type of UnmarkFileAsViewed */\nexport type UnmarkFileAsViewedInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The path of the file to mark as unviewed */\n  path: Scalars[\"String\"];\n  /** The Node ID of the pull request. */\n  pullRequestId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of UnmarkFileAsViewed */\nexport type UnmarkFileAsViewedPayload = {\n  __typename?: \"UnmarkFileAsViewedPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The updated pull request. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Autogenerated input type of UnmarkIssueAsDuplicate */\nexport type UnmarkIssueAsDuplicateInput = {\n  /** ID of the issue or pull request currently considered canonical/authoritative/original. */\n  canonicalId: Scalars[\"ID\"];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** ID of the issue or pull request currently marked as a duplicate. */\n  duplicateId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of UnmarkIssueAsDuplicate */\nexport type UnmarkIssueAsDuplicatePayload = {\n  __typename?: \"UnmarkIssueAsDuplicatePayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The issue or pull request that was marked as a duplicate. */\n  duplicate?: Maybe<IssueOrPullRequest>;\n};\n\n/** Represents an 'unmarked_as_duplicate' event on a given issue or pull request. */\nexport type UnmarkedAsDuplicateEvent = Node & {\n  __typename?: \"UnmarkedAsDuplicateEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** The authoritative issue or pull request which has been duplicated by another. */\n  canonical?: Maybe<IssueOrPullRequest>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** The issue or pull request which has been marked as a duplicate of another. */\n  duplicate?: Maybe<IssueOrPullRequest>;\n  id: Scalars[\"ID\"];\n  /** Canonical and duplicate belong to different repositories. */\n  isCrossRepository: Scalars[\"Boolean\"];\n};\n\n/** Autogenerated input type of UnminimizeComment */\nexport type UnminimizeCommentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The Node ID of the subject to modify. */\n  subjectId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of UnminimizeComment */\nexport type UnminimizeCommentPayload = {\n  __typename?: \"UnminimizeCommentPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The comment that was unminimized. */\n  unminimizedComment?: Maybe<Minimizable>;\n};\n\n/** Autogenerated input type of UnpinIssue */\nexport type UnpinIssueInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the issue to be unpinned */\n  issueId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of UnpinIssue */\nexport type UnpinIssuePayload = {\n  __typename?: \"UnpinIssuePayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The issue that was unpinned */\n  issue?: Maybe<Issue>;\n};\n\n/** Represents an 'unpinned' event on a given issue or pull request. */\nexport type UnpinnedEvent = Node & {\n  __typename?: \"UnpinnedEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  id: Scalars[\"ID\"];\n  /** Identifies the issue associated with the event. */\n  issue: Issue;\n};\n\n/** Autogenerated input type of UnresolveReviewThread */\nexport type UnresolveReviewThreadInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the thread to unresolve */\n  threadId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of UnresolveReviewThread */\nexport type UnresolveReviewThreadPayload = {\n  __typename?: \"UnresolveReviewThreadPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The thread to resolve. */\n  thread?: Maybe<PullRequestReviewThread>;\n};\n\n/** Represents an 'unsubscribed' event on a given `Subscribable`. */\nexport type UnsubscribedEvent = Node & {\n  __typename?: \"UnsubscribedEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  id: Scalars[\"ID\"];\n  /** Object referenced by event. */\n  subscribable: Subscribable;\n};\n\n/** Entities that can be updated. */\nexport type Updatable = {\n  /** Check if the current viewer can update this object. */\n  viewerCanUpdate: Scalars[\"Boolean\"];\n};\n\n/** Comments that can be updated. */\nexport type UpdatableComment = {\n  /** Reasons why the current viewer can not update this comment. */\n  viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;\n};\n\n/** Autogenerated input type of UpdateBranchProtectionRule */\nexport type UpdateBranchProtectionRuleInput = {\n  /** Can this branch be deleted. */\n  allowsDeletions?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** Are force pushes allowed on this branch. */\n  allowsForcePushes?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** Is branch creation a protected operation. */\n  blocksCreations?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** The global relay id of the branch protection rule to be updated. */\n  branchProtectionRuleId: Scalars[\"ID\"];\n  /** A list of User or Team IDs allowed to bypass force push targeting matching branches. */\n  bypassForcePushActorIds?: InputMaybe<Array<Scalars[\"ID\"]>>;\n  /** A list of User or Team IDs allowed to bypass pull requests targeting matching branches. */\n  bypassPullRequestActorIds?: InputMaybe<Array<Scalars[\"ID\"]>>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** Will new commits pushed to matching branches dismiss pull request review approvals. */\n  dismissesStaleReviews?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** Can admins overwrite branch protection. */\n  isAdminEnforced?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** The glob-like pattern used to determine matching branches. */\n  pattern?: InputMaybe<Scalars[\"String\"]>;\n  /** A list of User, Team or App IDs allowed to push to matching branches. */\n  pushActorIds?: InputMaybe<Array<Scalars[\"ID\"]>>;\n  /** Number of approving reviews required to update matching branches. */\n  requiredApprovingReviewCount?: InputMaybe<Scalars[\"Int\"]>;\n  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */\n  requiredStatusCheckContexts?: InputMaybe<Array<Scalars[\"String\"]>>;\n  /** The list of required status checks */\n  requiredStatusChecks?: InputMaybe<Array<RequiredStatusCheckInput>>;\n  /** Are approving reviews required to update matching branches. */\n  requiresApprovingReviews?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** Are reviews from code owners required to update matching branches. */\n  requiresCodeOwnerReviews?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** Are commits required to be signed. */\n  requiresCommitSignatures?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** Are conversations required to be resolved before merging. */\n  requiresConversationResolution?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** Are merge commits prohibited from being pushed to this branch. */\n  requiresLinearHistory?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** Are status checks required to update matching branches. */\n  requiresStatusChecks?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** Are branches required to be up to date before merging. */\n  requiresStrictStatusChecks?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** Is pushing to matching branches restricted. */\n  restrictsPushes?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** Is dismissal of pull request reviews restricted. */\n  restrictsReviewDismissals?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** A list of User or Team IDs allowed to dismiss reviews on pull requests targeting matching branches. */\n  reviewDismissalActorIds?: InputMaybe<Array<Scalars[\"ID\"]>>;\n};\n\n/** Autogenerated return type of UpdateBranchProtectionRule */\nexport type UpdateBranchProtectionRulePayload = {\n  __typename?: \"UpdateBranchProtectionRulePayload\";\n  /** The newly created BranchProtectionRule. */\n  branchProtectionRule?: Maybe<BranchProtectionRule>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated input type of UpdateCheckRun */\nexport type UpdateCheckRunInput = {\n  /** Possible further actions the integrator can perform, which a user may trigger. */\n  actions?: InputMaybe<Array<CheckRunAction>>;\n  /** The node of the check. */\n  checkRunId: Scalars[\"ID\"];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The time that the check run finished. */\n  completedAt?: InputMaybe<Scalars[\"DateTime\"]>;\n  /** The final conclusion of the check. */\n  conclusion?: InputMaybe<CheckConclusionState>;\n  /** The URL of the integrator's site that has the full details of the check. */\n  detailsUrl?: InputMaybe<Scalars[\"URI\"]>;\n  /** A reference for the run on the integrator's system. */\n  externalId?: InputMaybe<Scalars[\"String\"]>;\n  /** The name of the check. */\n  name?: InputMaybe<Scalars[\"String\"]>;\n  /** Descriptive details about the run. */\n  output?: InputMaybe<CheckRunOutput>;\n  /** The node ID of the repository. */\n  repositoryId: Scalars[\"ID\"];\n  /** The time that the check run began. */\n  startedAt?: InputMaybe<Scalars[\"DateTime\"]>;\n  /** The current status. */\n  status?: InputMaybe<RequestableCheckStatusState>;\n};\n\n/** Autogenerated return type of UpdateCheckRun */\nexport type UpdateCheckRunPayload = {\n  __typename?: \"UpdateCheckRunPayload\";\n  /** The updated check run. */\n  checkRun?: Maybe<CheckRun>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated input type of UpdateCheckSuitePreferences */\nexport type UpdateCheckSuitePreferencesInput = {\n  /** The check suite preferences to modify. */\n  autoTriggerPreferences: Array<CheckSuiteAutoTriggerPreference>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The Node ID of the repository. */\n  repositoryId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of UpdateCheckSuitePreferences */\nexport type UpdateCheckSuitePreferencesPayload = {\n  __typename?: \"UpdateCheckSuitePreferencesPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The updated repository. */\n  repository?: Maybe<Repository>;\n};\n\n/** Autogenerated input type of UpdateDiscussionComment */\nexport type UpdateDiscussionCommentInput = {\n  /** The new contents of the comment body. */\n  body: Scalars[\"String\"];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The Node ID of the discussion comment to update. */\n  commentId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of UpdateDiscussionComment */\nexport type UpdateDiscussionCommentPayload = {\n  __typename?: \"UpdateDiscussionCommentPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The modified discussion comment. */\n  comment?: Maybe<DiscussionComment>;\n};\n\n/** Autogenerated input type of UpdateDiscussion */\nexport type UpdateDiscussionInput = {\n  /** The new contents of the discussion body. */\n  body?: InputMaybe<Scalars[\"String\"]>;\n  /** The Node ID of a discussion category within the same repository to change this discussion to. */\n  categoryId?: InputMaybe<Scalars[\"ID\"]>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The Node ID of the discussion to update. */\n  discussionId: Scalars[\"ID\"];\n  /** The new discussion title. */\n  title?: InputMaybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated return type of UpdateDiscussion */\nexport type UpdateDiscussionPayload = {\n  __typename?: \"UpdateDiscussionPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The modified discussion. */\n  discussion?: Maybe<Discussion>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseAdministratorRole */\nexport type UpdateEnterpriseAdministratorRoleInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the Enterprise which the admin belongs to. */\n  enterpriseId: Scalars[\"ID\"];\n  /** The login of a administrator whose role is being changed. */\n  login: Scalars[\"String\"];\n  /** The new role for the Enterprise administrator. */\n  role: EnterpriseAdministratorRole;\n};\n\n/** Autogenerated return type of UpdateEnterpriseAdministratorRole */\nexport type UpdateEnterpriseAdministratorRolePayload = {\n  __typename?: \"UpdateEnterpriseAdministratorRolePayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** A message confirming the result of changing the administrator's role. */\n  message?: Maybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseAllowPrivateRepositoryForkingSetting */\nexport type UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the enterprise on which to set the allow private repository forking setting. */\n  enterpriseId: Scalars[\"ID\"];\n  /** The value for the allow private repository forking setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue;\n};\n\n/** Autogenerated return type of UpdateEnterpriseAllowPrivateRepositoryForkingSetting */\nexport type UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload = {\n  __typename?: \"UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The enterprise with the updated allow private repository forking setting. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of updating the allow private repository forking setting. */\n  message?: Maybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseDefaultRepositoryPermissionSetting */\nexport type UpdateEnterpriseDefaultRepositoryPermissionSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the enterprise on which to set the base repository permission setting. */\n  enterpriseId: Scalars[\"ID\"];\n  /** The value for the base repository permission setting on the enterprise. */\n  settingValue: EnterpriseDefaultRepositoryPermissionSettingValue;\n};\n\n/** Autogenerated return type of UpdateEnterpriseDefaultRepositoryPermissionSetting */\nexport type UpdateEnterpriseDefaultRepositoryPermissionSettingPayload = {\n  __typename?: \"UpdateEnterpriseDefaultRepositoryPermissionSettingPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The enterprise with the updated base repository permission setting. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of updating the base repository permission setting. */\n  message?: Maybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseMembersCanChangeRepositoryVisibilitySetting */\nexport type UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the enterprise on which to set the members can change repository visibility setting. */\n  enterpriseId: Scalars[\"ID\"];\n  /** The value for the members can change repository visibility setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue;\n};\n\n/** Autogenerated return type of UpdateEnterpriseMembersCanChangeRepositoryVisibilitySetting */\nexport type UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload = {\n  __typename?: \"UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The enterprise with the updated members can change repository visibility setting. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of updating the members can change repository visibility setting. */\n  message?: Maybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseMembersCanCreateRepositoriesSetting */\nexport type UpdateEnterpriseMembersCanCreateRepositoriesSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the enterprise on which to set the members can create repositories setting. */\n  enterpriseId: Scalars[\"ID\"];\n  /** Allow members to create internal repositories. Defaults to current value. */\n  membersCanCreateInternalRepositories?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** Allow members to create private repositories. Defaults to current value. */\n  membersCanCreatePrivateRepositories?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** Allow members to create public repositories. Defaults to current value. */\n  membersCanCreatePublicRepositories?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** When false, allow member organizations to set their own repository creation member privileges. */\n  membersCanCreateRepositoriesPolicyEnabled?: InputMaybe<Scalars[\"Boolean\"]>;\n  /**\n   * Value for the members can create repositories setting on the enterprise. This\n   * or the granular public/private/internal allowed fields (but not both) must be provided.\n   */\n  settingValue?: InputMaybe<EnterpriseMembersCanCreateRepositoriesSettingValue>;\n};\n\n/** Autogenerated return type of UpdateEnterpriseMembersCanCreateRepositoriesSetting */\nexport type UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload = {\n  __typename?: \"UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The enterprise with the updated members can create repositories setting. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of updating the members can create repositories setting. */\n  message?: Maybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseMembersCanDeleteIssuesSetting */\nexport type UpdateEnterpriseMembersCanDeleteIssuesSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the enterprise on which to set the members can delete issues setting. */\n  enterpriseId: Scalars[\"ID\"];\n  /** The value for the members can delete issues setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue;\n};\n\n/** Autogenerated return type of UpdateEnterpriseMembersCanDeleteIssuesSetting */\nexport type UpdateEnterpriseMembersCanDeleteIssuesSettingPayload = {\n  __typename?: \"UpdateEnterpriseMembersCanDeleteIssuesSettingPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The enterprise with the updated members can delete issues setting. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of updating the members can delete issues setting. */\n  message?: Maybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseMembersCanDeleteRepositoriesSetting */\nexport type UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the enterprise on which to set the members can delete repositories setting. */\n  enterpriseId: Scalars[\"ID\"];\n  /** The value for the members can delete repositories setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue;\n};\n\n/** Autogenerated return type of UpdateEnterpriseMembersCanDeleteRepositoriesSetting */\nexport type UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload = {\n  __typename?: \"UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The enterprise with the updated members can delete repositories setting. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of updating the members can delete repositories setting. */\n  message?: Maybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseMembersCanInviteCollaboratorsSetting */\nexport type UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the enterprise on which to set the members can invite collaborators setting. */\n  enterpriseId: Scalars[\"ID\"];\n  /** The value for the members can invite collaborators setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue;\n};\n\n/** Autogenerated return type of UpdateEnterpriseMembersCanInviteCollaboratorsSetting */\nexport type UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload = {\n  __typename?: \"UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The enterprise with the updated members can invite collaborators setting. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of updating the members can invite collaborators setting. */\n  message?: Maybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseMembersCanMakePurchasesSetting */\nexport type UpdateEnterpriseMembersCanMakePurchasesSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the enterprise on which to set the members can make purchases setting. */\n  enterpriseId: Scalars[\"ID\"];\n  /** The value for the members can make purchases setting on the enterprise. */\n  settingValue: EnterpriseMembersCanMakePurchasesSettingValue;\n};\n\n/** Autogenerated return type of UpdateEnterpriseMembersCanMakePurchasesSetting */\nexport type UpdateEnterpriseMembersCanMakePurchasesSettingPayload = {\n  __typename?: \"UpdateEnterpriseMembersCanMakePurchasesSettingPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The enterprise with the updated members can make purchases setting. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of updating the members can make purchases setting. */\n  message?: Maybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseMembersCanUpdateProtectedBranchesSetting */\nexport type UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the enterprise on which to set the members can update protected branches setting. */\n  enterpriseId: Scalars[\"ID\"];\n  /** The value for the members can update protected branches setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue;\n};\n\n/** Autogenerated return type of UpdateEnterpriseMembersCanUpdateProtectedBranchesSetting */\nexport type UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload = {\n  __typename?: \"UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The enterprise with the updated members can update protected branches setting. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of updating the members can update protected branches setting. */\n  message?: Maybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseMembersCanViewDependencyInsightsSetting */\nexport type UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the enterprise on which to set the members can view dependency insights setting. */\n  enterpriseId: Scalars[\"ID\"];\n  /** The value for the members can view dependency insights setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue;\n};\n\n/** Autogenerated return type of UpdateEnterpriseMembersCanViewDependencyInsightsSetting */\nexport type UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload = {\n  __typename?: \"UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The enterprise with the updated members can view dependency insights setting. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of updating the members can view dependency insights setting. */\n  message?: Maybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseOrganizationProjectsSetting */\nexport type UpdateEnterpriseOrganizationProjectsSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the enterprise on which to set the organization projects setting. */\n  enterpriseId: Scalars[\"ID\"];\n  /** The value for the organization projects setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue;\n};\n\n/** Autogenerated return type of UpdateEnterpriseOrganizationProjectsSetting */\nexport type UpdateEnterpriseOrganizationProjectsSettingPayload = {\n  __typename?: \"UpdateEnterpriseOrganizationProjectsSettingPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The enterprise with the updated organization projects setting. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of updating the organization projects setting. */\n  message?: Maybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseOwnerOrganizationRole */\nexport type UpdateEnterpriseOwnerOrganizationRoleInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the Enterprise which the owner belongs to. */\n  enterpriseId: Scalars[\"ID\"];\n  /** The ID of the organization for membership change. */\n  organizationId: Scalars[\"ID\"];\n  /** The role to assume in the organization. */\n  organizationRole: RoleInOrganization;\n};\n\n/** Autogenerated return type of UpdateEnterpriseOwnerOrganizationRole */\nexport type UpdateEnterpriseOwnerOrganizationRolePayload = {\n  __typename?: \"UpdateEnterpriseOwnerOrganizationRolePayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** A message confirming the result of changing the owner's organization role. */\n  message?: Maybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseProfile */\nexport type UpdateEnterpriseProfileInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The description of the enterprise. */\n  description?: InputMaybe<Scalars[\"String\"]>;\n  /** The Enterprise ID to update. */\n  enterpriseId: Scalars[\"ID\"];\n  /** The location of the enterprise. */\n  location?: InputMaybe<Scalars[\"String\"]>;\n  /** The name of the enterprise. */\n  name?: InputMaybe<Scalars[\"String\"]>;\n  /** The URL of the enterprise's website. */\n  websiteUrl?: InputMaybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated return type of UpdateEnterpriseProfile */\nexport type UpdateEnterpriseProfilePayload = {\n  __typename?: \"UpdateEnterpriseProfilePayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The updated enterprise. */\n  enterprise?: Maybe<Enterprise>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseRepositoryProjectsSetting */\nexport type UpdateEnterpriseRepositoryProjectsSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the enterprise on which to set the repository projects setting. */\n  enterpriseId: Scalars[\"ID\"];\n  /** The value for the repository projects setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue;\n};\n\n/** Autogenerated return type of UpdateEnterpriseRepositoryProjectsSetting */\nexport type UpdateEnterpriseRepositoryProjectsSettingPayload = {\n  __typename?: \"UpdateEnterpriseRepositoryProjectsSettingPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The enterprise with the updated repository projects setting. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of updating the repository projects setting. */\n  message?: Maybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseTeamDiscussionsSetting */\nexport type UpdateEnterpriseTeamDiscussionsSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the enterprise on which to set the team discussions setting. */\n  enterpriseId: Scalars[\"ID\"];\n  /** The value for the team discussions setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue;\n};\n\n/** Autogenerated return type of UpdateEnterpriseTeamDiscussionsSetting */\nexport type UpdateEnterpriseTeamDiscussionsSettingPayload = {\n  __typename?: \"UpdateEnterpriseTeamDiscussionsSettingPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The enterprise with the updated team discussions setting. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of updating the team discussions setting. */\n  message?: Maybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseTwoFactorAuthenticationRequiredSetting */\nexport type UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the enterprise on which to set the two factor authentication required setting. */\n  enterpriseId: Scalars[\"ID\"];\n  /** The value for the two factor authentication required setting on the enterprise. */\n  settingValue: EnterpriseEnabledSettingValue;\n};\n\n/** Autogenerated return type of UpdateEnterpriseTwoFactorAuthenticationRequiredSetting */\nexport type UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload = {\n  __typename?: \"UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The enterprise with the updated two factor authentication required setting. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of updating the two factor authentication required setting. */\n  message?: Maybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated input type of UpdateEnvironment */\nexport type UpdateEnvironmentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The node ID of the environment. */\n  environmentId: Scalars[\"ID\"];\n  /** The ids of users or teams that can approve deployments to this environment */\n  reviewers?: InputMaybe<Array<Scalars[\"ID\"]>>;\n  /** The wait timer in minutes. */\n  waitTimer?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** Autogenerated return type of UpdateEnvironment */\nexport type UpdateEnvironmentPayload = {\n  __typename?: \"UpdateEnvironmentPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The updated environment. */\n  environment?: Maybe<Environment>;\n};\n\n/** Autogenerated input type of UpdateIpAllowListEnabledSetting */\nexport type UpdateIpAllowListEnabledSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the owner on which to set the IP allow list enabled setting. */\n  ownerId: Scalars[\"ID\"];\n  /** The value for the IP allow list enabled setting. */\n  settingValue: IpAllowListEnabledSettingValue;\n};\n\n/** Autogenerated return type of UpdateIpAllowListEnabledSetting */\nexport type UpdateIpAllowListEnabledSettingPayload = {\n  __typename?: \"UpdateIpAllowListEnabledSettingPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The IP allow list owner on which the setting was updated. */\n  owner?: Maybe<IpAllowListOwner>;\n};\n\n/** Autogenerated input type of UpdateIpAllowListEntry */\nexport type UpdateIpAllowListEntryInput = {\n  /** An IP address or range of addresses in CIDR notation. */\n  allowListValue: Scalars[\"String\"];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the IP allow list entry to update. */\n  ipAllowListEntryId: Scalars[\"ID\"];\n  /** Whether the IP allow list entry is active when an IP allow list is enabled. */\n  isActive: Scalars[\"Boolean\"];\n  /** An optional name for the IP allow list entry. */\n  name?: InputMaybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated return type of UpdateIpAllowListEntry */\nexport type UpdateIpAllowListEntryPayload = {\n  __typename?: \"UpdateIpAllowListEntryPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The IP allow list entry that was updated. */\n  ipAllowListEntry?: Maybe<IpAllowListEntry>;\n};\n\n/** Autogenerated input type of UpdateIpAllowListForInstalledAppsEnabledSetting */\nexport type UpdateIpAllowListForInstalledAppsEnabledSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the owner. */\n  ownerId: Scalars[\"ID\"];\n  /** The value for the IP allow list configuration for installed GitHub Apps setting. */\n  settingValue: IpAllowListForInstalledAppsEnabledSettingValue;\n};\n\n/** Autogenerated return type of UpdateIpAllowListForInstalledAppsEnabledSetting */\nexport type UpdateIpAllowListForInstalledAppsEnabledSettingPayload = {\n  __typename?: \"UpdateIpAllowListForInstalledAppsEnabledSettingPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The IP allow list owner on which the setting was updated. */\n  owner?: Maybe<IpAllowListOwner>;\n};\n\n/** Autogenerated input type of UpdateIssueComment */\nexport type UpdateIssueCommentInput = {\n  /** The updated text of the comment. */\n  body: Scalars[\"String\"];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the IssueComment to modify. */\n  id: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of UpdateIssueComment */\nexport type UpdateIssueCommentPayload = {\n  __typename?: \"UpdateIssueCommentPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The updated comment. */\n  issueComment?: Maybe<IssueComment>;\n};\n\n/** Autogenerated input type of UpdateIssue */\nexport type UpdateIssueInput = {\n  /** An array of Node IDs of users for this issue. */\n  assigneeIds?: InputMaybe<Array<Scalars[\"ID\"]>>;\n  /** The body for the issue description. */\n  body?: InputMaybe<Scalars[\"String\"]>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the Issue to modify. */\n  id: Scalars[\"ID\"];\n  /** An array of Node IDs of labels for this issue. */\n  labelIds?: InputMaybe<Array<Scalars[\"ID\"]>>;\n  /** The Node ID of the milestone for this issue. */\n  milestoneId?: InputMaybe<Scalars[\"ID\"]>;\n  /** An array of Node IDs for projects associated with this issue. */\n  projectIds?: InputMaybe<Array<Scalars[\"ID\"]>>;\n  /** The desired issue state. */\n  state?: InputMaybe<IssueState>;\n  /** The title for the issue. */\n  title?: InputMaybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated return type of UpdateIssue */\nexport type UpdateIssuePayload = {\n  __typename?: \"UpdateIssuePayload\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The issue. */\n  issue?: Maybe<Issue>;\n};\n\n/** Autogenerated input type of UpdateLabel */\nexport type UpdateLabelInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** A 6 character hex code, without the leading #, identifying the updated color of the label. */\n  color?: InputMaybe<Scalars[\"String\"]>;\n  /** A brief description of the label, such as its purpose. */\n  description?: InputMaybe<Scalars[\"String\"]>;\n  /** The Node ID of the label to be updated. */\n  id: Scalars[\"ID\"];\n  /** The updated name of the label. */\n  name?: InputMaybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated return type of UpdateLabel */\nexport type UpdateLabelPayload = {\n  __typename?: \"UpdateLabelPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The updated label. */\n  label?: Maybe<Label>;\n};\n\n/** Autogenerated input type of UpdateNotificationRestrictionSetting */\nexport type UpdateNotificationRestrictionSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the owner on which to set the restrict notifications setting. */\n  ownerId: Scalars[\"ID\"];\n  /** The value for the restrict notifications setting. */\n  settingValue: NotificationRestrictionSettingValue;\n};\n\n/** Autogenerated return type of UpdateNotificationRestrictionSetting */\nexport type UpdateNotificationRestrictionSettingPayload = {\n  __typename?: \"UpdateNotificationRestrictionSettingPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The owner on which the setting was updated. */\n  owner?: Maybe<VerifiableDomainOwner>;\n};\n\n/** Autogenerated input type of UpdateOrganizationAllowPrivateRepositoryForkingSetting */\nexport type UpdateOrganizationAllowPrivateRepositoryForkingSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** Enable forking of private repositories in the organization? */\n  forkingEnabled: Scalars[\"Boolean\"];\n  /** The ID of the organization on which to set the allow private repository forking setting. */\n  organizationId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of UpdateOrganizationAllowPrivateRepositoryForkingSetting */\nexport type UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload = {\n  __typename?: \"UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** A message confirming the result of updating the allow private repository forking setting. */\n  message?: Maybe<Scalars[\"String\"]>;\n  /** The organization with the updated allow private repository forking setting. */\n  organization?: Maybe<Organization>;\n};\n\n/** Autogenerated input type of UpdateProjectCard */\nexport type UpdateProjectCardInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** Whether or not the ProjectCard should be archived */\n  isArchived?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** The note of ProjectCard. */\n  note?: InputMaybe<Scalars[\"String\"]>;\n  /** The ProjectCard ID to update. */\n  projectCardId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of UpdateProjectCard */\nexport type UpdateProjectCardPayload = {\n  __typename?: \"UpdateProjectCardPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The updated ProjectCard. */\n  projectCard?: Maybe<ProjectCard>;\n};\n\n/** Autogenerated input type of UpdateProjectColumn */\nexport type UpdateProjectColumnInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The name of project column. */\n  name: Scalars[\"String\"];\n  /** The ProjectColumn ID to update. */\n  projectColumnId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of UpdateProjectColumn */\nexport type UpdateProjectColumnPayload = {\n  __typename?: \"UpdateProjectColumnPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The updated project column. */\n  projectColumn?: Maybe<ProjectColumn>;\n};\n\n/** Autogenerated input type of UpdateProjectDraftIssue */\nexport type UpdateProjectDraftIssueInput = {\n  /** The IDs of the assignees of the draft issue. */\n  assigneeIds?: InputMaybe<Array<Scalars[\"ID\"]>>;\n  /** The body of the draft issue. */\n  body?: InputMaybe<Scalars[\"String\"]>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the draft issue to update. */\n  draftIssueId: Scalars[\"ID\"];\n  /** The title of the draft issue. */\n  title?: InputMaybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated return type of UpdateProjectDraftIssue */\nexport type UpdateProjectDraftIssuePayload = {\n  __typename?: \"UpdateProjectDraftIssuePayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The draft issue updated in the project. */\n  draftIssue?: Maybe<DraftIssue>;\n};\n\n/** Autogenerated input type of UpdateProject */\nexport type UpdateProjectInput = {\n  /** The description of project. */\n  body?: InputMaybe<Scalars[\"String\"]>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The name of project. */\n  name?: InputMaybe<Scalars[\"String\"]>;\n  /** The Project ID to update. */\n  projectId: Scalars[\"ID\"];\n  /** Whether the project is public or not. */\n  public?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** Whether the project is open or closed. */\n  state?: InputMaybe<ProjectState>;\n};\n\n/** Autogenerated input type of UpdateProjectNext */\nexport type UpdateProjectNextInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** Set the project to closed or open. */\n  closed?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** Set the readme description of the project. */\n  description?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the Project to update. */\n  projectId: Scalars[\"ID\"];\n  /** Set the project to public or private. */\n  public?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** Set the short description of the project. */\n  shortDescription?: InputMaybe<Scalars[\"String\"]>;\n  /** Set the title of the project. */\n  title?: InputMaybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated input type of UpdateProjectNextItemField */\nexport type UpdateProjectNextItemFieldInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The id of the field to be updated. */\n  fieldId?: InputMaybe<Scalars[\"ID\"]>;\n  /** The id of the item to be updated. */\n  itemId: Scalars[\"ID\"];\n  /** The ID of the Project. */\n  projectId: Scalars[\"ID\"];\n  /** The value which will be set on the field. */\n  value: Scalars[\"String\"];\n};\n\n/** Autogenerated return type of UpdateProjectNextItemField */\nexport type UpdateProjectNextItemFieldPayload = {\n  __typename?: \"UpdateProjectNextItemFieldPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The updated item. */\n  projectNextItem?: Maybe<ProjectNextItem>;\n};\n\n/** Autogenerated return type of UpdateProjectNext */\nexport type UpdateProjectNextPayload = {\n  __typename?: \"UpdateProjectNextPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The updated Project. */\n  projectNext?: Maybe<ProjectNext>;\n};\n\n/** Autogenerated return type of UpdateProject */\nexport type UpdateProjectPayload = {\n  __typename?: \"UpdateProjectPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The updated project. */\n  project?: Maybe<Project>;\n};\n\n/** Autogenerated input type of UpdatePullRequestBranch */\nexport type UpdatePullRequestBranchInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The head ref oid for the upstream branch. */\n  expectedHeadOid?: InputMaybe<Scalars[\"GitObjectID\"]>;\n  /** The Node ID of the pull request. */\n  pullRequestId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of UpdatePullRequestBranch */\nexport type UpdatePullRequestBranchPayload = {\n  __typename?: \"UpdatePullRequestBranchPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The updated pull request. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Autogenerated input type of UpdatePullRequest */\nexport type UpdatePullRequestInput = {\n  /** An array of Node IDs of users for this pull request. */\n  assigneeIds?: InputMaybe<Array<Scalars[\"ID\"]>>;\n  /**\n   * The name of the branch you want your changes pulled into. This should be an existing branch\n   * on the current repository.\n   */\n  baseRefName?: InputMaybe<Scalars[\"String\"]>;\n  /** The contents of the pull request. */\n  body?: InputMaybe<Scalars[\"String\"]>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** An array of Node IDs of labels for this pull request. */\n  labelIds?: InputMaybe<Array<Scalars[\"ID\"]>>;\n  /** Indicates whether maintainers can modify the pull request. */\n  maintainerCanModify?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** The Node ID of the milestone for this pull request. */\n  milestoneId?: InputMaybe<Scalars[\"ID\"]>;\n  /** An array of Node IDs for projects associated with this pull request. */\n  projectIds?: InputMaybe<Array<Scalars[\"ID\"]>>;\n  /** The Node ID of the pull request. */\n  pullRequestId: Scalars[\"ID\"];\n  /** The target state of the pull request. */\n  state?: InputMaybe<PullRequestUpdateState>;\n  /** The title of the pull request. */\n  title?: InputMaybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated return type of UpdatePullRequest */\nexport type UpdatePullRequestPayload = {\n  __typename?: \"UpdatePullRequestPayload\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The updated pull request. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Autogenerated input type of UpdatePullRequestReviewComment */\nexport type UpdatePullRequestReviewCommentInput = {\n  /** The text of the comment. */\n  body: Scalars[\"String\"];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The Node ID of the comment to modify. */\n  pullRequestReviewCommentId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of UpdatePullRequestReviewComment */\nexport type UpdatePullRequestReviewCommentPayload = {\n  __typename?: \"UpdatePullRequestReviewCommentPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The updated comment. */\n  pullRequestReviewComment?: Maybe<PullRequestReviewComment>;\n};\n\n/** Autogenerated input type of UpdatePullRequestReview */\nexport type UpdatePullRequestReviewInput = {\n  /** The contents of the pull request review body. */\n  body: Scalars[\"String\"];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The Node ID of the pull request review to modify. */\n  pullRequestReviewId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of UpdatePullRequestReview */\nexport type UpdatePullRequestReviewPayload = {\n  __typename?: \"UpdatePullRequestReviewPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The updated pull request review. */\n  pullRequestReview?: Maybe<PullRequestReview>;\n};\n\n/** Autogenerated input type of UpdateRef */\nexport type UpdateRefInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** Permit updates of branch Refs that are not fast-forwards? */\n  force?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** The GitObjectID that the Ref shall be updated to target. */\n  oid: Scalars[\"GitObjectID\"];\n  /** The Node ID of the Ref to be updated. */\n  refId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of UpdateRef */\nexport type UpdateRefPayload = {\n  __typename?: \"UpdateRefPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The updated Ref. */\n  ref?: Maybe<Ref>;\n};\n\n/** Autogenerated input type of UpdateRefs */\nexport type UpdateRefsInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** A list of ref updates. */\n  refUpdates: Array<RefUpdate>;\n  /** The Node ID of the repository. */\n  repositoryId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of UpdateRefs */\nexport type UpdateRefsPayload = {\n  __typename?: \"UpdateRefsPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated input type of UpdateRepository */\nexport type UpdateRepositoryInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** A new description for the repository. Pass an empty string to erase the existing description. */\n  description?: InputMaybe<Scalars[\"String\"]>;\n  /** Indicates if the repository should have the issues feature enabled. */\n  hasIssuesEnabled?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** Indicates if the repository should have the project boards feature enabled. */\n  hasProjectsEnabled?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** Indicates if the repository should have the wiki feature enabled. */\n  hasWikiEnabled?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** The URL for a web page about this repository. Pass an empty string to erase the existing URL. */\n  homepageUrl?: InputMaybe<Scalars[\"URI\"]>;\n  /** The new name of the repository. */\n  name?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the repository to update. */\n  repositoryId: Scalars[\"ID\"];\n  /**\n   * Whether this repository should be marked as a template such that anyone who\n   * can access it can create new repositories with the same files and directory structure.\n   */\n  template?: InputMaybe<Scalars[\"Boolean\"]>;\n};\n\n/** Autogenerated return type of UpdateRepository */\nexport type UpdateRepositoryPayload = {\n  __typename?: \"UpdateRepositoryPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The updated repository. */\n  repository?: Maybe<Repository>;\n};\n\n/** Autogenerated input type of UpdateSponsorshipPreferences */\nexport type UpdateSponsorshipPreferencesInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /**\n   * Specify whether others should be able to see that the sponsor is sponsoring\n   * the sponsorable. Public visibility still does not reveal which tier is used.\n   */\n  privacyLevel?: InputMaybe<SponsorshipPrivacy>;\n  /** Whether the sponsor should receive email updates from the sponsorable. */\n  receiveEmails?: InputMaybe<Scalars[\"Boolean\"]>;\n  /**\n   * The ID of the user or organization who is acting as the sponsor, paying for\n   * the sponsorship. Required if sponsorLogin is not given.\n   */\n  sponsorId?: InputMaybe<Scalars[\"ID\"]>;\n  /**\n   * The username of the user or organization who is acting as the sponsor, paying\n   * for the sponsorship. Required if sponsorId is not given.\n   */\n  sponsorLogin?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given. */\n  sponsorableId?: InputMaybe<Scalars[\"ID\"]>;\n  /** The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given. */\n  sponsorableLogin?: InputMaybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated return type of UpdateSponsorshipPreferences */\nexport type UpdateSponsorshipPreferencesPayload = {\n  __typename?: \"UpdateSponsorshipPreferencesPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The sponsorship that was updated. */\n  sponsorship?: Maybe<Sponsorship>;\n};\n\n/** Autogenerated input type of UpdateSubscription */\nexport type UpdateSubscriptionInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The new state of the subscription. */\n  state: SubscriptionState;\n  /** The Node ID of the subscribable object to modify. */\n  subscribableId: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of UpdateSubscription */\nexport type UpdateSubscriptionPayload = {\n  __typename?: \"UpdateSubscriptionPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The input subscribable entity. */\n  subscribable?: Maybe<Subscribable>;\n};\n\n/** Autogenerated input type of UpdateTeamDiscussionComment */\nexport type UpdateTeamDiscussionCommentInput = {\n  /** The updated text of the comment. */\n  body: Scalars[\"String\"];\n  /** The current version of the body content. */\n  bodyVersion?: InputMaybe<Scalars[\"String\"]>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the comment to modify. */\n  id: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of UpdateTeamDiscussionComment */\nexport type UpdateTeamDiscussionCommentPayload = {\n  __typename?: \"UpdateTeamDiscussionCommentPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The updated comment. */\n  teamDiscussionComment?: Maybe<TeamDiscussionComment>;\n};\n\n/** Autogenerated input type of UpdateTeamDiscussion */\nexport type UpdateTeamDiscussionInput = {\n  /** The updated text of the discussion. */\n  body?: InputMaybe<Scalars[\"String\"]>;\n  /**\n   * The current version of the body content. If provided, this update operation\n   * will be rejected if the given version does not match the latest version on the server.\n   */\n  bodyVersion?: InputMaybe<Scalars[\"String\"]>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The Node ID of the discussion to modify. */\n  id: Scalars[\"ID\"];\n  /** If provided, sets the pinned state of the updated discussion. */\n  pinned?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** The updated title of the discussion. */\n  title?: InputMaybe<Scalars[\"String\"]>;\n};\n\n/** Autogenerated return type of UpdateTeamDiscussion */\nexport type UpdateTeamDiscussionPayload = {\n  __typename?: \"UpdateTeamDiscussionPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The updated discussion. */\n  teamDiscussion?: Maybe<TeamDiscussion>;\n};\n\n/** Autogenerated input type of UpdateTeamReviewAssignment */\nexport type UpdateTeamReviewAssignmentInput = {\n  /** The algorithm to use for review assignment */\n  algorithm?: InputMaybe<TeamReviewAssignmentAlgorithm>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** Turn on or off review assignment */\n  enabled: Scalars[\"Boolean\"];\n  /** An array of team member IDs to exclude */\n  excludedTeamMemberIds?: InputMaybe<Array<Scalars[\"ID\"]>>;\n  /** The Node ID of the team to update review assignments of */\n  id: Scalars[\"ID\"];\n  /** Notify the entire team of the PR if it is delegated */\n  notifyTeam?: InputMaybe<Scalars[\"Boolean\"]>;\n  /** The number of team members to assign */\n  teamMemberCount?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** Autogenerated return type of UpdateTeamReviewAssignment */\nexport type UpdateTeamReviewAssignmentPayload = {\n  __typename?: \"UpdateTeamReviewAssignmentPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The team that was modified */\n  team?: Maybe<Team>;\n};\n\n/** Autogenerated input type of UpdateTeamsRepository */\nexport type UpdateTeamsRepositoryInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** Permission that should be granted to the teams. */\n  permission: RepositoryPermission;\n  /** Repository ID being granted access to. */\n  repositoryId: Scalars[\"ID\"];\n  /** A list of teams being granted access. Limit: 10 */\n  teamIds: Array<Scalars[\"ID\"]>;\n};\n\n/** Autogenerated return type of UpdateTeamsRepository */\nexport type UpdateTeamsRepositoryPayload = {\n  __typename?: \"UpdateTeamsRepositoryPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The repository that was updated. */\n  repository?: Maybe<Repository>;\n  /** The teams granted permission on the repository. */\n  teams?: Maybe<Array<Team>>;\n};\n\n/** Autogenerated input type of UpdateTopics */\nexport type UpdateTopicsInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The Node ID of the repository. */\n  repositoryId: Scalars[\"ID\"];\n  /** An array of topic names. */\n  topicNames: Array<Scalars[\"String\"]>;\n};\n\n/** Autogenerated return type of UpdateTopics */\nexport type UpdateTopicsPayload = {\n  __typename?: \"UpdateTopicsPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** Names of the provided topics that are not valid. */\n  invalidTopicNames?: Maybe<Array<Scalars[\"String\"]>>;\n  /** The updated repository. */\n  repository?: Maybe<Repository>;\n};\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type User = Actor &\n  Node &\n  PackageOwner &\n  ProfileOwner &\n  ProjectNextOwner &\n  ProjectOwner &\n  ProjectV2Owner &\n  RepositoryDiscussionAuthor &\n  RepositoryDiscussionCommentAuthor &\n  RepositoryOwner &\n  Sponsorable &\n  UniformResourceLocatable & {\n    __typename?: \"User\";\n    /** Determine if this repository owner has any items that can be pinned to their profile. */\n    anyPinnableItems: Scalars[\"Boolean\"];\n    /** A URL pointing to the user's public avatar. */\n    avatarUrl: Scalars[\"URI\"];\n    /** The user's public profile bio. */\n    bio?: Maybe<Scalars[\"String\"]>;\n    /** The user's public profile bio as HTML. */\n    bioHTML: Scalars[\"HTML\"];\n    /** Could this user receive email notifications, if the organization had notification restrictions enabled? */\n    canReceiveOrganizationEmailsWhenNotificationsRestricted: Scalars[\"Boolean\"];\n    /** A list of commit comments made by this user. */\n    commitComments: CommitCommentConnection;\n    /** The user's public profile company. */\n    company?: Maybe<Scalars[\"String\"]>;\n    /** The user's public profile company as HTML. */\n    companyHTML: Scalars[\"HTML\"];\n    /** The collection of contributions this user has made to different repositories. */\n    contributionsCollection: ContributionsCollection;\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars[\"DateTime\"];\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars[\"Int\"]>;\n    /** The user's publicly visible profile email. */\n    email: Scalars[\"String\"];\n    /** The estimated next GitHub Sponsors payout for this user/organization in cents (USD). */\n    estimatedNextSponsorsPayoutInCents: Scalars[\"Int\"];\n    /** A list of users the given user is followed by. */\n    followers: FollowerConnection;\n    /** A list of users the given user is following. */\n    following: FollowingConnection;\n    /** Find gist by repo name. */\n    gist?: Maybe<Gist>;\n    /** A list of gist comments made by this user. */\n    gistComments: GistCommentConnection;\n    /** A list of the Gists the user has created. */\n    gists: GistConnection;\n    /** True if this user/organization has a GitHub Sponsors listing. */\n    hasSponsorsListing: Scalars[\"Boolean\"];\n    /** The hovercard information for this user in a given context */\n    hovercard: Hovercard;\n    id: Scalars[\"ID\"];\n    /** The interaction ability settings for this user. */\n    interactionAbility?: Maybe<RepositoryInteractionAbility>;\n    /** Whether or not this user is a participant in the GitHub Security Bug Bounty. */\n    isBountyHunter: Scalars[\"Boolean\"];\n    /** Whether or not this user is a participant in the GitHub Campus Experts Program. */\n    isCampusExpert: Scalars[\"Boolean\"];\n    /** Whether or not this user is a GitHub Developer Program member. */\n    isDeveloperProgramMember: Scalars[\"Boolean\"];\n    /** Whether or not this user is a GitHub employee. */\n    isEmployee: Scalars[\"Boolean\"];\n    /** Whether or not this user is following the viewer. Inverse of viewer_is_following */\n    isFollowingViewer: Scalars[\"Boolean\"];\n    /** Whether or not this user is a member of the GitHub Stars Program. */\n    isGitHubStar: Scalars[\"Boolean\"];\n    /** Whether or not the user has marked themselves as for hire. */\n    isHireable: Scalars[\"Boolean\"];\n    /** Whether or not this user is a site administrator. */\n    isSiteAdmin: Scalars[\"Boolean\"];\n    /** Check if the given account is sponsoring this user/organization. */\n    isSponsoredBy: Scalars[\"Boolean\"];\n    /** True if the viewer is sponsored by this user/organization. */\n    isSponsoringViewer: Scalars[\"Boolean\"];\n    /** Whether or not this user is the viewing user. */\n    isViewer: Scalars[\"Boolean\"];\n    /** A list of issue comments made by this user. */\n    issueComments: IssueCommentConnection;\n    /** A list of issues associated with this user. */\n    issues: IssueConnection;\n    /**\n     * Showcases a selection of repositories and gists that the profile owner has\n     * either curated or that have been selected automatically based on popularity.\n     */\n    itemShowcase: ProfileItemShowcase;\n    /** The user's public profile location. */\n    location?: Maybe<Scalars[\"String\"]>;\n    /** The username used to login. */\n    login: Scalars[\"String\"];\n    /** The estimated monthly GitHub Sponsors income for this user/organization in cents (USD). */\n    monthlyEstimatedSponsorsIncomeInCents: Scalars[\"Int\"];\n    /** The user's public profile name. */\n    name?: Maybe<Scalars[\"String\"]>;\n    /** Find an organization by its login that the user belongs to. */\n    organization?: Maybe<Organization>;\n    /** Verified email addresses that match verified domains for a specified organization the user is a member of. */\n    organizationVerifiedDomainEmails: Array<Scalars[\"String\"]>;\n    /** A list of organizations the user belongs to. */\n    organizations: OrganizationConnection;\n    /** A list of packages under the owner. */\n    packages: PackageConnection;\n    /** A list of repositories and gists this profile owner can pin to their profile. */\n    pinnableItems: PinnableItemConnection;\n    /** A list of repositories and gists this profile owner has pinned to their profile */\n    pinnedItems: PinnableItemConnection;\n    /** Returns how many more items this profile owner can pin to their profile. */\n    pinnedItemsRemaining: Scalars[\"Int\"];\n    /** Find project by number. */\n    project?: Maybe<Project>;\n    /** Find a project by project (beta) number. */\n    projectNext?: Maybe<ProjectNext>;\n    /** A list of projects under the owner. */\n    projects: ProjectConnection;\n    /** A list of projects (beta) under the owner. */\n    projectsNext: ProjectNextConnection;\n    /** The HTTP path listing user's projects */\n    projectsResourcePath: Scalars[\"URI\"];\n    /** The HTTP URL listing user's projects */\n    projectsUrl: Scalars[\"URI\"];\n    /** A list of public keys associated with this user. */\n    publicKeys: PublicKeyConnection;\n    /** A list of pull requests associated with this user. */\n    pullRequests: PullRequestConnection;\n    /** A list of repositories that the user owns. */\n    repositories: RepositoryConnection;\n    /** A list of repositories that the user recently contributed to. */\n    repositoriesContributedTo: RepositoryConnection;\n    /** Find Repository. */\n    repository?: Maybe<Repository>;\n    /** Discussion comments this user has authored. */\n    repositoryDiscussionComments: DiscussionCommentConnection;\n    /** Discussions this user has started. */\n    repositoryDiscussions: DiscussionConnection;\n    /** The HTTP path for this user */\n    resourcePath: Scalars[\"URI\"];\n    /** Replies this user has saved */\n    savedReplies?: Maybe<SavedReplyConnection>;\n    /** List of users and organizations this entity is sponsoring. */\n    sponsoring: SponsorConnection;\n    /** List of sponsors for this user or organization. */\n    sponsors: SponsorConnection;\n    /** Events involving this sponsorable, such as new sponsorships. */\n    sponsorsActivities: SponsorsActivityConnection;\n    /** The GitHub Sponsors listing for this user or organization. */\n    sponsorsListing?: Maybe<SponsorsListing>;\n    /**\n     * The sponsorship from the viewer to this user/organization; that is, the\n     * sponsorship where you're the sponsor. Only returns a sponsorship if it is active.\n     */\n    sponsorshipForViewerAsSponsor?: Maybe<Sponsorship>;\n    /**\n     * The sponsorship from this user/organization to the viewer; that is, the\n     * sponsorship you're receiving. Only returns a sponsorship if it is active.\n     */\n    sponsorshipForViewerAsSponsorable?: Maybe<Sponsorship>;\n    /** List of sponsorship updates sent from this sponsorable to sponsors. */\n    sponsorshipNewsletters: SponsorshipNewsletterConnection;\n    /** This object's sponsorships as the maintainer. */\n    sponsorshipsAsMaintainer: SponsorshipConnection;\n    /** This object's sponsorships as the sponsor. */\n    sponsorshipsAsSponsor: SponsorshipConnection;\n    /** Repositories the user has starred. */\n    starredRepositories: StarredRepositoryConnection;\n    /** The user's description of what they're currently doing. */\n    status?: Maybe<UserStatus>;\n    /** Repositories the user has contributed to, ordered by contribution rank, plus repositories the user has created */\n    topRepositories: RepositoryConnection;\n    /** The user's Twitter username. */\n    twitterUsername?: Maybe<Scalars[\"String\"]>;\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars[\"DateTime\"];\n    /** The HTTP URL for this user */\n    url: Scalars[\"URI\"];\n    /** Can the viewer pin repositories and gists to the profile? */\n    viewerCanChangePinnedItems: Scalars[\"Boolean\"];\n    /** Can the current viewer create new projects on this owner. */\n    viewerCanCreateProjects: Scalars[\"Boolean\"];\n    /** Whether or not the viewer is able to follow the user. */\n    viewerCanFollow: Scalars[\"Boolean\"];\n    /** Whether or not the viewer is able to sponsor this user/organization. */\n    viewerCanSponsor: Scalars[\"Boolean\"];\n    /** Whether or not this user is followed by the viewer. Inverse of is_following_viewer. */\n    viewerIsFollowing: Scalars[\"Boolean\"];\n    /** True if the viewer is sponsoring this user/organization. */\n    viewerIsSponsoring: Scalars[\"Boolean\"];\n    /** A list of repositories the given user is watching. */\n    watching: RepositoryConnection;\n    /** A URL pointing to the user's public website/blog. */\n    websiteUrl?: Maybe<Scalars[\"URI\"]>;\n  };\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserAnyPinnableItemsArgs = {\n  type?: InputMaybe<PinnableItemType>;\n};\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserAvatarUrlArgs = {\n  size?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserCanReceiveOrganizationEmailsWhenNotificationsRestrictedArgs = {\n  login: Scalars[\"String\"];\n};\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserCommitCommentsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserContributionsCollectionArgs = {\n  from?: InputMaybe<Scalars[\"DateTime\"]>;\n  organizationID?: InputMaybe<Scalars[\"ID\"]>;\n  to?: InputMaybe<Scalars[\"DateTime\"]>;\n};\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserFollowersArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserFollowingArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserGistArgs = {\n  name: Scalars[\"String\"];\n};\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserGistCommentsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserGistsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<GistOrder>;\n  privacy?: InputMaybe<GistPrivacy>;\n};\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserHovercardArgs = {\n  primarySubjectId?: InputMaybe<Scalars[\"ID\"]>;\n};\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserIsSponsoredByArgs = {\n  accountLogin: Scalars[\"String\"];\n};\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserIssueCommentsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<IssueCommentOrder>;\n};\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserIssuesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  filterBy?: InputMaybe<IssueFilters>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  labels?: InputMaybe<Array<Scalars[\"String\"]>>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<IssueOrder>;\n  states?: InputMaybe<Array<IssueState>>;\n};\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserOrganizationArgs = {\n  login: Scalars[\"String\"];\n};\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserOrganizationVerifiedDomainEmailsArgs = {\n  login: Scalars[\"String\"];\n};\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserOrganizationsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserPackagesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  names?: InputMaybe<Array<InputMaybe<Scalars[\"String\"]>>>;\n  orderBy?: InputMaybe<PackageOrder>;\n  packageType?: InputMaybe<PackageType>;\n  repositoryId?: InputMaybe<Scalars[\"ID\"]>;\n};\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserPinnableItemsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  types?: InputMaybe<Array<PinnableItemType>>;\n};\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserPinnedItemsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  types?: InputMaybe<Array<PinnableItemType>>;\n};\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserProjectArgs = {\n  number: Scalars[\"Int\"];\n};\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserProjectNextArgs = {\n  number: Scalars[\"Int\"];\n};\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserProjectsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<ProjectOrder>;\n  search?: InputMaybe<Scalars[\"String\"]>;\n  states?: InputMaybe<Array<ProjectState>>;\n};\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserProjectsNextArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  query?: InputMaybe<Scalars[\"String\"]>;\n  sortBy?: InputMaybe<ProjectNextOrderField>;\n};\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserPublicKeysArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserPullRequestsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  baseRefName?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  headRefName?: InputMaybe<Scalars[\"String\"]>;\n  labels?: InputMaybe<Array<Scalars[\"String\"]>>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<IssueOrder>;\n  states?: InputMaybe<Array<PullRequestState>>;\n};\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserRepositoriesArgs = {\n  affiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  isFork?: InputMaybe<Scalars[\"Boolean\"]>;\n  isLocked?: InputMaybe<Scalars[\"Boolean\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<RepositoryOrder>;\n  ownerAffiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;\n  privacy?: InputMaybe<RepositoryPrivacy>;\n};\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserRepositoriesContributedToArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  contributionTypes?: InputMaybe<Array<InputMaybe<RepositoryContributionType>>>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  includeUserRepositories?: InputMaybe<Scalars[\"Boolean\"]>;\n  isLocked?: InputMaybe<Scalars[\"Boolean\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<RepositoryOrder>;\n  privacy?: InputMaybe<RepositoryPrivacy>;\n};\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserRepositoryArgs = {\n  followRenames?: InputMaybe<Scalars[\"Boolean\"]>;\n  name: Scalars[\"String\"];\n};\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserRepositoryDiscussionCommentsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  onlyAnswers?: InputMaybe<Scalars[\"Boolean\"]>;\n  repositoryId?: InputMaybe<Scalars[\"ID\"]>;\n};\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserRepositoryDiscussionsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  answered?: InputMaybe<Scalars[\"Boolean\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<DiscussionOrder>;\n  repositoryId?: InputMaybe<Scalars[\"ID\"]>;\n};\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserSavedRepliesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<SavedReplyOrder>;\n};\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserSponsoringArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<SponsorOrder>;\n};\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserSponsorsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<SponsorOrder>;\n  tierId?: InputMaybe<Scalars[\"ID\"]>;\n};\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserSponsorsActivitiesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<SponsorsActivityOrder>;\n  period?: InputMaybe<SponsorsActivityPeriod>;\n};\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserSponsorshipNewslettersArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<SponsorshipNewsletterOrder>;\n};\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserSponsorshipsAsMaintainerArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  includePrivate?: InputMaybe<Scalars[\"Boolean\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<SponsorshipOrder>;\n};\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserSponsorshipsAsSponsorArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<SponsorshipOrder>;\n};\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserStarredRepositoriesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<StarOrder>;\n  ownedByViewer?: InputMaybe<Scalars[\"Boolean\"]>;\n};\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserTopRepositoriesArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy: RepositoryOrder;\n  since?: InputMaybe<Scalars[\"DateTime\"]>;\n};\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserWatchingArgs = {\n  affiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  isLocked?: InputMaybe<Scalars[\"Boolean\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n  orderBy?: InputMaybe<RepositoryOrder>;\n  ownerAffiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;\n  privacy?: InputMaybe<RepositoryPrivacy>;\n};\n\n/** The possible durations that a user can be blocked for. */\nexport enum UserBlockDuration {\n  /** The user was blocked for 1 day */\n  OneDay = \"ONE_DAY\",\n  /** The user was blocked for 30 days */\n  OneMonth = \"ONE_MONTH\",\n  /** The user was blocked for 7 days */\n  OneWeek = \"ONE_WEEK\",\n  /** The user was blocked permanently */\n  Permanent = \"PERMANENT\",\n  /** The user was blocked for 3 days */\n  ThreeDays = \"THREE_DAYS\",\n}\n\n/** Represents a 'user_blocked' event on a given user. */\nexport type UserBlockedEvent = Node & {\n  __typename?: \"UserBlockedEvent\";\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Number of days that the user was blocked for. */\n  blockDuration: UserBlockDuration;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  id: Scalars[\"ID\"];\n  /** The user who was blocked. */\n  subject?: Maybe<User>;\n};\n\n/** The connection type for User. */\nexport type UserConnection = {\n  __typename?: \"UserConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<UserEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edit on user content */\nexport type UserContentEdit = Node & {\n  __typename?: \"UserContentEdit\";\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** Identifies the date and time when the object was deleted. */\n  deletedAt?: Maybe<Scalars[\"DateTime\"]>;\n  /** The actor who deleted this content */\n  deletedBy?: Maybe<Actor>;\n  /** A summary of the changes for this edit */\n  diff?: Maybe<Scalars[\"String\"]>;\n  /** When this content was edited */\n  editedAt: Scalars[\"DateTime\"];\n  /** The actor who edited this content */\n  editor?: Maybe<Actor>;\n  id: Scalars[\"ID\"];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars[\"DateTime\"];\n};\n\n/** A list of edits to content. */\nexport type UserContentEditConnection = {\n  __typename?: \"UserContentEditConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<UserContentEditEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<UserContentEdit>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type UserContentEditEdge = {\n  __typename?: \"UserContentEditEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<UserContentEdit>;\n};\n\n/** Represents a user. */\nexport type UserEdge = {\n  __typename?: \"UserEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<User>;\n};\n\n/** Email attributes from External Identity */\nexport type UserEmailMetadata = {\n  __typename?: \"UserEmailMetadata\";\n  /** Boolean to identify primary emails */\n  primary?: Maybe<Scalars[\"Boolean\"]>;\n  /** Type of email */\n  type?: Maybe<Scalars[\"String\"]>;\n  /** Email id */\n  value: Scalars[\"String\"];\n};\n\n/** The user's description of what they're currently doing. */\nexport type UserStatus = Node & {\n  __typename?: \"UserStatus\";\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** An emoji summarizing the user's status. */\n  emoji?: Maybe<Scalars[\"String\"]>;\n  /** The status emoji as HTML. */\n  emojiHTML?: Maybe<Scalars[\"HTML\"]>;\n  /** If set, the status will not be shown after this date. */\n  expiresAt?: Maybe<Scalars[\"DateTime\"]>;\n  id: Scalars[\"ID\"];\n  /** Whether this status indicates the user is not fully available on GitHub. */\n  indicatesLimitedAvailability: Scalars[\"Boolean\"];\n  /** A brief message describing what the user is doing. */\n  message?: Maybe<Scalars[\"String\"]>;\n  /** The organization whose members can see this status. If null, this status is publicly visible. */\n  organization?: Maybe<Organization>;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars[\"DateTime\"];\n  /** The user who has this status. */\n  user: User;\n};\n\n/** The connection type for UserStatus. */\nexport type UserStatusConnection = {\n  __typename?: \"UserStatusConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<UserStatusEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<UserStatus>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type UserStatusEdge = {\n  __typename?: \"UserStatusEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<UserStatus>;\n};\n\n/** Ordering options for user status connections. */\nexport type UserStatusOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order user statuses by. */\n  field: UserStatusOrderField;\n};\n\n/** Properties by which user status connections can be ordered. */\nexport enum UserStatusOrderField {\n  /** Order user statuses by when they were updated. */\n  UpdatedAt = \"UPDATED_AT\",\n}\n\n/** A domain that can be verified or approved for an organization or an enterprise. */\nexport type VerifiableDomain = Node & {\n  __typename?: \"VerifiableDomain\";\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars[\"Int\"]>;\n  /** The DNS host name that should be used for verification. */\n  dnsHostName?: Maybe<Scalars[\"URI\"]>;\n  /** The unicode encoded domain. */\n  domain: Scalars[\"URI\"];\n  /** Whether a TXT record for verification with the expected host name was found. */\n  hasFoundHostName: Scalars[\"Boolean\"];\n  /** Whether a TXT record for verification with the expected verification token was found. */\n  hasFoundVerificationToken: Scalars[\"Boolean\"];\n  id: Scalars[\"ID\"];\n  /** Whether or not the domain is approved. */\n  isApproved: Scalars[\"Boolean\"];\n  /** Whether this domain is required to exist for an organization or enterprise policy to be enforced. */\n  isRequiredForPolicyEnforcement: Scalars[\"Boolean\"];\n  /** Whether or not the domain is verified. */\n  isVerified: Scalars[\"Boolean\"];\n  /** The owner of the domain. */\n  owner: VerifiableDomainOwner;\n  /** The punycode encoded domain. */\n  punycodeEncodedDomain: Scalars[\"URI\"];\n  /** The time that the current verification token will expire. */\n  tokenExpirationTime?: Maybe<Scalars[\"DateTime\"]>;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars[\"DateTime\"];\n  /** The current verification token for the domain. */\n  verificationToken?: Maybe<Scalars[\"String\"]>;\n};\n\n/** The connection type for VerifiableDomain. */\nexport type VerifiableDomainConnection = {\n  __typename?: \"VerifiableDomainConnection\";\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<VerifiableDomainEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<VerifiableDomain>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars[\"Int\"];\n};\n\n/** An edge in a connection. */\nexport type VerifiableDomainEdge = {\n  __typename?: \"VerifiableDomainEdge\";\n  /** A cursor for use in pagination. */\n  cursor: Scalars[\"String\"];\n  /** The item at the end of the edge. */\n  node?: Maybe<VerifiableDomain>;\n};\n\n/** Ordering options for verifiable domain connections. */\nexport type VerifiableDomainOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order verifiable domains by. */\n  field: VerifiableDomainOrderField;\n};\n\n/** Properties by which verifiable domain connections can be ordered. */\nexport enum VerifiableDomainOrderField {\n  /** Order verifiable domains by their creation date. */\n  CreatedAt = \"CREATED_AT\",\n  /** Order verifiable domains by the domain name. */\n  Domain = \"DOMAIN\",\n}\n\n/** Types that can own a verifiable domain. */\nexport type VerifiableDomainOwner = Enterprise | Organization;\n\n/** Autogenerated input type of VerifyVerifiableDomain */\nexport type VerifyVerifiableDomainInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars[\"String\"]>;\n  /** The ID of the verifiable domain to verify. */\n  id: Scalars[\"ID\"];\n};\n\n/** Autogenerated return type of VerifyVerifiableDomain */\nexport type VerifyVerifiableDomainPayload = {\n  __typename?: \"VerifyVerifiableDomainPayload\";\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars[\"String\"]>;\n  /** The verifiable domain that was verified. */\n  domain?: Maybe<VerifiableDomain>;\n};\n\n/** A hovercard context with a message describing how the viewer is related. */\nexport type ViewerHovercardContext = HovercardContext & {\n  __typename?: \"ViewerHovercardContext\";\n  /** A string describing this context */\n  message: Scalars[\"String\"];\n  /** An octicon to accompany this context */\n  octicon: Scalars[\"String\"];\n  /** Identifies the user who is related to this context. */\n  viewer: User;\n};\n\n/** A subject that may be upvoted. */\nexport type Votable = {\n  /** Number of upvotes that this subject has received. */\n  upvoteCount: Scalars[\"Int\"];\n  /** Whether or not the current user can add or remove an upvote on this subject. */\n  viewerCanUpvote: Scalars[\"Boolean\"];\n  /** Whether or not the current user has already upvoted this subject. */\n  viewerHasUpvoted: Scalars[\"Boolean\"];\n};\n\n/** A workflow contains meta information about an Actions workflow file. */\nexport type Workflow = Node & {\n  __typename?: \"Workflow\";\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars[\"Int\"]>;\n  id: Scalars[\"ID\"];\n  /** The name of the workflow. */\n  name: Scalars[\"String\"];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars[\"DateTime\"];\n};\n\n/** A workflow run. */\nexport type WorkflowRun = Node & {\n  __typename?: \"WorkflowRun\";\n  /** The check suite this workflow run belongs to. */\n  checkSuite: CheckSuite;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars[\"DateTime\"];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars[\"Int\"]>;\n  /** The log of deployment reviews */\n  deploymentReviews: DeploymentReviewConnection;\n  id: Scalars[\"ID\"];\n  /** The pending deployment requests of all check runs in this workflow run */\n  pendingDeploymentRequests: DeploymentRequestConnection;\n  /** The HTTP path for this workflow run */\n  resourcePath: Scalars[\"URI\"];\n  /** A number that uniquely identifies this workflow run in its parent workflow. */\n  runNumber: Scalars[\"Int\"];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars[\"DateTime\"];\n  /** The HTTP URL for this workflow run */\n  url: Scalars[\"URI\"];\n  /** The workflow executed in this workflow run. */\n  workflow: Workflow;\n};\n\n/** A workflow run. */\nexport type WorkflowRunDeploymentReviewsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n\n/** A workflow run. */\nexport type WorkflowRunPendingDeploymentRequestsArgs = {\n  after?: InputMaybe<Scalars[\"String\"]>;\n  before?: InputMaybe<Scalars[\"String\"]>;\n  first?: InputMaybe<Scalars[\"Int\"]>;\n  last?: InputMaybe<Scalars[\"Int\"]>;\n};\n","import { HttpLink } from \"@apollo/client\";\nimport { setContext } from \"@apollo/client/link/context\";\nimport { onError } from \"@apollo/client/link/error\";\n// import { generateFetchWithTimeout } from \"@site/axios\";\nimport { fetch } from \"cross-fetch\";\n\nconst BLOG_API = \"https://api.github.com/graphql\";\n\nconst isBrowser = typeof window !== \"undefined\";\n\nexport const httpLink = new HttpLink({\n  uri: BLOG_API,\n  fetch,\n});\n\nexport const onErrorLink = onError(({ networkError, graphQLErrors }) => {\n  if (networkError) {\n    console.error(`network error \\n[message]: ${networkError.message}  \\n[stack]: ${networkError.stack}`);\n  }\n  if (graphQLErrors?.length) {\n    graphQLErrors.forEach((error) => {\n      console.error(`graphql error \\n[message]: ${error.message} \\n[stack]: ${error.stack}`);\n    });\n  }\n});\n\nexport const authLink = setContext((_, { headers }) => {\n  return {\n    headers: {\n      ...headers,\n      Authorization: `token ${\n        isBrowser\n          ? atob(\"Z2hwX2JMeHRuN2N4dGZjc0M5OXBVTlgzZmJ5dHFBejI2RjFEUHZ5TA==\")\n          : Buffer.from(\"Z2hwX2JMeHRuN2N4dGZjc0M5OXBVTlgzZmJ5dHFBejI2RjFEUHZ5TA==\", \"base64\").toString()\n      }`,\n    },\n  };\n});\n","/* eslint-disable */\n// @ts-nocheck\n\nimport type * as SchemaTypes from \"./schema\";\n\nimport type { TypedDocumentNode as DocumentNode } from \"@graphql-typed-document-node/core\";\nexport type GetViewerQueryVariables = SchemaTypes.Exact<{\n  first?: SchemaTypes.InputMaybe<SchemaTypes.Scalars[\"Int\"]>;\n}>;\n\nexport type GetViewerQuery = {\n  viewer: {\n    id: string;\n    name?: string | null;\n    login: string;\n    email: string;\n    createdAt: any;\n    avatarUrl: any;\n    websiteUrl?: any | null;\n    projectsUrl: any;\n    followers: { nodes?: Array<{ id: string; name?: string | null; login: string; email: string; bioHTML: any; avatarUrl: any } | null> | null };\n    following: { nodes?: Array<{ id: string; name?: string | null; login: string; email: string; bioHTML: any; avatarUrl: any } | null> | null };\n  };\n};\n\nexport type GetBlogListQueryVariables = SchemaTypes.Exact<{\n  name: SchemaTypes.Scalars[\"String\"];\n  owner: SchemaTypes.Scalars[\"String\"];\n  first?: SchemaTypes.InputMaybe<SchemaTypes.Scalars[\"Int\"]>;\n  last?: SchemaTypes.InputMaybe<SchemaTypes.Scalars[\"Int\"]>;\n  after?: SchemaTypes.InputMaybe<SchemaTypes.Scalars[\"String\"]>;\n  before?: SchemaTypes.InputMaybe<SchemaTypes.Scalars[\"String\"]>;\n  labels?: SchemaTypes.InputMaybe<Array<SchemaTypes.Scalars[\"String\"]> | SchemaTypes.Scalars[\"String\"]>;\n  orderBy?: SchemaTypes.InputMaybe<SchemaTypes.IssueOrder>;\n  states?: SchemaTypes.InputMaybe<Array<SchemaTypes.IssueState> | SchemaTypes.IssueState>;\n  filterBy?: SchemaTypes.InputMaybe<SchemaTypes.IssueFilters>;\n}>;\n\nexport type GetBlogListQuery = {\n  repository?: {\n    id: string;\n    issues: {\n      totalCount: number;\n      nodes?: Array<{\n        id: string;\n        number: number;\n        createdAt: any;\n        publishedAt?: any | null;\n        updatedAt: any;\n        state: SchemaTypes.IssueState;\n        title: string;\n        body: string;\n        bodyText: string;\n        url: any;\n        author?:\n          | { login: string; avatarUrl: any }\n          | { login: string; avatarUrl: any }\n          | { login: string; avatarUrl: any }\n          | { login: string; avatarUrl: any }\n          | { login: string; avatarUrl: any }\n          | null;\n      } | null> | null;\n      pageInfo: { endCursor?: string | null; startCursor?: string | null; hasNextPage: boolean; hasPreviousPage: boolean };\n    };\n  } | null;\n};\n\nexport type GetSingleBlogQueryVariables = SchemaTypes.Exact<{\n  name: SchemaTypes.Scalars[\"String\"];\n  owner: SchemaTypes.Scalars[\"String\"];\n  number: SchemaTypes.Scalars[\"Int\"];\n  first?: SchemaTypes.InputMaybe<SchemaTypes.Scalars[\"Int\"]>;\n  after?: SchemaTypes.InputMaybe<SchemaTypes.Scalars[\"String\"]>;\n}>;\n\nexport type GetSingleBlogQuery = {\n  repository?: {\n    id: string;\n    issue?: {\n      id: string;\n      body: string;\n      title: string;\n      number: number;\n      createdAt: any;\n      publishedAt?: any | null;\n      updatedAt: any;\n      author?:\n        | { login: string; avatarUrl: any }\n        | { login: string; avatarUrl: any }\n        | { login: string; avatarUrl: any }\n        | { login: string; avatarUrl: any }\n        | { login: string; avatarUrl: any }\n        | null;\n      comments: {\n        totalCount: number;\n        nodes?: Array<{\n          id: string;\n          body: string;\n          createdAt: any;\n          updatedAt: any;\n          viewerDidAuthor: boolean;\n          author?:\n            | { login: string; avatarUrl: any }\n            | { login: string; avatarUrl: any }\n            | { login: string; avatarUrl: any }\n            | { login: string; avatarUrl: any }\n            | { login: string; avatarUrl: any }\n            | null;\n        } | null> | null;\n        pageInfo: { endCursor?: string | null; startCursor?: string | null; hasNextPage: boolean; hasPreviousPage: boolean };\n      };\n    } | null;\n  } | null;\n};\n\nexport const GetViewerDocument = {\n  kind: \"Document\",\n  definitions: [\n    {\n      kind: \"OperationDefinition\",\n      operation: \"query\",\n      name: { kind: \"Name\", value: \"getViewer\" },\n      variableDefinitions: [\n        {\n          kind: \"VariableDefinition\",\n          variable: { kind: \"Variable\", name: { kind: \"Name\", value: \"first\" } },\n          type: { kind: \"NamedType\", name: { kind: \"Name\", value: \"Int\" } },\n          defaultValue: { kind: \"IntValue\", value: \"10\" },\n        },\n      ],\n      selectionSet: {\n        kind: \"SelectionSet\",\n        selections: [\n          {\n            kind: \"Field\",\n            name: { kind: \"Name\", value: \"viewer\" },\n            selectionSet: {\n              kind: \"SelectionSet\",\n              selections: [\n                { kind: \"Field\", name: { kind: \"Name\", value: \"id\" } },\n                { kind: \"Field\", name: { kind: \"Name\", value: \"name\" } },\n                { kind: \"Field\", name: { kind: \"Name\", value: \"login\" } },\n                { kind: \"Field\", name: { kind: \"Name\", value: \"email\" } },\n                { kind: \"Field\", name: { kind: \"Name\", value: \"createdAt\" } },\n                { kind: \"Field\", name: { kind: \"Name\", value: \"avatarUrl\" } },\n                { kind: \"Field\", name: { kind: \"Name\", value: \"websiteUrl\" } },\n                { kind: \"Field\", name: { kind: \"Name\", value: \"projectsUrl\" } },\n                {\n                  kind: \"Field\",\n                  name: { kind: \"Name\", value: \"followers\" },\n                  arguments: [\n                    { kind: \"Argument\", name: { kind: \"Name\", value: \"first\" }, value: { kind: \"Variable\", name: { kind: \"Name\", value: \"first\" } } },\n                  ],\n                  selectionSet: {\n                    kind: \"SelectionSet\",\n                    selections: [\n                      {\n                        kind: \"Field\",\n                        name: { kind: \"Name\", value: \"nodes\" },\n                        selectionSet: {\n                          kind: \"SelectionSet\",\n                          selections: [\n                            { kind: \"Field\", name: { kind: \"Name\", value: \"id\" } },\n                            { kind: \"Field\", name: { kind: \"Name\", value: \"name\" } },\n                            { kind: \"Field\", name: { kind: \"Name\", value: \"login\" } },\n                            { kind: \"Field\", name: { kind: \"Name\", value: \"email\" } },\n                            { kind: \"Field\", name: { kind: \"Name\", value: \"bioHTML\" } },\n                            { kind: \"Field\", name: { kind: \"Name\", value: \"avatarUrl\" } },\n                          ],\n                        },\n                      },\n                    ],\n                  },\n                },\n                {\n                  kind: \"Field\",\n                  name: { kind: \"Name\", value: \"following\" },\n                  arguments: [\n                    { kind: \"Argument\", name: { kind: \"Name\", value: \"first\" }, value: { kind: \"Variable\", name: { kind: \"Name\", value: \"first\" } } },\n                  ],\n                  selectionSet: {\n                    kind: \"SelectionSet\",\n                    selections: [\n                      {\n                        kind: \"Field\",\n                        name: { kind: \"Name\", value: \"nodes\" },\n                        selectionSet: {\n                          kind: \"SelectionSet\",\n                          selections: [\n                            { kind: \"Field\", name: { kind: \"Name\", value: \"id\" } },\n                            { kind: \"Field\", name: { kind: \"Name\", value: \"name\" } },\n                            { kind: \"Field\", name: { kind: \"Name\", value: \"login\" } },\n                            { kind: \"Field\", name: { kind: \"Name\", value: \"email\" } },\n                            { kind: \"Field\", name: { kind: \"Name\", value: \"bioHTML\" } },\n                            { kind: \"Field\", name: { kind: \"Name\", value: \"avatarUrl\" } },\n                          ],\n                        },\n                      },\n                    ],\n                  },\n                },\n              ],\n            },\n          },\n        ],\n      },\n    },\n  ],\n} as unknown as DocumentNode<GetViewerQuery, GetViewerQueryVariables>;\nexport const GetBlogListDocument = {\n  kind: \"Document\",\n  definitions: [\n    {\n      kind: \"OperationDefinition\",\n      operation: \"query\",\n      name: { kind: \"Name\", value: \"getBlogList\" },\n      variableDefinitions: [\n        {\n          kind: \"VariableDefinition\",\n          variable: { kind: \"Variable\", name: { kind: \"Name\", value: \"name\" } },\n          type: { kind: \"NonNullType\", type: { kind: \"NamedType\", name: { kind: \"Name\", value: \"String\" } } },\n        },\n        {\n          kind: \"VariableDefinition\",\n          variable: { kind: \"Variable\", name: { kind: \"Name\", value: \"owner\" } },\n          type: { kind: \"NonNullType\", type: { kind: \"NamedType\", name: { kind: \"Name\", value: \"String\" } } },\n        },\n        {\n          kind: \"VariableDefinition\",\n          variable: { kind: \"Variable\", name: { kind: \"Name\", value: \"first\" } },\n          type: { kind: \"NamedType\", name: { kind: \"Name\", value: \"Int\" } },\n        },\n        {\n          kind: \"VariableDefinition\",\n          variable: { kind: \"Variable\", name: { kind: \"Name\", value: \"last\" } },\n          type: { kind: \"NamedType\", name: { kind: \"Name\", value: \"Int\" } },\n        },\n        {\n          kind: \"VariableDefinition\",\n          variable: { kind: \"Variable\", name: { kind: \"Name\", value: \"after\" } },\n          type: { kind: \"NamedType\", name: { kind: \"Name\", value: \"String\" } },\n        },\n        {\n          kind: \"VariableDefinition\",\n          variable: { kind: \"Variable\", name: { kind: \"Name\", value: \"before\" } },\n          type: { kind: \"NamedType\", name: { kind: \"Name\", value: \"String\" } },\n        },\n        {\n          kind: \"VariableDefinition\",\n          variable: { kind: \"Variable\", name: { kind: \"Name\", value: \"labels\" } },\n          type: { kind: \"ListType\", type: { kind: \"NonNullType\", type: { kind: \"NamedType\", name: { kind: \"Name\", value: \"String\" } } } },\n        },\n        {\n          kind: \"VariableDefinition\",\n          variable: { kind: \"Variable\", name: { kind: \"Name\", value: \"orderBy\" } },\n          type: { kind: \"NamedType\", name: { kind: \"Name\", value: \"IssueOrder\" } },\n        },\n        {\n          kind: \"VariableDefinition\",\n          variable: { kind: \"Variable\", name: { kind: \"Name\", value: \"states\" } },\n          type: { kind: \"ListType\", type: { kind: \"NonNullType\", type: { kind: \"NamedType\", name: { kind: \"Name\", value: \"IssueState\" } } } },\n        },\n        {\n          kind: \"VariableDefinition\",\n          variable: { kind: \"Variable\", name: { kind: \"Name\", value: \"filterBy\" } },\n          type: { kind: \"NamedType\", name: { kind: \"Name\", value: \"IssueFilters\" } },\n        },\n      ],\n      selectionSet: {\n        kind: \"SelectionSet\",\n        selections: [\n          {\n            kind: \"Field\",\n            name: { kind: \"Name\", value: \"repository\" },\n            arguments: [\n              { kind: \"Argument\", name: { kind: \"Name\", value: \"name\" }, value: { kind: \"Variable\", name: { kind: \"Name\", value: \"name\" } } },\n              { kind: \"Argument\", name: { kind: \"Name\", value: \"owner\" }, value: { kind: \"Variable\", name: { kind: \"Name\", value: \"owner\" } } },\n            ],\n            selectionSet: {\n              kind: \"SelectionSet\",\n              selections: [\n                { kind: \"Field\", name: { kind: \"Name\", value: \"id\" } },\n                {\n                  kind: \"Field\",\n                  name: { kind: \"Name\", value: \"issues\" },\n                  arguments: [\n                    { kind: \"Argument\", name: { kind: \"Name\", value: \"first\" }, value: { kind: \"Variable\", name: { kind: \"Name\", value: \"first\" } } },\n                    { kind: \"Argument\", name: { kind: \"Name\", value: \"last\" }, value: { kind: \"Variable\", name: { kind: \"Name\", value: \"last\" } } },\n                    { kind: \"Argument\", name: { kind: \"Name\", value: \"after\" }, value: { kind: \"Variable\", name: { kind: \"Name\", value: \"after\" } } },\n                    { kind: \"Argument\", name: { kind: \"Name\", value: \"before\" }, value: { kind: \"Variable\", name: { kind: \"Name\", value: \"before\" } } },\n                    { kind: \"Argument\", name: { kind: \"Name\", value: \"labels\" }, value: { kind: \"Variable\", name: { kind: \"Name\", value: \"labels\" } } },\n                    { kind: \"Argument\", name: { kind: \"Name\", value: \"orderBy\" }, value: { kind: \"Variable\", name: { kind: \"Name\", value: \"orderBy\" } } },\n                    { kind: \"Argument\", name: { kind: \"Name\", value: \"states\" }, value: { kind: \"Variable\", name: { kind: \"Name\", value: \"states\" } } },\n                    { kind: \"Argument\", name: { kind: \"Name\", value: \"filterBy\" }, value: { kind: \"Variable\", name: { kind: \"Name\", value: \"filterBy\" } } },\n                  ],\n                  selectionSet: {\n                    kind: \"SelectionSet\",\n                    selections: [\n                      {\n                        kind: \"Field\",\n                        name: { kind: \"Name\", value: \"nodes\" },\n                        selectionSet: {\n                          kind: \"SelectionSet\",\n                          selections: [\n                            { kind: \"Field\", name: { kind: \"Name\", value: \"id\" } },\n                            {\n                              kind: \"Field\",\n                              name: { kind: \"Name\", value: \"author\" },\n                              selectionSet: {\n                                kind: \"SelectionSet\",\n                                selections: [\n                                  { kind: \"Field\", name: { kind: \"Name\", value: \"login\" } },\n                                  { kind: \"Field\", name: { kind: \"Name\", value: \"avatarUrl\" } },\n                                ],\n                              },\n                            },\n                            { kind: \"Field\", name: { kind: \"Name\", value: \"number\" } },\n                            { kind: \"Field\", name: { kind: \"Name\", value: \"createdAt\" } },\n                            { kind: \"Field\", name: { kind: \"Name\", value: \"publishedAt\" } },\n                            { kind: \"Field\", name: { kind: \"Name\", value: \"updatedAt\" } },\n                            { kind: \"Field\", name: { kind: \"Name\", value: \"state\" } },\n                            { kind: \"Field\", name: { kind: \"Name\", value: \"title\" } },\n                            { kind: \"Field\", name: { kind: \"Name\", value: \"body\" } },\n                            { kind: \"Field\", name: { kind: \"Name\", value: \"bodyText\" } },\n                            { kind: \"Field\", name: { kind: \"Name\", value: \"url\" } },\n                          ],\n                        },\n                      },\n                      {\n                        kind: \"Field\",\n                        name: { kind: \"Name\", value: \"pageInfo\" },\n                        selectionSet: {\n                          kind: \"SelectionSet\",\n                          selections: [\n                            { kind: \"Field\", name: { kind: \"Name\", value: \"endCursor\" } },\n                            { kind: \"Field\", name: { kind: \"Name\", value: \"startCursor\" } },\n                            { kind: \"Field\", name: { kind: \"Name\", value: \"hasNextPage\" } },\n                            { kind: \"Field\", name: { kind: \"Name\", value: \"hasPreviousPage\" } },\n                          ],\n                        },\n                      },\n                      { kind: \"Field\", name: { kind: \"Name\", value: \"totalCount\" } },\n                    ],\n                  },\n                },\n              ],\n            },\n          },\n        ],\n      },\n    },\n  ],\n} as unknown as DocumentNode<GetBlogListQuery, GetBlogListQueryVariables>;\nexport const GetSingleBlogDocument = {\n  kind: \"Document\",\n  definitions: [\n    {\n      kind: \"OperationDefinition\",\n      operation: \"query\",\n      name: { kind: \"Name\", value: \"getSingleBlog\" },\n      variableDefinitions: [\n        {\n          kind: \"VariableDefinition\",\n          variable: { kind: \"Variable\", name: { kind: \"Name\", value: \"name\" } },\n          type: { kind: \"NonNullType\", type: { kind: \"NamedType\", name: { kind: \"Name\", value: \"String\" } } },\n        },\n        {\n          kind: \"VariableDefinition\",\n          variable: { kind: \"Variable\", name: { kind: \"Name\", value: \"owner\" } },\n          type: { kind: \"NonNullType\", type: { kind: \"NamedType\", name: { kind: \"Name\", value: \"String\" } } },\n        },\n        {\n          kind: \"VariableDefinition\",\n          variable: { kind: \"Variable\", name: { kind: \"Name\", value: \"number\" } },\n          type: { kind: \"NonNullType\", type: { kind: \"NamedType\", name: { kind: \"Name\", value: \"Int\" } } },\n        },\n        {\n          kind: \"VariableDefinition\",\n          variable: { kind: \"Variable\", name: { kind: \"Name\", value: \"first\" } },\n          type: { kind: \"NamedType\", name: { kind: \"Name\", value: \"Int\" } },\n          defaultValue: { kind: \"IntValue\", value: \"10\" },\n        },\n        {\n          kind: \"VariableDefinition\",\n          variable: { kind: \"Variable\", name: { kind: \"Name\", value: \"after\" } },\n          type: { kind: \"NamedType\", name: { kind: \"Name\", value: \"String\" } },\n        },\n      ],\n      selectionSet: {\n        kind: \"SelectionSet\",\n        selections: [\n          {\n            kind: \"Field\",\n            name: { kind: \"Name\", value: \"repository\" },\n            arguments: [\n              { kind: \"Argument\", name: { kind: \"Name\", value: \"name\" }, value: { kind: \"Variable\", name: { kind: \"Name\", value: \"name\" } } },\n              { kind: \"Argument\", name: { kind: \"Name\", value: \"owner\" }, value: { kind: \"Variable\", name: { kind: \"Name\", value: \"owner\" } } },\n            ],\n            selectionSet: {\n              kind: \"SelectionSet\",\n              selections: [\n                { kind: \"Field\", name: { kind: \"Name\", value: \"id\" } },\n                {\n                  kind: \"Field\",\n                  name: { kind: \"Name\", value: \"issue\" },\n                  arguments: [\n                    { kind: \"Argument\", name: { kind: \"Name\", value: \"number\" }, value: { kind: \"Variable\", name: { kind: \"Name\", value: \"number\" } } },\n                  ],\n                  selectionSet: {\n                    kind: \"SelectionSet\",\n                    selections: [\n                      {\n                        kind: \"Field\",\n                        name: { kind: \"Name\", value: \"author\" },\n                        selectionSet: {\n                          kind: \"SelectionSet\",\n                          selections: [\n                            { kind: \"Field\", name: { kind: \"Name\", value: \"login\" } },\n                            { kind: \"Field\", name: { kind: \"Name\", value: \"avatarUrl\" } },\n                          ],\n                        },\n                      },\n                      { kind: \"Field\", name: { kind: \"Name\", value: \"id\" } },\n                      { kind: \"Field\", name: { kind: \"Name\", value: \"body\" } },\n                      { kind: \"Field\", name: { kind: \"Name\", value: \"title\" } },\n                      { kind: \"Field\", name: { kind: \"Name\", value: \"number\" } },\n                      { kind: \"Field\", name: { kind: \"Name\", value: \"createdAt\" } },\n                      { kind: \"Field\", name: { kind: \"Name\", value: \"publishedAt\" } },\n                      { kind: \"Field\", name: { kind: \"Name\", value: \"updatedAt\" } },\n                      {\n                        kind: \"Field\",\n                        name: { kind: \"Name\", value: \"comments\" },\n                        arguments: [\n                          { kind: \"Argument\", name: { kind: \"Name\", value: \"first\" }, value: { kind: \"Variable\", name: { kind: \"Name\", value: \"first\" } } },\n                          { kind: \"Argument\", name: { kind: \"Name\", value: \"after\" }, value: { kind: \"Variable\", name: { kind: \"Name\", value: \"after\" } } },\n                        ],\n                        selectionSet: {\n                          kind: \"SelectionSet\",\n                          selections: [\n                            {\n                              kind: \"Field\",\n                              name: { kind: \"Name\", value: \"nodes\" },\n                              selectionSet: {\n                                kind: \"SelectionSet\",\n                                selections: [\n                                  { kind: \"Field\", name: { kind: \"Name\", value: \"id\" } },\n                                  {\n                                    kind: \"Field\",\n                                    name: { kind: \"Name\", value: \"author\" },\n                                    selectionSet: {\n                                      kind: \"SelectionSet\",\n                                      selections: [\n                                        { kind: \"Field\", name: { kind: \"Name\", value: \"login\" } },\n                                        { kind: \"Field\", name: { kind: \"Name\", value: \"avatarUrl\" } },\n                                      ],\n                                    },\n                                  },\n                                  { kind: \"Field\", name: { kind: \"Name\", value: \"body\" } },\n                                  { kind: \"Field\", name: { kind: \"Name\", value: \"createdAt\" } },\n                                  { kind: \"Field\", name: { kind: \"Name\", value: \"updatedAt\" } },\n                                  { kind: \"Field\", name: { kind: \"Name\", value: \"viewerDidAuthor\" } },\n                                ],\n                              },\n                            },\n                            {\n                              kind: \"Field\",\n                              name: { kind: \"Name\", value: \"pageInfo\" },\n                              selectionSet: {\n                                kind: \"SelectionSet\",\n                                selections: [\n                                  { kind: \"Field\", name: { kind: \"Name\", value: \"endCursor\" } },\n                                  { kind: \"Field\", name: { kind: \"Name\", value: \"startCursor\" } },\n                                  { kind: \"Field\", name: { kind: \"Name\", value: \"hasNextPage\" } },\n                                  { kind: \"Field\", name: { kind: \"Name\", value: \"hasPreviousPage\" } },\n                                ],\n                              },\n                            },\n                            { kind: \"Field\", name: { kind: \"Name\", value: \"totalCount\" } },\n                          ],\n                        },\n                      },\n                    ],\n                  },\n                },\n              ],\n            },\n          },\n        ],\n      },\n    },\n  ],\n} as unknown as DocumentNode<GetSingleBlogQuery, GetSingleBlogQueryVariables>;\n","import { memo } from \"react\";\n\nimport { useGetInitialProps } from \"../hooks\";\n\nimport type { ComponentType } from \"react\";\n\nexport const AutoInjectProps = (Component: ComponentType<unknown>, path = \"/\") => {\n  const MemoComponent = memo(Component);\n\n  const RouterComponentWithProps = () => {\n    const props = useGetInitialProps(path);\n\n    return <MemoComponent {...props} />;\n  };\n\n  return RouterComponentWithProps;\n};\n","import { createContext, useContext, useState } from \"react\";\n\nimport type { ReactNode } from \"react\";\n\nexport const LoadingStateContext = createContext<{\n  loading: boolean;\n  setLoading: (p: boolean) => void;\n}>({ loading: false, setLoading: () => void 0 });\n\nexport const WrapperLoading = ({ children }: { children: ReactNode }) => {\n  const [loading, setLoading] = useState(false);\n  return <LoadingStateContext.Provider value={{ loading, setLoading }}>{children}</LoadingStateContext.Provider>;\n};\n\nexport const useLoadingState = () => useContext(LoadingStateContext);\n","import { memo, forwardRef } from \"react\";\nimport { createPortal } from \"react-dom\";\n\nimport { useEffectOnce, useIsMounted } from \"@client/hooks\";\n\nimport style from \"./index.module.scss\";\n\nlet div: HTMLDivElement | undefined;\n\nconst _Bar = forwardRef<HTMLDivElement>(function Bar(_, ref) {\n  useEffectOnce(() => {\n    if (!div) {\n      div = document.createElement(\"div\");\n    }\n    div.id = \"__loading_bar__\";\n    document.body.prepend(div);\n  });\n\n  const isMounted = useIsMounted();\n\n  return isMounted ? createPortal(<div ref={ref} className={style.loadingBar} style={{ height: `0px`, transform: `scale(0, 1)` }} />, div as Element) : null;\n});\nexport const Bar = memo(_Bar);\n","// extracted by mini-css-extract-plugin\nexport default {\"loadingBar\":\"ITbAOd\"};","import { useLoadingBar } from \"@client/hooks\";\n\n\nimport { useLoadingState } from \"../WrapperLoading\";\n\nimport { Bar } from \"./LoadingBar\";\n\nimport type { LoadingBarWrapperType } from \"@client/types/common\";\n\nexport const LoadingBar: LoadingBarWrapperType = () => {\n  const { loading } = useLoadingState();\n  const { ref } = useLoadingBar({ loading });\n  return <Bar ref={ref} />;\n};\n","import { createContext, useContext } from \"react\";\n\nimport { usePreLoad } from \"@client/hooks\";\nimport { preLoad } from \"@client/utils\";\n\nimport type { WrapperRouteType } from \"@client/types/common\";\n\nexport const LoadedLocationContext = createContext<ReturnType<typeof usePreLoad>[\"loaded\"] | null>(null);\n\nexport const WrapperRoute: WrapperRouteType = ({ children, routes, LoadingBar }) => {\n  const { loaded } = usePreLoad({ routes, preLoad });\n\n  // for pure client render\n  if (!loaded) return null;\n\n  return (\n    <LoadedLocationContext.Provider value={loaded}>\n      <LoadingBar />\n      {children}\n    </LoadedLocationContext.Provider>\n  );\n};\n\nexport const useLoadedLocation = () => useContext(LoadedLocationContext);\n","import { AnimatePresence, motion } from \"framer-motion\";\nimport { Fragment } from \"react\";\nimport { useRoutes } from \"react-router\";\n\nimport { getIsAnimateRouter } from \"@shared\";\n\nimport { allRoutes } from \"../router\";\n\nimport { useLoadedLocation } from \"./WrapperRoute\";\n\nexport const RenderMatch = () => {\n  const loaded = useLoadedLocation();\n  const all = useRoutes(allRoutes, loaded?.location);\n\n  return (\n    <>\n      {getIsAnimateRouter() ? (\n        <AnimatePresence exitBeforeEnter>\n          <Fragment key={loaded?.location.pathname}>\n            <motion.div\n              initial=\"initial\"\n              animate=\"in\"\n              exit=\"out\"\n              variants={{\n                initial: {\n                  opacity: 0,\n                },\n                in: {\n                  opacity: 1,\n                },\n                out: {\n                  opacity: 0,\n                },\n              }}\n              transition={{\n                type: \"spring\",\n                damping: 10,\n                stiffness: 50,\n              }}\n            >\n              {all}\n            </motion.div>\n          </Fragment>\n        </AnimatePresence>\n      ) : (\n        all\n      )}\n    </>\n  );\n};\n","import { ApolloProvider } from \"@apollo/client\";\nimport { useApollo } from \"@site/graphql\";\n\nimport type { ReactNode } from \"react\";\n\nexport const WrapperApollo = ({ children }: { children: ReactNode }) => {\n  const apolloClient = useApollo(null, true);\n\n  return <ApolloProvider client={apolloClient}>{children}</ApolloProvider>;\n};\n","import { Component } from \"react\";\n\nimport type { ErrorInfo, ReactNode, ReactElement } from \"react\";\n\nexport class WrapperErrorCatch extends Component<Record<string, unknown> & { children: ReactElement }, { error: string; stack: string; hasError: boolean }> {\n  state = {\n    stack: \"\",\n    error: \"\",\n    hasError: false,\n  };\n\n  static getDerivedStateFromError() {\n    return { hasError: true };\n  }\n\n  componentDidCatch(error: Error, info: ErrorInfo) {\n    this.setState({\n      error: error.message,\n      stack: info.componentStack,\n    });\n  }\n\n  render(): ReactNode {\n    if (this.state.hasError)\n      return (\n        <pre>\n          <p style={{ color: \"red\", whiteSpace: \"pre-wrap\" }}>{this.state.error}</p>\n          {this.state.stack}\n        </pre>\n      );\n    return this.props.children;\n  }\n}\n","import { useEffect, useRef } from \"react\";\nimport { IntlProvider } from \"react-intl\";\n\nimport { defaultLang, useAppSelector } from \"@shared\";\n\nimport type { ReactNode } from \"react\";\n\nexport const WrapperLang = ({ children }: { children: ReactNode }) => {\n  const htmlRef = useRef<HTMLHtmlElement | null>(null);\n\n  const data = useAppSelector((state) => state.server.serverLang.data);\n  const lang = useAppSelector((state) => state.client.clientLang.data);\n\n  useEffect(() => {\n    if (!htmlRef.current) {\n      htmlRef.current = document.querySelector(\"html\");\n    }\n    if (htmlRef.current) {\n      htmlRef.current.lang = lang;\n    }\n  }, [lang]);\n\n  return (\n    <IntlProvider locale={lang} messages={data[lang] || {}} defaultLocale={defaultLang}>\n      {children}\n    </IntlProvider>\n  );\n};\n","import { allRoutes } from \"@client/router\";\n\nimport { LoadingBar } from \"./LoadingBar\";\nimport { RenderMatch } from \"./RenderMatch\";\nimport { WrapperApollo } from \"./WrapperApollo\";\nimport { WrapperErrorCatch } from \"./WrapperCatch\";\nimport { WrapperLang } from \"./WrapperLang\";\nimport { WrapperLoading } from \"./WrapperLoading\";\nimport { WrapperRoute } from \"./WrapperRoute\";\n\nexport const App = () => {\n  return (\n    <WrapperApollo>\n      <WrapperLoading>\n        <WrapperLang>\n          <WrapperRoute routes={allRoutes} LoadingBar={LoadingBar}>\n            <WrapperErrorCatch>\n              <RenderMatch />\n            </WrapperErrorCatch>\n          </WrapperRoute>\n        </WrapperLang>\n      </WrapperLoading>\n    </WrapperApollo>\n  );\n};\n","import { ChakraProvider, cookieStorageManager } from \"@chakra-ui/react\";\nimport { CacheProvider } from \"@emotion/react\";\nimport { StrictMode } from \"react\";\nimport { HelmetProvider } from \"react-helmet-async\";\nimport { Provider } from \"react-redux\";\nimport { BrowserRouter as Router } from \"react-router-dom\";\n\nimport { createEmotionCache, theme } from \"../shared\";\n\nimport { App } from \"./common/App\";\n\nimport type { createUniversalStore } from \"../shared\";\n\nconst emotionCache = createEmotionCache();\n\nconst Root = ({ store }: { store: ReturnType<typeof createUniversalStore> }) => {\n  // this component will only run once when the page mount, so it's ok to use server's cookie\n  const cookieStore = cookieStorageManager(document.cookie);\n\n  return (\n    <StrictMode>\n      <CacheProvider value={emotionCache}>\n        <ChakraProvider theme={theme} colorModeManager={cookieStore}>\n          <Provider store={store} serverState={store.getState()}>\n            <Router>\n              <HelmetProvider>\n                <App />\n              </HelmetProvider>\n            </Router>\n          </Provider>\n        </ChakraProvider>\n      </CacheProvider>\n    </StrictMode>\n  );\n};\n\nexport { Root };\n","/* eslint-disable @typescript-eslint/no-var-requires */\nimport { loadableReady } from \"@loadable/component\";\nimport { render, hydrate } from \"react-dom\";\n\nimport { createUniversalStore, safeData } from \"../shared\";\n\nimport \"@client/styles/global.scss\";\nimport \"react-grid-layout/css/styles.css\";\nimport \"react-resizable/css/styles.css\";\n\nimport { Root } from \"./app\";\n\nimport type { RootState } from \"../shared\";\n\nconst place = document.querySelector(\"#__content__\") as HTMLDivElement;\n\nconst preLoadEnvElement = document.querySelector(\"script#__preload_env__\");\n\nconst preLoadStateElement = document.querySelector(\"script#__preload_state__\");\n\nconst store = createUniversalStore({\n  preloadedState: JSON.parse(preLoadStateElement?.innerHTML || \"{}\") as RootState,\n});\n\nwindow.__ENV__ = JSON.parse(preLoadEnvElement?.innerHTML || \"{}\");\n\nwindow.__PRELOAD_STORE_STATE__ = JSON.parse(preLoadStateElement?.innerHTML || \"{}\");\n\nsafeData(window.__ENV__);\n\nsafeData(window as unknown as Record<string, unknown>, \"__ENV__\");\n\nsafeData(window.__PRELOAD_STORE_STATE__);\n\nsafeData(window as unknown as Record<string, unknown>, \"__PRELOAD_STORE_STATE__\");\n\nconsole.log(`[client] render page by \"${window.__ENV__.FORMWORK}\" formwork!`);\n\nif (window.__ENV__.isPURE_CSR) {\n  const { loadCurrentLang } = require(\"@shared\");\n  loadCurrentLang(store.dispatch, window.__ENV__.LANG as \"en\" | \"ar\").then(() => loadableReady(() => render(<Root store={store} />, place)));\n} else {\n  if (!window.__ENV__.isSSR || (window.__ENV__.isDEVELOPMENT && window.__ENV__.isMIDDLEWARE)) {\n    loadableReady(() => render(<Root store={store} />, place));\n  } else {\n    loadableReady(() => hydrate(<Root store={store} />, place));\n  }\n}\n","import { debounce } from \"lodash-es\";\nimport { useMemo, useState } from \"react\";\n\nimport type { Dispatch, SetStateAction } from \"react\";\n\nexport const useDebouncedState = <T>(initialState: T | (() => T), time = 200): [T, Dispatch<SetStateAction<T>>] => {\n  const [state, setState] = useState(initialState);\n\n  const setDebounceState = useMemo(() => debounce(setState, time), [time]);\n\n  return [state, setDebounceState];\n};\n","import { useEffect } from \"react\";\n\nimport { useDebouncedState } from \"./useDebouncedState\";\n\nimport type { RefObject } from \"react\";\n\ntype DOMRectType = {\n  top: number;\n  bottom: number;\n  left: number;\n  right: number;\n  width: number;\n  height: number;\n  x: number;\n  y: number;\n};\n\nconst INITIAL_RECT: DOMRectType = {\n  width: 0,\n  height: 0,\n  left: 0,\n  right: 0,\n  top: 0,\n  bottom: 0,\n  x: 0,\n  y: 0,\n};\n\nexport function useDomSize({ ref, cssSelector }: { ref: RefObject<HTMLElement> | null; cssSelector?: string }): DOMRectType;\nexport function useDomSize({ ref, cssSelector }: { ref?: RefObject<HTMLElement>; cssSelector: string }): DOMRectType;\nexport function useDomSize({ ref, cssSelector }: { ref?: RefObject<HTMLElement> | null; cssSelector?: string }) {\n  const [rect, setRect] = useDebouncedState<DOMRectType>(INITIAL_RECT, 100);\n\n  useEffect(() => {\n    const domElement = ref ? ref.current : cssSelector ? document.querySelector(cssSelector) : null;\n    if (domElement) {\n      if (window.ResizeObserver) {\n        const resizeObserver = new ResizeObserver(() => {\n          setRect(domElement.getBoundingClientRect());\n        });\n\n        resizeObserver.observe(domElement);\n\n        return () => resizeObserver.disconnect();\n      } else {\n        const handleResize = () => setRect(domElement.getBoundingClientRect());\n\n        handleResize();\n\n        window.addEventListener(\"resize\", handleResize, { passive: true });\n\n        return () => window.removeEventListener(\"resize\", handleResize);\n      }\n    }\n  }, [ref, cssSelector, setRect]);\n\n  return rect;\n}\n","import { useReducer } from \"react\";\n\nexport const useUpdate = () => {\n  const [, update] = useReducer((p) => p + 1, 0);\n\n  return update;\n};\n","import { useEffect, useRef, useState } from \"react\";\nimport { useStore } from \"react-redux\";\nimport { useLocation, useNavigate } from \"react-router\";\nimport { useSearchParams } from \"react-router-dom\";\n\nimport { useLoadingState } from \"@client/common/WrapperLoading\";\nimport { getIsP_CSR } from \"@shared\";\nimport { clientActionName } from \"@shared/store/action\";\nimport { setDataSuccess_client } from \"@shared/store/reducer\";\n\nimport type { UsePreLoadType } from \"@client/types/hooks\";\nimport type { RootState } from \"@shared\";\n\n/* WrapperRoute */\nconst usePreLoad: UsePreLoadType = ({ routes, preLoad }) => {\n  const isRedirect = useRef<string | undefined>();\n  const store = useStore<RootState>();\n  const location = useLocation();\n  const navigate = useNavigate();\n  const [query] = useSearchParams();\n  const { setLoading } = useLoadingState();\n  // for pure client render, need preload data\n  const firstLoad = useRef(getIsP_CSR() ? true : false);\n  const loadedPath = useRef<string | undefined>(\"\");\n  const loadingPath = useRef<string | null>(\"\");\n  const timer1 = useRef<NodeJS.Timeout | null>(null);\n  const timer2 = useRef<NodeJS.Timeout | null>(null);\n  const storeRef = useRef(store);\n\n  // for pure client render, there are not exist loaded location\n  const [loadedLocation, setLoadedLocation] = useState(getIsP_CSR() ? undefined : { location, query });\n\n  loadingPath.current = `${location.pathname}?${query.toString()}`;\n\n  loadedPath.current = loadedLocation ? `${loadedLocation.location.pathname}?${loadedLocation.query.toString()}` : \"\";\n\n  storeRef.current = store;\n\n  useEffect(() => {\n    // skip first load if need\n    if (!firstLoad.current) {\n      const isRedirectCurrentPath = isRedirect.current && isRedirect.current === `${location.pathname}?${query.toString()}`;\n      if (!isRedirectCurrentPath) {\n        setLoading(false);\n      }\n      if (loadedPath.current !== `${location.pathname}?${query.toString()}`) {\n        if (!isRedirectCurrentPath) {\n          timer1.current && clearTimeout(timer1.current);\n          timer1.current = null;\n          timer2.current && clearTimeout(timer2.current);\n          timer2.current = null;\n          timer1.current = setTimeout(() => {\n            setLoading(true);\n          }, 200);\n        }\n\n        // 分离每次load逻辑  避免跳转错乱\n        const currentLoad = (location: ReturnType<typeof useLocation>, query: URLSearchParams): void => {\n          preLoad(routes, location.pathname, query, storeRef.current).then((config) => {\n            const currentLoadKey = `${location.pathname}?${query.toString()}`;\n            if (currentLoadKey === loadingPath.current) {\n              const { redirect, error, props } = config || {};\n              if (redirect) {\n                isRedirect.current = `${redirect.location.pathName}?${redirect.location.query?.toString()}`;\n              } else {\n                isRedirect.current = \"\";\n              }\n              if (error) {\n                console.error(error);\n                setLoading(false);\n              } else if (redirect) {\n                navigate(isRedirect.current);\n              } else {\n                timer2.current = setTimeout(() => {\n                  timer1.current && clearTimeout(timer1.current);\n                  timer1.current = null;\n                  if (loadingPath.current === currentLoadKey) {\n                    props && storeRef.current.dispatch(setDataSuccess_client({ name: clientActionName.clientProps, data: props }));\n                    setLoading(false);\n                    setLoadedLocation({ location, query });\n                  }\n                }, 50);\n              }\n            }\n          });\n        };\n\n        currentLoad(location, query);\n      }\n    } else {\n      firstLoad.current = false;\n    }\n  }, [location, preLoad, routes, navigate, query, setLoading]);\n\n  return { loaded: loadedLocation };\n};\n\nexport { usePreLoad };\n","const applyRootStyles = (rootId: string, p: number) => {\n  const root = document.querySelector(`#${rootId}`) as HTMLDivElement;\n\n  if (root) {\n    const h = window.innerHeight;\n    const s = (h - p) / h;\n    root.style.overflow = \"hidden\";\n    root.style.willChange = \"transform\";\n    root.style.transition = \"transform 200ms linear\";\n    root.style.transform = `translateY(calc(env(safe-area-inset-top) + ${p / 2}px)) scale(${s})`;\n    root.style.filter = \"blur(0.8px)\";\n  }\n};\n\nconst cleanupRootStyles = (rootId: string) => {\n  const root = document.getElementById(rootId) as HTMLDivElement;\n\n  function onTransitionEnd() {\n    root.style.removeProperty(\"overflow\");\n    root.style.removeProperty(\"will-change\");\n    root.style.removeProperty(\"transition\");\n  }\n\n  if (root) {\n    // Start animating back\n    root.style.removeProperty(\"transform\");\n    root.style.removeProperty(\"filter\");\n    root.addEventListener(\"transitionend\", onTransitionEnd, { once: true });\n  }\n};\n\nexport const applyOverlaysStyles = (ids: string[]) => {\n  ids.reverse().forEach((id, index) => applyRootStyles(id, 18 + index * 2));\n};\n\nexport const cleanupOverlaysStyles = (ids: string[]) => {\n  ids.forEach(cleanupRootStyles);\n};\n","import { findLast } from \"lodash-es\";\nimport { createContext, useCallback, useContext, useRef, useState } from \"react\";\n\nimport { delay } from \"@client/utils\";\nimport { applyOverlaysStyles, cleanupOverlaysStyles } from \"@client/utils/dom\";\n\nimport { useUpdate } from \"./useUpdate\";\n\nimport type React from \"react\";\n\nconst ROOT_BODY = \"__next\";\n\nconst OVERLAY_TIMER = \"__overlay_back\";\n\nexport interface OverlayProps {\n  id: string;\n  key: string;\n  head?: React.ReactNode;\n  body: JSX.Element;\n  foot?: React.ReactNode;\n  height?: number;\n  isFirst?: boolean;\n  className?: string;\n  showState?: boolean;\n  applyOverlay?: (id: string, isOpen?: boolean) => void;\n  closeHandler?: () => void;\n  closeComplete?: () => void;\n}\n\ninterface UseOverlayOpenType {\n  (props: Omit<OverlayProps, \"key\" | \"id\">): void;\n}\n\nlet count = 0;\n\nexport const OverlayOpenContext = createContext<UseOverlayOpenType>(() => void 0);\n\nexport const OverlayCloseContext = createContext<({ modalId, closeAll }?: { modalId?: string; closeAll?: boolean }) => void>(() => void 0);\n\nexport const OverlayArrayContext = createContext<{\n  desktop: Array<OverlayProps>;\n  mobile: Array<OverlayProps>;\n}>({ desktop: [], mobile: [] });\n\nexport const useOverlaysProps = () => {\n  const [overlays, setOverlays] = useState<OverlayProps[]>([]);\n  const overlaysRef = useRef(overlays);\n  const forceUpdate = useUpdate();\n  overlaysRef.current = overlays;\n  const applyOverlayStyle = useCallback((id: string, isOpen) => {\n    delay(\n      0,\n      () => {\n        const newAllOverlays = overlaysRef.current;\n        const stillShow = newAllOverlays.filter((n) => {\n          if (isOpen) {\n            return n.showState || n.id === id;\n          } else {\n            return n.showState && n.id !== id;\n          }\n        });\n        if (stillShow.length) {\n          const allIds = stillShow.map((n) => n.id);\n          const needReApplyIds = allIds.slice(0, -1);\n          const needClearId = allIds[allIds.length - 1];\n          applyOverlaysStyles([ROOT_BODY, ...needReApplyIds]);\n          cleanupOverlaysStyles([needClearId]);\n        } else {\n          cleanupOverlaysStyles([ROOT_BODY]);\n        }\n      },\n      OVERLAY_TIMER\n    );\n  }, []);\n  const open = useCallback(\n    (props: Omit<OverlayProps, \"key\">) => {\n      const overlayProps = props as OverlayProps;\n      const allOverlay = overlaysRef.current;\n      const lastOpen = findLast(allOverlay, (n) => n.showState);\n      overlayProps.key = `__overlay_${count++}`;\n      overlayProps.id = `__overlay_${count++}`;\n      overlayProps.height = lastOpen ? lastOpen.height - 6 : 92;\n      overlayProps.isFirst = lastOpen ? false : true;\n      overlayProps.showState = true;\n      const closeHandler = overlayProps.closeHandler;\n      const closeComplete = overlayProps.closeComplete;\n      overlayProps.closeHandler = () => {\n        overlayProps.showState = false;\n        closeHandler && closeHandler();\n        forceUpdate();\n      };\n      overlayProps.closeComplete = () => {\n        closeComplete && closeComplete();\n        setOverlays((last) => {\n          const newAllOverlays = last.filter((n) => n !== overlayProps);\n          if (newAllOverlays.length) {\n            newAllOverlays.reduce((p, c) => {\n              if (p.showState) {\n                c.isFirst = false;\n                return c;\n              } else if (c.showState) {\n                c.isFirst = true;\n                return c;\n              }\n            });\n          }\n          return newAllOverlays;\n        });\n      };\n      overlayProps.applyOverlay = applyOverlayStyle;\n      setOverlays((last) => {\n        const newAllOverlays = last.filter((n) => n.showState);\n        return [...newAllOverlays, overlayProps];\n      });\n    },\n    [forceUpdate, applyOverlayStyle]\n  );\n  const close = useCallback((props?: { modalId?: string; closeAll?: boolean }) => {\n    const allOverlay = overlaysRef.current;\n    const { modalId, closeAll } = props || {};\n    if (modalId !== undefined) {\n      const currentOverlay = allOverlay.find((n) => n.id === modalId);\n      currentOverlay?.closeHandler();\n    } else if (closeAll) {\n      allOverlay.filter((n) => n.showState).forEach((n) => n?.closeHandler());\n    } else {\n      const currentTopOverlay = findLast(allOverlay, (n) => n.showState);\n      currentTopOverlay?.closeHandler();\n    }\n  }, []);\n  return { overlays, open, close };\n};\n\nexport const useOverlaysOpen = () => useContext(OverlayOpenContext);\n\nexport const useOverlaysClose = () => useContext(OverlayCloseContext);\n\nexport const useOverlayArray = () => useContext(OverlayArrayContext);\n","import { useBreakpointValue } from \"@chakra-ui/react\";\n\nexport const useIsMobile = () => {\n  return useBreakpointValue({ base: true, lg: false });\n};\n","import { useState, useEffect } from \"react\";\n\nexport const useIsMounted = () => {\n  const [mounted, setMounted] = useState(false);\n  useEffect(() => {\n    setMounted(true);\n  }, []);\n\n  return mounted;\n};\n","import { useEffect, useRef } from \"react\";\n\nimport { cancel, delay } from \"../utils\";\n\ntype LoadingBarProps = {\n  height?: number;\n  present?: number;\n  loading?: boolean;\n};\n\nconst useLoadingBar = (props: LoadingBarProps = {}) => {\n  const { height = 2.5, present = 0, loading } = props;\n\n  const ref = useRef<HTMLDivElement>(null);\n\n  const state = useRef<LoadingBarProps>({ present, height });\n\n  useEffect(() => {\n    if (!loading) {\n      state.current.height = height;\n      state.current.present = present;\n    }\n  }, [loading, height, present]);\n\n  useEffect(() => {\n    if (ref.current) {\n      const ele = ref.current;\n      if (loading) {\n        let count = 2;\n        let id: number;\n        const start = (): void => {\n          if (count > 0.33) {\n            count -= 0.04;\n          }\n          let next = (state.current.present || 0) + count;\n          next = next < 99.5 ? next : 99.5;\n          ele.style.cssText =\n            `height: ${state.current.height}px;` + `transform: scale(${next / 100}, 1);` + `filter: drop-shadow(2px 2px 2px rgba(200, 200, 200, .4))`;\n          state.current.present = next;\n          id = requestAnimationFrame(start);\n        };\n        id = requestAnimationFrame(start);\n        return () => cancelAnimationFrame(id);\n      } else {\n        delay(40, () => (ele.style.transform = \"scale(1)\"), \"loadingBar\").then(() => delay(80, () => (ele.style.height = \"0px\"), \"loadingBar\"));\n        return () => cancel(\"loadingBar\");\n      }\n    }\n  }, [loading]);\n\n  return { ref };\n};\n\nexport { useLoadingBar };\n","import { useEffect } from \"react\";\n\nexport const useEffectOnce = (fn: () => unknown) => {\n  useEffect(() => {\n    fn();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n};\n","import { isBrowser } from \"framer-motion\";\nimport { useEffect } from \"react\";\n\nimport { useDebouncedState } from \"./useDebouncedState\";\n\nexport const useWindowSize = () => {\n  const [state, setState] = useDebouncedState({\n    height: isBrowser ? window.innerHeight : 0,\n    width: isBrowser ? window.innerHeight : 0,\n  });\n\n  useEffect(() => {\n    const resize = () => setState({ height: window.innerHeight, width: window.innerWidth });\n\n    resize();\n\n    window.addEventListener(\"resize\", resize, { passive: true });\n\n    return window.removeEventListener(\"reset\", resize);\n  }, [setState]);\n\n  return state;\n};\n","import { useEffect } from \"react\";\nimport { create } from \"zustand\";\nimport { shallow } from \"zustand/shallow\";\n\nconst useGlobalLockStore = create<{\n  count: number;\n  lock: () => void;\n  unlock: () => void;\n}>((set, get) => ({\n  count: 0,\n  lock: () => set({ count: get().count + 1 }),\n  unlock: () => set({ count: get().count - 1 }),\n}));\n\nexport const useLockBodyScroll = (isLock?: boolean) => {\n  const { lock, unlock } = useGlobalLockStore((state) => ({ lock: state.lock, unlock: state.unlock }), shallow);\n  useEffect(() => {\n    if (isLock) {\n      lock();\n      return unlock;\n    }\n  }, [isLock, lock, unlock]);\n};\n\nexport const useLockBodyCount = () => useGlobalLockStore((state) => state.count);\n","import { useAppSelector } from \"@shared\";\n\nimport { preLoadPropsKey } from \"../utils\";\n\nexport const useGetInitialProps = (pagePath: string) => {\n  const routerData = useAppSelector((state) => state.client.clientProps.data);\n\n  const propsKey = preLoadPropsKey(pagePath);\n\n  return routerData[propsKey];\n};\n","import { useMemo } from \"react\";\n\nimport type { Layout } from \"react-grid-layout\";\n\nexport const BLOG_GRID_HEIGHT = 10;\n\nconst _generateFunction =\n  (width: number) =>\n  (index: number, id: string, dataLength: number): Layout => {\n    const h = BLOG_GRID_HEIGHT + Math.floor(dataLength / 60);\n    const maxH = h > 60 ? 60 : h;\n    return {\n      i: id + index,\n      x: Math.floor(index % width),\n      y: Math.floor(index / width),\n      w: 1,\n      maxW: width,\n      h: maxH,\n      minH: BLOG_GRID_HEIGHT,\n    };\n  };\n\nconst smGenerate = _generateFunction(1);\nconst mdGenerate = _generateFunction(2);\nconst lgGenerate = _generateFunction(3);\n\nexport const useGetResponseListLayout = (items: { id: string; bodyText: string }[]) => {\n  return useMemo(() => {\n    const sm = items.map(({ id, bodyText }, i) => smGenerate(i, id, bodyText.length));\n    const md = items.map(({ id, bodyText }, i) => mdGenerate(i, id, bodyText.length));\n    const lg = items.map(({ id, bodyText }, i) => lgGenerate(i, id, bodyText.length));\n    return {\n      lg,\n      md: lg,\n      sm: md,\n      xs: sm,\n      xxs: sm,\n    };\n  }, [items]);\n};\n","/* eslint-disable prettier/prettier */\n/* do not editor this template */\nimport type { DynamicRouteConfig } from \"@client/types/route\";\n\nexport const dynamicRouteConfig: DynamicRouteConfig[] = [{\"path\":\"/Blog\",\"componentPath\":\"Blog\"},{\"path\":\"/Hot\",\"componentPath\":\"Hot\"},{\"path\":\"/\",\"componentPath\":\"index\"},{\"path\":\"/*\",\"componentPath\":\"404\"}];","import loadable from \"@loadable/component\";\nimport { createElement } from \"react\";\n\nimport { AutoInjectProps } from \"../common/AutoInjectProps\";\n\nimport { dynamicRouteConfig } from \"./dynamicRoutes\";\n\nimport type { PreLoadRouteConfig } from \"../types/route\";\n\nconst Layout = loadable(() => import(\"../common/Layout\"), {\n  resolveComponent: (module) => AutoInjectProps(module.default),\n});\n\nconst baseRouter: PreLoadRouteConfig = {\n  component: Layout,\n  element: createElement(Layout),\n};\n\nconst dynamicRoutes = dynamicRouteConfig\n  .map(({ path, componentPath }) => {\n    // just set true for current usage\n    if (__DEVELOPMENT__ ? false : true) {\n      if (path.startsWith(\"/\")) {\n        return {\n          path: `/MyReact/${path.slice(1)}`,\n          componentPath,\n        };\n      } else {\n        return {\n          path: `/MyReact/${path}`,\n          componentPath,\n        };\n      }\n    } else {\n      return { path, componentPath };\n    }\n  })\n  .map((it) => ({\n    path: it.path,\n    component: loadable(() => import(`../pages/${it.componentPath}`), { resolveComponent: (module) => AutoInjectProps(module.default, it.path) }),\n  }))\n  .map(({ path, component }) => ({\n    path: path,\n    component,\n    element: createElement(component),\n  }));\n\nbaseRouter.children = dynamicRoutes;\n\nexport const allRoutes = [baseRouter];\n\ntypeof window !== \"undefined\" && ((window as any).__router__ = allRoutes);\n","import type { Cancel, Delay, KeyMap, ReJectMap, TimeoutMap } from \"../types/util\";\n\nconst timeoutMap: TimeoutMap = {};\nconst rejectMap: ReJectMap = {};\nconst keyMap: KeyMap = {};\nlet keyLength = 0;\nconst maxKeyLength = 200;\n\nconst cancel: Cancel = (key) => {\n  if (timeoutMap[key]) {\n    const length = timeoutMap[key].length;\n    timeoutMap[key] = timeoutMap[key].map((id) => id && clearTimeout(id)).slice(length);\n    rejectMap[key] = rejectMap[key].map((reject) => reject && reject()).slice(length);\n  }\n  if (keyLength > maxKeyLength) {\n    const keys = Object.keys(keyMap).sort((key1, key2) => (keyMap[key1] > keyMap[key2] ? 1 : -1));\n    for (const keyItem of keys) {\n      if (keyItem !== key && !rejectMap[keyItem].length) {\n        delete keyMap[keyItem];\n        delete timeoutMap[keyItem];\n        delete rejectMap[keyItem];\n        keyLength--;\n      }\n    }\n  }\n};\n\nconst delay: Delay = (time, action, key) => {\n  if (key === undefined) {\n    return new Promise<void>((resolve) => {\n      setTimeout(() => {\n        resolve();\n      }, time);\n    }).then(() => {\n      if (action) return action();\n    });\n  } else {\n    if (!(key in keyMap)) {\n      keyMap[key] = 1;\n      timeoutMap[key] = [];\n      rejectMap[key] = [];\n      keyLength++;\n    } else {\n      keyMap[key]++;\n    }\n    cancel(key);\n    return new Promise<void>((resolve, reject) => {\n      rejectMap[key].push(reject);\n      timeoutMap[key].push(\n        setTimeout(() => {\n          resolve();\n        }, time)\n      );\n    })\n      .then(() => {\n        if (action) return action();\n      })\n      .catch(() => void 0);\n  }\n};\n\nexport { delay, cancel };\n","import merge from \"lodash/merge\";\nimport { matchRoutes } from \"react-router\";\n\nimport type { PreLoadStateProps, GetInitialStateType, PreLoadStateType, AllPreLoadStateType, PreLoadComponentType } from \"@client/types/common\";\nimport type { PreLoadRouteConfig } from \"@client/types/route\";\nimport type { LoadableComponent } from \"@loadable/component\";\nimport type { RootStore } from \"@shared\";\nimport type { ComponentClass } from \"react\";\nimport type { Params } from \"react-router\";\n\nexport type RedirectType = {\n  code?: number;\n  location: { pathName: string; query?: URLSearchParams };\n};\n\nfunction preLoad(\n  routes: PreLoadRouteConfig[],\n  pathname: string,\n  query: URLSearchParams,\n  store: RootStore\n): Promise<{\n  // used to preload script by page initial\n  page?: string[];\n  error?: string;\n  props?: Record<string, Record<string, unknown>>;\n  redirect?: RedirectType;\n}> {\n  const branch = matchRoutes(routes, pathname) || [];\n\n  const relativePathname = pathname;\n\n  const promises: Promise<{\n    error?: string;\n    page?: string[];\n    redirect?: RedirectType;\n    props?: Record<string, Record<string, unknown>>;\n  } | void>[] = [];\n\n  branch.forEach(({ route, params, pathname }) => {\n    const match = { params, pathname };\n    promises.push(_preLoad({ route: route as PreLoadRouteConfig, store, match, query, relativePathname }));\n  });\n\n  return Promise.all(promises).then((val) => {\n    if (val.length) {\n      const allInitialProps = val.filter(Boolean).reduce<{\n        error?: string;\n        page?: string[];\n        props?: Record<string, Record<string, unknown>>;\n        redirect?: RedirectType;\n      }>((s, c) => {\n        if (!c) {\n          return s;\n        }\n        s.props = merge(s.props, c.props);\n        s.page = (s.page || []).concat(c.page || []);\n        s.error = [s.error, c.error].filter(Boolean).join(\" || \");\n        s.redirect = c.redirect ? c.redirect : s.redirect;\n        return s;\n      }, {});\n      return allInitialProps;\n    }\n    return {\n      redirect: {\n        code: 301,\n        location: { pathName: \"/404\" },\n      },\n    };\n  });\n}\n\nconst preLoadPropsKey = (pathName: string) => `__preload-[${pathName}]-props__`;\n\ntype PreLoadProps = {\n  route: PreLoadRouteConfig;\n  store: RootStore;\n  match: { params: Params<string>; pathname: string };\n  relativePathname: string;\n  query: URLSearchParams;\n};\n\ntype PreLoadType = (props: PreLoadProps) => Promise<{\n  error?: string;\n  page?: string[];\n  redirect?: RedirectType;\n  props?: Record<string, Record<string, unknown>>;\n} | void>;\n\nconst resolvePreLoadStateFunction = async ({ route }: Pick<PreLoadProps, \"route\">): Promise<AllPreLoadStateType | null> => {\n  const preLoadStateArray: PreLoadStateType[] = [];\n  // for router\n  if (route.getInitialState) {\n    preLoadStateArray.push(route.getInitialState);\n  }\n  if (route.component) {\n    const WrapperComponent = route.component;\n    if (WrapperComponent[\"load\"] && typeof WrapperComponent[\"load\"] === \"function\") {\n      const loadAbleComponent = WrapperComponent as LoadableComponent<Record<string, unknown>>;\n      const preLoadComponent: PreLoadComponentType & { readonly default?: PreLoadComponentType } = await loadAbleComponent.load();\n      if (preLoadComponent.getInitialState && typeof preLoadComponent.getInitialState === \"function\") {\n        preLoadStateArray.push(preLoadComponent.getInitialState);\n      }\n      if (typeof preLoadComponent.default !== \"undefined\") {\n        const c = preLoadComponent.default;\n        if (c.getInitialState && typeof c.getInitialState === \"function\") {\n          preLoadStateArray.push(c.getInitialState);\n        }\n      }\n    } else {\n      const preLoadComponent = WrapperComponent as PreLoadComponentType;\n      if (preLoadComponent.getInitialState && typeof preLoadComponent.getInitialState === \"function\") {\n        preLoadStateArray.push(preLoadComponent.getInitialState);\n      }\n    }\n  }\n\n  if (preLoadStateArray.length) {\n    return async ({ store, pathName, params, relativePathname, query }: PreLoadStateProps) => {\n      const propsKey = preLoadPropsKey(pathName);\n      const res = await Promise.all(\n        preLoadStateArray.map((fn) =>\n          Promise.resolve()\n            .then(() => fn({ store, pathName, params, relativePathname, query }))\n            .catch((e) => {\n              // catch all error by default\n              console.error(`[${__CLIENT__ ? \"client\" : \"server\"}] getInitialState error ${e.toString()}`);\n              return null;\n            })\n        )\n      );\n\n      const result = res.filter(Boolean).reduce<{\n        redirect?: RedirectType;\n        error?: string;\n        props?: Record<string, unknown>;\n      }>((s, c) => {\n        if (!c) {\n          return s;\n        }\n        s.error = [s.error, c.error].filter(Boolean).join(\" || \");\n        s.props = merge(s.props, c.props);\n        s.redirect = c.redirect ? c.redirect : s.redirect;\n        return s;\n      }, {});\n\n      return {\n        ...result,\n        props: { [propsKey]: result.props || {} },\n      };\n    };\n  } else {\n    return null;\n  }\n};\n\nconst _preLoad: PreLoadType = async ({ route, store, match, query, relativePathname }) => {\n  const getInitialState = await resolvePreLoadStateFunction({ route });\n  if (getInitialState) {\n    const initialState = await getInitialState({\n      store,\n      pathName: match.pathname,\n      params: match.params,\n      relativePathname,\n      query,\n    });\n    if (route.path) {\n      return { ...initialState, page: [route.path] };\n    } else {\n      return initialState;\n    }\n  } else if (route.path) {\n    return { page: [route.path] };\n  }\n};\n\nfunction initialStateWrapper<T extends Record<string, unknown>>(getInitialState: GetInitialStateType<T>) {\n  function Wrapper(Component: ComponentClass<T> & { getInitialState?: GetInitialStateType<T> }): void {\n    Component.getInitialState = getInitialState;\n  }\n  return Wrapper;\n}\n\nexport { preLoad, initialStateWrapper, preLoadPropsKey };\n","import memoize from \"lodash/memoize\";\n\nexport const getIsMiddleware = memoize(() => (__SERVER__ ? JSON.parse(process.env.MIDDLEWARE || \"false\") : window.__ENV__.isMIDDLEWARE));\n\nexport const getIsSSR = memoize(() => (__SERVER__ ? JSON.parse(process.env.SSR || \"false\") : window.__ENV__.isSSR));\n\nexport const getIsAnimateRouter = memoize(() => (__SERVER__ ? JSON.parse(process.env.ANIMATE_ROUTER || \"false\") : window.__ENV__.isANIMATE_ROUTER));\n\nexport const getIsP_CSR = memoize(() => (__SERVER__ ? false : window.__ENV__.isPURE_CSR));\n\nexport const getIsStaticGenerate = memoize(() =>\n  __SERVER__ ? JSON.parse(process.env.STATIC_GENERATE || \"false\") && process.env.NODE_ENV === \"production\" : window.__ENV__.isSTATIC\n);\n\nexport const getPublicApi = memoize(() =>\n  __SERVER__ ? (__DEVELOPMENT__ ? process.env.PUBLIC_DEV_API_HOST : process.env.PUBLIC_PROD_API_HOST) : window.__ENV__.PUBLIC_API_HOST\n);\n","import { serverActionName } from \"./store/action\";\nimport { getDataAction_Server } from \"./store/reducer\";\n\nimport type { AppDispatch } from \"./store\";\n\nexport const supportedLang = {\n  en: \"English\",\n  zh: \"中文\",\n};\n\nexport const loadCurrentLang = async (dispatch: AppDispatch, lang: keyof typeof supportedLang) => {\n  await dispatch(getDataAction_Server({ name: serverActionName.serverLang, lang }));\n};\n\nexport const defaultLang = \"en\";\n","import axios from \"axios\";\nimport { call, put, select } from \"redux-saga/effects\";\n\nimport { getPublicApi } from \"@shared\";\nimport { clientActionName, serverActionName } from \"@shared/store/action\";\nimport { getDataFail_Server, getDataLoading_server, getDataSuccess_Server, setDataSuccess_client } from \"@shared/store/reducer\";\n\nimport type { StoreState } from \"@shared/store/type\";\n\nexport function* langSaga({ done, lang }: { done: () => void; lang: string }) {\n  try {\n    const langData: { [props: string]: any } = yield select<(s: StoreState) => { [props: string]: unknown }>((state) => state.server.serverLang.data);\n    if (!langData[lang]) {\n      yield put(getDataLoading_server({ name: serverActionName.serverLang }));\n      const request = axios.create({ baseURL: getPublicApi() });\n      const {\n        data: { data },\n      } = yield call((apiName: string) => request.get(apiName, { params: { lang } }), \"/api/lang\");\n      yield put(getDataSuccess_Server({ name: serverActionName.serverLang, data: { [lang]: data } }));\n    }\n    yield put(setDataSuccess_client({ name: clientActionName.clientLang, data: lang }));\n  } catch (e) {\n    if (__DEVELOPMENT__) {\n      console.error(\"langSaga error: \", (e as Error).message);\n    }\n    yield put(getDataFail_Server({ name: serverActionName.serverLang, error: (e as Error).toString() }));\n  } finally {\n    done();\n  }\n}\n","import { all, takeLatest } from \"redux-saga/effects\";\n\nimport { serverActionName } from \"../action\";\nimport { serverAction } from \"../reducer\";\n\nimport { langSaga } from \"./action\";\n\ntype StartActionType = { type: ReturnType<typeof serverAction.GET_DATA_ACTION>; done: () => void; [props: string]: any };\n\nfunction* rootSaga() {\n  yield all([takeLatest<StartActionType>(serverAction.GET_DATA_ACTION(serverActionName.serverLang), ({ done, lang }) => langSaga({ done, lang }))]);\n}\n\nexport { rootSaga };\n","import { fork, take, cancel } from \"redux-saga/effects\";\n\nimport type { rootSaga } from \".\";\nimport type { SagaStore } from \"../type\";\nimport type createSagaMiddleware from \"redux-saga\";\nimport type { Saga, Task } from \"redux-saga\";\n\nexport const CANCEL_SAGAS_HMR = \"@CANCEL_SAGAS_HMR\";\n\nfunction createAbortAbleSaga(saga: typeof rootSaga) {\n  if (__DEVELOPMENT__) {\n    return function* main() {\n      const sagaTask: Task = yield fork(saga);\n\n      yield take(CANCEL_SAGAS_HMR);\n      yield cancel(sagaTask);\n    };\n  } else {\n    return saga;\n  }\n}\n\nconst SagaManager = {\n  startSagas(saga: typeof rootSaga, sagaMiddleware: ReturnType<typeof createSagaMiddleware>) {\n    return sagaMiddleware.run(createAbortAbleSaga(saga) as Saga);\n  },\n\n  cancelSagas(store: SagaStore) {\n    store.dispatch({\n      type: CANCEL_SAGAS_HMR,\n    });\n  },\n};\n\nexport { SagaManager };\n","import { useDispatch, useSelector } from \"react-redux\";\nimport { legacy_createStore as createStore, applyMiddleware, compose } from \"redux\";\nimport createSagaMiddleware from \"redux-saga\";\nimport thunkMiddleware from \"redux-thunk\";\n\nimport { rootReducer } from \"./reducer\";\nimport { rootSaga } from \"./saga\";\nimport { SagaManager } from \"./saga/utils\";\n\nimport type { SagaStore } from \"./type\";\nimport type { TypedUseSelectorHook } from \"react-redux\";\nimport type { Middleware, PreloadedState } from \"redux\";\n\ntype CreateStoreProps = {\n  preloadedState?: PreloadedState<ReturnType<typeof rootReducer>>;\n  middleware?: Middleware[];\n};\n\nconst devTools =\n  __CLIENT__ && typeof window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ === \"function\" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({ actionsDenylist: [] });\n\nconst composeEnhancers = devTools || compose;\n\nexport const createUniversalStore = (props: CreateStoreProps = {}): SagaStore => {\n  const { preloadedState, middleware = [] } = props;\n  const sagaMiddleware = createSagaMiddleware();\n  const allMiddleware = [thunkMiddleware, sagaMiddleware, ...middleware];\n  const store = createStore(rootReducer, preloadedState, composeEnhancers(applyMiddleware(...allMiddleware))) as SagaStore;\n  store.sagaTask = SagaManager.startSagas(rootSaga, sagaMiddleware);\n\n  // Enable Webpack hot module\n  if (__DEVELOPMENT__ && module.hot) {\n    module.hot.accept(\"./reducer\", () => {\n      // eslint-disable-next-line @typescript-eslint/no-var-requires\n      const { rootReducer: nextRootReducer } = require(\"./reducer\");\n      store.replaceReducer(nextRootReducer);\n    });\n\n    module.hot.accept(\"./saga\", () => {\n      // eslint-disable-next-line @typescript-eslint/no-var-requires\n      const { rootSaga: nextRootSaga } = require(\"./saga\");\n      SagaManager.cancelSagas(store);\n      store.sagaTask = SagaManager.startSagas(nextRootSaga, sagaMiddleware);\n    });\n  }\n\n  return store;\n};\n\nexport type RootState = ReturnType<typeof rootReducer>;\n\nexport type RootStore = ReturnType<typeof createUniversalStore>;\n\nexport type AppDispatch = ReturnType<typeof createUniversalStore>[\"dispatch\"];\n\nexport const useAppDispatch: () => AppDispatch = useDispatch;\n\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\n","import { extendTheme } from \"@chakra-ui/react\";\n\nimport { semanticTokens } from \"./semanticTokens\";\nimport { styles } from \"./styles\";\n\nimport type { ChakraTheme} from \"@chakra-ui/react\";\n\n\nexport const theme: Partial<ChakraTheme> = extendTheme({\n  styles,\n  semanticTokens,\n});\n","import type { ChakraTheme } from \"@chakra-ui/react\";\n\nexport const styles: ChakraTheme[\"styles\"] = {\n  global: {\n    body: {\n      fontFamily: `ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica Neue, Arial, Noto Sans, sans-serif,\n      Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol, Noto Color Emoji`,\n    },\n  },\n};\n","import type { ChakraTheme } from \"@chakra-ui/react\";\n\nexport const semanticTokens: ChakraTheme[\"semanticTokens\"] = {\n  colors: {\n    mobileCardBackgroundColor: {\n      default: \"white\",\n      _dark: \"gray.700\",\n    },\n    cardBackgroundColor: {\n      default: \"whiteAlpha.500\",\n      _dark: \"blackAlpha.600\",\n    },\n    mobileModalColor: {\n      default: \"rgb(220, 220, 220)\",\n      _dark: \"gray.700\",\n    },\n    cardBorderColor: {\n      default: \"gray.300\",\n      _dark: \"gray.600\",\n    },\n    lightTextColor: {\n      default: \"gray.600\",\n      _dark: \"gray.400\",\n    },\n    siteBackgroundColor: {\n      default: \"rgba(250, 250, 250, 0.8)\",\n      _dark: \"rgba(24, 24, 24, 0.2)\",\n    },\n    bannerBackgroundColor: {\n      default: \"rgb(255, 255, 255)\",\n      _dark: \"#1A202C\",\n    },\n  },\n};\n","import type { HTMLProps } from \".\";\n\nexport const Body = ({ children, script = [] }: HTMLProps) => (\n  <body>\n    <div id=\"__content__\" dangerouslySetInnerHTML={{ __html: children || \"\" }} />\n    {script.filter(Boolean).map((ele) => ele)}\n  </body>\n);\n","import { getIsStaticGenerate } from \"@shared/env\";\n\nimport type { HTMLProps } from \".\";\n\nexport const Head = ({ env = \"{}\", link = [], preLoad = [], preloadedState = \"{}\", helmetContext: { helmet } = {}, emotionChunks }: HTMLProps) => (\n  <head>\n    <meta charSet=\"utf-8\" />\n    <meta name=\"build-time\" content={__BUILD_TIME__} />\n    <meta name=\"power-by\" content={`@my-react ꒰ঌ( ⌯' '⌯)໒꒱`} />\n    <meta name=\"author\" content=\"MrWangJustToDo\" />\n    <meta\n      name=\"description\"\n      content=\"@my-react is a React like package, it can be used to build a modern website just like this, feel free to use and fire a issue if you have! link: https://github.com/MrWangJustToDo/MyReact\"\n    />\n    <meta name=\"keywords\" content=\"react, react-dom, ssr, csr, ssg\" />\n    <base href={getIsStaticGenerate() ? \"/MyReact/\" : \"/\"} />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no\" />\n    <link rel=\"shortcut icon\" href=\"./favicon.ico\" type=\"image/x-icon\" />\n    {/* a type issue for react-helmet-async  */}\n    <>\n      {helmet?.base.toComponent()}\n      {helmet?.title.toComponent()}\n      {helmet?.meta.toComponent()}\n      {helmet?.link.toComponent()}\n      {helmet?.noscript.toComponent()}\n      {helmet?.style.toComponent()}\n      {helmet?.script.toComponent()}\n    </>\n    {preLoad.filter(Boolean).map((ele) => ele)}\n    {link.filter(Boolean).map((ele) => ele)}\n    {emotionChunks?.styles.map((style, index) => (\n      <style data-server data-emotion={`${style.key} ${style.ids.join(\" \")}`} key={style.key + \"_\" + index} dangerouslySetInnerHTML={{ __html: style.css }} />\n    ))}\n    <script id=\"__preload_env__\" type=\"application/json\" dangerouslySetInnerHTML={{ __html: `${env}` }} />\n    <script id=\"__preload_state__\" type=\"application/json\" dangerouslySetInnerHTML={{ __html: `${preloadedState}` }} />\n  </head>\n);\n","import { Body } from \"./Body\";\nimport { Head } from \"./Head\";\n\nimport type { EmotionCriticalToChunks } from \"@emotion/server/types/create-instance\";\nimport type { ReactElement } from \"react\";\nimport type { HelmetServerState } from \"react-helmet-async\";\n\nexport type HTMLProps = {\n  env?: string;\n  lang?: string;\n  children?: string;\n  preloadedState?: string;\n  link?: ReactElement[];\n  script?: ReactElement[];\n  preLoad?: ReactElement[];\n  emotionChunks?: EmotionCriticalToChunks;\n  helmetContext?: { helmet?: HelmetServerState };\n};\n\nexport const HTML = (props: HTMLProps) => {\n  return (\n    <html lang={props.lang || \"\"}>\n      <Head {...props} />\n      <Body {...props} />\n    </html>\n  );\n};\n","export const safeData = <T extends Record<string, unknown>>(data: T, key?: string): T => {\n  if (key) {\n    const cacheData = data[key];\n    Object.defineProperty(data, key, {\n      get: function () {\n        return cacheData;\n      },\n      configurable: false,\n    });\n    return data;\n  } else {\n    Object.keys(data).forEach((key) => {\n      const cacheData = data[key];\n      Object.defineProperty(data, key, {\n        get: function () {\n          return cacheData;\n        },\n        configurable: false,\n      });\n    });\n    return data;\n  }\n};\n","import createCache from \"@emotion/cache\";\n\nexport const createEmotionCache = () => createCache({ key: \"css\" });\n","export enum clientActionName {\n  clientLang = \"clientLang\",\n  clientProps = \"clientProps\",\n}\n\nexport enum serverActionName {\n  serverLang = \"serverLang\",\n}\n","import type { ClientActionType, CreateClientActionProps, CreateClientActionType } from \"../type\";\n\nconst clientAction: ClientActionType = {\n  SET_DATA_ACTION: (name) => `@client_action_${name}_start`,\n  SET_DATA_LOADING: (name) => `@client_action_${name}_loading`,\n  SET_DATA_SUCCESS: (name) => `@client_action_${name}_success`,\n  SET_DATA_FAIL: (name) => `@client_action_${name}_fail`,\n};\n\nconst setDataLoading_client: CreateClientActionType = ({ name }) => ({ type: clientAction.SET_DATA_LOADING(name), loadingState: true });\n\n// not need\nconst setDataAction_client: CreateClientActionType = ({ name }) => ({ type: clientAction.SET_DATA_ACTION(name), loadingState: true });\n\nconst setDataSuccess_client: CreateClientActionType = <T>({ name, data }: CreateClientActionProps<T>) => ({\n  type: clientAction.SET_DATA_SUCCESS(name),\n  data,\n  loadingState: false,\n});\n\nconst setDataFail_client: CreateClientActionType = <T>({ name, error }: CreateClientActionProps<T>) => ({\n  type: clientAction.SET_DATA_FAIL(name),\n  error,\n  loadingState: false,\n});\n\nexport { clientAction, setDataLoading_client, setDataAction_client, setDataSuccess_client, setDataFail_client };\n","import { produce } from \"immer\";\n\nimport { clientActionName } from \"@shared/store/action\";\n\nimport { clientAction } from \"../share/action\";\n\nimport type { ReducerState, ReducerStateAction, ReducerStateActionMapType } from \"@shared/store/type\";\nimport type { Reducer } from \"redux\";\n\ntype CurrentState = ReducerState<string>;\n\nconst initState: CurrentState = { data: \"\", error: null, loaded: false, loading: false };\n\nconst clientLangReducer: Reducer<CurrentState> = (state: CurrentState = initState, action: ReducerStateAction<string>) => {\n  const actionReducer = actionReducerMap[action.type];\n  if (actionReducer) {\n    return actionReducer(state, action);\n  } else {\n    return state;\n  }\n};\n\nconst actionReducerMap: ReducerStateActionMapType<string> = {\n  [clientAction.SET_DATA_LOADING(clientActionName.clientLang)]: (state, action) =>\n    produce(state, (proxy) => {\n      proxy.data = \"\";\n      proxy.error = null;\n      proxy.loading = action.loadingState || true;\n      proxy.loaded = false;\n    }),\n  [clientAction.SET_DATA_SUCCESS(clientActionName.clientLang)]: (state, action) =>\n    produce(state, (proxy) => {\n      proxy.data = action.data || \"\";\n      proxy.error = null;\n      proxy.loading = false;\n      proxy.loaded = true;\n    }),\n  [clientAction.SET_DATA_FAIL(clientActionName.clientLang)]: (state, action) =>\n    produce(state, (proxy) => {\n      proxy.data = \"\";\n      proxy.error = action.error;\n      proxy.loading = false;\n      proxy.loaded = true;\n    }),\n};\n\nexport { clientLangReducer };\n","import { produce } from \"immer\";\n\nimport { clientActionName } from \"@shared/store/action\";\n\nimport { clientAction } from \"../share/action\";\n\nimport type { ReducerState, ReducerStateAction, ReducerStateActionMapType } from \"@shared/store/type\";\nimport type { Reducer } from \"redux\";\n\ntype State = Record<string, Record<string, unknown>>;\n\ntype CurrentState = ReducerState<State>;\n\nconst initState: CurrentState = { data: {}, error: null, loaded: false, loading: false };\n\nconst clientPropsReducer: Reducer<CurrentState> = (state: CurrentState = initState, action: ReducerStateAction<State>) => {\n  const actionReducer = actionReducerMap[action.type];\n  if (actionReducer) {\n    return actionReducer(state, action);\n  } else {\n    return state;\n  }\n};\n\nconst actionReducerMap: ReducerStateActionMapType<State> = {\n  [clientAction.SET_DATA_LOADING(clientActionName.clientProps)]: (state, action) =>\n    produce(state, (proxy) => {\n      proxy.error = null;\n      proxy.loading = action.loadingState || true;\n      proxy.loaded = false;\n    }),\n  [clientAction.SET_DATA_SUCCESS(clientActionName.clientProps)]: (state, action) =>\n    produce(state, (proxy) => {\n      proxy.data = action.data;\n      proxy.error = null;\n      proxy.loading = false;\n      proxy.loaded = true;\n    }),\n  [clientAction.SET_DATA_FAIL(clientActionName.clientProps)]: (state, action) =>\n    produce(state, (proxy) => {\n      proxy.data = {};\n      proxy.error = action.error;\n      proxy.loading = false;\n      proxy.loaded = true;\n    }),\n};\n\nexport { clientPropsReducer };\n","import { combineReducers } from \"redux\";\n\nimport { clientActionName } from \"@shared/store/action\";\n\nimport { clientLangReducer, clientPropsReducer } from \"./action\";\n\nexport const client = combineReducers({\n  [clientActionName.clientLang]: clientLangReducer,\n  [clientActionName.clientProps]: clientPropsReducer,\n});\n\nexport * from \"./share/action\";\n","import type { CreateServerActionProps, CreateServerActionType, CreateServerActionWithDispatchType, ServerActionType } from \"../type\";\n\nconst serverAction: ServerActionType = {\n  GET_DATA_ACTION: (name) => `@server_action_${name}_startWithSaga`,\n  GET_DATA_LOADING: (name) => `@server_action_${name}_loading`,\n  GET_DATA_SUCCESS: (name) => `@server_action_${name}_success`,\n  GET_DATA_FAIL: (name) => `@server_action_${name}_fail`,\n};\n\n// support a usage like await dispatch(getDataAction_Server({name})) compose redux-saga & redux-thunk\nconst getDataAction_Server: CreateServerActionWithDispatchType =\n  ({ name, ...resProps }) =>\n  (dispatch) => {\n    let done: null | (() => void) = null;\n    const temp = new Promise<void>((r) => {\n      done = r;\n    });\n    dispatch({ type: serverAction.GET_DATA_ACTION(name), done, ...resProps });\n    return temp;\n  };\n\nconst getDataLoading_server: CreateServerActionType = ({ name }) => ({ type: serverAction.GET_DATA_LOADING(name), loadingState: true });\n\nconst getDataSuccess_Server: CreateServerActionType = <T>({ name, data }: CreateServerActionProps<T, unknown>) => ({\n  type: serverAction.GET_DATA_SUCCESS(name),\n  data,\n  loadingState: false,\n});\n\nconst getDataFail_Server: CreateServerActionType = <T>({ name, error }: CreateServerActionProps<T, unknown>) => ({\n  type: serverAction.GET_DATA_FAIL(name),\n  error,\n  loadingState: false,\n});\n\nexport { serverAction, getDataLoading_server, getDataAction_Server, getDataSuccess_Server, getDataFail_Server };\n","import { produce } from \"immer\";\n\nimport { serverActionName } from \"@shared/store/action\";\n\nimport { serverAction } from \"../share/action\";\n\nimport type { ReducerState, ReducerStateAction, ReducerStateActionMapType } from \"@shared/store/type\";\nimport type { Reducer } from \"redux\";\n\ntype LangObject = { [props: string]: Record<string, string> };\n\ntype CurrentState = ReducerState<LangObject>;\n\nconst initState: CurrentState = { data: {}, error: null, loaded: false, loading: false };\n\nconst serverLangReducer: Reducer<CurrentState> = (state: CurrentState = initState, action: ReducerStateAction<LangObject>) => {\n  const actionReducer = actionReducerMap[action.type];\n  if (actionReducer) {\n    return actionReducer(state, action);\n  } else {\n    return state;\n  }\n};\n\nconst actionReducerMap: ReducerStateActionMapType<LangObject> = {\n  [serverAction.GET_DATA_LOADING(serverActionName.serverLang)]: (state, action) =>\n    produce(state, (proxy) => {\n      proxy.error = null;\n      proxy.loading = action.loadingState || true;\n      proxy.loaded = false;\n    }),\n  [serverAction.GET_DATA_SUCCESS(serverActionName.serverLang)]: (state, action) =>\n    produce(state, (proxy) => {\n      proxy.data = { ...proxy.data, ...action.data };\n      proxy.error = null;\n      proxy.loading = false;\n      proxy.loaded = true;\n    }),\n  [serverAction.GET_DATA_FAIL(serverActionName.serverLang)]: (state, action) =>\n    produce(state, (proxy) => {\n      proxy.error = action.error;\n      proxy.loading = false;\n      proxy.loaded = true;\n    }),\n};\n\nexport { serverLangReducer };\n","import { combineReducers } from \"redux\";\n\nimport { serverActionName } from \"@shared/store/action\";\n\nimport { serverLangReducer } from \"./action\";\n\nexport const server = combineReducers({\n  [serverActionName.serverLang]: serverLangReducer,\n});\n\nexport * from \"./share/action\";\n","import { combineReducers } from \"redux\";\n\nimport { client } from \"./client\";\nimport { server } from \"./server\";\n\nexport const rootReducer = combineReducers({\n  client,\n  server,\n});\n\nexport * from \"./client\";\n\nexport * from \"./server\";\n","var map = {\n\t\"./\": [\n\t\t9951,\n\t\t50,\n\t\t736,\n\t\t270,\n\t\t904,\n\t\t617\n\t],\n\t\"./404\": [\n\t\t4160,\n\t\t50,\n\t\t736,\n\t\t751\n\t],\n\t\"./404.tsx\": [\n\t\t4160,\n\t\t50,\n\t\t736,\n\t\t751\n\t],\n\t\"./Blog\": [\n\t\t4681,\n\t\t50,\n\t\t736,\n\t\t270,\n\t\t904,\n\t\t89,\n\t\t587\n\t],\n\t\"./Blog.tsx\": [\n\t\t4681,\n\t\t50,\n\t\t736,\n\t\t270,\n\t\t904,\n\t\t89,\n\t\t587\n\t],\n\t\"./Hot\": [\n\t\t3842,\n\t\t50,\n\t\t19\n\t],\n\t\"./Hot.tsx\": [\n\t\t3842,\n\t\t50,\n\t\t19\n\t],\n\t\"./index\": [\n\t\t9951,\n\t\t50,\n\t\t736,\n\t\t270,\n\t\t904,\n\t\t617\n\t],\n\t\"./index.tsx\": [\n\t\t9951,\n\t\t50,\n\t\t736,\n\t\t270,\n\t\t904,\n\t\t617\n\t]\n};\nfunction webpackAsyncContext(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\treturn Promise.resolve().then(() => {\n\t\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t});\n\t}\n\n\tvar ids = map[req], id = ids[0];\n\treturn Promise.all(ids.slice(1).map(__webpack_require__.e)).then(() => {\n\t\treturn __webpack_require__(id);\n\t});\n}\nwebpackAsyncContext.keys = () => (Object.keys(map));\nwebpackAsyncContext.id = 5685;\nmodule.exports = webpackAsyncContext;","var map = {\n\t\"./\": 9951,\n\t\"./404\": 4160,\n\t\"./404.tsx\": 4160,\n\t\"./Blog\": 4681,\n\t\"./Blog.tsx\": 4681,\n\t\"./Hot\": 3842,\n\t\"./Hot.tsx\": 3842,\n\t\"./index\": 9951,\n\t\"./index.tsx\": 9951\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\tif(!__webpack_require__.m[id]) {\n\t\tvar e = new Error(\"Module '\" + req + \"' ('\" + id + \"') is not available (weak dependency)\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nwebpackContext.id = 4858;\nmodule.exports = webpackContext;"],"names":["module","exports","__my_react_internal__","currentComponentFiber","RESERVED_PROPS","key","ref","__self","__source","jsx","type","config","maybeKey","source","self","props","propsName","undefined","Object","prototype","hasOwnProperty","call","_typeof","typedType_1","keys","defaultProps","forEach","_a","TYPEKEY","Element","_jsx","_self","_source","_owner","current","_store","jsxs","apolloClient","ActorType","AuditLogOrderField","CheckAnnotationLevel","CheckConclusionState","CheckRunType","CheckStatusState","CollaboratorAffiliation","CommentAuthorAssociation","CommentCannotUpdateReason","CommitContributionOrderField","ContributionLevel","DefaultRepositoryPermissionField","DependencyGraphEcosystem","DeploymentOrderField","DeploymentProtectionRuleType","DeploymentReviewState","DeploymentState","DeploymentStatusState","DiffSide","DiscussionOrderField","DismissReason","EnterpriseAdministratorInvitationOrderField","EnterpriseAdministratorRole","EnterpriseDefaultRepositoryPermissionSettingValue","EnterpriseEnabledDisabledSettingValue","EnterpriseEnabledSettingValue","EnterpriseMemberOrderField","EnterpriseMembersCanCreateRepositoriesSettingValue","EnterpriseMembersCanMakePurchasesSettingValue","EnterpriseServerInstallationOrderField","EnterpriseServerUserAccountEmailOrderField","EnterpriseServerUserAccountOrderField","EnterpriseServerUserAccountsUploadOrderField","EnterpriseServerUserAccountsUploadSyncState","EnterpriseUserAccountMembershipRole","EnterpriseUserDeployment","FileViewedState","FundingPlatform","GistOrderField","GistPrivacy","GitSignatureState","IdentityProviderConfigurationState","IpAllowListEnabledSettingValue","IpAllowListEntryOrderField","IpAllowListForInstalledAppsEnabledSettingValue","IssueCommentOrderField","IssueOrderField","IssueState","IssueTimelineItemsItemType","LabelOrderField","LanguageOrderField","LockReason","MergeStateStatus","MergeableState","MigrationSourceType","MigrationState","MilestoneOrderField","MilestoneState","NotificationRestrictionSettingValue","OidcProviderType","OauthApplicationCreateAuditEntryState","OperationType","OrderDirection","OrgAddMemberAuditEntryPermission","OrgCreateAuditEntryBillingPlan","OrgEnterpriseOwnerOrderField","OrgRemoveBillingManagerAuditEntryReason","OrgRemoveMemberAuditEntryMembershipType","OrgRemoveMemberAuditEntryReason","OrgRemoveOutsideCollaboratorAuditEntryMembershipType","OrgRemoveOutsideCollaboratorAuditEntryReason","OrgUpdateDefaultRepositoryPermissionAuditEntryPermission","OrgUpdateMemberAuditEntryPermission","OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility","OrganizationInvitationRole","OrganizationInvitationType","OrganizationMemberRole","OrganizationMembersCanCreateRepositoriesSettingValue","OrganizationOrderField","PackageFileOrderField","PackageOrderField","PackageType","PackageVersionOrderField","PatchStatus","PinnableItemType","PinnedDiscussionGradient","PinnedDiscussionPattern","ProjectCardArchivedState","ProjectCardState","ProjectColumnPurpose","ProjectItemType","ProjectNextFieldType","ProjectNextOrderField","ProjectOrderField","ProjectState","ProjectTemplate","ProjectViewLayout","PullRequestMergeMethod","PullRequestOrderField","PullRequestReviewCommentState","PullRequestReviewDecision","PullRequestReviewEvent","PullRequestReviewState","PullRequestState","PullRequestTimelineItemsItemType","PullRequestUpdateState","ReactionContent","ReactionOrderField","RefOrderField","ReleaseOrderField","RepoAccessAuditEntryVisibility","RepoAddMemberAuditEntryVisibility","RepoArchivedAuditEntryVisibility","RepoChangeMergeSettingAuditEntryMergeType","RepoCreateAuditEntryVisibility","RepoDestroyAuditEntryVisibility","RepoRemoveMemberAuditEntryVisibility","ReportedContentClassifiers","RepositoryAffiliation","RepositoryContributionType","RepositoryInteractionLimit","RepositoryInteractionLimitExpiry","RepositoryInteractionLimitOrigin","RepositoryInvitationOrderField","RepositoryLockReason","RepositoryMigrationOrderDirection","RepositoryMigrationOrderField","RepositoryOrderField","RepositoryPermission","RepositoryPrivacy","RepositoryVisibility","RepositoryVulnerabilityAlertState","RequestableCheckStatusState","RoleInOrganization","SamlDigestAlgorithm","SamlSignatureAlgorithm","SavedReplyOrderField","SearchType","SecurityAdvisoryEcosystem","SecurityAdvisoryIdentifierType","SecurityAdvisoryOrderField","SecurityAdvisorySeverity","SecurityVulnerabilityOrderField","SponsorOrderField","SponsorableOrderField","SponsorsActivityAction","SponsorsActivityOrderField","SponsorsActivityPeriod","SponsorsGoalKind","SponsorsTierOrderField","SponsorshipNewsletterOrderField","SponsorshipOrderField","SponsorshipPrivacy","StarOrderField","StatusState","SubscriptionState","TeamDiscussionCommentOrderField","TeamDiscussionOrderField","TeamMemberOrderField","TeamMemberRole","TeamMembershipType","TeamOrderField","TeamPrivacy","TeamRepositoryOrderField","TeamReviewAssignmentAlgorithm","TeamRole","TopicSuggestionDeclineReason","TrackedIssueStates","UserBlockDuration","UserStatusOrderField","VerifiableDomainOrderField","autoMergeCache","InMemoryCache","typePolicies","Repository","fields","issues","keyArgs","merge","existing","incoming","nodes","pageInfo","startCursor","_b","__assign","__spreadArray","Issue","comments","plainCache","isBrowser","window","httpLink","HttpLink","uri","fetch","onErrorLink","onError","networkError","graphQLErrors","console","error","concat","message","stack","length","authLink","setContext","_","headers","Authorization","atob","Buffer","from","toString","__SERVER__","createApolloClient","initialState","enableInfinityLoad","_apolloClient","restProps","__rest","ApolloClient","ssrMode","link","cache","_createApolloClient","restore","existCacheData","extract","useApollo","useMemo","GetViewerDocument","kind","definitions","operation","name","value","variableDefinitions","variable","defaultValue","selectionSet","selections","arguments","GetBlogListDocument","GetSingleBlogDocument","AutoInjectProps","Component","path","MemoComponent","memo","useGetInitialProps","_objectSpread","LoadingStateContext","createContext","loading","setLoading","WrapperLoading","_ref","children","_useState","useState","_useState2","_slicedToArray","Provider","useLoadingState","useContext","div","_Bar","forwardRef","useEffectOnce","document","createElement","id","body","prepend","useIsMounted","createPortal","className","style","height","transform","Bar","LoadingBar","useLoadingBar","LoadedLocationContext","WrapperRoute","routes","loaded","usePreLoad","preLoad","_jsxs","RenderMatch","all","useRoutes","allRoutes","location","_Fragment","getIsAnimateRouter","AnimatePresence","exitBeforeEnter","Fragment","motion","initial","animate","exit","variants","opacity","in","out","transition","damping","stiffness","pathname","WrapperApollo","ApolloProvider","client","WrapperErrorCatch","_Component","_inherits","_super","_this","_classCallCheck","_len","args","Array","_key","apply","state","hasError","_createClass","info","this","setState","componentStack","color","whiteSpace","WrapperLang","htmlRef","useRef","data","useAppSelector","server","serverLang","lang","clientLang","useEffect","querySelector","IntlProvider","locale","messages","defaultLocale","defaultLang","App","emotionCache","createEmotionCache","Root","store","cookieStore","cookieStorageManager","cookie","StrictMode","CacheProvider","ChakraProvider","theme","colorModeManager","serverState","getState","Router","HelmetProvider","place","preLoadEnvElement","preLoadStateElement","createUniversalStore","preloadedState","JSON","parse","innerHTML","__ENV__","__PRELOAD_STORE_STATE__","safeData","log","FORMWORK","isPURE_CSR","loadCurrentLang","require","dispatch","LANG","then","loadableReady","render","isSSR","isDEVELOPMENT","isMIDDLEWARE","hydrate","useDebouncedState","time","debounce","INITIAL_RECT","width","left","right","top","bottom","x","y","useDomSize","cssSelector","_useDebouncedState","_useDebouncedState2","rect","setRect","domElement","ResizeObserver","resizeObserver","getBoundingClientRect","observe","disconnect","handleResize","addEventListener","passive","removeEventListener","isRedirect","useStore","useLocation","navigate","useNavigate","_useSearchParams","useSearchParams","query","firstLoad","getIsP_CSR","loadedPath","loadingPath","timer1","timer2","storeRef","loadedLocation","setLoadedLocation","isRedirectCurrentPath","clearTimeout","setTimeout","currentLoadKey","_redirect$location$qu","_ref2","redirect","pathName","setDataSuccess_client","clientActionName","currentLoad","cleanupRootStyles","rootId","root","getElementById","removeProperty","once","cleanupOverlaysStyles","ids","ROOT_BODY","count","OverlayOpenContext","OverlayCloseContext","OverlayArrayContext","desktop","mobile","useOverlaysProps","_useReducer","overlays","setOverlays","overlaysRef","forceUpdate","useReducer","p","applyOverlayStyle","useCallback","isOpen","delay","stillShow","filter","n","showState","allIds","map","needReApplyIds","slice","needClearId","_toConsumableArray","reverse","index","h","innerHeight","s","overflow","willChange","applyRootStyles","open","overlayProps","allOverlay","lastOpen","findLast","isFirst","closeHandler","closeComplete","last","newAllOverlays","reduce","c","applyOverlay","close","modalId","closeAll","currentOverlay","find","currentTopOverlay","useOverlaysOpen","useOverlaysClose","useOverlayArray","useIsMobile","useBreakpointValue","base","lg","mounted","setMounted","_props$height","_props$present","present","ele","requestAnimationFrame","start","next","cssText","cancelAnimationFrame","cancel","fn","useWindowSize","resize","innerWidth","useGlobalLockStore","create","set","get","lock","unlock","useLockBodyCount","pagePath","clientProps","preLoadPropsKey","_generateFunction","dataLength","Math","floor","maxH","i","w","maxW","minH","smGenerate","mdGenerate","lgGenerate","useGetResponseListLayout","items","sm","bodyText","md","_ref3","xs","xxs","dynamicRouteConfig","Layout","loadable","resolved","chunkName","isReady","resolve","__webpack_modules__","importAsync","requireAsync","requireSync","__webpack_require__","resolveComponent","default","baseRouter","component","element","dynamicRoutes","componentPath","startsWith","it","replace","__router__","timeoutMap","rejectMap","keyMap","keyLength","reject","_step","_iterator","_createForOfIteratorHelper","sort","key1","key2","done","keyItem","err","e","f","action","Promise","push","catch","branch","matchRoutes","relativePathname","promises","route","match","params","_preLoad","val","Boolean","page","join","code","resolvePreLoadStateFunction","_asyncToGenerator","_regeneratorRuntime","_callee2","preLoadStateArray","WrapperComponent","loadAbleComponent","preLoadComponent","_preLoadComponent","_context2","prev","getInitialState","load","sent","abrupt","_ref5","_callee","_ref4","propsKey","res","result","_context","_defineProperty","stop","_x2","_x","_ref7","_callee3","_ref6","_context3","_x3","initialStateWrapper","getIsMiddleware","memoize","getIsSSR","isANIMATE_ROUTER","getIsStaticGenerate","isSTATIC","getPublicApi","PUBLIC_API_HOST","supportedLang","en","zh","getDataAction_Server","serverActionName","langSaga","request","_yield$call","select","put","getDataLoading_server","axios","baseURL","apiName","getDataSuccess_Server","t0","getDataFail_Server","finish","rootSaga","takeLatest","serverAction","_marked","SagaManager","startSagas","saga","sagaMiddleware","run","cancelSagas","composeEnhancers","__REDUX_DEVTOOLS_EXTENSION_COMPOSE__","actionsDenylist","compose","_props$middleware","middleware","createSagaMiddleware","allMiddleware","thunkMiddleware","createStore","rootReducer","applyMiddleware","sagaTask","useAppDispatch","useDispatch","useSelector","extendTheme","styles","global","fontFamily","semanticTokens","colors","mobileCardBackgroundColor","_dark","cardBackgroundColor","mobileModalColor","cardBorderColor","lightTextColor","siteBackgroundColor","bannerBackgroundColor","Body","_ref$script","script","dangerouslySetInnerHTML","__html","Head","_ref$env","env","_ref$link","_ref$preLoad","_ref$preloadedState","_ref$helmetContext","helmetContext","helmet","emotionChunks","charSet","content","__BUILD_TIME__","href","rel","toComponent","title","meta","noscript","css","HTML","cacheData","defineProperty","configurable","createCache","clientAction","loadingState","initState","actionReducerMap","_actionReducerMap","produce","proxy","combineReducers","_combineReducers","actionReducer","GET_DATA_ACTION","GET_DATA_LOADING","GET_DATA_SUCCESS","GET_DATA_FAIL","resProps","_objectWithoutProperties","_excluded","temp","r","webpackAsyncContext","req","o","Error","webpackContext","webpackContextResolve","m"],"sourceRoot":""}