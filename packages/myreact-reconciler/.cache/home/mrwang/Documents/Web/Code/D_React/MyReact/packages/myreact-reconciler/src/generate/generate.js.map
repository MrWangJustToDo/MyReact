{"version":3,"file":"generate.js","sourceRoot":"","sources":["generate.ts"],"names":[],"mappings":"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","sourcesContent":["import { isValidElement, __myreact_internal__, __myreact_shared__ } from \"@my-react/react\";\n\nimport { enableKeyDiff } from \"../share\";\n\nimport type {\n  ArrayElementNode,\n  MyReactElementNode,\n  MyReactElement,\n  MaybeArrayElementNode,\n  MyReactFiberNode,\n} from \"@my-react/react\";\n\nconst { isAppMounted, globalDispatch, MyReactFiberNode: MyReactFiberNodeClass } = __myreact_internal__;\n\nconst { updateFiberNode, createFiberNode } = __myreact_shared__;\n\nconst getKeyMatchedChildren = (\n  newChildren: ArrayElementNode,\n  prevFiberChildren: Array<MyReactFiberNode | MyReactFiberNode[]>\n) => {\n  if (!isAppMounted.current) return prevFiberChildren;\n  if (!enableKeyDiff.current) return prevFiberChildren;\n  if (!prevFiberChildren) return prevFiberChildren;\n  if (prevFiberChildren.length === 0) return prevFiberChildren;\n\n  const tempChildren = prevFiberChildren.slice(0);\n  const assignPrevChildren: Array<MyReactFiberNode | MyReactFiberNode[]> = Array(tempChildren.length).fill(null);\n\n  newChildren.forEach((element, index) => {\n    if (tempChildren.length) {\n      if (isValidElement(element)) {\n        if (typeof element.key === \"string\") {\n          const targetIndex = tempChildren.findIndex(\n            (fiber) =>\n              fiber instanceof MyReactFiberNodeClass &&\n              typeof fiber.element === \"object\" &&\n              fiber.element?.key === element.key\n          );\n          if (targetIndex !== -1) {\n            assignPrevChildren[index] = tempChildren[targetIndex];\n            tempChildren.splice(targetIndex, 1);\n          }\n        } else {\n          // TODO\n        }\n      }\n    }\n  });\n\n  return assignPrevChildren.map((v) => {\n    if (v) return v;\n    return tempChildren.shift();\n  });\n};\n\nconst getIsSameTypeNode = (newChild: MaybeArrayElementNode, prevFiberChild?: MyReactFiberNode | MyReactFiberNode[]) => {\n  if (!isAppMounted.current) return false;\n  const newChildIsArray = Array.isArray(newChild);\n  const prevElementChildIsArray = Array.isArray(prevFiberChild);\n  if (newChildIsArray && prevElementChildIsArray) return true;\n  if (newChildIsArray) return false;\n  if (prevElementChildIsArray) return false;\n\n  const typedPrevFiberChild = prevFiberChild as MyReactFiberNode;\n  const typedNewChild = newChild as MyReactElementNode;\n\n  const prevRenderedChild = typedPrevFiberChild?.element;\n  const result = typedPrevFiberChild?.checkIsSameType(typedNewChild);\n  if (result && enableKeyDiff.current && !typedPrevFiberChild.__isTextNode__ && !typedPrevFiberChild.__isNullNode__) {\n    return (typedNewChild as MyReactElement).key === (prevRenderedChild as MyReactElement).key;\n  } else {\n    return result;\n  }\n};\n\nconst getNewFiberWithUpdate = (\n  newChild: MaybeArrayElementNode,\n  parentFiber: MyReactFiberNode,\n  prevFiberChild?: MyReactFiberNode | MyReactFiberNode[],\n  assignPrevFiberChild?: MyReactFiberNode | MyReactFiberNode[]\n): MyReactFiberNode | MyReactFiberNode[] => {\n  const isSameType = getIsSameTypeNode(newChild, assignPrevFiberChild);\n  if (isSameType) {\n    if (Array.isArray(newChild) && Array.isArray(prevFiberChild) && Array.isArray(assignPrevFiberChild)) {\n      const assignPrevFiberChildren = getKeyMatchedChildren(newChild, assignPrevFiberChild) as MyReactFiberNode[];\n      if (newChild.length < assignPrevFiberChildren.length) {\n        globalDispatch.current.pendingUnmount(parentFiber, assignPrevFiberChildren.slice(newChild.length));\n      }\n      return newChild.map((v, index) =>\n        getNewFiberWithUpdate(v, parentFiber, prevFiberChild[index], assignPrevFiberChildren[index])\n      ) as MyReactFiberNode[];\n    }\n\n    return updateFiberNode(\n      {\n        fiber: assignPrevFiberChild as MyReactFiberNode,\n        parent: parentFiber,\n        prevFiber: prevFiberChild as MyReactFiberNode,\n      },\n      newChild as MyReactElementNode\n    );\n  } else {\n    if (assignPrevFiberChild) {\n      globalDispatch.current.pendingUnmount(parentFiber, assignPrevFiberChild);\n    }\n\n    if (Array.isArray(newChild)) {\n      return newChild.map((v) => getNewFiberWithUpdate(v, parentFiber)) as MyReactFiberNode[];\n    }\n\n    return createFiberNode(\n      {\n        fiberIndex: parentFiber.fiberIndex + 1,\n        parent: parentFiber,\n        type: \"position\",\n      },\n      newChild\n    );\n  }\n};\n\nconst getNewFiberWithInitial = (\n  newChild: MaybeArrayElementNode,\n  parentFiber: MyReactFiberNode\n): MyReactFiberNode | MyReactFiberNode[] => {\n  if (Array.isArray(newChild)) {\n    return newChild.map((v) => getNewFiberWithInitial(v, parentFiber)) as MyReactFiberNode[];\n  }\n\n  return createFiberNode({ fiberIndex: parentFiber.fiberIndex + 1, parent: parentFiber }, newChild);\n};\n\nexport const transformChildrenFiber = (\n  parentFiber: MyReactFiberNode,\n  children: MaybeArrayElementNode | null | undefined\n) => {\n  let index = 0;\n\n  const isUpdate = parentFiber.__isUpdateRender__;\n\n  const newChildren = Array.isArray(children) ? children : [children];\n\n  const prevFiberChildren = isUpdate ? parentFiber.__renderedChildren__ : [];\n\n  const assignPrevFiberChildren = getKeyMatchedChildren(newChildren, prevFiberChildren);\n\n  parentFiber.__renderedChildren__ = [];\n\n  parentFiber.beforeUpdate();\n\n  while (index < newChildren.length || index < assignPrevFiberChildren.length) {\n    const newChild = newChildren[index];\n    const prevFiberChild = prevFiberChildren[index];\n    const assignPrevFiberChild = assignPrevFiberChildren[index];\n\n    const newFiber = isUpdate\n      ? getNewFiberWithUpdate(newChild, parentFiber, prevFiberChild, assignPrevFiberChild)\n      : getNewFiberWithInitial(newChild, parentFiber);\n\n    parentFiber.__renderedChildren__.push(newFiber);\n\n    index++;\n  }\n\n  parentFiber.afterUpdate();\n\n  return parentFiber.children;\n};\n"]}