{"version":3,"file":"generate.js","sourceRoot":"","sources":["generate.ts"],"names":[],"mappings":"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","sourcesContent":["import { isValidElement } from \"../element\";\nimport { MyReactFiberNode, createFiberNode, updateFiberNode } from \"../fiber\";\nimport { enableKeyDiff, globalDispatch, isAppMounted, isServerRender, isHydrateRender } from \"../share\";\n\nimport type { Children, ChildrenNode, ArrayChildrenNode, MaybeArrayChildrenNode } from \"../element\";\n\nconst getKeyMatchedChildren = (\n  newChildren: ArrayChildrenNode,\n  prevFiberChildren: Array<MyReactFiberNode | MyReactFiberNode[]>\n) => {\n  if (!isAppMounted.current) return prevFiberChildren;\n  if (isServerRender.current) return prevFiberChildren;\n  if (isHydrateRender.current) return prevFiberChildren;\n  if (!enableKeyDiff.current) return prevFiberChildren;\n  if (!prevFiberChildren) return prevFiberChildren;\n  if (prevFiberChildren.length === 0) return prevFiberChildren;\n\n  const tempChildren = prevFiberChildren.slice(0);\n  const assignPrevChildren: Array<MyReactFiberNode | MyReactFiberNode[]> = Array(tempChildren.length).fill(null);\n\n  newChildren.forEach((element, index) => {\n    if (tempChildren.length) {\n      if (isValidElement(element)) {\n        if (typeof element.key === \"string\") {\n          const targetIndex = tempChildren.findIndex(\n            (fiber) =>\n              fiber instanceof MyReactFiberNode &&\n              typeof fiber.element === \"object\" &&\n              fiber.element?.key === element.key\n          );\n          if (targetIndex !== -1) {\n            assignPrevChildren[index] = tempChildren[targetIndex];\n            tempChildren.splice(targetIndex, 1);\n          }\n        } else {\n          // TODO\n        }\n      }\n    }\n  });\n\n  return assignPrevChildren.map((v) => {\n    if (v) return v;\n    return tempChildren.shift();\n  });\n};\n\nconst getIsSameTypeNode = (\n  newChild: MaybeArrayChildrenNode,\n  prevFiberChild?: MyReactFiberNode | MyReactFiberNode[]\n) => {\n  if (!isAppMounted.current) return false;\n  const newChildIsArray = Array.isArray(newChild);\n  const prevElementChildIsArray = Array.isArray(prevFiberChild);\n  if (newChildIsArray && prevElementChildIsArray) return true;\n  if (newChildIsArray) return false;\n  if (prevElementChildIsArray) return false;\n\n  const typedPrevFiberChild = prevFiberChild as MyReactFiberNode;\n  const typedNewChild = newChild as ChildrenNode;\n\n  const prevRenderedChild = typedPrevFiberChild?.element;\n  const result = typedPrevFiberChild?.checkIsSameType(typedNewChild);\n  if (result && enableKeyDiff.current && !typedPrevFiberChild.__isTextNode__ && !typedPrevFiberChild.__isNullNode__) {\n    return (typedNewChild as Children).key === (prevRenderedChild as Children).key;\n  } else {\n    return result;\n  }\n};\n\nconst getNewFiberWithUpdate = (\n  newChild: MaybeArrayChildrenNode,\n  parentFiber: MyReactFiberNode,\n  prevFiberChild?: MyReactFiberNode | MyReactFiberNode[],\n  assignPrevFiberChild?: MyReactFiberNode | MyReactFiberNode[]\n): MyReactFiberNode | MyReactFiberNode[] => {\n  const isSameType = getIsSameTypeNode(newChild, assignPrevFiberChild);\n  if (isSameType) {\n    if (Array.isArray(newChild) && Array.isArray(prevFiberChild) && Array.isArray(assignPrevFiberChild)) {\n      const assignPrevFiberChildren = getKeyMatchedChildren(newChild, assignPrevFiberChild) as MyReactFiberNode[];\n      if (newChild.length < assignPrevFiberChildren.length) {\n        globalDispatch.current.pendingUnmount(parentFiber, assignPrevFiberChildren.slice(newChild.length));\n      }\n      return newChild.map((v, index) =>\n        getNewFiberWithUpdate(v, parentFiber, prevFiberChild[index], assignPrevFiberChildren[index])\n      ) as MyReactFiberNode[];\n    }\n\n    return updateFiberNode(\n      {\n        fiber: assignPrevFiberChild as MyReactFiberNode,\n        parent: parentFiber,\n        prevFiber: prevFiberChild as MyReactFiberNode,\n      },\n      newChild as ChildrenNode\n    );\n  } else {\n    if (assignPrevFiberChild) {\n      globalDispatch.current.pendingUnmount(parentFiber, assignPrevFiberChild);\n    }\n\n    if (Array.isArray(newChild)) {\n      return newChild.map((v) => getNewFiberWithUpdate(v, parentFiber)) as MyReactFiberNode[];\n    }\n\n    return createFiberNode(\n      {\n        fiberIndex: parentFiber.fiberIndex + 1,\n        parent: parentFiber,\n        type: \"position\",\n      },\n      newChild\n    );\n  }\n};\n\nconst getNewFiberWithInitial = (\n  newChild: MaybeArrayChildrenNode,\n  parentFiber: MyReactFiberNode\n): MyReactFiberNode | MyReactFiberNode[] => {\n  if (Array.isArray(newChild)) {\n    return newChild.map((v) => getNewFiberWithInitial(v, parentFiber)) as MyReactFiberNode[];\n  }\n\n  return createFiberNode({ fiberIndex: parentFiber.fiberIndex + 1, parent: parentFiber }, newChild);\n};\n\nexport const transformChildrenFiber = (\n  parentFiber: MyReactFiberNode,\n  children: MaybeArrayChildrenNode | null | undefined\n) => {\n  let index = 0;\n\n  const isUpdate = parentFiber.__isUpdateRender__;\n\n  const newChildren = Array.isArray(children) ? children : [children];\n\n  const prevFiberChildren = isUpdate ? parentFiber.__renderedChildren__ : [];\n\n  const assignPrevFiberChildren = getKeyMatchedChildren(newChildren, prevFiberChildren);\n\n  parentFiber.__renderedChildren__ = [];\n\n  parentFiber.beforeUpdate();\n\n  while (index < newChildren.length || index < assignPrevFiberChildren.length) {\n    const newChild = newChildren[index];\n    const prevFiberChild = prevFiberChildren[index];\n    const assignPrevFiberChild = assignPrevFiberChildren[index];\n\n    const newFiber = isUpdate\n      ? getNewFiberWithUpdate(newChild, parentFiber, prevFiberChild, assignPrevFiberChild)\n      : getNewFiberWithInitial(newChild, parentFiber);\n\n    parentFiber.__renderedChildren__.push(newFiber);\n\n    index++;\n  }\n\n  parentFiber.afterUpdate();\n\n  return parentFiber.children;\n};\n"]}